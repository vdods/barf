// ///////////////////////////////////////////////////////////////////////////
// barf_commonlang_scanner.reflex by Victor Dods, created 2006/11/09
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%targets cpp

// ///////////////////////////////////////////////////////////////////////////
// cpp scanner header-file-related directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.header_filename "barf_commonlang_scanner.hpp"
%target.cpp.implementation_filename "barf_commonlang_scanner.cpp"
%target.cpp.top_of_header_file %{
#if !defined(_BARF_COMMONLANG_SCANNER_HPP_)
#define _BARF_COMMONLANG_SCANNER_HPP_

#include "barf_commonlang.hpp"

#include <ostream>

#include "barf_inputbase.hpp"

namespace Barf {
namespace Ast {

class Base;

} // end of namespace Ast

namespace CommonLang {
%}
%target.cpp.class_name Scanner
%target.cpp.class_inheritance { protected InputBase }
%target.cpp.top_of_class {
    struct Token
    {
        enum Type
        {
            BAD_END_OF_FILE = 0x100,
            BAD_TOKEN,
            CHAR_LITERAL,
            DIRECTIVE_ADD_CODESPEC,
            DIRECTIVE_ADD_OPTIONAL_DIRECTIVE,
            DIRECTIVE_ADD_REQUIRED_DIRECTIVE,
            DIRECTIVE_DEFAULT,
            DIRECTIVE_DEFAULT_PARSE_NONTERMINAL,
            DIRECTIVE_DUMB_CODE_BLOCK,
            DIRECTIVE_ERROR,
            DIRECTIVE_ID,
            DIRECTIVE_MACRO,
            DIRECTIVE_NONTERMINAL,
            DIRECTIVE_PREC,
            DIRECTIVE_START_IN_SCANNER_MODE,
            DIRECTIVE_STATE,
            DIRECTIVE_STRICT_CODE_BLOCK,
            DIRECTIVE_STRING,
            DIRECTIVE_TARGET,
            DIRECTIVE_TARGETS,
            DIRECTIVE_TERMINAL,
            DIRECTIVE_TYPE,
            DUMB_CODE_BLOCK,
            END_OF_FILE,
            END_PREAMBLE,
            ID,
            NEWLINE,
            REGEX,
            STRICT_CODE_BLOCK,
            STRING_LITERAL,

            COUNT_PLUS_0x100
        }; // end of enum Scanner::Token::Type
    }; // end of struct Scanner::Token
}
%target.cpp.scan_method_parameters { Ast::Base **token }
%target.cpp.bottom_of_class {
    using InputBase::GetIsOpen;
    using InputBase::GetFiLoc;
    using InputBase::GetInputName;

    bool OpenFile (string const &input_filename);
    void OpenString (string const &input_string, string const &input_name, bool use_line_numbers = false);
    void OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers);

    using InputBase::Close;

private:

    Token::Type ParseDirective (string const &accepted_string, Ast::Base **token);

    bool m_is_in_preamble;
    Uint32 m_regex_paren_level;
    Uint32 m_regex_bracket_level;
    Uint32 m_code_block_bracket_level;
    Mode::Name m_return_state;
}
%target.cpp.bottom_of_header_file %{
ostream &operator << (ostream &stream, Scanner::Token::Type scanner_token_type);

} // end of namespace CommonLang
} // end of namespace Barf

#endif // !defined(_BARF_COMMONLANG_SCANNER_HPP_)
%}

// ///////////////////////////////////////////////////////////////////////////
// cpp scanner implementation-file-related directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.top_of_implementation_file %{
#include <cstdlib>
#include <sstream>

#include "barf_ast.hpp"
#include "barf_util.hpp"

// #define SPEW(x) cerr << x << endl
#define SPEW(x)

namespace Barf {
namespace CommonLang {

ostream &operator << (ostream &stream, Scanner::Token::Type scanner_token_type)
{
    static string const s_scanner_token_type_string[Scanner::Token::COUNT_PLUS_0x100 - 0x100] =
    {
        "BAD_END_OF_FILE",
        "BAD_TOKEN",
        "CHAR_LITERAL",
        "DIRECTIVE_ADD_CODESPEC",
        "DIRECTIVE_ADD_OPTIONAL_DIRECTIVE",
        "DIRECTIVE_ADD_REQUIRED_DIRECTIVE",
        "DIRECTIVE_DEFAULT",
        "DIRECTIVE_DEFAULT_PARSE_NONTERMINAL",
        "DIRECTIVE_DUMB_CODE_BLOCK",
        "DIRECTIVE_ERROR",
        "DIRECTIVE_ID",
        "DIRECTIVE_MACRO",
        "DIRECTIVE_NONTERMINAL",
        "DIRECTIVE_PREC",
        "DIRECTIVE_START_IN_SCANNER_MODE",
        "DIRECTIVE_STATE",
        "DIRECTIVE_STRICT_CODE_BLOCK",
        "DIRECTIVE_STRING",
        "DIRECTIVE_TARGET",
        "DIRECTIVE_TARGETS",
        "DIRECTIVE_TERMINAL",
        "DIRECTIVE_TYPE",
        "DUMB_CODE_BLOCK",
        "END_OF_FILE",
        "END_PREAMBLE",
        "ID",
        "NEWLINE",
        "REGEX",
        "STRICT_CODE_BLOCK",
        "STRING_LITERAL"
    };
    if (scanner_token_type < 0x100)
    {
        assert(scanner_token_type >= 0);
        return stream << GetCharLiteral(Uint8(scanner_token_type));
    }
    else
    {
        assert(scanner_token_type < Scanner::Token::COUNT_PLUS_0x100);
        return stream << s_scanner_token_type_string[scanner_token_type - 0x100];
    }
}

bool Scanner::OpenFile (string const &input_filename)
{
    bool open_succeeded = InputBase::OpenFile(input_filename);
    if (open_succeeded)
        ResetForNewInput_();
    return open_succeeded;
}

void Scanner::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    InputBase::OpenString(input_string, input_name, use_line_numbers);
    ResetForNewInput_();
}

void Scanner::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    InputBase::OpenUsingStream(input_stream, input_name, use_line_numbers);
    ResetForNewInput_();
}

Scanner::Token::Type Scanner::ParseDirective (string const &accepted_string, Ast::Base **token)
{
    assert(token != NULL);
    assert(*token == NULL);

    if (accepted_string == "%add_codespec") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_ADD_CODESPEC; }
    if (accepted_string == "%add_optional_directive") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_ADD_OPTIONAL_DIRECTIVE; }
    if (accepted_string == "%add_required_directive") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_ADD_REQUIRED_DIRECTIVE; }
    if (accepted_string == "%default") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_DEFAULT; }
    if (accepted_string == "%dumb_code_block") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_DUMB_CODE_BLOCK; }
    if (accepted_string == "%error") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_ERROR; }
    if (accepted_string == "%identifier") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_ID; }
    if (accepted_string == "%macro") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_MACRO; }
    if (accepted_string == "%nonterminal") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_NONTERMINAL; }
    if (accepted_string == "%prec") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_PREC; }
    if (accepted_string == "%default_parse_nonterminal") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL; }
    if (accepted_string == "%start_in_scanner_mode") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_START_IN_SCANNER_MODE; }
    if (accepted_string == "%scanner_mode") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_STATE; }
    if (accepted_string == "%strict_code_block") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_STRICT_CODE_BLOCK; }
    if (accepted_string == "%string") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_STRING; }
    if (accepted_string == "%target") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_TARGET; }
    if (accepted_string == "%targets") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_TARGETS; }
    if (accepted_string == "%terminal") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_TERMINAL; }
    if (accepted_string == "%type") { *token = new Ast::ThrowAway(GetFiLoc()); return Token::DIRECTIVE_TYPE; }

    EmitError(GetFiLoc(), "invalid directive \"" + accepted_string + "\"");
    return Token::BAD_TOKEN;
}
%}
%target.cpp.start_of_scan_method_actions %{
    assert(token != NULL);
    assert(*token == NULL);
%}
%target.cpp.end_of_scan_method_actions %{
    assert(false && "you didn't handle EOF properly");
    return Token::BAD_END_OF_FILE;
%}
%target.cpp.bottom_of_implementation_file %{
} // end of namespace CommonLang
} // end of namespace Barf
%}

// ///////////////////////////////////////////////////////////////////////////
// cpp scanner I/O parameters
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.return_type "Scanner::Token::Type"
%target.cpp.return_true_iff_input_is_at_end {
    return In().peek() == char_traits<char>::eof();
}
%target.cpp.return_next_input_char {
    return In().get();
}
%target.cpp.rejection_actions {
    EmitError(GetFiLoc(), "unrecognized character " + GetCharLiteral(rejected_atom));
}
%target.cpp.reset_for_new_input_actions {
    m_is_in_preamble = true;
    m_regex_paren_level = 0;
    m_code_block_bracket_level = 0;
}

// ///////////////////////////////////////////////////////////////////////////
// cpp scanner misc directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.generate_debug_spew_code
%target.cpp.dont_generate_timestamps

// ///////////////////////////////////////////////////////////////////////////
// target-independent scanner directives
// ///////////////////////////////////////////////////////////////////////////

// a single octal (base 8) digit
%macro OCT_DIGIT            ([0-7])
// an octal escape char (e.g. \042)
%macro OCT_CHAR             (\\0{OCT_DIGIT}+)

// a single hexadecimal (base 16) digit
%macro HEX_DIGIT            ([0-9A-Fa-f])
// a hexadecimal escape char (e.g. \xF9)
%macro HEX_CHAR             (\\x{HEX_DIGIT}+)

// an escaped char literal (e.g. '\t', '\0' or even '\j')
%macro CHAR_ESC_CHAR        (\\[[:print:]])
// everything that doesn't need to be escaped in a char literal (e.g. 'p')
%macro CHAR_NORMAL_CHAR     ([^[:cntrl:]"'\\])

// single-char escape codes for a string literal (e.g. "yo!\n")
%macro STRING_ESC_CHAR      (\\[[:print:]])
// everything that doesn't need to be escaped in a string literal
%macro STRING_NORMAL_CHAR   ([^[:cntrl:]"\\]|\t|\n)

// id (same as C-style, but can't start or end with an underscore)
%macro ID                   ([A-Za-z]([_A-Za-z0-9]*[A-Za-z0-9])?)

// all operators that should be returned by ascii value
%macro OPERATOR             ([.:;|])
// non-newline whitespace
%macro WHITESPACE           ([ \t])
// newline
%macro NEWLINE              (\n)
// any char
%macro ANYTHING             (\n|.)

%start_in_scanner_mode MAIN

%%

// ///////////////////////////////////////////////////////////////////////////
// scanner modes and constituent regex rules
// ///////////////////////////////////////////////////////////////////////////

%scanner_mode MAIN
:
    (/\*) // opening delimiter for a block comment
    %target.cpp {
        SPEW("MAIN - (/\\*) = " << GetStringLiteral(accepted_string));
        m_return_state = Mode::MAIN;
        ScannerMode(Mode::BLOCK_COMMENT);
    }
|
    (//.*) // line comment (not including the newline)
    %target.cpp {
        SPEW("MAIN - (//.*) = " << GetStringLiteral(accepted_string));
    }
|
    (') // opening quote for a char literal
    %target.cpp {
        SPEW("MAIN - (') = " << GetStringLiteral(accepted_string));
        ScannerMode(Mode::CHAR_LITERAL_GUTS);
    }
|
    (") // opening quote for a string literal
    %target.cpp {
        SPEW("MAIN - (\") = " << GetStringLiteral(accepted_string));
        *token = new Ast::String(GetFiLoc());
        ScannerMode(Mode::STRING_LITERAL_GUTS);
    }
|
    (\() // opening delimiter for a regular expression
    %target.cpp {
        SPEW("MAIN - (\\() = " << GetStringLiteral(accepted_string));
        *token = new Ast::String(GetFiLoc());
        ScannerMode(Mode::REGULAR_EXPRESSION);
    }
|
    (%\{) // opening delimiter for a dumb code block
    %target.cpp {
        SPEW("MAIN - (%\\{) = " << GetStringLiteral(accepted_string));
        *token = new Ast::DumbCodeBlock(GetFiLoc());
        ScannerMode(Mode::DUMB_CODE_BLOCK);
    }
|
    (\{) // opening delimiter for a strict code block
    %target.cpp {
        SPEW("MAIN - (\\{) = " << GetStringLiteral(accepted_string));
        *token = new Ast::StrictCodeBlock(GetFiLoc());
        ScannerMode(Mode::STRICT_CODE_BLOCK);
    }
|
    (%{ID}) // a directive
    %target.cpp {
        SPEW("MAIN - (%{ID}) = " << GetStringLiteral(accepted_string));
        return Scanner::ParseDirective(accepted_string, token);
    }
|
    (%%)
    %target.cpp {
        SPEW("MAIN - (%%) = " << GetStringLiteral(accepted_string));
        *token = new Ast::ThrowAway(GetFiLoc());
        m_is_in_preamble = false;
        return Token::END_PREAMBLE;
    }
|
    ({ID})
    %target.cpp {
        SPEW("MAIN - ({ID}) = " << GetStringLiteral(accepted_string));
        *token = new Ast::Id(accepted_string, GetFiLoc());
        return Token::ID;
    }
|
    ({OPERATOR})
    %target.cpp {
        SPEW("MAIN - ({OPERATOR}) = " << GetStringLiteral(accepted_string));
        return Token::Type(accepted_string[0]);
    }
|
    ({WHITESPACE})
    %target.cpp {
        SPEW("MAIN - ({WHITESPACE}) = " << GetStringLiteral(accepted_string));
        // ignore all whitespace
    }
|
    ({NEWLINE})
    %target.cpp {
        SPEW("MAIN - ({NEWLINE}) = " << GetStringLiteral(accepted_string));
        IncrementLineNumber();
        if (m_is_in_preamble)
            return Token::NEWLINE;
    }
|
    (\z)
    %target.cpp {
        SPEW("MAIN - (\\z) = " << GetStringLiteral(accepted_string));
        return Token::END_OF_FILE;
    }
|
    (.)
    %target.cpp {
        SPEW("MAIN - (.) = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "unexpected character " + GetCharLiteral(accepted_string[0]));
        return Token::BAD_TOKEN;
    }
;

%scanner_mode BLOCK_COMMENT
:
    (\*/) // closing delimiter for a block comment
    %target.cpp {
        SPEW("BLOCK_COMMENT - (\\*/) = " << GetStringLiteral(accepted_string));
        if (*token != NULL)
            Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        ScannerMode(m_return_state);
    }
|
    ([^*]+|\*)
    %target.cpp {
        SPEW("BLOCK_COMMENT - ([^*]+|\\*) = " << GetStringLiteral(accepted_string));
        if (*token != NULL)
            Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        IncrementLineNumber(GetNewlineCount(accepted_string));
    }
|
    (\z)
    %target.cpp {
        SPEW("BLOCK_COMMENT - (\\z) = " << GetStringLiteral(accepted_string));
        EmitWarning(GetFiLoc(), "unterminated block comment");
        return Token::END_OF_FILE;
    }
;

%scanner_mode CHAR_LITERAL_GUTS
:
    ({OCT_CHAR})
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - ({OCT_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == '0');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 8);
        if (value >= 0x100)
            EmitError(GetFiLoc(), "octal character literal value out of range (" + accepted_string + ")");
        *token = new Ast::Char(Uint8(value), GetFiLoc());
        ScannerMode(Mode::CHAR_LITERAL_END);
    }
|
    ({HEX_CHAR})
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - ({HEX_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == 'x');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 16);
        if (value >= 0x100)
            EmitError(GetFiLoc(), "hexadecimal character literal value out of range (" + accepted_string + ")");
        *token = new Ast::Char(Uint8(value), GetFiLoc());
        ScannerMode(Mode::CHAR_LITERAL_END);
    }
|
    ({CHAR_ESC_CHAR})
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - ({CHAR_ESC_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(accepted_string.length() == 2);
        assert(accepted_string[0] == '\\');
        Ast::Char *ch = new Ast::Char(Uint8(accepted_string[1]), GetFiLoc());
        ch->Escape();
        *token = ch;
        ScannerMode(Mode::CHAR_LITERAL_END);
    }
|
    ({CHAR_NORMAL_CHAR})
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - ({CHAR_NORMAL_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(accepted_string.length() == 1);
        *token = new Ast::Char(Uint8(accepted_string[0]), GetFiLoc());
        ScannerMode(Mode::CHAR_LITERAL_END);
    }
|
    (\\?\z) // end of file (which may be preceded by a backslash)
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - (\\\\?\\z) = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "unterminated character literal");
        return Token::END_OF_FILE;
    }
|
    ({ANYTHING}) // anything else just means it's malformed
    %target.cpp {
        SPEW("CHAR_LITERAL_GUTS - ({ANYTHING}) = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "unexpected character " + GetCharLiteral(accepted_string[0]) + " in character literal");
        if (accepted_string[0] == '\n')
            IncrementLineNumber();
        *token = new Ast::Char(Uint8(accepted_string[0]), GetFiLoc());
        ScannerMode(Mode::CHAR_LITERAL_END);
    }
;

%scanner_mode CHAR_LITERAL_END
:
    (') // closing single-quote
    %target.cpp {
        SPEW("CHAR_LITERAL_END - (') - accepted_string = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        ScannerMode(Mode::MAIN);
        return Token::CHAR_LITERAL;
    }
|
    (\\?\z) // end of file (which may be preceded by a backslash)
    %target.cpp {
        SPEW("CHAR_LITERAL_END - (\\\\?\\z) - accepted_string = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "unterminated character literal");
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        ScannerMode(Mode::MAIN);
        return Token::END_OF_FILE;
    }
|
    ({ANYTHING}) // anything else just means it's malformed
    %target.cpp {
        SPEW("CHAR_LITERAL_END - ({ANYTHING}) = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "malformed character literal");
        if (accepted_string[0] == '\n')
            IncrementLineNumber();
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        ScannerMode(Mode::MAIN);
        return Token::BAD_TOKEN;
    }
;

%scanner_mode STRING_LITERAL_GUTS
:
    ({OCT_CHAR})
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - ({OCT_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == '0');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 8);
        if (value >= 0x100)
            EmitError(GetFiLoc(), "octal character literal value out of range (" + accepted_string + ")");
        Dsc<Ast::String *>(*token)->AppendChar(Uint8(value));
    }
|
    ({HEX_CHAR})
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - ({HEX_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == 'x');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 16);
        if (value >= 0x100)
            EmitError(GetFiLoc(), "hexadecimal character literal value out of range (" + accepted_string + ")");
        Dsc<Ast::String *>(*token)->AppendChar(Uint8(value));
    }
|
    ({STRING_ESC_CHAR})
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - ({STRING_ESC_CHAR}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        assert(accepted_string.length() == 2);
        assert(accepted_string[0] == '\\');
        Dsc<Ast::String *>(*token)->AppendChar(GetEscapedChar(Uint8(accepted_string[1])));
    }
|
    ({STRING_NORMAL_CHAR}+)
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - ({STRING_NORMAL_CHAR}+) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::TextBase *>(*token)->AppendText(accepted_string);
    }
|
    (") // the closing quote for the string literal
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - (\") = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        ScannerMode(Mode::MAIN);
        return Token::STRING_LITERAL;
    }
|
    (\\?\z) // end of file (which may be preceded by a backslash)
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - (\\\\?\\z) = " << GetStringLiteral(accepted_string));
        EmitError(GetFiLoc(), "unterminated string literal");
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        return Token::END_OF_FILE;
    }
|
    ({ANYTHING}) // anything else is an unexpected char
    %target.cpp {
        SPEW("STRING_LITERAL_GUTS - ({ANYTHING}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        EmitError(GetFiLoc(), "ignoring unexpected character " + GetCharLiteral(accepted_string[0]) + " in string literal");
    }
;

%scanner_mode REGULAR_EXPRESSION
:
    (\)) // closing delimiter for a regular expression
    %target.cpp {
        SPEW("REGULAR_EXPRESSION - (\\)) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        if (m_regex_paren_level == 0)
        {
            ScannerMode(Mode::MAIN);
            return Token::REGEX;
        }
        --m_regex_paren_level;
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
    }
|
    (\() // opening delimeter for a sub-expression
    %target.cpp {
        SPEW("REGULAR_EXPRESSION - (\\() = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        ++m_regex_paren_level;
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
    }
|
    (\[) // opening delimiter for a bracket expression
    %target.cpp {
        SPEW("REGULAR_EXPRESSION - (\\[) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
        m_regex_bracket_level = 0;
        ScannerMode(Mode::REGULAR_EXPRESSION_BRACKET_EXPRESSION);
    }
|
    (([^()\[\]\\]|\\{ANYTHING})+) // any not-()[]-or-backslash, or any escaped char
    %target.cpp {
        SPEW("REGULAR_EXPRESSION - (([^()\\[\\]{}\\\\)|\\\\{ANYTHING})+) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
    }
|
    (\\?\z) // end of file (which may be preceded by a backslash)
    %target.cpp {
        SPEW("REGULAR_EXPRESSION - (\\\\?\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated regular expression");
        return Token::END_OF_FILE;
    }
;

%scanner_mode REGULAR_EXPRESSION_BRACKET_EXPRESSION
:
    (\]) // closing delimiter for bracket expression (or char class)
    %target.cpp {
        SPEW("REGULAR_EXPRESSION_BRACKET_EXPRESSION - (\\]) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
        if (m_regex_bracket_level == 0)
            ScannerMode(Mode::REGULAR_EXPRESSION);
        else
            --m_regex_bracket_level;
    }
|
    (\[) // opening delimiter for char class
    %target.cpp {
        SPEW("REGULAR_EXPRESSION_BRACKET_EXPRESSION - (\\[) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
        ++m_regex_bracket_level;
    }
|
    (([^\[\]\\]|\\{ANYTHING})+) // any non-delimiter non-backslash or any escaped char
    %target.cpp {
        SPEW("REGULAR_EXPRESSION_BRACKET_EXPRESSION - (([^\\[\\]\\\\]|\\\\{ANYTHING})+) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::String *>(*token)->AppendText(accepted_string);
    }
|
    (\\?\z) // end of file (which may be preceded by a backslash)
    %target.cpp {
        SPEW("REGULAR_EXPRESSION_BRACKET_EXPRESSION - (\\\\?\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated bracket expression inside regular expression");
        return Token::END_OF_FILE;
    }
;

%scanner_mode DUMB_CODE_BLOCK
:
    (%\}) // closing delimiter for a dumb code block
    %target.cpp {
        SPEW("DUMB_CODE_BLOCK - (%\\}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        ScannerMode(Mode::MAIN);
        return Token::DUMB_CODE_BLOCK;
    }
|
    ([^%]+|%)
    %target.cpp {
        SPEW("DUMB_CODE_BLOCK - ([^%]+) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
    }
|
    (\z)
    %target.cpp {
        SPEW("DUMB_CODE_BLOCK - (\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated %{ %} style code block");
        return Token::END_OF_FILE;
    }
;

%scanner_mode STRICT_CODE_BLOCK
:
    (\}) // closing delimiter for a code block
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (\\}) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        if (m_code_block_bracket_level == 0)
        {
            ScannerMode(Mode::MAIN);
            return Token::STRICT_CODE_BLOCK;
        }
        --m_code_block_bracket_level;
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
    }
|
    (\{) // opening delimiter for a code block
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (\\{) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        ++m_code_block_bracket_level;
    }
|
    (') // opening quote for a char literal
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (') = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        ScannerMode(Mode::CHAR_LITERAL_INSIDE_STRICT_CODE_BLOCK);
    }
|
    (") // opening quote for a string literal
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (\") = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        ScannerMode(Mode::STRING_LITERAL_INSIDE_STRICT_CODE_BLOCK);
    }
|
    (/[*]) // opening delimiter for a block comment
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (/[*]) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
        m_return_state = Mode::STRICT_CODE_BLOCK;
        ScannerMode(Mode::BLOCK_COMMENT);
    }
|
    (//.*) // line comment (not including the newline)
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (//.*) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
    }
|
    ([^{}'"/]+|.) // any non-delimiter char or just any single char
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - ([^{}'\"/]+|.) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::CodeBlock *>(*token)->AppendText(accepted_string);
    }
|
    (\z) // end of file
    %target.cpp {
        SPEW("STRICT_CODE_BLOCK - (\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated { } style code block");
        return Token::END_OF_FILE;
    }
;

%scanner_mode CHAR_LITERAL_INSIDE_STRICT_CODE_BLOCK
:
    (([^'\\]|\\{ANYTHING})*') // everything up to and including the first non-escaped single quote
    %target.cpp {
        SPEW("CHAR_LITERAL_INSIDE_STRICT_CODE_BLOCK - (([^'\\\\]|\\\\{ANYTHING})*') = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        Dsc<Ast::StrictCodeBlock *>(*token)->AppendText(accepted_string);
        ScannerMode(Mode::STRICT_CODE_BLOCK);
    }
|
    (([^'\\]|\\{ANYTHING})*\\?\z) // everything up to an end of file encountered before the first single quote
    %target.cpp {
        SPEW("CHAR_LITERAL_INSIDE_STRICT_CODE_BLOCK - (([^'\\\\]|\\\\{ANYTHING})*\\\\?\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated character literal in { } style code block");
        IncrementLineNumber(GetNewlineCount(accepted_string));
        return Token::END_OF_FILE;
    }
;

%scanner_mode STRING_LITERAL_INSIDE_STRICT_CODE_BLOCK
:
    (([^"\\]|\\{ANYTHING})*") // everything up to and including the first non-escaped double quote
    %target.cpp {
        SPEW("STRING_LITERAL_INSIDE_STRICT_CODE_BLOCK - (([^\"\\\\]|\\\\{ANYTHING})*\") = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        Dsc<Ast::StrictCodeBlock *>(*token)->AppendText(accepted_string);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        ScannerMode(Mode::STRICT_CODE_BLOCK);
    }
|
    (([^"\\]|\\{ANYTHING})*\\?\z) // everything up to an end of file encountered before the first double quote
    %target.cpp {
        SPEW("STRING_LITERAL_INSIDE_STRICT_CODE_BLOCK - (([^\"\\\\]|\\\\{ANYTHING}))*\\\\?\\z) = " << GetStringLiteral(accepted_string));
        assert(*token != NULL);
        delete *token;
        *token = NULL;
        EmitError(GetFiLoc(), "unterminated string literal in { } style code block");
        IncrementLineNumber(GetNewlineCount(accepted_string));
        return Token::END_OF_FILE;
    }
;
