// ///////////////////////////////////////////////////////////////////////////
// barf_regex_parser.trison by Victor Dods, created 2006/01/30
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%targets cpp


%target.cpp.header_filename "barf_regex_parser.hpp"
%target.cpp.implementation_filename "barf_regex_parser.cpp"


%target.cpp.top_of_header_file %{
#if !defined(_BARF_REGEX_PARSER_HPP_)
#define _BARF_REGEX_PARSER_HPP_

#include "barf_regex.hpp"

#include <istream>

#include "barf_inputbase.hpp"
#include "barf_regex_ast.hpp"
#include "barf_util.hpp"

namespace Barf {
namespace Regex {
%}
%target.cpp.class_name Parser
%target.cpp.class_inheritance { protected InputBase }
%target.cpp.parse_method_access "private:"
%target.cpp.bottom_of_class {
    using InputBase::GetIsOpen;
    using InputBase::GetFiLoc;
    using InputBase::GetInputName;

    using InputBase::OpenFile;
    using InputBase::OpenString;
    using InputBase::OpenUsingStream;

    using InputBase::Close;

    bool ScannerDebugSpew () const { return false; /* TODO: not implemented yet */ }
    void ScannerDebugSpew (bool debug_spew) { /* TODO: not implemented yet */ }

    // this method will throw a std::string if a macro is used without
    // providing a macro map, or otherwise if an undefined macro is
    // referenced.
    ParserReturnCode Parse (RegularExpression **parsed_regex, RegularExpressionMap *macro_map);

private:

    mutable RegularExpressionMap *m_macro_map;
}
%target.cpp.bottom_of_header_file %{
} // end of namespace Regex
} // end of namespace Barf

#endif // !defined(_BARF_REGEX_PARSER_HPP_)
%}


%target.cpp.top_of_implementation_file %{
#include <sstream>

namespace Barf {
namespace Regex {
%}
%target.cpp.superclass_and_member_constructors { InputBase() }
%target.cpp.constructor_actions {
    m_macro_map = NULL;
}
%target.cpp.destructor_actions {
    assert(m_macro_map == NULL);
}
%target.cpp.bottom_of_implementation_file %{
inline bool IsHexDigit (Uint8 const c)
{
    return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';
}

inline Uint8 GetHexDigitValue (Uint8 c)
{
    assert(IsHexDigit(c));
    if (c >= '0' && c <= '9')
        c -= '0';
    else if (c >= 'A' && c <= 'F')
        c += 0xA - 'A';
    else if (c >= 'a' && c <= 'f')
        c += 0xA - 'a';
    return c;
}

Parser::ParserReturnCode Parser::Parse (RegularExpression **parsed_regex, RegularExpressionMap *macro_map)
{
    assert(parsed_regex != NULL);
    assert(m_macro_map == NULL);
    try {
        Ast::Base *parsed_tree_root = NULL;
        m_macro_map = macro_map;
        ParserReturnCode retval = Parse(&parsed_tree_root);
        *parsed_regex = Dsc<RegularExpression *>(parsed_tree_root);
        m_macro_map = NULL;
        return retval;
    } catch (string const &exception) {
        *parsed_regex = NULL;
        m_macro_map = NULL;
        throw exception;
    }
}

} // end of namespace Regex
} // end of namespace Barf
%}


%target.cpp.token_data_type "Ast::Base *"
%target.cpp.token_data_default "NULL"
%target.cpp.custom_token_data_type_cast Dsc
%target.cpp.throw_away_token_actions {
    delete token_data;
}
%target.cpp.scan_actions {
    while (true)
    {
        int c;

        c = In().get();
        if (c == EOF)
            return Token(Terminal::END_);

        if (c >= '0' && c <= '9')
        {
//             fprintf(stderr, "\n######## scanning DIGIT '%c'\n", static_cast<char>(c));
            return Token(Terminal::DIGIT, new Char(c));
        }
        else if (c >= 'A' && c <= 'Z'
                 ||
                 c >= 'a' && c <= 'z')
        {
//             fprintf(stderr, "\n######## scanning CHAR '%c'\n", static_cast<char>(c));
            return Token(Terminal::ALPHA, new Char(c));
        }
        else if (c >= 128 && c < 256)
        {
//             fprintf(stderr, "\n######## scanning extended ascii CHAR \\0x%02X\n", c);
            return Token(Terminal::ALPHA, new Char(c));
        }

        switch (c)
        {
            // special case for backslash, because it can be followed by a hex char
            case '\\':
                // fuck it for now, just return the backslash
                /*
                if (In().peek() == EOF)
                {
                    In().get();
                    assert(In().eof());
                    return Token::Id('\\');
                }

                c = In().peek();
                if (c == 'x')
                {
                    In().get();
                    assert(!In().eof());

                    c = In().peek();
                    if (c == EOF)
                    {
                        cerr << "\n\nBLAH BLAH\n\n" << endl;
                        assert(In().eof());
                    }
                    if (c != EOF && IsHexDigit(c))
                    {
                        In().get();
                        assert(!In().eof());
                        Uint8 hex_value = GetHexDigitValue(c);

                        c = In().peek();
                        if (c != EOF && IsHexDigit(c))
                        {
                            In().get();
                            assert(!In().eof());
                            hex_value = (hex_value << 4) + GetHexDigitValue(c);
                        }

                        return Token(Terminal::ALPHA, new Char(hex_value, true));
                    }
                    else
                    {
                        // unget the 'x' char
//                         In().putback('x');
                        In().unget();
//                         assert(!In().eof());
//                         assert((c = In().peek()) == 'x');
                        return Token::Id('\\');
                    }
                }
                // if it didn't work, push the char back in the stream and return '\\'
                else
                {
                    return Token::Id('\\');
                }
                */
            case '^':
            case '$':
            case '*':
            case '+':
            case '?':
            case '{':
            case '}':
            case '[':
            case ']':
            case '(':
            case ')':
            case '.':
            case ',':
            case '|':
            case '-':
            case ':':
//                 fprintf(stderr, "\n######## scanning control char '%c'\n", static_cast<char>(c));
                return Token::Id(c);

            case '\0':
            case '\a':
            case '\b':
            case '\t':
            case '\n':
            case '\v':
            case '\f':
            case '\r':
//                 fprintf(stderr, "\n######## skipping escaped char\n");
                break;

            case ' ':
            case '!':
            case '"':
            case '#':
            case '%':
            case '&':
            case '\'':
            case '/':
            case ';':
            case '<':
            case '=':
            case '>':
            case '@':
            case '_':
            case '`':
            case '~':
//                 fprintf(stderr, "\n######## scanning CHAR '%c'\n", static_cast<char>(c));
                return Token(Terminal::CHAR, new Char(c));

            default:
//                 fprintf(stderr, "\n######## skipping invalid char\n");
                break;
        }
    }
}


%target.cpp.generate_debug_spew_code
%target.cpp.debug_spew_prefix {"Regex::Parser" << (GetFiLoc().GetIsValid() ? " ("+GetFiLoc().GetAsString()+")" : g_empty_string) << ":"}
%target.cpp.dont_generate_timestamps


//////////////////////////////////////////////////////////////////////////////
// grammar metadata
//////////////////////////////////////////////////////////////////////////////

%terminal BAD_TOKEN
%terminal ALPHA %type.cpp "Char *"
%terminal CHAR %type.cpp "Char *"
%terminal DIGIT %type.cpp "Char *"
                       // NOTE: quotes around examples for clarity
%terminal '|'          // branch operator; e.g. "re1|re2" matches "re1" or "re2"
%terminal '(' ')'      // associative grouping delimiters
%terminal '?'          // "a?" matches "" or "a"
%terminal '*'          // "a*" matches "" or "a" or "aa" or "aaa" etc
%terminal '+'          // "a+" matches "a" or "aa" or "aaa" etc
%terminal '{' ',' '}'  // "a{3}" matches "aaa"
                       // "a{3,}" matches "aaa" or "aaaa" or "aaaaa" etc
                       // "a{3,4}" matches "aaa" or "aaaa"
%terminal '^'          // "^blah" matches "blah" only at the beginning of a line
%terminal '$'          // "blah$" matches "blah" only at the end of a line
%terminal '.'          // "." matches any non-newline char
%terminal '\\'         // escape char
%terminal '[' ']'      // bracket expression delimiters
%terminal '-'          // bracket range delimiter
%terminal ':'          // char class delimiter
                       // "[abc]" matches "a" or "b" or "c"
                       // "[a-e]" matches "a" or "b" or "c" or "d" or "e"
                       // "[[:digit:]]" matches "0" or "1" or "2" or "3" or "4"
                       //                    or "5" or "6" or "7" or "8" or "9"
                       // other char classes include "alnum", "alpha", etc

%default_parse_nonterminal regex

%%

//////////////////////////////////////////////////////////////////////////////
// grammar specification
//////////////////////////////////////////////////////////////////////////////

%nonterminal regex %type.cpp "RegularExpression *"
:
    regex:regex '|' branch:branch
    %target.cpp {
        regex->Append(branch);
        return regex;
    }
|
    branch:branch
    %target.cpp {
        RegularExpression *regex = new RegularExpression();
        regex->Append(branch);
        return regex;
    }
;

%nonterminal branch %type.cpp "Branch *"
:
    branch_which_didnt_just_accept_an_atom:branch   %target.cpp { return branch; }
|   branch_which_just_accepted_an_atom:branch       %target.cpp { return branch; }
|   /* empty reduction rule */                      %target.cpp { return new Branch(); }
;

%nonterminal branch_which_didnt_just_accept_an_atom %type.cpp "Branch *"
:
    branch_which_just_accepted_an_atom:branch bound:bound
    %target.cpp {
        branch->AddBound(bound);
        return branch;
    }
;

%nonterminal branch_which_just_accepted_an_atom %type.cpp "Branch *"
:
    branch_which_just_accepted_an_atom:branch atom:atom
    %target.cpp {
        branch->AddAtom(atom);
        return branch;
    }
|
    branch_which_didnt_just_accept_an_atom:branch atom:atom
    %target.cpp {
        branch->AddAtom(atom);
        return branch;
    }
|
    atom:atom
    %target.cpp {
        Branch *branch = new Branch();
        branch->AddAtom(atom);
        return branch;
    }
;

//////////////////////////////////////////////////////////////////////////////
// atom and bound rules (which together make a piece)
//////////////////////////////////////////////////////////////////////////////

%nonterminal atom %type.cpp "Atom *"
:
    '{' id:macro_name '}'
    %target.cpp {
        assert(macro_name != NULL);
        if (m_macro_map == NULL)
            THROW_STRING("can not use regex macros if no macro map was provided");
        RegularExpression *macro_regex = m_macro_map->GetElement(macro_name->GetText());
        if (macro_regex == NULL)
            THROW_STRING("undefined macro \"" + macro_name->GetText() + "\"");
        return macro_regex;
    }
|
    '(' regex:regex ')'         %target.cpp { return regex; }
|   '(' ')'                     %target.cpp { return new RegularExpression(); }
|   '^'                         %target.cpp { return new Char('\0', CT_BEGINNING_OF_LINE); }
|   '$'                         %target.cpp { return new Char('\0', CT_END_OF_LINE); }
|   '.'                         %target.cpp { return new BracketCharSet('\n', true); }
|   atom_normal_char:ch         %target.cpp { return ch; }
|   '\\' atom_normal_char:ch    %target.cpp { ch->Escape(); return ch; }
|   '\\' atom_control_char:ch   %target.cpp { return ch; }
|   bracket_expression:exp      %target.cpp { return exp; }
;

%nonterminal bound %type.cpp "Bound *"
:
    '*' %target.cpp { return new Bound(0, Bound::NO_UPPER_BOUND); }
|
    '+' %target.cpp { return new Bound(1, Bound::NO_UPPER_BOUND); }
|
    '?' %target.cpp { return new Bound(0, 1); }
|
    '{' integer:exact_bound '}'
    %target.cpp {
        assert(exact_bound->GetValue() >= 0);
        Bound *bound = new Bound(exact_bound->GetValue(), exact_bound->GetValue());
        delete exact_bound;
        return bound;
    }
|
    '{' integer:lower_bound ',' '}'
    %target.cpp {
        assert(lower_bound->GetValue() >= 0);
        return new Bound(lower_bound->GetValue(), Bound::NO_UPPER_BOUND);
    }
|
    '{' integer:lower_bound ',' integer:upper_bound '}'
    %target.cpp {
        assert(lower_bound->GetValue() >= 0);
        assert(upper_bound->GetValue() >= 0);
        if (lower_bound->GetValue() > upper_bound->GetValue() ||
            lower_bound->GetValue() == 0 && upper_bound->GetValue() == 0)
        {
            ostringstream out;
            out << "invalid bound {" << lower_bound->GetValue() << ',' << upper_bound->GetValue() << '}';
            throw out.str();
        }
        else if (lower_bound->GetValue() > Bound::GetMaximumBoundValue())
        {
            ostringstream out;
            out << "bound value " << lower_bound->GetValue() << " is out of range (max 255)";
            throw out.str();
        }
        else if (upper_bound->GetValue() > Bound::GetMaximumBoundValue())
        {
            ostringstream out;
            out << "bound value " << upper_bound->GetValue() << " is out of range (max 255)";
            throw out.str();
        }
        Bound *bound = new Bound(lower_bound->GetValue(), upper_bound->GetValue());
        delete lower_bound;
        delete upper_bound;
        return bound;
    }
;

//////////////////////////////////////////////////////////////////////////////
// bracket expression rules
//////////////////////////////////////////////////////////////////////////////

%nonterminal bracket_expression %type.cpp "Atom *"
:
    '[' bracket_char_set:bracket_char_set ']'
    %target.cpp {
        if (bracket_char_set->GetIsEmpty())
            THROW_STRING("invalid empty bracket expression");
        return bracket_char_set;
    }
|
    '[' '^' bracket_char_set:bracket_char_set ']'
    %target.cpp {
        if (bracket_char_set->GetIsEmpty())
            THROW_STRING("invalid empty bracket expression");
        bracket_char_set->Negate();
        return bracket_char_set;
    }
;

%nonterminal bracket_char_set %type.cpp "BracketCharSet *"
:
    bracket_char_set:bracket_char_set bracket_expression_char:ch
    %target.cpp {
        bracket_char_set->AddChar(ch->GetChar());
        delete ch;
        return bracket_char_set;
    }
|
    bracket_char_set:bracket_char_set bracket_expression_char:begin_range '-' bracket_expression_char:end_range
    %target.cpp {
        if (end_range->GetChar() < begin_range->GetChar())
            THROW_STRING("invalid bracketed range [" << GetCharLiteral(begin_range->GetChar(), false) << '-' << GetCharLiteral(end_range->GetChar(), false) << ']');
        bracket_char_set->AddCharRange(
            begin_range->GetChar(),
            end_range->GetChar());
        delete begin_range;
        delete end_range;
        return bracket_char_set;
    }
|
    bracket_char_set:bracket_char_set '[' ':' id:id ':' ']'
    %target.cpp {
        bracket_char_set->AddCharClass(id->GetText());
        delete id;
        return bracket_char_set;
    }
|
    // empty reduction rule
    %target.cpp {
        BracketCharSet *bracket_char_set = new BracketCharSet();
        return bracket_char_set;
    }
;

%nonterminal bracket_expression_char %type.cpp "Char *"
:   // normal chars don't require any escaping.
    bracket_expression_normal_char:normal_char        %target.cpp { return normal_char; }
|   // some normal chars can be escaped (like '\n')
    '\\' bracket_expression_normal_char:normal_char   %target.cpp { normal_char->Escape(); return normal_char; }
|   // control chars require escaping.
    '\\' bracket_expression_control_char:control_char %target.cpp { return control_char; }
;

//////////////////////////////////////////////////////////////////////////////
// grammar primitive rules
//////////////////////////////////////////////////////////////////////////////

// these chars are special only in atom parsing (not inside
// a bound or a bracket expression).  all others (with the exception
// of backslash, the escape char) are treated as normal chars.
// no char here should be present in atom_normal_char,
// and the union of atom_normal_char, atom_control_char
// and backslash should constitute all valid chars.
%nonterminal atom_control_char %type.cpp "Char *"
:
    // branch operator
    '|' %target.cpp { return new Char('|'); }
|   // associative grouping delimiter (open)
    '(' %target.cpp { return new Char('('); }
|   // associative grouping delimiter (close)
    ')' %target.cpp { return new Char(')'); }
|   // bound delimiter (open)
    '{' %target.cpp { return new Char('{'); }
|   // bound delimiter (close)
    '}' %target.cpp { return new Char('}'); }
|   // bracket expression delimiter (open)
    '[' %target.cpp { return new Char('['); }
|   // bracket expression delimiter (close)
    ']' %target.cpp { return new Char(']'); }
|   // indicates 0 or 1 of the previous atom
    '?' %target.cpp { return new Char('?'); }
|   // indicates 0 or more of the previous atom
    '*' %target.cpp { return new Char('*'); }
|   // indicates 1 or more of the previous atom
    '+' %target.cpp { return new Char('+'); }
|   // match-any-non-newline char
    '.' %target.cpp { return new Char('.'); }
|   // match-the-beginning-of-a-line epsilon operator
    '^' %target.cpp { return new Char('^'); }
|   // match-the-end-of-a-line epsilon operator
    '$' %target.cpp { return new Char('$'); }
|   // backslash -- for escaping other chars
    '\\' %target.cpp { return new Char('\\'); }
;

// these chars have no special meaning in atom parsing (not
// inside a bound or a bracket expression).  all others (with the exception
// of backslash, the escape char) are treated as control chars.
// no char here should be present in atom_control_char,
// and the union of atom_normal_char, atom_control_char
// and backslash should constitute all valid chars.
%nonterminal atom_normal_char %type.cpp "Char *"
:
    ALPHA:alpha %target.cpp { return alpha; }
|   DIGIT:digit %target.cpp { return digit; }
|   CHAR:ch     %target.cpp { return ch; }
|   ','         %target.cpp { return new Char(','); }
|   '-'         %target.cpp { return new Char('-'); }
|   ':'         %target.cpp { return new Char(':'); }
;

// these chars are special only inside bracket expressions.  all others
// (with the exception of backslash, the escape char) are treated as
// normal chars.  no char here should be present in
// bracket_expression_normal_char, and the union of
// bracket_expression_normal_char, bracket_expression_control_char
// and backslash should constitute all valid chars.
%nonterminal bracket_expression_control_char %type.cpp "Char *"
:
    // delimits a bracket atom range
    '-' %target.cpp { return new Char('-'); }
|   // indicates bracket char set negation
    '^' %target.cpp { return new Char('^'); }
|   // indicates the beginning of a char class expression
    '[' %target.cpp { return new Char('['); }
|   // indicates the end of the bracket expression (or char class exp)
    ']' %target.cpp { return new Char(']'); }
|   // backslash -- for escaping other chars
    '\\' %target.cpp { return new Char('\\'); }
;

// these chars have no special meaning inside bracket expressions.  all
// others (with the exception of backslash, the escape char) are treated
// as normal chars.  no char here should be present in
// bracket_expression_normal_char, and the union of
// bracket_expression_normal_char, bracket_expression_control_char
// and backslash should constitute all valid chars.
%nonterminal bracket_expression_normal_char %type.cpp "Char *"
:
    ALPHA:alpha %target.cpp { return alpha; }
|   DIGIT:digit %target.cpp { return digit; }
|   CHAR:ch     %target.cpp { return ch; }
|   '|'         %target.cpp { return new Char('|'); }
|   ':'         %target.cpp { return new Char(':'); }
|   '?'         %target.cpp { return new Char('?'); }
|   '*'         %target.cpp { return new Char('*'); }
|   '+'         %target.cpp { return new Char('+'); }
|   '.'         %target.cpp { return new Char('.'); }
|   '$'         %target.cpp { return new Char('$'); }
|   ','         %target.cpp { return new Char(','); }
|   '('         %target.cpp { return new Char('('); }
|   ')'         %target.cpp { return new Char(')'); }
|   '{'         %target.cpp { return new Char('{'); }
|   '}'         %target.cpp { return new Char('}'); }
;

%nonterminal id %type.cpp "Ast::Id *"
:
    id:id ALPHA:alpha
    %target.cpp {
        assert(id != NULL);
        id->AppendChar(alpha->GetChar());
        delete alpha;
        return id;
    }
|
    id:id CHAR:ch
    %target.cpp {
        assert(id != NULL);
        id->AppendChar(ch->GetChar());
        delete ch;
        return id;
    }
|
    id:id DIGIT:digit
    %target.cpp {
        assert(id != NULL);
        id->AppendChar(digit->GetChar());
        delete digit;
        return id;
    }
|
    ALPHA:alpha
    %target.cpp {
        string temp;
        temp += alpha->GetChar();
        Ast::Id *id = new Ast::Id(temp, FiLoc::ms_invalid);
        delete alpha;
        return id;
    }
|
    CHAR:ch
    %target.cpp {
        string temp;
        temp += ch->GetChar();
        Ast::Id *id = new Ast::Id(temp, FiLoc::ms_invalid);
        delete ch;
        return id;
    }
;

%nonterminal integer %type.cpp "Ast::SignedInteger *"
:
    integer:integer DIGIT:digit
    %target.cpp {
        integer->ShiftAndAdd(digit->GetChar() - '0');
        if (integer->GetValue() > 255)
            integer->SetValue(255);
        delete digit;
        return integer;
    }
|
    DIGIT:digit
    %target.cpp {
        Ast::SignedInteger *integer = new Ast::SignedInteger(digit->GetChar() - '0', FiLoc::ms_invalid);
        delete digit;
        return integer;
    }
;
