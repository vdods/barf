// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// barf_regex_parser.cpp generated by trison
// from barf_regex_parser.trison using trison.cpp.targetspec and trison.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "barf_regex_parser.hpp"


#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }


#line 74 "barf_regex_parser.trison"

#include <sstream>

namespace Barf {
namespace Regex {

bool IsHexDigit (Uint8 const c)
{
    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');
}

Uint8 HexDigitValue (Uint8 c)
{
    assert(IsHexDigit(c));
    if (c >= '0' && c <= '9')
        c -= '0';
    else if (c >= 'A' && c <= 'F')
        c += 0xA - 'A';
    else if (c >= 'a' && c <= 'f')
        c += 0xA - 'a';
    return c;
}

#line 37 "barf_regex_parser.cpp"

Parser::Parser ()
    :

#line 97 "barf_regex_parser.trison"
 InputBase() 
#line 44 "barf_regex_parser.cpp"
{
    DebugSpew(false);


#line 98 "barf_regex_parser.trison"

    m_macro_map = NULL;
    m_active_backslash = false;

#line 54 "barf_regex_parser.cpp"
}

Parser::~Parser ()
{
    // clean up dynamically allocated memory.
    ClearStack_();
    ClearLookaheadQueue_();



#line 102 "barf_regex_parser.trison"

    assert(m_macro_map == NULL);

#line 69 "barf_regex_parser.cpp"
}

bool Parser::IsAtEndOfInput ()
{
    return Lookahead_(0).m_id == Terminal::END_;
}

void Parser::ResetForNewInput ()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 82 "barf_regex_parser.cpp"
 << " executing reset-for-new-input actions" << std::endl)
    
    // clean up stuff that might be hanging around from the last parse's input.
    ClearStack_();
    ClearLookaheadQueue_();


#line 283 "barf_regex_parser.trison"

    m_macro_map = NULL;
    m_active_backslash = false;

#line 95 "barf_regex_parser.cpp"
}

Parser::ParserReturnCode Parser::Parse (Ast::Base * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    return Parse_(return_token, nonterminal_to_parse);
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

Parser::ParserReturnCode Parser::Parse_ (Ast::Base * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 114 "barf_regex_parser.cpp"
 << " starting parse" << std::endl)

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = NULL;

    // this is the try {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    try {

    // make sure all our structures are empty and variables initialized.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();
    m_is_in_error_panic_ = false;

    // push the initial state of the DPDA.
    assert((false
           || nonterminal_to_parse == ParseNonterminal::atom
           || nonterminal_to_parse == ParseNonterminal::atom_control_char
           || nonterminal_to_parse == ParseNonterminal::atom_normal_char
           || nonterminal_to_parse == ParseNonterminal::bound
           || nonterminal_to_parse == ParseNonterminal::bracket_char_set
           || nonterminal_to_parse == ParseNonterminal::bracket_expression
           || nonterminal_to_parse == ParseNonterminal::bracket_expression_char
           || nonterminal_to_parse == ParseNonterminal::bracket_expression_control_char
           || nonterminal_to_parse == ParseNonterminal::bracket_expression_normal_char
           || nonterminal_to_parse == ParseNonterminal::branch
           || nonterminal_to_parse == ParseNonterminal::branch_which_didnt_just_accept_an_atom
           || nonterminal_to_parse == ParseNonterminal::branch_which_just_accepted_an_atom
           || nonterminal_to_parse == ParseNonterminal::id
           || nonterminal_to_parse == ParseNonterminal::integer
           || nonterminal_to_parse == ParseNonterminal::regex
           ) && "invalid nonterminal_to_parse");
    m_stack_.push_back(StackElement_(nonterminal_to_parse, NULL));
    // main parser loop
    while (true)
    {
        if (m_is_in_error_panic_)
        {
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 161 "barf_regex_parser.cpp"
 << " begin error panic" << std::endl)

            while (true)
            {
                // get the current state (top of the stack)
                assert(!m_stack_.empty());
                BarfCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
                assert(current_state_index < ms_state_count_);
                State_ const &current_state = ms_state_table_[current_state_index];
                TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

                // check if the current state accepts ERROR_ (only need to check the
                // non-default transitions, since the default transition can't be a shift).
                bool accepts_error = false;
                for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                       *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                     transition != transition_end;
                     ++transition)
                {
                    if (transition->m_type == Transition_::SHIFT && transition->m_lookahead_count == 1 && *transition->m_lookahead_sequence == Terminal::ERROR_)
                    {
                        accepts_error = true;
                        break;
                    }
                }

                if (accepts_error)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 193 "barf_regex_parser.cpp"
 << " end error panic; success (current state accepts ERROR_ token)" << std::endl)
                    // if the current state accepts error, then we check if the lookahead token
                    // is Terminal::END_.  if it is, then we add a dummy Terminal::ERROR_ token
                    // in before it (since %error can't accept END_).  otherwise, we throw away
                    // the lookahead token, then clear the thrown-away token data, and set the
                    // token id to ERROR_.
                    assert(!m_lookahead_queue_.empty());
                    if (m_lookahead_queue_[0].m_id == Terminal::END_)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 206 "barf_regex_parser.cpp"
 << " deferring Terminal::END_ (padding with Terminal::ERROR_ token)" << std::endl)
                        m_lookahead_queue_.push_front(Token(Terminal::END_)); // dummy value
                    }
                    else
                        ThrowAwayToken_(m_lookahead_queue_[0].m_data);
                    m_lookahead_queue_[0].m_id = Terminal::ERROR_;
                    m_lookahead_queue_[0].m_data = NULL;
                    m_is_in_error_panic_ = false;
                    break;
                }
                else
                {
                    if (m_stack_.size() > 1)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 224 "barf_regex_parser.cpp"
 << " continue error panic; pop stack (current state doesn't accept ERROR_ token)" << std::endl)
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 232 "barf_regex_parser.cpp"
 << " end error panic; abort (stack is empty)" << std::endl)
                    }
                    // otherwise throw away the data at the top of the stack, and pop the stack.
                    // then if the stack is empty, an unhandled parse error occurred.
                    ThrowAwayToken_(m_stack_.rbegin()->m_token_data);
                    m_stack_.resize(m_stack_.size()-1);
                    if (m_stack_.empty())
                    {
                        // parser_return_code_ and return_token are already appropriately
                        // set, so just break out of the inner loop.
                        break;
                    }
                }
            }

            // if we're still in error panic, then this indicates that we bottomed-
            // out the stack and it's an unhandled parse error, so break from the
            // main loop.
            if (m_is_in_error_panic_)
                break;
        }
        else // !m_is_in_error_panic_
        {
            // get the current state (top of the stack)
            assert(!m_stack_.empty());
            BarfCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
            assert(current_state_index < ms_state_count_);
            State_ const &current_state = ms_state_table_[current_state_index];
            TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

            // TODO -- binary search for faster transition matching?

            // loop through the current state's transitions and see if any match
            bool transition_exercised = false;
            BarfCpp_::Uint32 tested_lookahead_count = 0;
            for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                   *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                transition != transition_end;
                ++transition)
            {
                // the non-default transitions can only be REDUCE or SHIFT
                assert(transition->m_type == Transition_::REDUCE || transition->m_type == Transition_::SHIFT);

                // check if the lookaheads match those of this transition.
                bool lookahead_sequence_matched = true;
                for (BarfCpp_::Uint32 i = 0; i < transition->m_lookahead_count; ++i)
                {
                    if (Lookahead_(i).m_id != transition->m_lookahead_sequence[i])
                    {
                        lookahead_sequence_matched = false;
                        break;
                    }
                    else
                    {
                        if (i+1 > tested_lookahead_count)
                            tested_lookahead_count = i+1;
                    }
                }

                // if all the lookaheads matched, then exercise this transition,
                // and break out of this inner (transition) loop.
                if (lookahead_sequence_matched)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 299 "barf_regex_parser.cpp"
 << " current (relevant) lookahead(s):")
                    for (BarfCpp_::Uint32 i = 0; i < tested_lookahead_count; ++i)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                    }
                    TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                    ExerciseTransition_(*transition);
                    transition_exercised = true;
                    break;
                }
            }

            // if no transition was exercised, then exercise the default transition
            if (!transition_exercised)
            {
                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 319 "barf_regex_parser.cpp"
 << " current (relevant) lookahead(s):")
                for (BarfCpp_::Uint32 i = 0; i < tested_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 330 "barf_regex_parser.cpp"
 << " exercising default transition" << std::endl)
                // exercise the default transition.  a return value of true indicates
                // that the parser should return.
                if (ExerciseTransition_(*current_state.m_transition_table))
                {
                    // the token (data) on the top of the stack is the return token.
                    // set parser_return_code_ and assign the top stack token data to
                    // *return_token and then break out of the main parser loop.
                    assert(m_stack_[0].m_state_index == BarfCpp_::Uint32(nonterminal_to_parse));
                    assert(m_stack_.size() == 2);
                    parser_return_code_ = PRC_SUCCESS;
                    *return_token = m_stack_.rbegin()->m_token_data;
                    // take the return token out of the stack, so it's not thrown away
                    // when we clear the stack later.
                    m_stack_.rbegin()->m_token_data = NULL;
                    break;
                }
            }
        }
    }

    // clear the stack, because we won't need it for the next parse.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();

    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    } catch (...) {
        // clear the stack, because we won't need it for the next parse.
        // we don't clear the lookahead queue here because we might want to
        // parse multiple times from the same input, and the lookahead queue
        // could have the next few tokens in it.
        ClearStack_();
        // rethrow the (unknown) exception.
        throw;
    }

    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 376 "barf_regex_parser.cpp"
 << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 381 "barf_regex_parser.cpp"
 << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

    return parser_return_code_;
}

void Parser::ThrowAwayToken_ (Token::Data &token_data) throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 392 "barf_regex_parser.cpp"
 << " executing throw-away-token actions" << std::endl)


#line 152 "barf_regex_parser.trison"

    delete token_data;

#line 400 "barf_regex_parser.cpp"
}

Parser::Token Parser::Scan_ ()
{

#line 155 "barf_regex_parser.trison"

    while (true)
    {
        int c;

        c = In().get();
        if (c == EOF)
        {
            m_active_backslash = false;
            return Token(Terminal::END_);
        }

        if (c >= '0' && c <= '9')
        {
            m_active_backslash = false;
            return Token(Terminal::DIGIT, new Char(c));
        }
        else if ((c >= 'A' && c <= 'Z')
                 ||
                 (c >= 'a' && c <= 'z'))
        {
            m_active_backslash = false;
            return Token(Terminal::ALPHA, new Char(c));
        }

        assert(c >= 0 && c < 256);

        switch (c)
        {
            // backslash needs to be handled in a special way, since
            // it can delimit a hex char (e.g. \xA7).
            //
            // the desired behavior is that in the string "\\xA7" the
            // sequence of returned chars is '\' '\' 'x' 'A' '7' (i.e.
            // "\\" takes precedence over "\xA7") whereas in the string
            // "\xA7" the sequence a single character having hex value A7.
            case '\\':
            {
                // if there's an active backslash, we'll want to just
                // return the backslash, because the active backslash
                // (the previous character) will escape it.
                if (m_active_backslash)
                {
                    m_active_backslash = false;
                    return Token::Id('\\');
                }                
                // if the next char isn't 'x' (i.e. we will not be
                // parsing a hex char), then this backslash is active.
                if (In().peek() != 'x')
                {
                    m_active_backslash = true;
                    return Token::Id('\\');
                }
                assert(!m_active_backslash);

                // eat the 'x'
                c = In().get();
                assert(c == 'x');

                // we're expecting exactly two hex digits after the \x
                Uint8 hex_value = 0;
                for (Uint8 i = 0; i < 2; ++i)
                {
                    c = In().get();
                    if (c == EOF)
                        THROW_STRING("encountered end of input while trying to scan hex char");
                    if (!IsHexDigit(c))
                        THROW_STRING("expected exactly two hex digits after \"\\x\"");
                    hex_value <<= 4;
                    hex_value |= HexDigitValue(c);
                }
                
                // (for now) prevent usage of the null char \x00, since
                // the scanner implementation uses '\0' as a sentinel value.
                if (hex_value == 0)
                    THROW_STRING("can't use hex char \x00");

                return Token(Terminal::HEX_CHAR, new Char(hex_value));
            }

            // other control chars
            case '^':
            case '$':
            case '*':
            case '+':
            case '?':
            case '{':
            case '}':
            case '[':
            case ']':
            case '(':
            case ')':
            case '.':
            case ',':
            case '|':
            case '-':
            case ':':
                m_active_backslash = false;
                return Token::Id(c);

            // non-alphanumeric normal chars
            case ' ':
            case '!':
            case '"':
            case '#':
            case '%':
            case '&':
            case '\'':
            case '/':
            case ';':
            case '<':
            case '=':
            case '>':
            case '@':
            case '_':
            case '`':
            case '~':
                m_active_backslash = false;
                return Token(Terminal::CHAR, new Char(c));

            // anything else is an invalid char
            default:
                m_active_backslash = false;
                THROW_STRING("invalid char (use hex char " << CharLiteral(c, false) << " instead)");
                break;
        }
    }

#line 535 "barf_regex_parser.cpp"
}

void Parser::ClearStack_ () throw()
{
    if (m_stack_.empty())
        return; // nothing to do

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 546 "barf_regex_parser.cpp"
 << " clearing the stack" << std::endl)

    Stack_::iterator it = m_stack_.begin();
    Stack_::iterator it_end = m_stack_.end();
    // skip the bottom of the stack, since it
    // contains the start state and no token data.
    ++it;
    for ( ; it != it_end; ++it)
        ThrowAwayToken_(it->m_token_data);
    m_stack_.clear();
}

void Parser::ClearLookaheadQueue_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 564 "barf_regex_parser.cpp"
 << " clearing the lookahead queue" << std::endl)

    for (LookaheadQueue_::iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
        ThrowAwayToken_(it->m_data);
    m_lookahead_queue_.clear();
}

Parser::Token const &Parser::Lookahead_ (LookaheadQueue_::size_type index)
{
    while (index >= m_lookahead_queue_.size())
    {
        m_lookahead_queue_.push_back(Scan_());

        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 581 "barf_regex_parser.cpp"
 << " pushed " << *m_lookahead_queue_.rbegin() << " onto back of lookahead queue" << std::endl)
    }
    return m_lookahead_queue_[index];
}

bool Parser::ExerciseTransition_ (Transition_ const &transition)
{
    switch (transition.m_type)
    {
        case Transition_::REDUCE:
        {
            // execute the indicated reduction rule, push the returned Token
            // onto the front of the lookahead queue, then pop the corresponding
            // number of stack elements.
            assert(transition.m_data < ms_rule_count_);
            Rule_ const &rule = ms_rule_table_[transition.m_data];
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 601 "barf_regex_parser.cpp"
 << " REDUCE " << rule.m_description << std::endl)
            assert(m_stack_.size() > rule.m_token_count);
            m_lookahead_queue_.push_front(
                Token(
                    rule.m_reduction_nonterminal_token_id,
                    ExecuteReductionRule_(transition.m_data)));
            m_stack_.resize(m_stack_.size() - rule.m_token_count);
            assert(rule.m_reduction_nonterminal_token_id < ms_token_name_count_);
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 613 "barf_regex_parser.cpp"
 << " pushed " << Token(rule.m_reduction_nonterminal_token_id) << " onto front of lookahead queue" << std::endl)
            return false; // indicating the parser isn't returning
        }

        case Transition_::RETURN:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 622 "barf_regex_parser.cpp"
 << " RETURN" << std::endl)
            return true; // indicating the parser is returning

        case Transition_::SHIFT:
            // push the state (indicated by the shift transition) and token data
            // onto the stack, then pop the corresponding lookahead.
            assert(transition.m_data < ms_state_count_);
            assert(Lookahead_(0).m_id < ms_token_name_count_); // at this point, we're past a possible
                                                               // client error, so asserting here is ok.
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 635 "barf_regex_parser.cpp"
 << " SHIFT " << Lookahead_(0) << std::endl)
            m_stack_.push_back(StackElement_(transition.m_data, Lookahead_(0).m_data));
            m_lookahead_queue_.pop_front();
            return false; // indicating the parser isn't returning

        case Transition_::ERROR_PANIC:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 645 "barf_regex_parser.cpp"
 << " ERROR_PANIC" << std::endl)
            m_is_in_error_panic_ = true;
            return false; // indicating the parser isn't returning

        default:
            assert(false && "invalid transition type (bad state machine, or memory corruption)");
            return false; // indicating the parser isn't returning
    }
}

Parser::Token::Data Parser::ExecuteReductionRule_ (BarfCpp_::Uint32 const rule_index_)
{
    assert(rule_index_ < ms_rule_count_);
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 662 "barf_regex_parser.cpp"
 << " executing reduction rule " << rule_index_ << std::endl)
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return NULL;

        case 0:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RegularExpression * regex(Dsc<RegularExpression *>(m_stack_[m_stack_.size()-3].m_token_data));
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 336 "barf_regex_parser.trison"

        for (RegularExpression::size_type i = 0; i < regex->size(); ++i)
            if (Regex::NodesAreEqual(branch, regex->Element(i)))
                THROW_STRING("duplicated branch");
                
        regex->Append(branch);
        return regex;
    
#line 685 "barf_regex_parser.cpp"
            break;
        }

        case 1:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 346 "barf_regex_parser.trison"

        RegularExpression *regex = new RegularExpression();
        regex->Append(branch);
        return regex;
    
#line 700 "barf_regex_parser.cpp"
            break;
        }

        case 2:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 355 "barf_regex_parser.trison"
 return branch; 
#line 711 "barf_regex_parser.cpp"
            break;
        }

        case 3:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 356 "barf_regex_parser.trison"
 return branch; 
#line 722 "barf_regex_parser.cpp"
            break;
        }

        case 4:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 357 "barf_regex_parser.trison"
 return new Branch(); 
#line 732 "barf_regex_parser.cpp"
            break;
        }

        case 5:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-2].m_token_data));
            Bound * bound(Dsc<Bound *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 363 "barf_regex_parser.trison"

        branch->AddBound(bound);
        return branch;
    
#line 747 "barf_regex_parser.cpp"
            break;
        }

        case 6:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-2].m_token_data));
            Atom * atom(Dsc<Atom *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 372 "barf_regex_parser.trison"

        branch->AddAtom(atom);
        return branch;
    
#line 762 "barf_regex_parser.cpp"
            break;
        }

        case 7:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Branch * branch(Dsc<Branch *>(m_stack_[m_stack_.size()-2].m_token_data));
            Atom * atom(Dsc<Atom *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 378 "barf_regex_parser.trison"

        branch->AddAtom(atom);
        return branch;
    
#line 777 "barf_regex_parser.cpp"
            break;
        }

        case 8:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Atom * atom(Dsc<Atom *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 384 "barf_regex_parser.trison"

        Branch *branch = new Branch();
        branch->AddAtom(atom);
        return branch;
    
#line 792 "barf_regex_parser.cpp"
            break;
        }

        case 9:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * macro_name(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 398 "barf_regex_parser.trison"

        assert(macro_name != NULL);
        if (m_macro_map == NULL)
            THROW_STRING("undefined macro \"" + macro_name->GetText() + "\" (no macro map was provided)");
        RegularExpression *macro_regex = m_macro_map->Element(macro_name->GetText());
        if (macro_regex == NULL)
            THROW_STRING("undefined macro \"" + macro_name->GetText() + "\"");
        return macro_regex;
    
#line 811 "barf_regex_parser.cpp"
            break;
        }

        case 10:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RegularExpression * regex(Dsc<RegularExpression *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 407 "barf_regex_parser.trison"
 return regex; 
#line 822 "barf_regex_parser.cpp"
            break;
        }

        case 11:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 408 "barf_regex_parser.trison"
 return new RegularExpression(); 
#line 832 "barf_regex_parser.cpp"
            break;
        }

        case 12:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 409 "barf_regex_parser.trison"
 return new ConditionalChar(CT_BEGINNING_OF_LINE); 
#line 842 "barf_regex_parser.cpp"
            break;
        }

        case 13:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 410 "barf_regex_parser.trison"
 return new ConditionalChar(CT_END_OF_LINE); 
#line 852 "barf_regex_parser.cpp"
            break;
        }

        case 14:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 411 "barf_regex_parser.trison"
 return new BracketCharSet('\n', true); 
#line 862 "barf_regex_parser.cpp"
            break;
        }

        case 15:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 412 "barf_regex_parser.trison"
 return ch; 
#line 873 "barf_regex_parser.cpp"
            break;
        }

        case 16:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 414 "barf_regex_parser.trison"

        if (ch->GetChar() == '0')
            THROW_STRING("can't use \\0");
        Atom *escaped = ch->Escaped();
        // if escaping changed the char (i.e. it new'ed something), delete the old
        if (ch != escaped)
            delete ch;
        return escaped;
    
#line 892 "barf_regex_parser.cpp"
            break;
        }

        case 17:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 423 "barf_regex_parser.trison"
 return ch; 
#line 903 "barf_regex_parser.cpp"
            break;
        }

        case 18:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 424 "barf_regex_parser.trison"
 return ch; 
#line 914 "barf_regex_parser.cpp"
            break;
        }

        case 19:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Atom * exp(Dsc<Atom *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 425 "barf_regex_parser.trison"
 return exp; 
#line 925 "barf_regex_parser.cpp"
            break;
        }

        case 20:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 430 "barf_regex_parser.trison"
 return new Bound(0, Bound::NO_UPPER_BOUND); 
#line 935 "barf_regex_parser.cpp"
            break;
        }

        case 21:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 432 "barf_regex_parser.trison"
 return new Bound(1, Bound::NO_UPPER_BOUND); 
#line 945 "barf_regex_parser.cpp"
            break;
        }

        case 22:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 434 "barf_regex_parser.trison"
 return new Bound(0, 1); 
#line 955 "barf_regex_parser.cpp"
            break;
        }

        case 23:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::SignedInteger * exact_bound(Dsc<Ast::SignedInteger *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 437 "barf_regex_parser.trison"

        assert(exact_bound->Value() >= 0);
        Bound *bound = new Bound(exact_bound->Value(), exact_bound->Value());
        delete exact_bound;
        return bound;
    
#line 971 "barf_regex_parser.cpp"
            break;
        }

        case 24:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::SignedInteger * lower_bound(Dsc<Ast::SignedInteger *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 445 "barf_regex_parser.trison"

        assert(lower_bound->Value() >= 0);
        return new Bound(lower_bound->Value(), Bound::NO_UPPER_BOUND);
    
#line 985 "barf_regex_parser.cpp"
            break;
        }

        case 25:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::SignedInteger * lower_bound(Dsc<Ast::SignedInteger *>(m_stack_[m_stack_.size()-4].m_token_data));
            Ast::SignedInteger * upper_bound(Dsc<Ast::SignedInteger *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 451 "barf_regex_parser.trison"

        assert(lower_bound->Value() >= 0);
        assert(upper_bound->Value() >= 0);
        if (lower_bound->Value() > upper_bound->Value() ||
            (lower_bound->Value() == 0 && upper_bound->Value() == 0))
        {
            ostringstream out;
            out << "invalid bound {" << lower_bound->Value() << ',' << upper_bound->Value() << '}';
            throw out.str();
        }
        else if (lower_bound->Value() > Bound::MaximumBoundValue())
        {
            ostringstream out;
            out << "bound value " << lower_bound->Value() << " is out of range (max 255)";
            throw out.str();
        }
        else if (upper_bound->Value() > Bound::MaximumBoundValue())
        {
            ostringstream out;
            out << "bound value " << upper_bound->Value() << " is out of range (max 255)";
            throw out.str();
        }
        Bound *bound = new Bound(lower_bound->Value(), upper_bound->Value());
        delete lower_bound;
        delete upper_bound;
        return bound;
    
#line 1023 "barf_regex_parser.cpp"
            break;
        }

        case 26:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            BracketCharSet * bracket_char_set(Dsc<BracketCharSet *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 487 "barf_regex_parser.trison"

        if (bracket_char_set->IsEmpty())
            THROW_STRING("invalid empty bracket expression");
        return bracket_char_set;
    
#line 1038 "barf_regex_parser.cpp"
            break;
        }

        case 27:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            BracketCharSet * bracket_char_set(Dsc<BracketCharSet *>(m_stack_[m_stack_.size()-2].m_token_data));

#line 494 "barf_regex_parser.trison"

        if (bracket_char_set->IsEmpty())
            THROW_STRING("invalid empty bracket expression");
        bracket_char_set->Negate();
        return bracket_char_set;
    
#line 1054 "barf_regex_parser.cpp"
            break;
        }

        case 28:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            BracketCharSet * bracket_char_set(Dsc<BracketCharSet *>(m_stack_[m_stack_.size()-2].m_token_data));
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 505 "barf_regex_parser.trison"

        bracket_char_set->AddChar(ch->GetChar());
        delete ch;
        return bracket_char_set;
    
#line 1070 "barf_regex_parser.cpp"
            break;
        }

        case 29:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            BracketCharSet * bracket_char_set(Dsc<BracketCharSet *>(m_stack_[m_stack_.size()-4].m_token_data));
            Char * begin_range(Dsc<Char *>(m_stack_[m_stack_.size()-3].m_token_data));
            Char * end_range(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 512 "barf_regex_parser.trison"

        if (end_range->GetChar() < begin_range->GetChar())
            THROW_STRING("invalid bracketed range [" << CharLiteral(begin_range->GetChar(), false) << '-' << CharLiteral(end_range->GetChar(), false) << ']');
        bracket_char_set->AddCharRange(
            begin_range->GetChar(),
            end_range->GetChar());
        delete begin_range;
        delete end_range;
        return bracket_char_set;
    
#line 1092 "barf_regex_parser.cpp"
            break;
        }

        case 30:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            BracketCharSet * bracket_char_set(Dsc<BracketCharSet *>(m_stack_[m_stack_.size()-6].m_token_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-3].m_token_data));

#line 524 "barf_regex_parser.trison"

        bracket_char_set->AddCharClass(id->GetText());
        delete id;
        return bracket_char_set;
    
#line 1108 "barf_regex_parser.cpp"
            break;
        }

        case 31:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 531 "barf_regex_parser.trison"

        BracketCharSet *bracket_char_set = new BracketCharSet();
        return bracket_char_set;
    
#line 1121 "barf_regex_parser.cpp"
            break;
        }

        case 32:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * normal_char(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 539 "barf_regex_parser.trison"
 return normal_char; 
#line 1132 "barf_regex_parser.cpp"
            break;
        }

        case 33:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * normal_char(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 541 "barf_regex_parser.trison"
 normal_char->EscapeInsideBracketExpression(); return normal_char; 
#line 1143 "barf_regex_parser.cpp"
            break;
        }

        case 34:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * control_char(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 543 "barf_regex_parser.trison"
 return control_char; 
#line 1154 "barf_regex_parser.cpp"
            break;
        }

        case 35:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * hex_char(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 545 "barf_regex_parser.trison"
 return hex_char; 
#line 1165 "barf_regex_parser.cpp"
            break;
        }

        case 36:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 562 "barf_regex_parser.trison"
 return new Char('|'); 
#line 1175 "barf_regex_parser.cpp"
            break;
        }

        case 37:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 564 "barf_regex_parser.trison"
 return new Char('('); 
#line 1185 "barf_regex_parser.cpp"
            break;
        }

        case 38:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 566 "barf_regex_parser.trison"
 return new Char(')'); 
#line 1195 "barf_regex_parser.cpp"
            break;
        }

        case 39:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 568 "barf_regex_parser.trison"
 return new Char('{'); 
#line 1205 "barf_regex_parser.cpp"
            break;
        }

        case 40:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 570 "barf_regex_parser.trison"
 return new Char('}'); 
#line 1215 "barf_regex_parser.cpp"
            break;
        }

        case 41:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 572 "barf_regex_parser.trison"
 return new Char('['); 
#line 1225 "barf_regex_parser.cpp"
            break;
        }

        case 42:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 574 "barf_regex_parser.trison"
 return new Char(']'); 
#line 1235 "barf_regex_parser.cpp"
            break;
        }

        case 43:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 576 "barf_regex_parser.trison"
 return new Char('?'); 
#line 1245 "barf_regex_parser.cpp"
            break;
        }

        case 44:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 578 "barf_regex_parser.trison"
 return new Char('*'); 
#line 1255 "barf_regex_parser.cpp"
            break;
        }

        case 45:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 580 "barf_regex_parser.trison"
 return new Char('+'); 
#line 1265 "barf_regex_parser.cpp"
            break;
        }

        case 46:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 582 "barf_regex_parser.trison"
 return new Char('.'); 
#line 1275 "barf_regex_parser.cpp"
            break;
        }

        case 47:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 584 "barf_regex_parser.trison"
 return new Char('^'); 
#line 1285 "barf_regex_parser.cpp"
            break;
        }

        case 48:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 586 "barf_regex_parser.trison"
 return new Char('$'); 
#line 1295 "barf_regex_parser.cpp"
            break;
        }

        case 49:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 588 "barf_regex_parser.trison"
 return new Char('\\'); 
#line 1305 "barf_regex_parser.cpp"
            break;
        }

        case 50:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * alpha(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 600 "barf_regex_parser.trison"
 return alpha; 
#line 1316 "barf_regex_parser.cpp"
            break;
        }

        case 51:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * digit(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 601 "barf_regex_parser.trison"
 return digit; 
#line 1327 "barf_regex_parser.cpp"
            break;
        }

        case 52:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 602 "barf_regex_parser.trison"
 return ch; 
#line 1338 "barf_regex_parser.cpp"
            break;
        }

        case 53:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 603 "barf_regex_parser.trison"
 return new Char(','); 
#line 1348 "barf_regex_parser.cpp"
            break;
        }

        case 54:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 604 "barf_regex_parser.trison"
 return new Char('-'); 
#line 1358 "barf_regex_parser.cpp"
            break;
        }

        case 55:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 605 "barf_regex_parser.trison"
 return new Char(':'); 
#line 1368 "barf_regex_parser.cpp"
            break;
        }

        case 56:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 618 "barf_regex_parser.trison"
 return new Char('-'); 
#line 1378 "barf_regex_parser.cpp"
            break;
        }

        case 57:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 620 "barf_regex_parser.trison"
 return new Char('^'); 
#line 1388 "barf_regex_parser.cpp"
            break;
        }

        case 58:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 622 "barf_regex_parser.trison"
 return new Char('['); 
#line 1398 "barf_regex_parser.cpp"
            break;
        }

        case 59:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 624 "barf_regex_parser.trison"
 return new Char(']'); 
#line 1408 "barf_regex_parser.cpp"
            break;
        }

        case 60:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 626 "barf_regex_parser.trison"
 return new Char('\\'); 
#line 1418 "barf_regex_parser.cpp"
            break;
        }

        case 61:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * alpha(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 638 "barf_regex_parser.trison"
 return alpha; 
#line 1429 "barf_regex_parser.cpp"
            break;
        }

        case 62:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * digit(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 639 "barf_regex_parser.trison"
 return digit; 
#line 1440 "barf_regex_parser.cpp"
            break;
        }

        case 63:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 640 "barf_regex_parser.trison"
 return ch; 
#line 1451 "barf_regex_parser.cpp"
            break;
        }

        case 64:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 641 "barf_regex_parser.trison"
 return new Char('|'); 
#line 1461 "barf_regex_parser.cpp"
            break;
        }

        case 65:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 642 "barf_regex_parser.trison"
 return new Char(':'); 
#line 1471 "barf_regex_parser.cpp"
            break;
        }

        case 66:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 643 "barf_regex_parser.trison"
 return new Char('?'); 
#line 1481 "barf_regex_parser.cpp"
            break;
        }

        case 67:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 644 "barf_regex_parser.trison"
 return new Char('*'); 
#line 1491 "barf_regex_parser.cpp"
            break;
        }

        case 68:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 645 "barf_regex_parser.trison"
 return new Char('+'); 
#line 1501 "barf_regex_parser.cpp"
            break;
        }

        case 69:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 646 "barf_regex_parser.trison"
 return new Char('.'); 
#line 1511 "barf_regex_parser.cpp"
            break;
        }

        case 70:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 647 "barf_regex_parser.trison"
 return new Char('$'); 
#line 1521 "barf_regex_parser.cpp"
            break;
        }

        case 71:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 648 "barf_regex_parser.trison"
 return new Char(','); 
#line 1531 "barf_regex_parser.cpp"
            break;
        }

        case 72:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 649 "barf_regex_parser.trison"
 return new Char('('); 
#line 1541 "barf_regex_parser.cpp"
            break;
        }

        case 73:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 650 "barf_regex_parser.trison"
 return new Char(')'); 
#line 1551 "barf_regex_parser.cpp"
            break;
        }

        case 74:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 651 "barf_regex_parser.trison"
 return new Char('{'); 
#line 1561 "barf_regex_parser.cpp"
            break;
        }

        case 75:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 652 "barf_regex_parser.trison"
 return new Char('}'); 
#line 1571 "barf_regex_parser.cpp"
            break;
        }

        case 76:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token_data));
            Char * alpha(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 658 "barf_regex_parser.trison"

        assert(id != NULL);
        id->AppendChar(alpha->GetChar());
        delete alpha;
        return id;
    
#line 1588 "barf_regex_parser.cpp"
            break;
        }

        case 77:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token_data));
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 666 "barf_regex_parser.trison"

        assert(id != NULL);
        id->AppendChar(ch->GetChar());
        delete ch;
        return id;
    
#line 1605 "barf_regex_parser.cpp"
            break;
        }

        case 78:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token_data));
            Char * digit(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 674 "barf_regex_parser.trison"

        assert(id != NULL);
        id->AppendChar(digit->GetChar());
        delete digit;
        return id;
    
#line 1622 "barf_regex_parser.cpp"
            break;
        }

        case 79:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * alpha(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 682 "barf_regex_parser.trison"

        string temp;
        temp += alpha->GetChar();
        Ast::Id *id = new Ast::Id(temp, FiLoc::ms_invalid);
        delete alpha;
        return id;
    
#line 1639 "barf_regex_parser.cpp"
            break;
        }

        case 80:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * ch(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 691 "barf_regex_parser.trison"

        string temp;
        temp += ch->GetChar();
        Ast::Id *id = new Ast::Id(temp, FiLoc::ms_invalid);
        delete ch;
        return id;
    
#line 1656 "barf_regex_parser.cpp"
            break;
        }

        case 81:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::SignedInteger * integer(Dsc<Ast::SignedInteger *>(m_stack_[m_stack_.size()-2].m_token_data));
            Char * digit(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 703 "barf_regex_parser.trison"

        integer->ShiftAndAdd(digit->GetChar() - '0');
        if (integer->Value() > 255)
            integer->SetValue(255);
        delete digit;
        return integer;
    
#line 1674 "barf_regex_parser.cpp"
            break;
        }

        case 82:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Char * digit(Dsc<Char *>(m_stack_[m_stack_.size()-1].m_token_data));

#line 712 "barf_regex_parser.trison"

        Ast::SignedInteger *integer = new Ast::SignedInteger(digit->GetChar() - '0', FiLoc::ms_invalid);
        delete digit;
        return integer;
    
#line 1689 "barf_regex_parser.cpp"
            break;
        }

    }

    assert(false && "no value returned from reduction rule code block");
    return NULL;
}

void Parser::PrintParserStatus_ (std::ostream &stream) const
{
    assert(!m_stack_.empty());

    stream << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1706 "barf_regex_parser.cpp"
 << " parser stack: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        stream << it->m_state_index;
        Stack_::const_iterator next_it = it;
        if (++next_it != it_end)
            stream << ' ';
    }
    stream << std::endl;

    PrintIndented_(stream, ms_state_table_[m_stack_.rbegin()->m_state_index].m_description);
    stream << std::endl;
}

void Parser::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1727 "barf_regex_parser.cpp"
 << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << 
#line 290 "barf_regex_parser.trison"
"Regex::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1735 "barf_regex_parser.cpp"
 << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, Parser::Token const &token)
{
    if (token.m_id < Parser::ms_token_name_count_)
        stream << '(' << Parser::ms_token_name_table_[token.m_id] << ')';
    else
        stream << "!INVALID TOKEN!";
    return stream;
}

Parser::Rule_ const Parser::ms_rule_table_[] =
{
    { Parser::Nonterminal_::regex, 3, "regex <- regex '|' branch" },
    { Parser::Nonterminal_::regex, 1, "regex <- branch" },
    { Parser::Nonterminal_::branch, 1, "branch <- branch_which_didnt_just_accept_an_atom" },
    { Parser::Nonterminal_::branch, 1, "branch <- branch_which_just_accepted_an_atom" },
    { Parser::Nonterminal_::branch, 0, "branch <-" },
    { Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom, 2, "branch_which_didnt_just_accept_an_atom <- branch_which_just_accepted_an_atom bound" },
    { Parser::Nonterminal_::branch_which_just_accepted_an_atom, 2, "branch_which_just_accepted_an_atom <- branch_which_just_accepted_an_atom atom" },
    { Parser::Nonterminal_::branch_which_just_accepted_an_atom, 2, "branch_which_just_accepted_an_atom <- branch_which_didnt_just_accept_an_atom atom" },
    { Parser::Nonterminal_::branch_which_just_accepted_an_atom, 1, "branch_which_just_accepted_an_atom <- atom" },
    { Parser::Nonterminal_::atom, 3, "atom <- '{' id '}'" },
    { Parser::Nonterminal_::atom, 3, "atom <- '(' regex ')'" },
    { Parser::Nonterminal_::atom, 2, "atom <- '(' ')'" },
    { Parser::Nonterminal_::atom, 1, "atom <- '^'" },
    { Parser::Nonterminal_::atom, 1, "atom <- '$'" },
    { Parser::Nonterminal_::atom, 1, "atom <- '.'" },
    { Parser::Nonterminal_::atom, 1, "atom <- atom_normal_char" },
    { Parser::Nonterminal_::atom, 2, "atom <- '\\\\' atom_normal_char" },
    { Parser::Nonterminal_::atom, 2, "atom <- '\\\\' atom_control_char" },
    { Parser::Nonterminal_::atom, 1, "atom <- HEX_CHAR" },
    { Parser::Nonterminal_::atom, 1, "atom <- bracket_expression" },
    { Parser::Nonterminal_::bound, 1, "bound <- '*'" },
    { Parser::Nonterminal_::bound, 1, "bound <- '+'" },
    { Parser::Nonterminal_::bound, 1, "bound <- '?'" },
    { Parser::Nonterminal_::bound, 3, "bound <- '{' integer '}'" },
    { Parser::Nonterminal_::bound, 4, "bound <- '{' integer ',' '}'" },
    { Parser::Nonterminal_::bound, 5, "bound <- '{' integer ',' integer '}'" },
    { Parser::Nonterminal_::bracket_expression, 3, "bracket_expression <- '[' bracket_char_set ']'" },
    { Parser::Nonterminal_::bracket_expression, 4, "bracket_expression <- '[' '^' bracket_char_set ']'" },
    { Parser::Nonterminal_::bracket_char_set, 2, "bracket_char_set <- bracket_char_set bracket_expression_char" },
    { Parser::Nonterminal_::bracket_char_set, 4, "bracket_char_set <- bracket_char_set bracket_expression_char '-' bracket_expression_char" },
    { Parser::Nonterminal_::bracket_char_set, 6, "bracket_char_set <- bracket_char_set '[' ':' id ':' ']'" },
    { Parser::Nonterminal_::bracket_char_set, 0, "bracket_char_set <-" },
    { Parser::Nonterminal_::bracket_expression_char, 1, "bracket_expression_char <- bracket_expression_normal_char" },
    { Parser::Nonterminal_::bracket_expression_char, 2, "bracket_expression_char <- '\\\\' bracket_expression_normal_char" },
    { Parser::Nonterminal_::bracket_expression_char, 2, "bracket_expression_char <- '\\\\' bracket_expression_control_char" },
    { Parser::Nonterminal_::bracket_expression_char, 1, "bracket_expression_char <- HEX_CHAR" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '|'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '('" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- ')'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '{'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '}'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '['" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- ']'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '?'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '*'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '+'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '.'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '^'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '$'" },
    { Parser::Nonterminal_::atom_control_char, 1, "atom_control_char <- '\\\\'" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- ALPHA" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- DIGIT" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- CHAR" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- ','" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- '-'" },
    { Parser::Nonterminal_::atom_normal_char, 1, "atom_normal_char <- ':'" },
    { Parser::Nonterminal_::bracket_expression_control_char, 1, "bracket_expression_control_char <- '-'" },
    { Parser::Nonterminal_::bracket_expression_control_char, 1, "bracket_expression_control_char <- '^'" },
    { Parser::Nonterminal_::bracket_expression_control_char, 1, "bracket_expression_control_char <- '['" },
    { Parser::Nonterminal_::bracket_expression_control_char, 1, "bracket_expression_control_char <- ']'" },
    { Parser::Nonterminal_::bracket_expression_control_char, 1, "bracket_expression_control_char <- '\\\\'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- ALPHA" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- DIGIT" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- CHAR" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '|'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- ':'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '?'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '*'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '+'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '.'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '$'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- ','" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '('" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- ')'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '{'" },
    { Parser::Nonterminal_::bracket_expression_normal_char, 1, "bracket_expression_normal_char <- '}'" },
    { Parser::Nonterminal_::id, 2, "id <- id ALPHA" },
    { Parser::Nonterminal_::id, 2, "id <- id CHAR" },
    { Parser::Nonterminal_::id, 2, "id <- id DIGIT" },
    { Parser::Nonterminal_::id, 1, "id <- ALPHA" },
    { Parser::Nonterminal_::id, 1, "id <- CHAR" },
    { Parser::Nonterminal_::integer, 2, "integer <- integer DIGIT" },
    { Parser::Nonterminal_::integer, 1, "integer <- DIGIT" }
};
BarfCpp_::Size const Parser::ms_rule_count_ = sizeof(Parser::ms_rule_table_) / sizeof(*Parser::ms_rule_table_);

Parser::State_ const Parser::ms_state_table_[] =
{
    { 22, ms_transition_table_+0, "START regex                                                                                 \nrule 0: regex <- . regex '|' branch                                                         \nrule 2: branch <- . branch_which_didnt_just_accept_an_atom                                  \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        \nrule 3: branch <- . branch_which_just_accepted_an_atom                                      \nrule 4: branch <- .                                                                         \nrule 1: regex <- . branch                                                                   " },
    { 1, ms_transition_table_+22, "rule 13: atom <- '$' ." },
    { 22, ms_transition_table_+23, "rule 0: regex <- . regex '|' branch                                                         \nrule 2: branch <- . branch_which_didnt_just_accept_an_atom                                  \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 10: atom <- '(' . regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 11: atom <- '(' . ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        \nrule 3: branch <- . branch_which_just_accepted_an_atom                                      \nrule 4: branch <- .                                                                         \nrule 1: regex <- . branch                                                                   " },
    { 21, ms_transition_table_+45, "rule 2: branch <- . branch_which_didnt_just_accept_an_atom                                  \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        \nrule 3: branch <- . branch_which_just_accepted_an_atom                                      \nrule 4: branch <- .                                                                         \nrule 1: regex <- . branch                                                                   " },
    { 1, ms_transition_table_+66, "rule 53: atom_normal_char <- ',' ." },
    { 1, ms_transition_table_+67, "rule 54: atom_normal_char <- '-' ." },
    { 1, ms_transition_table_+68, "rule 14: atom <- '.' ." },
    { 1, ms_transition_table_+69, "rule 55: atom_normal_char <- ':' ." },
    { 3, ms_transition_table_+70, "rule 26: bracket_expression <- '[' . bracket_char_set ']'                                          \nrule 28: bracket_char_set <- . bracket_char_set bracket_expression_char                            \nrule 29: bracket_char_set <- . bracket_char_set bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- . bracket_char_set '[' ':' id ':' ']'                                 \nrule 31: bracket_char_set <- .                                                                     \nrule 27: bracket_expression <- '[' . '^' bracket_char_set ']'                                      " },
    { 2, ms_transition_table_+73, "rule 28: bracket_char_set <- . bracket_char_set bracket_expression_char                            \nrule 29: bracket_char_set <- . bracket_char_set bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- . bracket_char_set '[' ':' id ':' ']'                                 \nrule 31: bracket_char_set <- .                                                                     \nrule 27: bracket_expression <- '[' '^' . bracket_char_set ']'                                      " },
    { 22, ms_transition_table_+75, "rule 28: bracket_char_set <- bracket_char_set . bracket_expression_char                            \nrule 32: bracket_expression_char <- . bracket_expression_normal_char                               \nrule 61: bracket_expression_normal_char <- . ALPHA                                                 \nrule 62: bracket_expression_normal_char <- . DIGIT                                                 \nrule 63: bracket_expression_normal_char <- . CHAR                                                  \nrule 64: bracket_expression_normal_char <- . '|'                                                   \nrule 65: bracket_expression_normal_char <- . ':'                                                   \nrule 66: bracket_expression_normal_char <- . '?'                                                   \nrule 67: bracket_expression_normal_char <- . '*'                                                   \nrule 68: bracket_expression_normal_char <- . '+'                                                   \nrule 69: bracket_expression_normal_char <- . '.'                                                   \nrule 70: bracket_expression_normal_char <- . '$'                                                   \nrule 71: bracket_expression_normal_char <- . ','                                                   \nrule 72: bracket_expression_normal_char <- . '('                                                   \nrule 73: bracket_expression_normal_char <- . ')'                                                   \nrule 74: bracket_expression_normal_char <- . '{'                                                   \nrule 75: bracket_expression_normal_char <- . '}'                                                   \nrule 33: bracket_expression_char <- . '\\\\' bracket_expression_normal_char                          \nrule 34: bracket_expression_char <- . '\\\\' bracket_expression_control_char                         \nrule 35: bracket_expression_char <- . HEX_CHAR                                                     \nrule 29: bracket_char_set <- bracket_char_set . bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- bracket_char_set . '[' ':' id ':' ']'                                 \nrule 27: bracket_expression <- '[' '^' bracket_char_set . ']'                                      " },
    { 1, ms_transition_table_+97, "rule 70: bracket_expression_normal_char <- '$' ." },
    { 1, ms_transition_table_+98, "rule 72: bracket_expression_normal_char <- '(' ." },
    { 1, ms_transition_table_+99, "rule 73: bracket_expression_normal_char <- ')' ." },
    { 1, ms_transition_table_+100, "rule 67: bracket_expression_normal_char <- '*' ." },
    { 1, ms_transition_table_+101, "rule 68: bracket_expression_normal_char <- '+' ." },
    { 1, ms_transition_table_+102, "rule 71: bracket_expression_normal_char <- ',' ." },
    { 1, ms_transition_table_+103, "rule 69: bracket_expression_normal_char <- '.' ." },
    { 1, ms_transition_table_+104, "rule 65: bracket_expression_normal_char <- ':' ." },
    { 1, ms_transition_table_+105, "rule 66: bracket_expression_normal_char <- '?' ." },
    { 2, ms_transition_table_+106, "rule 30: bracket_char_set <- bracket_char_set '[' . ':' id ':' ']'" },
    { 4, ms_transition_table_+108, "rule 76: id <- . id ALPHA                                         \nrule 77: id <- . id CHAR                                          \nrule 78: id <- . id DIGIT                                         \nrule 79: id <- . ALPHA                                            \nrule 80: id <- . CHAR                                             \nrule 30: bracket_char_set <- bracket_char_set '[' ':' . id ':' ']'" },
    { 1, ms_transition_table_+112, "rule 79: id <- ALPHA ." },
    { 1, ms_transition_table_+113, "rule 80: id <- CHAR ." },
    { 5, ms_transition_table_+114, "rule 76: id <- id . ALPHA                                         \nrule 77: id <- id . CHAR                                          \nrule 78: id <- id . DIGIT                                         \nrule 30: bracket_char_set <- bracket_char_set '[' ':' id . ':' ']'" },
    { 2, ms_transition_table_+119, "rule 30: bracket_char_set <- bracket_char_set '[' ':' id ':' . ']'" },
    { 1, ms_transition_table_+121, "rule 30: bracket_char_set <- bracket_char_set '[' ':' id ':' ']' ." },
    { 1, ms_transition_table_+122, "rule 76: id <- id ALPHA ." },
    { 1, ms_transition_table_+123, "rule 77: id <- id CHAR ." },
    { 1, ms_transition_table_+124, "rule 78: id <- id DIGIT ." },
    { 23, ms_transition_table_+125, "rule 61: bracket_expression_normal_char <- . ALPHA                        \nrule 62: bracket_expression_normal_char <- . DIGIT                        \nrule 63: bracket_expression_normal_char <- . CHAR                         \nrule 64: bracket_expression_normal_char <- . '|'                          \nrule 65: bracket_expression_normal_char <- . ':'                          \nrule 66: bracket_expression_normal_char <- . '?'                          \nrule 67: bracket_expression_normal_char <- . '*'                          \nrule 68: bracket_expression_normal_char <- . '+'                          \nrule 69: bracket_expression_normal_char <- . '.'                          \nrule 70: bracket_expression_normal_char <- . '$'                          \nrule 71: bracket_expression_normal_char <- . ','                          \nrule 72: bracket_expression_normal_char <- . '('                          \nrule 73: bracket_expression_normal_char <- . ')'                          \nrule 74: bracket_expression_normal_char <- . '{'                          \nrule 75: bracket_expression_normal_char <- . '}'                          \nrule 33: bracket_expression_char <- '\\\\' . bracket_expression_normal_char \nrule 34: bracket_expression_char <- '\\\\' . bracket_expression_control_char\nrule 56: bracket_expression_control_char <- . '-'                         \nrule 57: bracket_expression_control_char <- . '^'                         \nrule 58: bracket_expression_control_char <- . '['                         \nrule 59: bracket_expression_control_char <- . ']'                         \nrule 60: bracket_expression_control_char <- . '\\\\'                        " },
    { 1, ms_transition_table_+148, "rule 56: bracket_expression_control_char <- '-' ." },
    { 1, ms_transition_table_+149, "rule 58: bracket_expression_control_char <- '[' ." },
    { 1, ms_transition_table_+150, "rule 60: bracket_expression_control_char <- '\\\\' ." },
    { 1, ms_transition_table_+151, "rule 59: bracket_expression_control_char <- ']' ." },
    { 1, ms_transition_table_+152, "rule 57: bracket_expression_control_char <- '^' ." },
    { 1, ms_transition_table_+153, "rule 74: bracket_expression_normal_char <- '{' ." },
    { 1, ms_transition_table_+154, "rule 64: bracket_expression_normal_char <- '|' ." },
    { 1, ms_transition_table_+155, "rule 75: bracket_expression_normal_char <- '}' ." },
    { 1, ms_transition_table_+156, "rule 61: bracket_expression_normal_char <- ALPHA ." },
    { 1, ms_transition_table_+157, "rule 63: bracket_expression_normal_char <- CHAR ." },
    { 1, ms_transition_table_+158, "rule 62: bracket_expression_normal_char <- DIGIT ." },
    { 1, ms_transition_table_+159, "rule 34: bracket_expression_char <- '\\\\' bracket_expression_control_char ." },
    { 1, ms_transition_table_+160, "rule 33: bracket_expression_char <- '\\\\' bracket_expression_normal_char ." },
    { 1, ms_transition_table_+161, "rule 27: bracket_expression <- '[' '^' bracket_char_set ']' ." },
    { 1, ms_transition_table_+162, "rule 35: bracket_expression_char <- HEX_CHAR ." },
    { 2, ms_transition_table_+163, "rule 28: bracket_char_set <- bracket_char_set bracket_expression_char .                            \nrule 29: bracket_char_set <- bracket_char_set bracket_expression_char . '-' bracket_expression_char" },
    { 20, ms_transition_table_+165, "rule 32: bracket_expression_char <- . bracket_expression_normal_char                               \nrule 61: bracket_expression_normal_char <- . ALPHA                                                 \nrule 62: bracket_expression_normal_char <- . DIGIT                                                 \nrule 63: bracket_expression_normal_char <- . CHAR                                                  \nrule 64: bracket_expression_normal_char <- . '|'                                                   \nrule 65: bracket_expression_normal_char <- . ':'                                                   \nrule 66: bracket_expression_normal_char <- . '?'                                                   \nrule 67: bracket_expression_normal_char <- . '*'                                                   \nrule 68: bracket_expression_normal_char <- . '+'                                                   \nrule 69: bracket_expression_normal_char <- . '.'                                                   \nrule 70: bracket_expression_normal_char <- . '$'                                                   \nrule 71: bracket_expression_normal_char <- . ','                                                   \nrule 72: bracket_expression_normal_char <- . '('                                                   \nrule 73: bracket_expression_normal_char <- . ')'                                                   \nrule 74: bracket_expression_normal_char <- . '{'                                                   \nrule 75: bracket_expression_normal_char <- . '}'                                                   \nrule 33: bracket_expression_char <- . '\\\\' bracket_expression_normal_char                          \nrule 34: bracket_expression_char <- . '\\\\' bracket_expression_control_char                         \nrule 35: bracket_expression_char <- . HEX_CHAR                                                     \nrule 29: bracket_char_set <- bracket_char_set bracket_expression_char '-' . bracket_expression_char" },
    { 1, ms_transition_table_+185, "rule 29: bracket_char_set <- bracket_char_set bracket_expression_char '-' bracket_expression_char ." },
    { 1, ms_transition_table_+186, "rule 32: bracket_expression_char <- bracket_expression_normal_char ." },
    { 22, ms_transition_table_+187, "rule 26: bracket_expression <- '[' bracket_char_set . ']'                                          \nrule 28: bracket_char_set <- bracket_char_set . bracket_expression_char                            \nrule 32: bracket_expression_char <- . bracket_expression_normal_char                               \nrule 61: bracket_expression_normal_char <- . ALPHA                                                 \nrule 62: bracket_expression_normal_char <- . DIGIT                                                 \nrule 63: bracket_expression_normal_char <- . CHAR                                                  \nrule 64: bracket_expression_normal_char <- . '|'                                                   \nrule 65: bracket_expression_normal_char <- . ':'                                                   \nrule 66: bracket_expression_normal_char <- . '?'                                                   \nrule 67: bracket_expression_normal_char <- . '*'                                                   \nrule 68: bracket_expression_normal_char <- . '+'                                                   \nrule 69: bracket_expression_normal_char <- . '.'                                                   \nrule 70: bracket_expression_normal_char <- . '$'                                                   \nrule 71: bracket_expression_normal_char <- . ','                                                   \nrule 72: bracket_expression_normal_char <- . '('                                                   \nrule 73: bracket_expression_normal_char <- . ')'                                                   \nrule 74: bracket_expression_normal_char <- . '{'                                                   \nrule 75: bracket_expression_normal_char <- . '}'                                                   \nrule 33: bracket_expression_char <- . '\\\\' bracket_expression_normal_char                          \nrule 34: bracket_expression_char <- . '\\\\' bracket_expression_control_char                         \nrule 35: bracket_expression_char <- . HEX_CHAR                                                     \nrule 29: bracket_char_set <- bracket_char_set . bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- bracket_char_set . '[' ':' id ':' ']'                                 " },
    { 1, ms_transition_table_+209, "rule 26: bracket_expression <- '[' bracket_char_set ']' ." },
    { 23, ms_transition_table_+210, "rule 50: atom_normal_char <- . ALPHA     \nrule 51: atom_normal_char <- . DIGIT     \nrule 52: atom_normal_char <- . CHAR      \nrule 53: atom_normal_char <- . ','       \nrule 54: atom_normal_char <- . '-'       \nrule 55: atom_normal_char <- . ':'       \nrule 16: atom <- '\\\\' . atom_normal_char \nrule 17: atom <- '\\\\' . atom_control_char\nrule 36: atom_control_char <- . '|'      \nrule 37: atom_control_char <- . '('      \nrule 38: atom_control_char <- . ')'      \nrule 39: atom_control_char <- . '{'      \nrule 40: atom_control_char <- . '}'      \nrule 41: atom_control_char <- . '['      \nrule 42: atom_control_char <- . ']'      \nrule 43: atom_control_char <- . '?'      \nrule 44: atom_control_char <- . '*'      \nrule 45: atom_control_char <- . '+'      \nrule 46: atom_control_char <- . '.'      \nrule 47: atom_control_char <- . '^'      \nrule 48: atom_control_char <- . '$'      \nrule 49: atom_control_char <- . '\\\\'     " },
    { 1, ms_transition_table_+233, "rule 48: atom_control_char <- '$' ." },
    { 1, ms_transition_table_+234, "rule 37: atom_control_char <- '(' ." },
    { 1, ms_transition_table_+235, "rule 38: atom_control_char <- ')' ." },
    { 1, ms_transition_table_+236, "rule 44: atom_control_char <- '*' ." },
    { 1, ms_transition_table_+237, "rule 45: atom_control_char <- '+' ." },
    { 1, ms_transition_table_+238, "rule 46: atom_control_char <- '.' ." },
    { 1, ms_transition_table_+239, "rule 43: atom_control_char <- '?' ." },
    { 1, ms_transition_table_+240, "rule 41: atom_control_char <- '[' ." },
    { 1, ms_transition_table_+241, "rule 49: atom_control_char <- '\\\\' ." },
    { 1, ms_transition_table_+242, "rule 42: atom_control_char <- ']' ." },
    { 1, ms_transition_table_+243, "rule 47: atom_control_char <- '^' ." },
    { 1, ms_transition_table_+244, "rule 39: atom_control_char <- '{' ." },
    { 1, ms_transition_table_+245, "rule 36: atom_control_char <- '|' ." },
    { 1, ms_transition_table_+246, "rule 40: atom_control_char <- '}' ." },
    { 1, ms_transition_table_+247, "rule 50: atom_normal_char <- ALPHA ." },
    { 1, ms_transition_table_+248, "rule 52: atom_normal_char <- CHAR ." },
    { 1, ms_transition_table_+249, "rule 51: atom_normal_char <- DIGIT ." },
    { 1, ms_transition_table_+250, "rule 17: atom <- '\\\\' atom_control_char ." },
    { 1, ms_transition_table_+251, "rule 16: atom <- '\\\\' atom_normal_char ." },
    { 1, ms_transition_table_+252, "rule 12: atom <- '^' ." },
    { 4, ms_transition_table_+253, "rule 9: atom <- '{' . id '}'\nrule 76: id <- . id ALPHA   \nrule 77: id <- . id CHAR    \nrule 78: id <- . id DIGIT   \nrule 79: id <- . ALPHA      \nrule 80: id <- . CHAR       " },
    { 5, ms_transition_table_+257, "rule 9: atom <- '{' id . '}'\nrule 76: id <- id . ALPHA   \nrule 77: id <- id . CHAR    \nrule 78: id <- id . DIGIT   " },
    { 1, ms_transition_table_+262, "rule 9: atom <- '{' id '}' ." },
    { 1, ms_transition_table_+263, "rule 18: atom <- HEX_CHAR ." },
    { 1, ms_transition_table_+264, "rule 1: regex <- branch ." },
    { 18, ms_transition_table_+265, "rule 2: branch <- branch_which_didnt_just_accept_an_atom .                                 \nrule 9: atom <- . '{' id '}'                                                               \nrule 10: atom <- . '(' regex ')'                                                           \nrule 11: atom <- . '(' ')'                                                                 \nrule 12: atom <- . '^'                                                                     \nrule 13: atom <- . '$'                                                                     \nrule 14: atom <- . '.'                                                                     \nrule 15: atom <- . atom_normal_char                                                        \nrule 50: atom_normal_char <- . ALPHA                                                       \nrule 51: atom_normal_char <- . DIGIT                                                       \nrule 52: atom_normal_char <- . CHAR                                                        \nrule 53: atom_normal_char <- . ','                                                         \nrule 54: atom_normal_char <- . '-'                                                         \nrule 55: atom_normal_char <- . ':'                                                         \nrule 16: atom <- . '\\\\' atom_normal_char                                                   \nrule 17: atom <- . '\\\\' atom_control_char                                                  \nrule 18: atom <- . HEX_CHAR                                                                \nrule 19: atom <- . bracket_expression                                                      \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                  \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                              \nrule 7: branch_which_just_accepted_an_atom <- branch_which_didnt_just_accept_an_atom . atom" },
    { 1, ms_transition_table_+283, "rule 7: branch_which_just_accepted_an_atom <- branch_which_didnt_just_accept_an_atom atom ." },
    { 1, ms_transition_table_+284, "rule 19: atom <- bracket_expression ." },
    { 1, ms_transition_table_+285, "rule 15: atom <- atom_normal_char ." },
    { 22, ms_transition_table_+286, "rule 5: branch_which_didnt_just_accept_an_atom <- branch_which_just_accepted_an_atom . bound\nrule 6: branch_which_just_accepted_an_atom <- branch_which_just_accepted_an_atom . atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 20: bound <- . '*'                                                                     \nrule 21: bound <- . '+'                                                                     \nrule 22: bound <- . '?'                                                                     \nrule 23: bound <- . '{' integer '}'                                                         \nrule 24: bound <- . '{' integer ',' '}'                                                     \nrule 25: bound <- . '{' integer ',' integer '}'                                             \nrule 3: branch <- branch_which_just_accepted_an_atom .                                      " },
    { 1, ms_transition_table_+308, "rule 20: bound <- '*' ." },
    { 1, ms_transition_table_+309, "rule 21: bound <- '+' ." },
    { 1, ms_transition_table_+310, "rule 22: bound <- '?' ." },
    { 6, ms_transition_table_+311, "rule 9: atom <- '{' . id '}'                   \nrule 76: id <- . id ALPHA                      \nrule 77: id <- . id CHAR                       \nrule 78: id <- . id DIGIT                      \nrule 79: id <- . ALPHA                         \nrule 80: id <- . CHAR                          \nrule 23: bound <- '{' . integer '}'            \nrule 81: integer <- . integer DIGIT            \nrule 82: integer <- . DIGIT                    \nrule 24: bound <- '{' . integer ',' '}'        \nrule 25: bound <- '{' . integer ',' integer '}'" },
    { 1, ms_transition_table_+317, "rule 82: integer <- DIGIT ." },
    { 4, ms_transition_table_+318, "rule 23: bound <- '{' integer . '}'            \nrule 81: integer <- integer . DIGIT            \nrule 24: bound <- '{' integer . ',' '}'        \nrule 25: bound <- '{' integer . ',' integer '}'" },
    { 4, ms_transition_table_+322, "rule 81: integer <- . integer DIGIT            \nrule 82: integer <- . DIGIT                    \nrule 24: bound <- '{' integer ',' . '}'        \nrule 25: bound <- '{' integer ',' . integer '}'" },
    { 1, ms_transition_table_+326, "rule 24: bound <- '{' integer ',' '}' ." },
    { 3, ms_transition_table_+327, "rule 81: integer <- integer . DIGIT            \nrule 25: bound <- '{' integer ',' integer . '}'" },
    { 1, ms_transition_table_+330, "rule 25: bound <- '{' integer ',' integer '}' ." },
    { 1, ms_transition_table_+331, "rule 81: integer <- integer DIGIT ." },
    { 1, ms_transition_table_+332, "rule 23: bound <- '{' integer '}' ." },
    { 1, ms_transition_table_+333, "rule 6: branch_which_just_accepted_an_atom <- branch_which_just_accepted_an_atom atom ." },
    { 1, ms_transition_table_+334, "rule 5: branch_which_didnt_just_accept_an_atom <- branch_which_just_accepted_an_atom bound ." },
    { 1, ms_transition_table_+335, "rule 8: branch_which_just_accepted_an_atom <- atom ." },
    { 3, ms_transition_table_+336, "rule 0: regex <- regex . '|' branch\nrule 10: atom <- '(' regex . ')'   " },
    { 1, ms_transition_table_+339, "rule 10: atom <- '(' regex ')' ." },
    { 21, ms_transition_table_+340, "rule 0: regex <- regex '|' . branch                                                         \nrule 2: branch <- . branch_which_didnt_just_accept_an_atom                                  \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        \nrule 3: branch <- . branch_which_just_accepted_an_atom                                      \nrule 4: branch <- .                                                                         " },
    { 1, ms_transition_table_+361, "rule 0: regex <- regex '|' branch ." },
    { 2, ms_transition_table_+362, "RETURN regex                       \nrule 0: regex <- regex . '|' branch" },
    { 21, ms_transition_table_+364, "START branch                                                                                \nrule 2: branch <- . branch_which_didnt_just_accept_an_atom                                  \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        \nrule 3: branch <- . branch_which_just_accepted_an_atom                                      \nrule 4: branch <- .                                                                         " },
    { 1, ms_transition_table_+385, "RETURN branch" },
    { 20, ms_transition_table_+386, "START branch_which_didnt_just_accept_an_atom                                                \nrule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        " },
    { 18, ms_transition_table_+406, "RETURN branch_which_didnt_just_accept_an_atom                                              \nrule 9: atom <- . '{' id '}'                                                               \nrule 10: atom <- . '(' regex ')'                                                           \nrule 11: atom <- . '(' ')'                                                                 \nrule 12: atom <- . '^'                                                                     \nrule 13: atom <- . '$'                                                                     \nrule 14: atom <- . '.'                                                                     \nrule 15: atom <- . atom_normal_char                                                        \nrule 50: atom_normal_char <- . ALPHA                                                       \nrule 51: atom_normal_char <- . DIGIT                                                       \nrule 52: atom_normal_char <- . CHAR                                                        \nrule 53: atom_normal_char <- . ','                                                         \nrule 54: atom_normal_char <- . '-'                                                         \nrule 55: atom_normal_char <- . ':'                                                         \nrule 16: atom <- . '\\\\' atom_normal_char                                                   \nrule 17: atom <- . '\\\\' atom_control_char                                                  \nrule 18: atom <- . HEX_CHAR                                                                \nrule 19: atom <- . bracket_expression                                                      \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                  \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                              \nrule 7: branch_which_just_accepted_an_atom <- branch_which_didnt_just_accept_an_atom . atom" },
    { 22, ms_transition_table_+424, "rule 5: branch_which_didnt_just_accept_an_atom <- branch_which_just_accepted_an_atom . bound\nrule 6: branch_which_just_accepted_an_atom <- branch_which_just_accepted_an_atom . atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 20: bound <- . '*'                                                                     \nrule 21: bound <- . '+'                                                                     \nrule 22: bound <- . '?'                                                                     \nrule 23: bound <- . '{' integer '}'                                                         \nrule 24: bound <- . '{' integer ',' '}'                                                     \nrule 25: bound <- . '{' integer ',' integer '}'                                             " },
    { 20, ms_transition_table_+446, "rule 5: branch_which_didnt_just_accept_an_atom <- . branch_which_just_accepted_an_atom bound\nSTART branch_which_just_accepted_an_atom                                                    \nrule 6: branch_which_just_accepted_an_atom <- . branch_which_just_accepted_an_atom atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 7: branch_which_just_accepted_an_atom <- . branch_which_didnt_just_accept_an_atom atom \nrule 8: branch_which_just_accepted_an_atom <- . atom                                        " },
    { 18, ms_transition_table_+466, "rule 9: atom <- . '{' id '}'                                                               \nrule 10: atom <- . '(' regex ')'                                                           \nrule 11: atom <- . '(' ')'                                                                 \nrule 12: atom <- . '^'                                                                     \nrule 13: atom <- . '$'                                                                     \nrule 14: atom <- . '.'                                                                     \nrule 15: atom <- . atom_normal_char                                                        \nrule 50: atom_normal_char <- . ALPHA                                                       \nrule 51: atom_normal_char <- . DIGIT                                                       \nrule 52: atom_normal_char <- . CHAR                                                        \nrule 53: atom_normal_char <- . ','                                                         \nrule 54: atom_normal_char <- . '-'                                                         \nrule 55: atom_normal_char <- . ':'                                                         \nrule 16: atom <- . '\\\\' atom_normal_char                                                   \nrule 17: atom <- . '\\\\' atom_control_char                                                  \nrule 18: atom <- . HEX_CHAR                                                                \nrule 19: atom <- . bracket_expression                                                      \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                  \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                              \nrule 7: branch_which_just_accepted_an_atom <- branch_which_didnt_just_accept_an_atom . atom" },
    { 22, ms_transition_table_+484, "rule 5: branch_which_didnt_just_accept_an_atom <- branch_which_just_accepted_an_atom . bound\nRETURN branch_which_just_accepted_an_atom                                                   \nrule 6: branch_which_just_accepted_an_atom <- branch_which_just_accepted_an_atom . atom     \nrule 9: atom <- . '{' id '}'                                                                \nrule 10: atom <- . '(' regex ')'                                                            \nrule 11: atom <- . '(' ')'                                                                  \nrule 12: atom <- . '^'                                                                      \nrule 13: atom <- . '$'                                                                      \nrule 14: atom <- . '.'                                                                      \nrule 15: atom <- . atom_normal_char                                                         \nrule 50: atom_normal_char <- . ALPHA                                                        \nrule 51: atom_normal_char <- . DIGIT                                                        \nrule 52: atom_normal_char <- . CHAR                                                         \nrule 53: atom_normal_char <- . ','                                                          \nrule 54: atom_normal_char <- . '-'                                                          \nrule 55: atom_normal_char <- . ':'                                                          \nrule 16: atom <- . '\\\\' atom_normal_char                                                    \nrule 17: atom <- . '\\\\' atom_control_char                                                   \nrule 18: atom <- . HEX_CHAR                                                                 \nrule 19: atom <- . bracket_expression                                                       \nrule 26: bracket_expression <- . '[' bracket_char_set ']'                                   \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'                               \nrule 20: bound <- . '*'                                                                     \nrule 21: bound <- . '+'                                                                     \nrule 22: bound <- . '?'                                                                     \nrule 23: bound <- . '{' integer '}'                                                         \nrule 24: bound <- . '{' integer ',' '}'                                                     \nrule 25: bound <- . '{' integer ',' integer '}'                                             " },
    { 18, ms_transition_table_+506, "START atom                                                   \nrule 9: atom <- . '{' id '}'                                 \nrule 10: atom <- . '(' regex ')'                             \nrule 11: atom <- . '(' ')'                                   \nrule 12: atom <- . '^'                                       \nrule 13: atom <- . '$'                                       \nrule 14: atom <- . '.'                                       \nrule 15: atom <- . atom_normal_char                          \nrule 50: atom_normal_char <- . ALPHA                         \nrule 51: atom_normal_char <- . DIGIT                         \nrule 52: atom_normal_char <- . CHAR                          \nrule 53: atom_normal_char <- . ','                           \nrule 54: atom_normal_char <- . '-'                           \nrule 55: atom_normal_char <- . ':'                           \nrule 16: atom <- . '\\\\' atom_normal_char                     \nrule 17: atom <- . '\\\\' atom_control_char                    \nrule 18: atom <- . HEX_CHAR                                  \nrule 19: atom <- . bracket_expression                        \nrule 26: bracket_expression <- . '[' bracket_char_set ']'    \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'" },
    { 1, ms_transition_table_+524, "RETURN atom" },
    { 6, ms_transition_table_+525, "START bound                                    \nrule 20: bound <- . '*'                        \nrule 21: bound <- . '+'                        \nrule 22: bound <- . '?'                        \nrule 23: bound <- . '{' integer '}'            \nrule 24: bound <- . '{' integer ',' '}'        \nrule 25: bound <- . '{' integer ',' integer '}'" },
    { 3, ms_transition_table_+531, "rule 23: bound <- '{' . integer '}'            \nrule 81: integer <- . integer DIGIT            \nrule 82: integer <- . DIGIT                    \nrule 24: bound <- '{' . integer ',' '}'        \nrule 25: bound <- '{' . integer ',' integer '}'" },
    { 1, ms_transition_table_+534, "RETURN bound" },
    { 3, ms_transition_table_+535, "START bracket_expression                                     \nrule 26: bracket_expression <- . '[' bracket_char_set ']'    \nrule 27: bracket_expression <- . '[' '^' bracket_char_set ']'" },
    { 1, ms_transition_table_+538, "RETURN bracket_expression" },
    { 2, ms_transition_table_+539, "START bracket_char_set                                                                             \nrule 28: bracket_char_set <- . bracket_char_set bracket_expression_char                            \nrule 29: bracket_char_set <- . bracket_char_set bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- . bracket_char_set '[' ':' id ':' ']'                                 \nrule 31: bracket_char_set <- .                                                                     " },
    { 21, ms_transition_table_+541, "RETURN bracket_char_set                                                                            \nrule 28: bracket_char_set <- bracket_char_set . bracket_expression_char                            \nrule 32: bracket_expression_char <- . bracket_expression_normal_char                               \nrule 61: bracket_expression_normal_char <- . ALPHA                                                 \nrule 62: bracket_expression_normal_char <- . DIGIT                                                 \nrule 63: bracket_expression_normal_char <- . CHAR                                                  \nrule 64: bracket_expression_normal_char <- . '|'                                                   \nrule 65: bracket_expression_normal_char <- . ':'                                                   \nrule 66: bracket_expression_normal_char <- . '?'                                                   \nrule 67: bracket_expression_normal_char <- . '*'                                                   \nrule 68: bracket_expression_normal_char <- . '+'                                                   \nrule 69: bracket_expression_normal_char <- . '.'                                                   \nrule 70: bracket_expression_normal_char <- . '$'                                                   \nrule 71: bracket_expression_normal_char <- . ','                                                   \nrule 72: bracket_expression_normal_char <- . '('                                                   \nrule 73: bracket_expression_normal_char <- . ')'                                                   \nrule 74: bracket_expression_normal_char <- . '{'                                                   \nrule 75: bracket_expression_normal_char <- . '}'                                                   \nrule 33: bracket_expression_char <- . '\\\\' bracket_expression_normal_char                          \nrule 34: bracket_expression_char <- . '\\\\' bracket_expression_control_char                         \nrule 35: bracket_expression_char <- . HEX_CHAR                                                     \nrule 29: bracket_char_set <- bracket_char_set . bracket_expression_char '-' bracket_expression_char\nrule 30: bracket_char_set <- bracket_char_set . '[' ':' id ':' ']'                                 " },
    { 20, ms_transition_table_+562, "START bracket_expression_char                                             \nrule 32: bracket_expression_char <- . bracket_expression_normal_char      \nrule 61: bracket_expression_normal_char <- . ALPHA                        \nrule 62: bracket_expression_normal_char <- . DIGIT                        \nrule 63: bracket_expression_normal_char <- . CHAR                         \nrule 64: bracket_expression_normal_char <- . '|'                          \nrule 65: bracket_expression_normal_char <- . ':'                          \nrule 66: bracket_expression_normal_char <- . '?'                          \nrule 67: bracket_expression_normal_char <- . '*'                          \nrule 68: bracket_expression_normal_char <- . '+'                          \nrule 69: bracket_expression_normal_char <- . '.'                          \nrule 70: bracket_expression_normal_char <- . '$'                          \nrule 71: bracket_expression_normal_char <- . ','                          \nrule 72: bracket_expression_normal_char <- . '('                          \nrule 73: bracket_expression_normal_char <- . ')'                          \nrule 74: bracket_expression_normal_char <- . '{'                          \nrule 75: bracket_expression_normal_char <- . '}'                          \nrule 33: bracket_expression_char <- . '\\\\' bracket_expression_normal_char \nrule 34: bracket_expression_char <- . '\\\\' bracket_expression_control_char\nrule 35: bracket_expression_char <- . HEX_CHAR                            " },
    { 1, ms_transition_table_+582, "RETURN bracket_expression_char" },
    { 16, ms_transition_table_+583, "START atom_control_char             \nrule 36: atom_control_char <- . '|' \nrule 37: atom_control_char <- . '(' \nrule 38: atom_control_char <- . ')' \nrule 39: atom_control_char <- . '{' \nrule 40: atom_control_char <- . '}' \nrule 41: atom_control_char <- . '[' \nrule 42: atom_control_char <- . ']' \nrule 43: atom_control_char <- . '?' \nrule 44: atom_control_char <- . '*' \nrule 45: atom_control_char <- . '+' \nrule 46: atom_control_char <- . '.' \nrule 47: atom_control_char <- . '^' \nrule 48: atom_control_char <- . '$' \nrule 49: atom_control_char <- . '\\\\'" },
    { 1, ms_transition_table_+599, "RETURN atom_control_char" },
    { 8, ms_transition_table_+600, "START atom_normal_char              \nrule 50: atom_normal_char <- . ALPHA\nrule 51: atom_normal_char <- . DIGIT\nrule 52: atom_normal_char <- . CHAR \nrule 53: atom_normal_char <- . ','  \nrule 54: atom_normal_char <- . '-'  \nrule 55: atom_normal_char <- . ':'  " },
    { 1, ms_transition_table_+608, "RETURN atom_normal_char" },
    { 7, ms_transition_table_+609, "START bracket_expression_control_char             \nrule 56: bracket_expression_control_char <- . '-' \nrule 57: bracket_expression_control_char <- . '^' \nrule 58: bracket_expression_control_char <- . '[' \nrule 59: bracket_expression_control_char <- . ']' \nrule 60: bracket_expression_control_char <- . '\\\\'" },
    { 1, ms_transition_table_+616, "RETURN bracket_expression_control_char" },
    { 17, ms_transition_table_+617, "START bracket_expression_normal_char              \nrule 61: bracket_expression_normal_char <- . ALPHA\nrule 62: bracket_expression_normal_char <- . DIGIT\nrule 63: bracket_expression_normal_char <- . CHAR \nrule 64: bracket_expression_normal_char <- . '|'  \nrule 65: bracket_expression_normal_char <- . ':'  \nrule 66: bracket_expression_normal_char <- . '?'  \nrule 67: bracket_expression_normal_char <- . '*'  \nrule 68: bracket_expression_normal_char <- . '+'  \nrule 69: bracket_expression_normal_char <- . '.'  \nrule 70: bracket_expression_normal_char <- . '$'  \nrule 71: bracket_expression_normal_char <- . ','  \nrule 72: bracket_expression_normal_char <- . '('  \nrule 73: bracket_expression_normal_char <- . ')'  \nrule 74: bracket_expression_normal_char <- . '{'  \nrule 75: bracket_expression_normal_char <- . '}'  " },
    { 1, ms_transition_table_+634, "RETURN bracket_expression_normal_char" },
    { 4, ms_transition_table_+635, "START id                 \nrule 76: id <- . id ALPHA\nrule 77: id <- . id CHAR \nrule 78: id <- . id DIGIT\nrule 79: id <- . ALPHA   \nrule 80: id <- . CHAR    " },
    { 4, ms_transition_table_+639, "RETURN id                \nrule 76: id <- id . ALPHA\nrule 77: id <- id . CHAR \nrule 78: id <- id . DIGIT" },
    { 3, ms_transition_table_+643, "START integer                      \nrule 81: integer <- . integer DIGIT\nrule 82: integer <- . DIGIT        " },
    { 2, ms_transition_table_+646, "RETURN integer                     \nrule 81: integer <- integer . DIGIT" }
};
BarfCpp_::Size const Parser::ms_state_count_ = sizeof(Parser::ms_state_table_) / sizeof(*Parser::ms_state_table_);

Parser::Transition_ const Parser::ms_transition_table_[] =
{
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+1 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+2 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+3 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+4 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+5 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+6 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+7 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+8 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+9 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+10 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+11 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+12 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+13 },
    { Parser::Transition_::SHIFT, 102, 1, ms_lookahead_table_+14 },
    { Parser::Transition_::SHIFT, 77, 1, ms_lookahead_table_+15 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+16 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+17 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+18 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+19 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+20 },
    { Parser::Transition_::REDUCE, 13, 0, ms_lookahead_table_+21 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+21 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+21 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+22 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+23 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+24 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+25 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+26 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+27 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+28 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+29 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+30 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+31 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+32 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+33 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+34 },
    { Parser::Transition_::SHIFT, 98, 1, ms_lookahead_table_+35 },
    { Parser::Transition_::SHIFT, 77, 1, ms_lookahead_table_+36 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+37 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+38 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+39 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+40 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+41 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+42 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+42 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+43 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+44 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+45 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+46 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+47 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+48 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+49 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+50 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+51 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+52 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+53 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+54 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+55 },
    { Parser::Transition_::SHIFT, 77, 1, ms_lookahead_table_+56 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+57 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+58 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+59 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+60 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+61 },
    { Parser::Transition_::REDUCE, 53, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::REDUCE, 54, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::REDUCE, 14, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::REDUCE, 55, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::REDUCE, 31, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::SHIFT, 9, 1, ms_lookahead_table_+62 },
    { Parser::Transition_::SHIFT, 50, 1, ms_lookahead_table_+63 },
    { Parser::Transition_::REDUCE, 31, 0, ms_lookahead_table_+64 },
    { Parser::Transition_::SHIFT, 10, 1, ms_lookahead_table_+64 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+65 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+65 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+66 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+67 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+68 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+69 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+70 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+71 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+72 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+73 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+74 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+75 },
    { Parser::Transition_::SHIFT, 44, 1, ms_lookahead_table_+76 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+77 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+78 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+79 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+80 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+81 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+82 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+83 },
    { Parser::Transition_::SHIFT, 46, 1, ms_lookahead_table_+84 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+85 },
    { Parser::Transition_::REDUCE, 70, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 72, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 73, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 67, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 68, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 71, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 69, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 65, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::REDUCE, 66, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::SHIFT, 21, 1, ms_lookahead_table_+86 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+87 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+87 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+88 },
    { Parser::Transition_::SHIFT, 24, 1, ms_lookahead_table_+89 },
    { Parser::Transition_::REDUCE, 79, 0, ms_lookahead_table_+90 },
    { Parser::Transition_::REDUCE, 80, 0, ms_lookahead_table_+90 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+90 },
    { Parser::Transition_::SHIFT, 25, 1, ms_lookahead_table_+90 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+91 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+92 },
    { Parser::Transition_::SHIFT, 29, 1, ms_lookahead_table_+93 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+94 },
    { Parser::Transition_::SHIFT, 26, 1, ms_lookahead_table_+94 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::REDUCE, 76, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::REDUCE, 77, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::REDUCE, 78, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+95 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+96 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+97 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+98 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+99 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+100 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+101 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+102 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+103 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+104 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+105 },
    { Parser::Transition_::SHIFT, 33, 1, ms_lookahead_table_+106 },
    { Parser::Transition_::SHIFT, 34, 1, ms_lookahead_table_+107 },
    { Parser::Transition_::SHIFT, 35, 1, ms_lookahead_table_+108 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+109 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+110 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+111 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+112 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+113 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+114 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+115 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+116 },
    { Parser::Transition_::REDUCE, 56, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 58, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 60, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 59, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 57, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 74, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 64, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 75, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 61, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 63, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 62, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 34, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 33, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 27, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 35, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 28, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::SHIFT, 47, 1, ms_lookahead_table_+117 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+118 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+118 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+119 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+120 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+121 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+122 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+123 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+124 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+125 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+126 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+127 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+128 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+129 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+130 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+131 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+132 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+133 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+134 },
    { Parser::Transition_::SHIFT, 48, 1, ms_lookahead_table_+135 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+136 },
    { Parser::Transition_::REDUCE, 29, 0, ms_lookahead_table_+137 },
    { Parser::Transition_::REDUCE, 32, 0, ms_lookahead_table_+137 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+137 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+137 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+138 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+139 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+140 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+141 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+142 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+143 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+144 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+145 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+146 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+147 },
    { Parser::Transition_::SHIFT, 51, 1, ms_lookahead_table_+148 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+149 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+150 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+151 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+152 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+153 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+154 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+155 },
    { Parser::Transition_::SHIFT, 46, 1, ms_lookahead_table_+156 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+157 },
    { Parser::Transition_::REDUCE, 26, 0, ms_lookahead_table_+158 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+158 },
    { Parser::Transition_::SHIFT, 53, 1, ms_lookahead_table_+158 },
    { Parser::Transition_::SHIFT, 54, 1, ms_lookahead_table_+159 },
    { Parser::Transition_::SHIFT, 55, 1, ms_lookahead_table_+160 },
    { Parser::Transition_::SHIFT, 56, 1, ms_lookahead_table_+161 },
    { Parser::Transition_::SHIFT, 57, 1, ms_lookahead_table_+162 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+163 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+164 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+165 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+166 },
    { Parser::Transition_::SHIFT, 59, 1, ms_lookahead_table_+167 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+168 },
    { Parser::Transition_::SHIFT, 61, 1, ms_lookahead_table_+169 },
    { Parser::Transition_::SHIFT, 62, 1, ms_lookahead_table_+170 },
    { Parser::Transition_::SHIFT, 63, 1, ms_lookahead_table_+171 },
    { Parser::Transition_::SHIFT, 64, 1, ms_lookahead_table_+172 },
    { Parser::Transition_::SHIFT, 65, 1, ms_lookahead_table_+173 },
    { Parser::Transition_::SHIFT, 66, 1, ms_lookahead_table_+174 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+175 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+176 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+177 },
    { Parser::Transition_::SHIFT, 70, 1, ms_lookahead_table_+178 },
    { Parser::Transition_::SHIFT, 71, 1, ms_lookahead_table_+179 },
    { Parser::Transition_::REDUCE, 48, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 37, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 38, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 44, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 46, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 43, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 41, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 49, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 42, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 47, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 39, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 36, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 40, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 50, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 52, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 51, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 17, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 16, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::REDUCE, 12, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+180 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+180 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+181 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+182 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+183 },
    { Parser::Transition_::SHIFT, 75, 1, ms_lookahead_table_+183 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+184 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+185 },
    { Parser::Transition_::SHIFT, 29, 1, ms_lookahead_table_+186 },
    { Parser::Transition_::REDUCE, 9, 0, ms_lookahead_table_+187 },
    { Parser::Transition_::REDUCE, 18, 0, ms_lookahead_table_+187 },
    { Parser::Transition_::REDUCE, 1, 0, ms_lookahead_table_+187 },
    { Parser::Transition_::REDUCE, 2, 0, ms_lookahead_table_+187 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+187 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+188 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+189 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+190 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+191 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+192 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+193 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+194 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+195 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+196 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+197 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+198 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+199 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+200 },
    { Parser::Transition_::SHIFT, 79, 1, ms_lookahead_table_+201 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+202 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+203 },
    { Parser::Transition_::REDUCE, 7, 0, ms_lookahead_table_+204 },
    { Parser::Transition_::REDUCE, 19, 0, ms_lookahead_table_+204 },
    { Parser::Transition_::REDUCE, 15, 0, ms_lookahead_table_+204 },
    { Parser::Transition_::REDUCE, 3, 0, ms_lookahead_table_+204 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+204 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+205 },
    { Parser::Transition_::SHIFT, 83, 1, ms_lookahead_table_+206 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+207 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+208 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+209 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+210 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+211 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+212 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+213 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+214 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+215 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+216 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+217 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+218 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+219 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+220 },
    { Parser::Transition_::SHIFT, 95, 1, ms_lookahead_table_+221 },
    { Parser::Transition_::SHIFT, 96, 1, ms_lookahead_table_+222 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+223 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+224 },
    { Parser::Transition_::REDUCE, 20, 0, ms_lookahead_table_+225 },
    { Parser::Transition_::REDUCE, 21, 0, ms_lookahead_table_+225 },
    { Parser::Transition_::REDUCE, 22, 0, ms_lookahead_table_+225 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+225 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+225 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+226 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+227 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+228 },
    { Parser::Transition_::SHIFT, 88, 1, ms_lookahead_table_+229 },
    { Parser::Transition_::REDUCE, 82, 0, ms_lookahead_table_+230 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+230 },
    { Parser::Transition_::SHIFT, 89, 1, ms_lookahead_table_+230 },
    { Parser::Transition_::SHIFT, 94, 1, ms_lookahead_table_+231 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+232 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+233 },
    { Parser::Transition_::SHIFT, 90, 1, ms_lookahead_table_+233 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+234 },
    { Parser::Transition_::SHIFT, 91, 1, ms_lookahead_table_+235 },
    { Parser::Transition_::REDUCE, 24, 0, ms_lookahead_table_+236 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+236 },
    { Parser::Transition_::SHIFT, 92, 1, ms_lookahead_table_+236 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+237 },
    { Parser::Transition_::REDUCE, 25, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::REDUCE, 81, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::REDUCE, 23, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::REDUCE, 6, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::REDUCE, 5, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::REDUCE, 8, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+238 },
    { Parser::Transition_::SHIFT, 99, 1, ms_lookahead_table_+238 },
    { Parser::Transition_::SHIFT, 100, 1, ms_lookahead_table_+239 },
    { Parser::Transition_::REDUCE, 10, 0, ms_lookahead_table_+240 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+240 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+240 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+241 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+242 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+243 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+244 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+245 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+246 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+247 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+248 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+249 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+250 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+251 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+252 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+253 },
    { Parser::Transition_::SHIFT, 101, 1, ms_lookahead_table_+254 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+255 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+256 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+257 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+258 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+259 },
    { Parser::Transition_::REDUCE, 0, 0, ms_lookahead_table_+260 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+260 },
    { Parser::Transition_::SHIFT, 100, 1, ms_lookahead_table_+260 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+261 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+261 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+262 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+263 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+264 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+265 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+266 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+267 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+268 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+269 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+270 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+271 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+272 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+273 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+274 },
    { Parser::Transition_::SHIFT, 104, 1, ms_lookahead_table_+275 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+276 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+277 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+278 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+279 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+280 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+281 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+281 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+281 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+282 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+283 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+284 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+285 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+286 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+287 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+288 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+289 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+290 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+291 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+292 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+293 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+294 },
    { Parser::Transition_::SHIFT, 106, 1, ms_lookahead_table_+295 },
    { Parser::Transition_::SHIFT, 107, 1, ms_lookahead_table_+296 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+297 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+298 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+299 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+300 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+300 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+301 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+302 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+303 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+304 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+305 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+306 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+307 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+308 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+309 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+310 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+311 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+312 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+313 },
    { Parser::Transition_::SHIFT, 79, 1, ms_lookahead_table_+314 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+315 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+316 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+317 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+317 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+318 },
    { Parser::Transition_::SHIFT, 83, 1, ms_lookahead_table_+319 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+320 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+321 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+322 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+323 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+324 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+325 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+326 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+327 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+328 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+329 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+330 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+331 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+332 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+333 },
    { Parser::Transition_::SHIFT, 95, 1, ms_lookahead_table_+334 },
    { Parser::Transition_::SHIFT, 96, 1, ms_lookahead_table_+335 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+336 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+337 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+338 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+338 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+339 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+340 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+341 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+342 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+343 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+344 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+345 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+346 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+347 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+348 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+349 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+350 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+351 },
    { Parser::Transition_::SHIFT, 109, 1, ms_lookahead_table_+352 },
    { Parser::Transition_::SHIFT, 110, 1, ms_lookahead_table_+353 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+354 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+355 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+356 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+357 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+357 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+358 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+359 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+360 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+361 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+362 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+363 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+364 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+365 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+366 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+367 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+368 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+369 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+370 },
    { Parser::Transition_::SHIFT, 79, 1, ms_lookahead_table_+371 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+372 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+373 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+374 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+374 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+375 },
    { Parser::Transition_::SHIFT, 83, 1, ms_lookahead_table_+376 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+377 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+378 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+379 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+380 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+381 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+382 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+383 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+384 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+385 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+386 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+387 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+388 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+389 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+390 },
    { Parser::Transition_::SHIFT, 95, 1, ms_lookahead_table_+391 },
    { Parser::Transition_::SHIFT, 96, 1, ms_lookahead_table_+392 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+393 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+394 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+395 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+395 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+396 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+397 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+398 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+399 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+400 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+401 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+402 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+403 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+404 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+405 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+406 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+407 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+408 },
    { Parser::Transition_::SHIFT, 112, 1, ms_lookahead_table_+409 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+410 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+411 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+412 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+412 },
    { Parser::Transition_::SHIFT, 83, 1, ms_lookahead_table_+412 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+413 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+414 },
    { Parser::Transition_::SHIFT, 114, 1, ms_lookahead_table_+415 },
    { Parser::Transition_::SHIFT, 115, 1, ms_lookahead_table_+416 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+417 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+417 },
    { Parser::Transition_::SHIFT, 88, 1, ms_lookahead_table_+418 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+419 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+419 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+419 },
    { Parser::Transition_::SHIFT, 117, 1, ms_lookahead_table_+420 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+421 },
    { Parser::Transition_::REDUCE, 31, 0, ms_lookahead_table_+421 },
    { Parser::Transition_::SHIFT, 119, 1, ms_lookahead_table_+421 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+422 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+422 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+423 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+424 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+425 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+426 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+427 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+428 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+429 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+430 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+431 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+432 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+433 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+434 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+435 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+436 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+437 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+438 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+439 },
    { Parser::Transition_::SHIFT, 46, 1, ms_lookahead_table_+440 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+441 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+442 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+442 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+443 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+444 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+445 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+446 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+447 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+448 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+449 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+450 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+451 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+452 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+453 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+454 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+455 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+456 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+457 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+458 },
    { Parser::Transition_::SHIFT, 121, 1, ms_lookahead_table_+459 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+460 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+461 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+461 },
    { Parser::Transition_::SHIFT, 53, 1, ms_lookahead_table_+461 },
    { Parser::Transition_::SHIFT, 54, 1, ms_lookahead_table_+462 },
    { Parser::Transition_::SHIFT, 55, 1, ms_lookahead_table_+463 },
    { Parser::Transition_::SHIFT, 56, 1, ms_lookahead_table_+464 },
    { Parser::Transition_::SHIFT, 57, 1, ms_lookahead_table_+465 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+466 },
    { Parser::Transition_::SHIFT, 59, 1, ms_lookahead_table_+467 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+468 },
    { Parser::Transition_::SHIFT, 61, 1, ms_lookahead_table_+469 },
    { Parser::Transition_::SHIFT, 62, 1, ms_lookahead_table_+470 },
    { Parser::Transition_::SHIFT, 63, 1, ms_lookahead_table_+471 },
    { Parser::Transition_::SHIFT, 64, 1, ms_lookahead_table_+472 },
    { Parser::Transition_::SHIFT, 65, 1, ms_lookahead_table_+473 },
    { Parser::Transition_::SHIFT, 66, 1, ms_lookahead_table_+474 },
    { Parser::Transition_::SHIFT, 123, 1, ms_lookahead_table_+475 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+476 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+476 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+476 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+477 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+478 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+479 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+480 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+481 },
    { Parser::Transition_::SHIFT, 125, 1, ms_lookahead_table_+482 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+483 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+483 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+483 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+484 },
    { Parser::Transition_::SHIFT, 33, 1, ms_lookahead_table_+485 },
    { Parser::Transition_::SHIFT, 34, 1, ms_lookahead_table_+486 },
    { Parser::Transition_::SHIFT, 35, 1, ms_lookahead_table_+487 },
    { Parser::Transition_::SHIFT, 127, 1, ms_lookahead_table_+488 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+489 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+489 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+489 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+490 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+491 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+492 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+493 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+494 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+495 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+496 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+497 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+498 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+499 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+500 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+501 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+502 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+503 },
    { Parser::Transition_::SHIFT, 129, 1, ms_lookahead_table_+504 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+505 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+505 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+505 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+506 },
    { Parser::Transition_::SHIFT, 131, 1, ms_lookahead_table_+507 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+508 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+508 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+509 },
    { Parser::Transition_::SHIFT, 29, 1, ms_lookahead_table_+510 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+511 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+511 },
    { Parser::Transition_::SHIFT, 133, 1, ms_lookahead_table_+512 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+513 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+513 }
};
BarfCpp_::Size const Parser::ms_transition_count_ = sizeof(Parser::ms_transition_table_) / sizeof(*Parser::ms_transition_table_);

Parser::Token::Id const Parser::ms_lookahead_table_[] =
{
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::regex,
    Parser::Nonterminal_::branch,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::regex,
    Parser::Nonterminal_::branch,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::branch,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '^',
    Parser::Nonterminal_::bracket_char_set,
    Parser::Nonterminal_::bracket_char_set,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '[',
    '\\',
    ']',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::bracket_expression_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    ':',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Nonterminal_::id,
    ':',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    ']',
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '-',
    '.',
    ':',
    '?',
    '[',
    '\\',
    ']',
    '^',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::bracket_expression_control_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    '-',
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '\\',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::bracket_expression_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '[',
    '\\',
    ']',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::bracket_expression_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '-',
    '.',
    ':',
    '?',
    '[',
    '\\',
    ']',
    '^',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::atom_control_char,
    Parser::Nonterminal_::atom_normal_char,
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Nonterminal_::id,
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    '*',
    '+',
    ',',
    '-',
    '.',
    ':',
    '?',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bound,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::id,
    Parser::Nonterminal_::integer,
    ',',
    '}',
    Parser::Terminal::DIGIT,
    '}',
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::integer,
    '}',
    Parser::Terminal::DIGIT,
    ')',
    '|',
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::branch,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '|',
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::branch,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    '*',
    '+',
    ',',
    '-',
    '.',
    ':',
    '?',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bound,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::branch_which_didnt_just_accept_an_atom,
    Parser::Nonterminal_::branch_which_just_accepted_an_atom,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    '*',
    '+',
    ',',
    '-',
    '.',
    ':',
    '?',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bound,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '$',
    '(',
    ',',
    '-',
    '.',
    ':',
    '[',
    '\\',
    '^',
    '{',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::atom,
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::atom_normal_char,
    '*',
    '+',
    '?',
    '{',
    Parser::Nonterminal_::bound,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::integer,
    '[',
    Parser::Nonterminal_::bracket_expression,
    Parser::Nonterminal_::bracket_char_set,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '[',
    '\\',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::bracket_expression_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '\\',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::HEX_CHAR,
    Parser::Nonterminal_::bracket_expression_char,
    Parser::Nonterminal_::bracket_expression_normal_char,
    '$',
    '(',
    ')',
    '*',
    '+',
    '.',
    '?',
    '[',
    '\\',
    ']',
    '^',
    '{',
    '|',
    '}',
    Parser::Nonterminal_::atom_control_char,
    ',',
    '-',
    ':',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::atom_normal_char,
    '-',
    '[',
    '\\',
    ']',
    '^',
    Parser::Nonterminal_::bracket_expression_control_char,
    '$',
    '(',
    ')',
    '*',
    '+',
    ',',
    '.',
    ':',
    '?',
    '{',
    '|',
    '}',
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::bracket_expression_normal_char,
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Nonterminal_::id,
    Parser::Terminal::ALPHA,
    Parser::Terminal::CHAR,
    Parser::Terminal::DIGIT,
    Parser::Terminal::DIGIT,
    Parser::Nonterminal_::integer,
    Parser::Terminal::DIGIT
};
BarfCpp_::Size const Parser::ms_lookahead_count_ = sizeof(Parser::ms_lookahead_table_) / sizeof(*Parser::ms_lookahead_table_);

char const *const Parser::ms_token_name_table_[] =
{
    "'\\0'",
    "'\\x01'",
    "'\\x02'",
    "'\\x03'",
    "'\\x04'",
    "'\\x05'",
    "'\\x06'",
    "'\\a'",
    "'\\b'",
    "'\\t'",
    "'\\n'",
    "'\\v'",
    "'\\f'",
    "'\\r'",
    "'\\x0E'",
    "'\\x0F'",
    "'\\x10'",
    "'\\x11'",
    "'\\x12'",
    "'\\x13'",
    "'\\x14'",
    "'\\x15'",
    "'\\x16'",
    "'\\x17'",
    "'\\x18'",
    "'\\x19'",
    "'\\x1A'",
    "'\\x1B'",
    "'\\x1C'",
    "'\\x1D'",
    "'\\x1E'",
    "'\\x1F'",
    "' '",
    "'!'",
    "'\"'",
    "'#'",
    "'$'",
    "'%'",
    "'&'",
    "'\\''",
    "'('",
    "')'",
    "'*'",
    "'+'",
    "','",
    "'-'",
    "'.'",
    "'/'",
    "'0'",
    "'1'",
    "'2'",
    "'3'",
    "'4'",
    "'5'",
    "'6'",
    "'7'",
    "'8'",
    "'9'",
    "':'",
    "';'",
    "'<'",
    "'='",
    "'>'",
    "'?'",
    "'@'",
    "'A'",
    "'B'",
    "'C'",
    "'D'",
    "'E'",
    "'F'",
    "'G'",
    "'H'",
    "'I'",
    "'J'",
    "'K'",
    "'L'",
    "'M'",
    "'N'",
    "'O'",
    "'P'",
    "'Q'",
    "'R'",
    "'S'",
    "'T'",
    "'U'",
    "'V'",
    "'W'",
    "'X'",
    "'Y'",
    "'Z'",
    "'['",
    "'\\\\'",
    "']'",
    "'^'",
    "'_'",
    "'`'",
    "'a'",
    "'b'",
    "'c'",
    "'d'",
    "'e'",
    "'f'",
    "'g'",
    "'h'",
    "'i'",
    "'j'",
    "'k'",
    "'l'",
    "'m'",
    "'n'",
    "'o'",
    "'p'",
    "'q'",
    "'r'",
    "'s'",
    "'t'",
    "'u'",
    "'v'",
    "'w'",
    "'x'",
    "'y'",
    "'z'",
    "'{'",
    "'|'",
    "'}'",
    "'~'",
    "'\\x7F'",
    "'\\x80'",
    "'\\x81'",
    "'\\x82'",
    "'\\x83'",
    "'\\x84'",
    "'\\x85'",
    "'\\x86'",
    "'\\x87'",
    "'\\x88'",
    "'\\x89'",
    "'\\x8A'",
    "'\\x8B'",
    "'\\x8C'",
    "'\\x8D'",
    "'\\x8E'",
    "'\\x8F'",
    "'\\x90'",
    "'\\x91'",
    "'\\x92'",
    "'\\x93'",
    "'\\x94'",
    "'\\x95'",
    "'\\x96'",
    "'\\x97'",
    "'\\x98'",
    "'\\x99'",
    "'\\x9A'",
    "'\\x9B'",
    "'\\x9C'",
    "'\\x9D'",
    "'\\x9E'",
    "'\\x9F'",
    "'\\xA0'",
    "'\\xA1'",
    "'\\xA2'",
    "'\\xA3'",
    "'\\xA4'",
    "'\\xA5'",
    "'\\xA6'",
    "'\\xA7'",
    "'\\xA8'",
    "'\\xA9'",
    "'\\xAA'",
    "'\\xAB'",
    "'\\xAC'",
    "'\\xAD'",
    "'\\xAE'",
    "'\\xAF'",
    "'\\xB0'",
    "'\\xB1'",
    "'\\xB2'",
    "'\\xB3'",
    "'\\xB4'",
    "'\\xB5'",
    "'\\xB6'",
    "'\\xB7'",
    "'\\xB8'",
    "'\\xB9'",
    "'\\xBA'",
    "'\\xBB'",
    "'\\xBC'",
    "'\\xBD'",
    "'\\xBE'",
    "'\\xBF'",
    "'\\xC0'",
    "'\\xC1'",
    "'\\xC2'",
    "'\\xC3'",
    "'\\xC4'",
    "'\\xC5'",
    "'\\xC6'",
    "'\\xC7'",
    "'\\xC8'",
    "'\\xC9'",
    "'\\xCA'",
    "'\\xCB'",
    "'\\xCC'",
    "'\\xCD'",
    "'\\xCE'",
    "'\\xCF'",
    "'\\xD0'",
    "'\\xD1'",
    "'\\xD2'",
    "'\\xD3'",
    "'\\xD4'",
    "'\\xD5'",
    "'\\xD6'",
    "'\\xD7'",
    "'\\xD8'",
    "'\\xD9'",
    "'\\xDA'",
    "'\\xDB'",
    "'\\xDC'",
    "'\\xDD'",
    "'\\xDE'",
    "'\\xDF'",
    "'\\xE0'",
    "'\\xE1'",
    "'\\xE2'",
    "'\\xE3'",
    "'\\xE4'",
    "'\\xE5'",
    "'\\xE6'",
    "'\\xE7'",
    "'\\xE8'",
    "'\\xE9'",
    "'\\xEA'",
    "'\\xEB'",
    "'\\xEC'",
    "'\\xED'",
    "'\\xEE'",
    "'\\xEF'",
    "'\\xF0'",
    "'\\xF1'",
    "'\\xF2'",
    "'\\xF3'",
    "'\\xF4'",
    "'\\xF5'",
    "'\\xF6'",
    "'\\xF7'",
    "'\\xF8'",
    "'\\xF9'",
    "'\\xFA'",
    "'\\xFB'",
    "'\\xFC'",
    "'\\xFD'",
    "'\\xFE'",
    "'\\xFF'",
    "END_",
    "ERROR_",
    "BAD_TOKEN",
    "ALPHA",
    "CHAR",
    "DIGIT",
    "HEX_CHAR",
    "regex",
    "branch",
    "branch_which_didnt_just_accept_an_atom",
    "branch_which_just_accepted_an_atom",
    "atom",
    "bound",
    "bracket_expression",
    "bracket_char_set",
    "bracket_expression_char",
    "atom_control_char",
    "atom_normal_char",
    "bracket_expression_control_char",
    "bracket_expression_normal_char",
    "id",
    "integer"
};
BarfCpp_::Size const Parser::ms_token_name_count_ = sizeof(Parser::ms_token_name_table_) / sizeof(*Parser::ms_token_name_table_);

// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 107 "barf_regex_parser.trison"

bool Parser::OpenFile (string const &input_filename)
{
    ResetForNewInput();
    return InputBase::OpenFile(input_filename);
}

void Parser::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    return InputBase::OpenString(input_string, input_name, use_line_numbers);
}

void Parser::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    return InputBase::OpenUsingStream(input_stream, input_name, use_line_numbers);
}

Parser::ParserReturnCode Parser::Parse (RegularExpression **parsed_regex, RegularExpressionMap *macro_map)
{
    assert(parsed_regex != NULL);
    assert(m_macro_map == NULL);
    try {
        Ast::Base *parsed_tree_root = NULL;
        m_macro_map = macro_map;
        ParserReturnCode retval = Parse(&parsed_tree_root);
        *parsed_regex = Dsc<RegularExpression *>(parsed_tree_root);
        m_macro_map = NULL;
        return retval;
    } catch (string const &exception) {
        *parsed_regex = NULL;
        m_macro_map = NULL;
        throw exception;
    }
}

} // end of namespace Regex
} // end of namespace Barf

#line 3480 "barf_regex_parser.cpp"
