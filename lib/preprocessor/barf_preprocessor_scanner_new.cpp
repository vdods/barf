// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// barf_preprocessor_scanner_new.cpp generated by reflex
// from barf_preprocessor_scanner_new.reflex using reflex.cpp.targetspec and reflex.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "barf_preprocessor_scanner_new.hpp"

#include <iostream>

#define REFLEX_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }


#line 68 "barf_preprocessor_scanner_new.reflex"

#include "barf_preprocessor_ast.hpp"

#define SPEW(x) cerr << x << endl
// #define SPEW(x)

namespace Barf {
namespace Preprocessor {

bool ScannerNew::OpenFile (string const &input_filename)
{
    bool open_succeeded = InputBase::OpenFile(input_filename);
    if (open_succeeded)
        ResetForNewInput();
    return open_succeeded;
}

void ScannerNew::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    InputBase::OpenString(input_string, input_name, use_line_numbers);
    ResetForNewInput();
}

void ScannerNew::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    InputBase::OpenUsingStream(input_stream, input_name, use_line_numbers);
    ResetForNewInput();
}

Parser::Token ScannerNew::ParseKeyword (string const &accepted_string)
{
    if (accepted_string == "declare_array")         return Parser::Token(Parser::Terminal::DECLARE_ARRAY);
    if (accepted_string == "declare_map")           return Parser::Token(Parser::Terminal::DECLARE_MAP);
    if (accepted_string == "define")                return Parser::Token(Parser::Terminal::DEFINE);
    if (accepted_string == "dump_symbol_table")     return Parser::Token(Parser::Terminal::DUMP_SYMBOL_TABLE);
    if (accepted_string == "else")                  return Parser::Token(Parser::Terminal::ELSE);
    if (accepted_string == "else_if")               return Parser::Token(Parser::Terminal::ELSE_IF);
    if (accepted_string == "end_define")            return Parser::Token(Parser::Terminal::END_DEFINE);
    if (accepted_string == "end_for_each")          return Parser::Token(Parser::Terminal::END_FOR_EACH);
    if (accepted_string == "end_if")                return Parser::Token(Parser::Terminal::END_IF);
    if (accepted_string == "end_loop")              return Parser::Token(Parser::Terminal::END_LOOP);
    if (accepted_string == "error")                 return Parser::Token(Parser::Terminal::ERROR);
    if (accepted_string == "fatal_error")           return Parser::Token(Parser::Terminal::FATAL_ERROR);
    if (accepted_string == "for_each")              return Parser::Token(Parser::Terminal::FOR_EACH);
    if (accepted_string == "if")                    return Parser::Token(Parser::Terminal::IF);
    if (accepted_string == "include")               return Parser::Token(Parser::Terminal::INCLUDE);
    if (accepted_string == "int")                   return Parser::Token(Parser::Terminal::KEYWORD_INT);
    if (accepted_string == "is_defined")            return Parser::Token(Parser::Terminal::IS_DEFINED);
    if (accepted_string == "loop")                  return Parser::Token(Parser::Terminal::LOOP);
    if (accepted_string == "sandbox_include")       return Parser::Token(Parser::Terminal::SANDBOX_INCLUDE);
    if (accepted_string == "sizeof")                return Parser::Token(Parser::Terminal::SIZEOF);
    if (accepted_string == "string")                return Parser::Token(Parser::Terminal::KEYWORD_STRING);
    if (accepted_string == "string_length")         return Parser::Token(Parser::Terminal::STRING_LENGTH);
    if (accepted_string == "to_character_literal")  return Parser::Token(Parser::Terminal::TO_STRING_LITERAL);
    if (accepted_string == "to_string_literal")     return Parser::Token(Parser::Terminal::TO_STRING_LITERAL);
    if (accepted_string == "undefine")              return Parser::Token(Parser::Terminal::UNDEFINE);
    if (accepted_string == "warning")               return Parser::Token(Parser::Terminal::WARNING);

    return Parser::Token(Parser::Terminal::ID, new Ast::Id(accepted_string, GetFiLoc()));
}

#line 76 "barf_preprocessor_scanner_new.cpp"

ScannerNew::ScannerNew ()
    :
    ReflexCpp_::AutomatonApparatus(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputApparatus::IsInputAtEndMethod>(&ScannerNew::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputApparatus::ReadNextAtomMethod>(&ScannerNew::ReadNextAtom_))
{
    DebugSpew(false);
    ResetForNewInput();


#line 129 "barf_preprocessor_scanner_new.reflex"

    m_text = NULL;

#line 97 "barf_preprocessor_scanner_new.cpp"
}

ScannerNew::~ScannerNew ()
{

#line 132 "barf_preprocessor_scanner_new.reflex"

    delete m_text;
    m_text = NULL;

#line 108 "barf_preprocessor_scanner_new.cpp"
}

ScannerNew::Mode::Name ScannerNew::ScannerMode () const
{
    assert(InitialState_() != NULL);
    BarfCpp_::Size initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return Mode::START_;
        case 0: return Mode::EXPECTING_END_OF_FILE;
        case 3: return Mode::READING_BODY;
        case 12: return Mode::READING_CODE;
        case 26: return Mode::READING_CODE_STRING_LITERAL_GUTS;
        case 42: return Mode::TRANSITION_TO_CODE;
    }
}

void ScannerNew::ScannerMode (Mode::Name mode)
{
    assert(
        mode == Mode::EXPECTING_END_OF_FILE ||
        mode == Mode::READING_BODY ||
        mode == Mode::READING_CODE ||
        mode == Mode::READING_CODE_STRING_LITERAL_GUTS ||
        mode == Mode::TRANSITION_TO_CODE ||
        (false && "invalid Mode::Name"));
    InitialState_(ms_state_table_ + mode);
    REFLEX_CPP_DEBUG_CODE_(
        std::cerr << 
#line 167 "barf_preprocessor_scanner_new.reflex"
"Preprocessor::ScannerNew" << (GetFiLoc().GetIsValid() ? " ("+GetFiLoc().GetAsString()+")" : g_empty_string) << ":"
#line 141 "barf_preprocessor_scanner_new.cpp"
 << " transitioning to mode ";
        PrintScannerMode_(mode);
        std::cerr << std::endl)
    assert(ScannerMode() == mode);
}

void ScannerNew::ResetForNewInput ()
{
    ReflexCpp_::AutomatonApparatus::ResetForNewInput_(ms_state_table_ + Mode::START_);


#line 159 "barf_preprocessor_scanner_new.reflex"


#line 156 "barf_preprocessor_scanner_new.cpp"
}

Parser::Token ScannerNew::Scan ()
{

    std::string accepted_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        bool was_at_end_of_input_ = IsAtEndOfInput();

        BarfCpp_::Uint32 accept_handler_index_ = RunDfa_(accepted_string);
        // if no valid accept_handler_index_ was returned, then accepted_string
        // was filled with the first unaccepted input atom (i.e. the rejected
        // atom).  we'll call the HandleUnmatchedCharacter_ method on it.
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            assert(accepted_string.length() == 1);
            BarfCpp_::Uint8 rejected_atom = accepted_string[0];
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << 
#line 167 "barf_preprocessor_scanner_new.reflex"
"Preprocessor::ScannerNew" << (GetFiLoc().GetIsValid() ? " ("+GetFiLoc().GetAsString()+")" : g_empty_string) << ":"
#line 187 "barf_preprocessor_scanner_new.cpp"
 << " rejecting atom '";
                PrintAtom_(rejected_atom);
                std::cerr << '\'' << std::endl)

            // execute the rejected-atom-handling actions.  the rejected atom
            // is in rejected_atom.  the loop is so a break statement inside
            // rejection_actions doesn't break out of the main scanner loop.
            do
            {

#line 156 "barf_preprocessor_scanner_new.reflex"

    EmitError("unrecognized character " + GetCharLiteral(rejected_atom), GetFiLoc());

#line 202 "barf_preprocessor_scanner_new.cpp"

            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << 
#line 167 "barf_preprocessor_scanner_new.reflex"
"Preprocessor::ScannerNew" << (GetFiLoc().GetIsValid() ? " ("+GetFiLoc().GetAsString()+")" : g_empty_string) << ":"
#line 214 "barf_preprocessor_scanner_new.cpp"
 << " accepting string ";
                PrintString_(accepted_string);
                std::cerr << ", corresponding to mode ";
                PrintScannerMode_(ScannerMode());
                std::cerr << ", regex (" << ms_accept_handler_regex_[accept_handler_index_] << ")." << std::endl)
            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
                case 0:
                {

#line 433 "barf_preprocessor_scanner_new.reflex"

        SPEW("EXPECTING_END_OF_FILE - ({ANYTHING}*) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(false && "this should never happen");
        return Parser::Terminal::BAD_TOKEN;
    
#line 233 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 1:
                {

#line 440 "barf_preprocessor_scanner_new.reflex"

        SPEW("EXPECTING_END_OF_FILE - ({END_OF_FILE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        return Parser::Terminal::END_;
    
#line 246 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 2:
                {

#line 221 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_BODY - (([^<]|<[^<|{])*<?<\\|) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(accepted_string.length() >= 2);
        Ast::Base *token = new Text(accepted_string.c_str(), accepted_string.length()-2, GetFiLoc());
        IncrementLineNumber(GetNewlineCount(accepted_string));
        m_is_reading_newline_sensitive_code = true;
        ScannerMode(Mode::TRANSITION_TO_CODE);
        return Parser::Token(Parser::Terminal::TEXT, token);
    
#line 264 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 3:
                {

#line 232 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_BODY - (([^<]|<[^<|{])*<?<\\{) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(accepted_string.length() >= 2);
        Ast::Base *token = new Text(accepted_string.c_str(), accepted_string.length()-2, GetFiLoc());
        IncrementLineNumber(GetNewlineCount(accepted_string));
        m_is_reading_newline_sensitive_code = false;
        ScannerMode(Mode::TRANSITION_TO_CODE);
        return Parser::Token(Parser::Terminal::TEXT, token);
    
#line 282 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 4:
                {

#line 243 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_BODY - (([^<]|<[^<|{])*<?{END_OF_FILE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(accepted_string.length() >= 0);
        Ast::Base *token = new Text(accepted_string.c_str(), accepted_string.length(), GetFiLoc());
        IncrementLineNumber(GetNewlineCount(accepted_string));
        ScannerMode(Mode::EXPECTING_END_OF_FILE);
        return Parser::Token(Parser::Terminal::END_, token);
    
#line 299 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 5:
                {

#line 271 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({WHITESPACE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        // ignore whitespace
    
#line 312 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 6:
                {

#line 277 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({NEWLINE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        IncrementLineNumber(1);
        if (m_is_reading_newline_sensitive_code)
        {
            ScannerMode(Mode::READING_BODY);
            return Parser::Token(Parser::Terminal::CODE_NEWLINE);
        }
    
#line 330 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 7:
                {

#line 288 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({END_OF_FILE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        ScannerMode(Mode::EXPECTING_END_OF_FILE);
        if (m_is_reading_newline_sensitive_code)
            return Parser::Token(Parser::Terminal::CODE_NEWLINE);
    
#line 345 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 8:
                {

#line 296 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - (\\}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        if (!m_is_reading_newline_sensitive_code)
            return Parser::Terminal::END_CODE;
        EmitError("unexpected '}' encountered", GetFiLoc());
        return Parser::Token(Parser::Terminal::BAD_TOKEN);
    
#line 361 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 9:
                {

#line 305 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({OPERATOR}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        return Parser::Token(Parser::Token::Id(accepted_string[0]));
    
#line 374 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 10:
                {

#line 311 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({ID}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        return ParseKeyword(accepted_string);
    
#line 387 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 11:
                {

#line 317 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({INTEGER_LITERAL}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        Sint32 value = 0;
        istringstream in(accepted_string);
        in >> value;
        return Parser::Token(Parser::Terminal::INTEGER_LITERAL, new Integer(value, GetFiLoc()));
    
#line 403 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 12:
                {

#line 326 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - (\") = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text == NULL);
        m_text = new Text("", GetFiLoc());
        ScannerMode(Mode::READING_CODE_STRING_LITERAL_GUTS);
    
#line 418 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 13:
                {

#line 334 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - ({END_OF_FILE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        EmitError("unexpected end of file encountered within preprocessor code section", GetFiLoc());
        return Parser::Token(Parser::Terminal::END_);
    
#line 432 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 14:
                {

#line 341 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE - (.) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        EmitError("unrecognized character encountered within preprocessor code section", GetFiLoc());
        return Parser::Token(Parser::Terminal::BAD_TOKEN);
    
#line 446 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 15:
                {

#line 351 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({OCT_CHAR}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == '0');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 8);
        if (value >= 0x100)
            EmitError("octal character literal value out of range (" + accepted_string + ")", GetFiLoc());
        m_text->AppendChar(Uint8(value));
    
#line 466 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 16:
                {

#line 364 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({HEX_CHAR}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        assert(accepted_string.length() >= 3);
        assert(accepted_string[0] == '\\');
        assert(accepted_string[1] == 'x');
        Uint32 value = strtol(accepted_string.c_str()+2, NULL, 16);
        if (value >= 0x100)
            EmitError("hexadecimal character literal value out of range (" + accepted_string + ")", GetFiLoc());
        m_text->AppendChar(Uint8(value));
    
#line 486 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 17:
                {

#line 377 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({STRING_ESC_CHAR}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        assert(accepted_string.length() == 2);
        assert(accepted_string[0] == '\\');
        m_text->AppendChar(GetEscapedChar(Uint8(accepted_string[1])));
    
#line 502 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 18:
                {

#line 386 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({STRING_BAD_ESC_CHAR}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        assert(accepted_string.length() == 2);
        assert(accepted_string[0] == '\\');
        EmitError("malformed string literal escape code -- backslash followed by " + GetCharLiteral(accepted_string[1]), GetFiLoc());
    
#line 518 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 19:
                {

#line 395 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({STRING_NORMAL_CHAR}+) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        IncrementLineNumber(GetNewlineCount(accepted_string));
        m_text->AppendText(accepted_string);
    
#line 533 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 20:
                {

#line 403 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - (\") = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        ScannerMode(Mode::READING_CODE);
        Ast::Base *token = m_text;
        m_text = NULL;
        return Parser::Token(Parser::Terminal::STRING_LITERAL, token);
    
#line 550 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 21:
                {

#line 413 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - (\\\\?{END_OF_FILE}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        EmitError("unterminated string literal", GetFiLoc());
        assert(m_text != NULL);
        delete m_text;
        m_text = NULL;
        return Parser::Token(Parser::Terminal::END_);
    
#line 567 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 22:
                {

#line 423 "barf_preprocessor_scanner_new.reflex"

        SPEW("READING_CODE_STRING_LITERAL_GUTS - ({ANYTHING}) = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        assert(m_text != NULL);
        EmitError("ignoring unexpected character " + GetCharLiteral(accepted_string[0]) + " in string literal", GetFiLoc());
    
#line 581 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                case 23:
                {

#line 258 "barf_preprocessor_scanner_new.reflex"

        SPEW("TRANSITION_TO_CODE - () = " << GetStringLiteral(accepted_string) << " @ " << GetFiLoc());
        ScannerMode(Mode::READING_CODE);
        if (m_is_reading_newline_sensitive_code)
            return Parser::Token(Parser::Terminal::CODE_LINE);
        else
            return Parser::Token(Parser::Terminal::START_CODE);
    
#line 598 "barf_preprocessor_scanner_new.cpp"

                }
                break;

                default: assert(false && "this should never happen"); break;
            }
        }
    }


#line 136 "barf_preprocessor_scanner_new.reflex"

    assert(false && "you didn't handle EOF properly");
    return Parser::Token(Parser::Terminal::END_);

#line 614 "barf_preprocessor_scanner_new.cpp"
}

// ///////////////////////////////////////////////////////////////////////
// begin internal reflex-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

bool ScannerNew::IsInputAtEnd_ ()
{

#line 150 "barf_preprocessor_scanner_new.reflex"

    return In().peek() == char_traits<char>::eof();

#line 628 "barf_preprocessor_scanner_new.cpp"
}

BarfCpp_::Uint8 ScannerNew::ReadNextAtom_ ()
{

#line 153 "barf_preprocessor_scanner_new.reflex"

    return In().get();

#line 638 "barf_preprocessor_scanner_new.cpp"
}

void ScannerNew::PrintAtom_ (BarfCpp_::Uint8 atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << BarfCpp_::Uint16(atom);
        std::cerr.width(1);
    }
}

void ScannerNew::PrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        PrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

void ScannerNew::PrintScannerMode_ (Mode::Name mode)
{
    if (false) { }
    else if (mode == Mode::EXPECTING_END_OF_FILE) { std::cerr << "EXPECTING_END_OF_FILE"; }
    else if (mode == Mode::READING_BODY) { std::cerr << "READING_BODY"; }
    else if (mode == Mode::READING_CODE) { std::cerr << "READING_CODE"; }
    else if (mode == Mode::READING_CODE_STRING_LITERAL_GUTS) { std::cerr << "READING_CODE_STRING_LITERAL_GUTS"; }
    else if (mode == Mode::TRANSITION_TO_CODE) { std::cerr << "TRANSITION_TO_CODE"; }
}

// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus::DfaState_ const ScannerNew::ms_state_table_[] =
{
    { 0, 2, ms_transition_table_+0 },
    { 0, 1, ms_transition_table_+2 },
    { 0, 1, ms_transition_table_+3 },
    { 24, 2, ms_transition_table_+4 },
    { 24, 3, ms_transition_table_+6 },
    { 24, 2, ms_transition_table_+9 },
    { 24, 6, ms_transition_table_+11 },
    { 24, 2, ms_transition_table_+17 },
    { 3, 0, ms_transition_table_+19 },
    { 2, 0, ms_transition_table_+19 },
    { 4, 6, ms_transition_table_+19 },
    { 4, 3, ms_transition_table_+25 },
    { 24, 2, ms_transition_table_+28 },
    { 24, 28, ms_transition_table_+30 },
    { 14, 0, ms_transition_table_+58 },
    { 5, 0, ms_transition_table_+58 },
    { 6, 0, ms_transition_table_+58 },
    { 9, 0, ms_transition_table_+58 },
    { 12, 0, ms_transition_table_+58 },
    { 11, 0, ms_transition_table_+58 },
    { 14, 1, ms_transition_table_+58 },
    { 11, 1, ms_transition_table_+59 },
    { 10, 4, ms_transition_table_+60 },
    { 10, 4, ms_transition_table_+64 },
    { 8, 0, ms_transition_table_+68 },
    { 7, 28, ms_transition_table_+68 },
    { 24, 2, ms_transition_table_+96 },
    { 24, 9, ms_transition_table_+98 },
    { 22, 0, ms_transition_table_+107 },
    { 19, 4, ms_transition_table_+107 },
    { 19, 4, ms_transition_table_+111 },
    { 20, 0, ms_transition_table_+115 },
    { 22, 2, ms_transition_table_+115 },
    { 22, 7, ms_transition_table_+117 },
    { 18, 0, ms_transition_table_+124 },
    { 17, 0, ms_transition_table_+124 },
    { 17, 1, ms_transition_table_+124 },
    { 15, 1, ms_transition_table_+125 },
    { 17, 3, ms_transition_table_+126 },
    { 16, 3, ms_transition_table_+129 },
    { 21, 7, ms_transition_table_+132 },
    { 21, 9, ms_transition_table_+139 },
    { 23, 0, ms_transition_table_+148 }
};
BarfCpp_::Size const ScannerNew::ms_state_count_ = sizeof(ScannerNew::ms_state_table_) / sizeof(*ScannerNew::ms_state_table_);

ReflexCpp_::AutomatonApparatus::DfaTransition_ const ScannerNew::ms_transition_table_[] =
{
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 255, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 255, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+11 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 60, 0, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 59, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 61, 255, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+6 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+10 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 60, 0, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 59, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 61, 122, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 125, 255, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 60, 0, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 59, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 61, 122, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 125, 255, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 60, 0, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 59, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 61, 255, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+13 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+25 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 9, 0, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 10, 0, ms_state_table_+16 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 32, 0, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 33, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+18 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 64, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 91, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 93, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 94, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 96, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 125, 0, ms_state_table_+24 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 36, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 37, 38, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 40, 47, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 58, 59, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 60, 63, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 126, 255, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 9, 0, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 10, 0, ms_state_table_+16 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 32, 0, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 33, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+18 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 39, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 64, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 91, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 93, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 94, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 95, 0, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 96, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 123, 0, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 124, 0, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 125, 0, ms_state_table_+24 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 36, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 37, 38, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 40, 47, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 49, 57, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 58, 59, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 60, 63, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 90, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 122, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 126, 255, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+41 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+31 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 9, 10, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 9, 10, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 9, 10, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 0, ms_state_table_+33 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::CONDITIONAL, 2, 2, ms_state_table_+40 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+36 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+38 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 31, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 47, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 49, 119, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 121, 126, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 55, ms_state_table_+37 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 48, 57, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 65, 70, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 97, 102, ms_state_table_+39 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 48, 0, ms_state_table_+36 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 120, 0, ms_state_table_+38 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 31, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 47, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 49, 119, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 121, 126, ms_state_table_+35 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+34 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 34, 0, ms_state_table_+31 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM, 92, 0, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 1, 8, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 9, 10, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 11, 31, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 32, 33, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 35, 91, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 93, 126, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::INPUT_ATOM_RANGE, 127, 255, ms_state_table_+28 }
};
BarfCpp_::Size const ScannerNew::ms_transition_count_ = sizeof(ScannerNew::ms_transition_table_) / sizeof(*ScannerNew::ms_transition_table_);

char const *const ScannerNew::ms_accept_handler_regex_[] =
{
    "{ANYTHING}*",
    "{END_OF_FILE}",
    "([^<]|<[^<|{])*<?<\\|",
    "([^<]|<[^<|{])*<?<\\{",
    "([^<]|<[^<|{])*<?{END_OF_FILE}",
    "{WHITESPACE}",
    "{NEWLINE}",
    "{END_OF_FILE}",
    "\\}",
    "{OPERATOR}",
    "{ID}",
    "{INTEGER_LITERAL}",
    "\"",
    "{END_OF_FILE}",
    ".",
    "{OCT_CHAR}",
    "{HEX_CHAR}",
    "{STRING_ESC_CHAR}",
    "{STRING_BAD_ESC_CHAR}",
    "{STRING_NORMAL_CHAR}+",
    "\"",
    "\\\\?{END_OF_FILE}",
    "{ANYTHING}",
    ""
};
BarfCpp_::Uint32 const ScannerNew::ms_accept_handler_count_ = sizeof(ScannerNew::ms_accept_handler_regex_) / sizeof(*ScannerNew::ms_accept_handler_regex_);

// ///////////////////////////////////////////////////////////////////////
// end of internal reflex-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 140 "barf_preprocessor_scanner_new.reflex"

} // end of namespace Preprocessor
} // end of namespace Barf

#line 940 "barf_preprocessor_scanner_new.cpp"
