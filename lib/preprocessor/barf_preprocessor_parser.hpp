// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// barf_preprocessor_parser.hpp generated by trison
// from barf_preprocessor_parser.trison using trison.cpp.targetspec and trison.cpp.header.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#pragma once


#include <cassert>
#include <cstdint>
#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <set>
#include <utility>
#include <vector>


#line 18 "barf_preprocessor_parser.trison"

#if !defined(BARF_PREPROCESSOR_PARSER_HPP_)
#define BARF_PREPROCESSOR_PARSER_HPP_

#include "barf_preprocessor.hpp"

#include "barf_filoc.hpp"

namespace Barf {
namespace Ast {

class Base;

} // end of namespace Ast

namespace Preprocessor {

class Scanner;

#line 41 "barf_preprocessor_parser.hpp"

/// @brief A parser class.
///
/// A parser class generated by trison
/// from barf_preprocessor_parser.trison using trison.cpp.targetspec and trison.cpp.header.codespec.
///
/// The term "primary source" will be used to refer to the .trison source file from which
/// this file was generated.  Specifically, the primary source is barf_preprocessor_parser.trison.
///
/// The term "client" will be used to refer to the programmer who is writing the trison
/// primary source file to generate a parser (e.g. "the client shouldn't return X from Y"
/// or "the client must provide a way to X and Y").
class Parser
{
public:

    /// Return values for Parse().
    enum ParserReturnCode : std::uint32_t
    {
        /// Indicates the Parse() method returned successfully.
        PRC_SUCCESS = 0,
        /// Indicates an unhandled parse error occurred (i.e. no %error-accepting
        /// rules were encountered).
        PRC_UNHANDLED_PARSE_ERROR,
        /// Indicates that the parse was halted because the number of realized
        /// lookaheads exceeded the max allowable lookahead count (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT,
        /// Indicates that the parse was halted because the realized size of the
        /// lookahead queue exceeded the max allowable lookahead queue size (NPDA
        /// target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE,
        /// Indicates that the parse was halted because the depth of the parse tree
        /// exceeded the max allowable parse tree depth (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH,
        /// Indicates that the parse didn't complete because of some internal error.
        PRC_INTERNAL_ERROR
    }; // end of enum Parser::ParserReturnCode

    /// "Namespace" for Parser::Terminal::Name, which enumerates all valid
    /// token ids which this parser will accept as lookaheads.
    struct Terminal
    {
        /// @brief Acceptable values returnable to the parser in %target.cpp.scan_actions.
        /// There are two special terminals: END_ and ERROR_.
        ///
        /// Parser::Terminal::END_ should be returned in %target.cpp.scan_actions
        /// by the client when the input source has reached the end of input.  The parser
        /// will not request any more input after Parser::Terminal::END_ is received.
        ///
        /// Parser::Terminal::ERROR_ should not ever be used by the client, as
        /// it is used internally by the parser.
        ///
        /// The rest are the terminals as declared in the primary source, and should
        /// be used by the client when returning from %target.cpp.scan_actions.
        enum Name
        {
            END_ = 256,
            ERROR_ = 257,
            TEXT = 258,
            START_CODE = 259,
            END_CODE = 260,
            CODE_LINE = 261,
            CODE_NEWLINE = 262,
            ID = 263,
            DUMP_SYMBOL_TABLE = 264,
            IF = 265,
            ELSE = 266,
            ELSE_IF = 267,
            END_IF = 268,
            UNDEFINE = 269,
            DECLARE_ARRAY = 270,
            DECLARE_MAP = 271,
            DEFINE = 272,
            END_DEFINE = 273,
            LOOP = 274,
            END_LOOP = 275,
            FOR_EACH = 276,
            END_FOR_EACH = 277,
            INCLUDE = 278,
            SANDBOX_INCLUDE = 279,
            WARNING = 280,
            ERROR = 281,
            FATAL_ERROR = 282,
            SIZEOF = 283,
            IS_DEFINED = 284,
            INTEGER_LITERAL = 285,
            STRING_LITERAL = 286,
            KEYWORD_INT = 287,
            KEYWORD_STRING = 288,
            STRING_LENGTH = 289,
            TO_CHARACTER_LITERAL = 290,
            TO_STRING_LITERAL = 291,
            BAD_TOKEN = 292
        }; // end of enum Parser::Terminal::Name
    }; // end of struct Parser::Terminal

    /// "Namespace" for Parser::Nonterminal::Name, which enumerates all nonterminals.
    /// This is used internally by the parser, but is also used by the client to specify which
    /// nonterminal should be parsed by the parser.
    struct Nonterminal
    {
        /// There is one special nonterminal: none_.  This should not be used by the client,
        /// as it is only used internally by the parser.
        enum Name
        {
            none_ = 0,
            body = 293,
            executable = 294,
            code = 295,
            code_body = 296,
            conditional_series = 297,
            conditional_series_end = 298,
            if_statement = 299,
            else_statement = 300,
            else_if_statement = 301,
            end_if = 302,
            define = 303,
            define_scalar = 304,
            define_array_element = 305,
            define_map_element = 306,
            end_define = 307,
            loop = 308,
            end_loop = 309,
            for_each = 310,
            end_for_each = 311,
            expression = 312
        }; // end of enum Parser::Nonterminal::Name
    }; // end of struct Parser::Nonterminal

    /// @brief Return type for %target.cpp.scan_actions.
    ///
    /// The client should package-up and return a Parser::Token from
    /// the code specified by %target.cpp.scan_actions, which delivers the
    /// token type and token data to the parser for input.  The constructor
    /// takes one or two parameters; the second can be omitted, indicating
    /// that the %target.cpp.token_data_default value will be used.
    struct Token
    {
        typedef std::uint32_t Id; // TODO -- smallest int
        typedef Ast::Base * Data;

        Id m_id;
        Data m_data;

        /// @brief Constructor for Token struct.
        ///
        /// @param id Gives the token id, e.g. Terminal::END_ or whatever
        ///        other terminals were declared in the primary source.
        /// @param data Gives the data associated with this token, e.g. if
        ///        you were constructing an AST, data would point to an AST
        ///        node constructed during scanning.
        Token (Id id, Data const &data = NULL) : m_id(id), m_data(data) { }
    }; // end of struct Parser::Token

public:

    /// Constructor.  The client can specify parameters in the primary source
    /// via the %target.cpp.constructor_parameters directive.
    Parser ();
    /// Destructor.  The client can force the destructor to be declared virtual
    /// by specifying the %target.cpp.force_virtual_destructor directive in the
    /// primary source.
    ~Parser ();

    /// @brief Returns true if and only if the next unshifted lookahead
    ///        token is Terminal::END_.
    ///
    /// It is not sufficient to just check the EOF condition on the input
    /// source (e.g. the scanner, cin, etc), because the parser may have read,
    /// but not consumed, additional lookaheads up to EOF.  Thus checking
    /// the input source for EOF condition may give false positives.  This
    /// method should be the preferred means to check EOF condition.
    ///
    /// It should be noted that this may cause the parser to read (but never
    /// consume) up to one additional lookahead token, owing to the necessity
    /// of checking what the next lookahead token is.
    bool IsAtEndOfInput ();
    /// Returns true iff the most recent parse encountered an error (even if it
    /// recovered using error handling rules in the grammar).
    bool HasEncounteredErrorState () const;
    /// Returns the highest value that MaxRealizedLookaheadCount may be before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT error is generated.  The default
    /// is set by the default_max_allowable_lookahead_count directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableLookaheadCount () const;
    /// Returns the maximum number of lookaheads (not including %error tokens) used in
    /// any parser decision so far (this is not the theoretical maximum for the
    /// grammar/npda, it's the maximum only for the states the parser has actually
    /// encountered).
    std::size_t MaxRealizedLookaheadCount () const;
    /// Returns the highest value that MaxRealizedLookaheadQueueSize may be before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE error is generated.  The default
    /// is set by the default_max_allowable_lookahead_queue_size directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableLookaheadQueueSize () const;
    /// Returns the maximum size of the lookahead queue (including %error tokens) used
    /// in any parser decision so far (this is not the theoretical maximum for the
    /// grammar/npda, it's the maximum only for the states the parser has actually
    /// encountered).
    std::size_t MaxRealizedLookaheadQueueSize () const;
    /// Returns the maximum parse tree depth that may occur before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH error is generated.  The default
    /// is set by the default_max_allowable_parse_tree_depth directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableParseTreeDepth () const;
    /// Returns the maximum parse tree depth achieved in any parser decision so far
    /// (this is not the theoretical maximum for the grammar/npda, it's the maximum
    /// only for the states the parser has actually encountered).
    std::uint32_t MaxRealizedParseTreeDepth () const;

    /// Sets the maximum allowable lookahead count.  The initial value is given by
    /// the default_max_allowable_lookahead_count directive defined in trison.cpp.targetspec.
    void SetMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count);
    /// Sets the maximum allowable lookahead queue size.  The initial value is given by
    /// the default_max_allowable_lookahead_queue_size directive defined in trison.cpp.targetspec.
    void SetMaxAllowableLookaheadQueueSize (std::int64_t max_allowable_lookahead_queue_size);
    /// Sets the maximum allowable parse tree depth.  The initial value is given by
    /// the default_max_allowable_parse_tree_depth directive defined in trison.cpp.targetspec.
    void SetMaxAllowableParseTreeDepth (std::int64_t max_allowable_parse_tree_depth);

    /// Bitflag enums for granular specification of debug spew.
    enum DebugSpewFlags
    {
        // Individual flags
        DSF_START_END_PARSE             = 1 << 0,
        DSF_ITERATION_COUNT             = 1 << 1,
        DSF_SCANNER_ACTION              = 1 << 2,
        DSF_PARSER_ACTION               = 1 << 3,
        DSF_STACK_AND_LOOKAHEADS        = 1 << 4,
        DSF_PROGRAMMER_ERROR            = 1 << 5,
        DSF_PARSE_TREE_MESSAGE          = 1 << 6,
        DSF_LIMIT_EXCEEDED              = 1 << 7,
        DSF_SHIFT_REDUCE_CONFLICT       = 1 << 8,
        DSF_REDUCE_REDUCE_CONFLICT      = 1 << 9,
        DSF_TRANSITION_PROCESSING       = 1 << 10,
        DSF_TRANSITION_EXERCISING       = 1 << 11,
        DSF_HPS_REMOVE_DEFUNCT          = 1 << 12,
        DSF_HPS_NODE_CREATION_DELETION  = 1 << 13,
        // If more are added, then make sure to update DSF_HIGHEST_.
        DSF_HIGHEST_                    = DSF_HPS_NODE_CREATION_DELETION,

        // Pre-defined common sets of bitflags, in ascending order of verbosity.
        DSF__NONE                        = 0,
        DSF__MINIMAL                     = DSF_START_END_PARSE|DSF_SCANNER_ACTION|DSF_PARSER_ACTION|DSF_LIMIT_EXCEEDED|DSF_PROGRAMMER_ERROR,
        DSF__MINIMAL_VERBOSE             = DSF__MINIMAL|DSF_STACK_AND_LOOKAHEADS,
        DSF__INTERMEDIATE                = DSF__MINIMAL_VERBOSE|DSF_ITERATION_COUNT|DSF_PARSE_TREE_MESSAGE|DSF_SHIFT_REDUCE_CONFLICT,
        DSF__ALL                         = DSF_HIGHEST_-1 // This depends on everything being contiguous bitflags
    };

    /// Returns true if and only if "debug spew" is enabled (which prints, to the
    /// debug spew stream, exactly what the parser is doing at each step).  This
    /// method, along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    bool DebugSpewIsEnabled () const { return m_debug_spew_stream_ != NULL; }
    /// Returns the debug spew stream (see DebugSpewIsEnabled()).  This method,
    /// along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    std::ostream *DebugSpewStream () { return m_debug_spew_stream_; }
    /// Sets the debug spew stream (see DebugSpewIsEnabled()).  If NULL is passed
    /// in, then debug spew printing will be disabled.  The default value is NULL.
    /// This method, along with all other debug spew code can be removed by removing
    /// the %target.cpp.generate_debug_spew_code directive from the primary source.
    void SetDebugSpewStream (std::ostream *debug_spew_stream) { m_debug_spew_stream_ = debug_spew_stream; }
    /// Gets the flags which specify which debug spew messages to allow.
    DebugSpewFlags ActiveDebugSpewFlags () const { return m_active_debug_spew_flags_; }
    /// Sets the flags which specify which debug spew messages to allow.  The values
    /// DSF_NONE, DSF_MINIMAL, DSF_INTERMEDIATE, and DSF_ALL are designed to give convenient
    /// common sets of flags.
    void SetActiveDebugSpewFlags (DebugSpewFlags active_debug_spew_flags) { m_active_debug_spew_flags_ = active_debug_spew_flags; }
    /// Returns the debug spew prefix string, which may depend on values like the
    /// current filename, line number, etc.
    std::string DebugSpewPrefix () const;

    /// @brief This method must be called if the input source changes.
    ///
    /// This parser is capable of attempting multiple contiguous parses from the
    /// same input source.  The lookahead queue is preserved between calls to
    /// Parse().  Therefore, if the input source changes, the lookahead queue
    /// must be cleared so that the new input source can be read.  The client
    /// must call this method if the input source changes.
    void ResetForNewInput ();

    /// @brief This is the main method of the parser; it will attempt to parse
    ///        the nonterminal specified.
    ///
    /// The %target.cpp.parse_method_access directive can be used to specify the
    /// access level of this method.
    ///
    /// The %target.cpp.top_of_parse_method_actions and
    /// %target.cpp.bottom_of_parse_method_actions directives can be used to specify
    /// code to execute at the beginning and end, respectively, of the Parse() method.
    /// This includes the ability to enclose the body of the Parse() method within a
    /// try {} block, for exception handling (if exceptions are thrown in scan_actions
    /// or any reduction rule code, then the %target.cpp.enable_scan_actions_exceptions
    /// or %target.cpp.enable_reduction_rule_exceptions directives must be specified
    /// respectively; this will cause the parser to catch and rethrow any exceptions
    /// thrown by scan_actions or reduction rule code, allowing it to clean up
    /// dynamically allocated memory, etc.
    ///
    /// @param return_token A pointer to the value which will be assigned to upon
    ///        successfully parsing the requested nonterminal. If the parse fails,
    ///        the value of the %target.cpp.token_data_default directive will
    ///        be assigned.
    /// @param nonterminal_to_parse The Parse() method can attempt to parse any
    ///        nonterminal declared in the primary source.  If unspecified, the
    ///        Parse() method will attempt to parse the nonterminal specified by the
    ///        %default_parse_nonterminal directive.
    /// @return Parser::PRC_SUCCESS if the parse was successful (which includes
    ///         occurrences of parse errors which were handled by client-specified
    ///         %error-accepting rules), or Parser::PRC_UNHANDLED_PARSE_ERROR
    ///         if a parse error was not handled by any %error-accepting rules.
    ParserReturnCode Parse (Ast::Base * *return_token, Nonterminal::Name nonterminal_to_parse = Nonterminal::body);


#line 38 "barf_preprocessor_parser.trison"

    FiLoc const &GetFiLoc () const;

    bool ScannerDebugSpewIsEnabled () const;
    std::ostream *ScannerDebugSpewStream ();
    void SetScannerDebugSpewStream (std::ostream *debug_spew_stream);

    bool OpenFile (string const &input_filename);
    void OpenString (string const &input_string, string const &input_name, bool use_line_numbers = false);
    void OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers);

private:

    Scanner *m_scanner;

#line 375 "barf_preprocessor_parser.hpp"


private:

    // ///////////////////////////////////////////////////////////////////////
    // begin internal trison-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    std::int64_t m_max_allowable_lookahead_count;
    std::int64_t m_max_allowable_lookahead_queue_size;
    std::int64_t m_max_allowable_parse_tree_depth;

    // debug spew methods
    void PrintIndented_ (std::ostream &stream, char const *string) const;

    std::ostream *m_debug_spew_stream_;
    DebugSpewFlags m_active_debug_spew_flags_;

    static char const *const ms_parser_return_code_string_table_[];
    static std::size_t const ms_parser_return_code_string_count_;

    static char const *const ms_token_name_table_[];
    static std::size_t const ms_token_name_count_;

    static std::uint32_t NonterminalStartStateIndex_ (Nonterminal::Name nonterminal);
    ParserReturnCode Parse_ (Ast::Base * *return_token, Nonterminal::Name nonterminal_to_parse);
    void ThrowAwayToken_ (Token const &token) throw();
    void ThrowAwayTokenData_ (Ast::Base * const &token_data) throw();
    Token::Data InsertLookaheadErrorActions_ (Token const &noconsume_lookahead_token);
    Token::Data DiscardLookaheadActions_ (Token const &consume_stack_top_error_token, Token const &consume_lookahead_token);
    Token::Data PopStack1Actions_ (std::vector<Token> const &consume_stack_top_tokens, Token const &consume_lookahead_token);
    Token::Data PopStack2Actions_ (std::vector<Token> const &consume_stack_top_tokens, Token const &noconsume_lookahead_token);
    void ResetForNewInput_ () throw();
    Token Scan_ () throw();
    void RunNonassocErrorActions_ (Token const &lookahead);
    // debug spew methods
    void PrintParserStatus_ (std::ostream &out) const;

private:

    struct Grammar_
    {
        // These values are prescribed within trison and can't be changed.
        enum Associativity : std::uint32_t
        {
            ASSOC_LEFT      = 0, // %left
            ASSOC_NONASSOC  = 1, // %nonassoc
            ASSOC_RIGHT     = 2  // %right
        };

        // TODO: Rename to Precedence
        struct Precedence_
        {
            // Default precedence is always 0, higher values have higher precedence.
            std::int32_t    m_level;
            Associativity   m_associativity;
            char const *    m_name;
        }; // end of struct Parser::Grammar_::Precedence_

        // TODO: Rename to Rule
        struct Rule_
        {
            Token::Id       m_reduction_nonterminal_token_id;
            std::uint32_t   m_token_count;
            std::uint32_t   m_precedence_index;
            char const *    m_description;
        }; // end of struct Parser::Grammar_::Rule_

        // TODO: Get rid of trailing _ chars

        // Returns true iff lhs_rule_index denotes a rule with a higher precedence than that denoted by rhs_rule_index.
        static bool CompareRuleByPrecedence_ (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index);

        static char const *const    ms_associativity_string_table_[];
        static std::size_t const    ms_associativity_count_;
        // TODO: rename to PRECEDENCE_TABLE and RULE_TABLE ?
        static Precedence_ const    ms_precedence_table_[];
        static std::size_t const    ms_precedence_count_;
        static Rule_ const          ms_rule_table_[];
        static std::size_t const    ms_rule_count_;
    }; // end of struct Parser::Grammar_

    struct Npda_
    {
        struct Transition_;

        // TODO: Get rid of trailing _ chars
        struct State_
        {
            std::size_t         m_transition_count; // TODO: smallest int
            Transition_ const * m_transition_table;
            std::uint32_t       m_associated_rule_index;
            char const *        m_description;
        }; // end of struct Parser::Grammar_::State_

        struct Transition_
        {
            // TODO: Make this into a strong enum (C++11)
            enum Type { RETURN = 1, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, EPSILON };
            std::uint8_t    m_type;
            // TODO: Rename this to m_token_id
            std::uint32_t   m_token_index;  // TODO: smallest int
            std::uint32_t   m_data_index;   // TODO: smallest int

            // TODO: Make a typedef for sorted type index?

            // Lexicographic ordering on the tuple (m_type, m_token_index, m_data_index).
            struct Order
            {
                // TODO: Rename SortedTypeIndex to ActionClassIndex?
                static std::uint32_t SortedTypeIndex (Type type)
                {
                    switch (type)
                    {
                        case REDUCE:
                        case SHIFT:
                            return 0;

                        case DISCARD_LOOKAHEAD:
                        case POP_STACK:
                            return 1;

                        case RETURN:
                            return 2;

                        case INSERT_LOOKAHEAD_ERROR:
                        case EPSILON:
                            return 3;

                        default:
                            assert(false && "this should never happen");
                            return 3; // Arbitrary
                    }
                }

                bool operator () (Transition_ const &lhs, Transition_ const &rhs) const
                {
                    std::uint32_t sorted_type_index_lhs = SortedTypeIndex(Type(lhs.m_type));
                    std::uint32_t sorted_type_index_rhs = SortedTypeIndex(Type(rhs.m_type));
                    if (sorted_type_index_lhs != sorted_type_index_rhs)
                        return sorted_type_index_lhs < sorted_type_index_rhs;
                    else if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;
                    else if (lhs.m_token_index != rhs.m_token_index)
                        return lhs.m_token_index < rhs.m_token_index;
                    else
                        return lhs.m_data_index < rhs.m_data_index;
                }
            }; // end of struct Parser::Grammar_::Transition_::Order
        }; // end of struct Parser::Grammar_::Transition_

        typedef std::set<Transition_,Transition_::Order>    TransitionSet_;
        typedef std::vector<Transition_>                    TransitionVector_;

        typedef std::uint32_t                               StateIndex_;
        typedef std::set<StateIndex_>                       StateIndexSet_;
        typedef std::vector<StateIndex_>                    StateIndexVector_;

    private:

        // These functions are used in the implementation of NonEpsilonTransitionsOfState_.

        // Returns the epsilon closure of the given NPDA state.  Return value is memoized.
        static StateIndexVector_ const &EpsilonClosureOfState_ (StateIndex_ state_index);
        // Computes the epsilon closure of the given NPDA state, placing the computed value in epsilon_closure.
        static void ComputeEpsilonClosureOfState_ (StateIndex_ state_index, StateIndexSet_ &epsilon_closure);

    public:

        // Returns the transitions, matching given sorted_type_index, for the epsilon closure of the given NPDA state.  Return value is memoized.
        static TransitionVector_ const &NonEpsilonTransitionsOfState_ (StateIndex_ state_index, std::uint32_t sorted_type_index);

        // TODO: rename to STATE_TABLE and TRANSITION_TABLE ?
        static State_ const         ms_state_table_[];
        static std::size_t const    ms_state_count_;
        static Transition_ const    ms_transition_table_[];
        static std::size_t const    ms_transition_count_;
    }; // end of struct Parser::Npda_

    // NOTE: Because this uses std::shared_ptr, if you create a cycle in the list (which is valid and
    // the algorithms will work), then you must explicitly break it later in order for that memory to
    // be cleaned up (otherwise the ref count of the elements in the cycle will never go back to zero).
    template <typename DataType>
    struct TreeNode_ : public std::enable_shared_from_this<TreeNode_<DataType>>
    {
        // Ideally this would be private and std::make_shared<TreeNode_> would be a friend
        // in order to force use of std::make_shared to construct std::shared_ptr<TreeNode_>
        // instances instead of bare TreeNode_ instances, but I couldn't figure out how to
        // do this correctly.
        template <typename... Types>
        TreeNode_ (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
            :   m_parent(parent)
            ,   m_data(std::forward<Types>(args)...)
        { }

        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateWithParent (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
        {
            return std::make_shared<TreeNode_>(parent, std::forward<Types>(args)...);
        }
        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateOrphan (Types&&... args)
        {
            return std::make_shared<TreeNode_>(nullptr, std::forward<Types>(args)...);
        }

        static bool Equals (std::shared_ptr<TreeNode_ const> const &lhs, std::shared_ptr<TreeNode_ const> const &rhs)
        {
            if (lhs.get() == rhs.get())
                return true;

            assert(bool(lhs) || bool(rhs)); // They can't both be null at this point.
            if (!bool(lhs) || !bool(rhs))
                return false; // If either one is null, then they're not equal.

            return lhs->Data() == rhs->Data() && Equals(lhs->Parent(), rhs->Parent());
        }

        bool HasParent () const { return bool(m_parent); }
        std::shared_ptr<TreeNode_ const> Parent () const { return m_parent; }
        std::shared_ptr<TreeNode_> const &Parent () { return m_parent; }
        DataType const &Data () const { return m_data; }
        DataType &Data () { return m_data; }
        std::size_t BranchLength () const
        {
            if (HasParent())
                return 1 + Parent()->BranchLength_Impl(*this);
            else
                return 1;
        }

        template <typename T>
        void PrintRootToLeaf (std::ostream &out, T (*DataTransform)(DataType const &)) const
        {
            if (this->HasParent())
            {
                Parent()->PrintRootToLeaf(out, DataTransform);
                out << ' ';
            }
            out << DataTransform(Data());
        }

    private:

        // The initial_element parameter is used to prevent infinite loop in the case of a branch containing a cycle.
        std::size_t BranchLength_Impl (TreeNode_ const &initial_element) const
        {
            if (this == &initial_element)
                return 0;
            else if (HasParent())
                return 1 + Parent()->BranchLength_Impl(initial_element);
            else
                return 1;
        }

        std::shared_ptr<TreeNode_> m_parent;
        DataType m_data;
    };

    typedef std::uint32_t                               ActionData_;

    typedef std::deque<Token>                           TokenQueue_;
    typedef std::vector<Token>                          TokenStack_;
    typedef std::deque<Token::Id>                       TokenIdQueue_;

    // This forms one element, containing the NPDA state index, of a NPDA state stack (aka branch).
    typedef TreeNode_<Npda_::StateIndex_>               BranchState_;
    typedef std::shared_ptr<BranchState_>               BranchStatePtr_;

    // These are tracked in parallel with BranchState_, etc for the purposes of debug spew only.
    typedef TreeNode_<Token::Id>                        BranchTokenId_;
    typedef std::shared_ptr<BranchTokenId_>             BranchTokenIdPtr_;

    // These are used in printing the branch state stacks and token id stacks.
    template <typename T>
    static T const &IdentityTransform_ (T const &x) { return x; }
    static char const *TokenName_ (Token::Id const &token_id) { return ms_token_name_table_[token_id]; }

    struct Branch_
    {
        Branch_ () { } // Default initialization is nullptr.
        Branch_ (BranchStatePtr_ const &state_ptr, BranchTokenIdPtr_ const &token_id_ptr)
            :   m_state_ptr(state_ptr)
            ,   m_token_id_ptr(token_id_ptr)
        {
            assert(bool(m_state_ptr) == bool(m_token_id_ptr) && "pointers must both be set or both be unset");
        }

        bool HasParent () const {
            assert(m_state_ptr->HasParent() == m_token_id_ptr->HasParent());
            return m_state_ptr->HasParent();
        }
        Branch_ Parent () const {
            return Branch_(m_state_ptr->Parent(), m_token_id_ptr->Parent());
        }
        bool HasAsAncestor (Branch_ const &other) const
        {
            Branch_ b(*this);
            while (true)
            {
                if (b == other)
                    return true;

                if (b.HasParent())
                    b = b.Parent();
                else
                    return false;
            }
        }

        bool operator == (Branch_ const &other) const { return BranchState_::Equals(m_state_ptr, other.m_state_ptr); }

        BranchStatePtr_ const &StatePtr () const { return m_state_ptr; }
        BranchTokenIdPtr_ const &TokenIdPtr () const { return m_token_id_ptr; }

    private:

        // This is the head of the NPDA state branch that this HPS tracks.
        BranchStatePtr_ m_state_ptr;
        // This is the head of the Token::Id branch that this HPS tracks (which is exactly
        // parallel to the NPDA state branch tracked by m_state_ptr).
        BranchTokenIdPtr_ m_token_id_ptr;
    };

    typedef std::vector<Branch_>            BranchVector_;
    typedef std::vector<BranchVector_>      BranchVectorStack_;

    struct  ParseTreeNode_;

    typedef std::deque<ParseTreeNode_ *>    HPSQueue_;

    struct RealizedState_
    {
        RealizedState_      (Npda_::StateIndex_ initial_state);

        BranchVectorStack_ const &BranchVectorStack             () const { return m_branch_vector_stack; }
        TokenStack_ const & TokenStack                          () const { return m_token_stack; }
        TokenQueue_ const & LookaheadQueue                      () const { return m_lookahead_queue; }

        std::size_t         MaxRealizedLookaheadCount           () const { return m_max_realized_lookahead_count; }
        std::size_t         MaxRealizedLookaheadQueueSize       () const { return m_max_realized_lookahead_queue_size; }
        bool                HasExceededMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count) const { return max_allowable_lookahead_count >= 0 && m_max_realized_lookahead_count > std::size_t(max_allowable_lookahead_count); }
        bool                HasExceededMaxAllowableLookaheadQueueSize (std::int64_t max_allowable_lookahead_queue_size) const { return max_allowable_lookahead_queue_size >= 0 && m_max_realized_lookahead_queue_size > std::size_t(max_allowable_lookahead_queue_size); }
        bool                HasEncounteredErrorState            () const { return m_has_encountered_error_state; }

        // This is used during the hypothetical branch processing for when more lookaheads are needed in the queue.
        void                PushBackLookahead                   (Token const &lookahead, HPSQueue_ const &hps_queue);

        Token               PopStack                            ();
        void                ReplaceTokenStackTopWith            (Token const &replacement);
        Token               PopFrontLookahead                   (HPSQueue_ &hps_queue);

        void                StealTokenStackTop                  (Ast::Base * *&return_token);

        // void                ExecuteAction                       (Npda_::Transition_::Type action, ActionData_ action_data);

        // TODO: Need to figure out how to handle popping the token stack (since in a way it should be the
        // responsibility of ExecuteAction).  Maybe ExecuteAction should accept Token* which it will populate
        // with the popped token in the case of POP_STACK, so that the parser can call the throw-away-token actions.

        void                ExecuteActionReduce                 (Grammar_::Rule_ const &rule, Token::Data const &reduced_nonterminal_token_data, HPSQueue_ &hps_queue);
        void                ExecuteActionShift                  (BranchVector_ const &shifted_branch_vector, HPSQueue_ &hps_queue);
        void                ExecuteActionInsertLookaheadError   (HPSQueue_ &hps_queue);
        void                ExecuteActionDiscardLookahead       (HPSQueue_ &hps_queue);
        // This one is tricky to implement within RealizedState_ alone.
        //void                ExecuteActionPopStack               (std::uint32_t pop_count);

        void                PrintStackAndLookaheads             (std::ostream &out) const;

        void                ClearStack                          ();
        void                Reinitialize                        (Npda_::StateIndex_ initial_state);

    private:

        void                Initialize                          (Npda_::StateIndex_ initial_state);

    public:
        void                PushFrontLookahead                  (Token const &lookahead, HPSQueue_ &hps_queue);
    private:
        void                UpdateMaxRealizedLookaheadCount     ();
    public:
        void                SetHasEncounteredErrorState         () { m_has_encountered_error_state = true; }
    private:

        static bool         IsScannerGeneratedTokenId           (Token::Id token_id)
        {
            // If this is a Terminal (anything between 0 and Terminal::BAD_TOKEN)
            // that isn't ERROR_, then it's scanner-generated (i.e. not parser-generated).
            return token_id != Terminal::ERROR_ && token_id <= Terminal::BAD_TOKEN;
        }

        // The set of the realized branches (i.e. the set of the tops of the NPDA state stacks)
        BranchVectorStack_  m_branch_vector_stack;
        TokenStack_         m_token_stack;
        TokenQueue_         m_lookahead_queue;
        // This is related to k in the LALR(k) quantity of the grammar, though it's only what's been realized
        // during the parse, not the theoretical bound (if it even exists).
        std::size_t         m_max_realized_lookahead_count;
        std::size_t         m_max_realized_lookahead_queue_size;
        // TODO: Maybe make this into the number of times error recovery has been entered.
        bool                m_has_encountered_error_state;
    }; // end of struct Parser::RealizedState_

    struct HypotheticalState_
    {
        HypotheticalState_      (std::uint32_t initial_state);
        ~HypotheticalState_     ();

        // The min and max realized lookahead cursors being equal across all HPSes indicates that
        // all HPSes have consumed the same number of lookaheads, so they're in a well-defined
        // state with respect to resolving SHIFT/REDUCE conflicts.
        bool                    MinAndMaxRealizedLookaheadCursorsAreEqual () const;
        // Indicates if ParseTreeDepth() has exceeded max_allowable_parse_tree_depth.
        bool                    HasExceededMaxAllowableParseTreeDepth (std::int64_t max_allowable_parse_tree_depth) const;

        // Deletes the branch that the given node (which may not be the root node) is a part of.
        // A branch of a node N is defined as the set of nodes that are descendants of N, and all
        // ancestors of N having exactly one child, excluding the root node.  Thus if the whole parse
        // tree is a single line of nodes extending from the root, then calling DeleteBranch on any
        // non-root node will delete all non-root nodes.
        void                    DeleteBranch (ParseTreeNode_ *branch_node);

        // Destroys the parse tree and recreates a root node with no children.
        void                    DestroyParseTree ();

    //private: // TEMP commented out until HypotheticalState_ is properly encapsulated.

        // Note that if m_hps_queue is empty, then *min = std::numeric_limits<std::uint32_t>::max()
        // and *max = std::numeric_limits<std::uint32_t>::min().  If min or max is nullptr, doesn't
        // assign to that one.
        void                    ComputeMinAndMaxRealizedLookaheadCursors (std::uint32_t *min, std::uint32_t *max) const;
        // Returns max of m_depth of each of m_hps_queue minus m_root->m_depth, giving a relative depth.
        std::uint32_t           ParseTreeDepth () const;
        std::uint32_t           MaxRealizedParseTreeDepth () const { return m_max_realized_parse_tree_depth; }

        ParseTreeNode_ *        m_root;
        HPSQueue_               m_hps_queue;
        // This is stored so new memory isn't necessarily allocated for each parse iteration.
        HPSQueue_               m_new_hps_queue;
        mutable std::uint32_t   m_max_realized_parse_tree_depth;
    }; // end of struct Parser::HypotheticalState_

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, Ast::Base * *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ const &token_stack) throw();

    // TODO: This should probably be inside HypotheticalState_
    struct ParseTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Npda_::Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, SHIFT, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // The granularity of the ordering depends on m_type.  In particular,
            // - POP_STACK is lexicographic ordering on the tuple (m_type, m_single_data).
            // - REDUCE only cares about m_type; the rule number itself doesn't matter.
            // - SHIFT only cares about m_type; the shifted token ID is only used in printing anyway
            // - other types only care about m_type.
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT:
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            }; // end of struct Parser::ParseTreeNode_::Spec::Order
        }; // end of struct Parser::ParseTreeNode_::Spec

        static char const *AsString (Type type);

        struct ParseTreeNodeOrder
        {
            bool operator () (ParseTreeNode_ const *lhs, ParseTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseTreeNode_ *,ParseTreeNodeOrder>           ParseTreeNodeSet;
        typedef std::map<Spec,ParseTreeNodeSet,Spec::Order>             ChildMap;
        typedef std::pair<std::int32_t,std::int32_t>                    PrecedenceLevelRange;

        Spec                    m_spec;
        Branch_                 m_hypothetical_head;
        BranchVector_           m_child_branch_vector;
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_           m_hypothetical_lookahead_token_id_queue;
        std::uint32_t           m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        ParseTreeNode_ *        m_parent_node;
        ChildMap                m_child_nodes;
        // Index of depth in from the initial root.  Used to compute relative depth of parse tree.
        // Yes, this may wrap, but it doesn't matter, because the relative parse tree depth is what
        // matters, and it won't be more than can be stored in std::uint32_t.
        std::uint32_t           m_depth;

        ParseTreeNode_ (Spec const &spec)
            :   m_spec(spec)
            ,   m_realized_lookahead_cursor(0)
            ,   m_parent_node(NULL)
            ,   m_depth(0)
        { }
        ~ParseTreeNode_ ();

        bool IsRoot () const { return m_parent_node == NULL; }
        bool HasParent () const { return m_parent_node != NULL; }
        bool HasTrunkChild () const;
        ParseTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (Parser &parser) const;
        // Some actions are considered to block the HPS from continuing (because it must be realized before
        // continuing).  RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseTreeNode_ *&shift, ParseTreeNode_ *&reduce);

        void AddChild (ParseTreeNode_ *child);
        void RemoveChild (ParseTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseTreeNode_ &orphan_target) const;

        void Print (std::ostream &out, Parser const *parser, std::string const &prefix, std::uint32_t indent_level = 0, bool suppress_initial_prefix = false) const;
    }; // end of struct Parser::ParseTreeNode_

    Token const &Lookahead_ (TokenQueue_::size_type index) throw();

    ParseTreeNode_ *        TakeHypotheticalActionOnHPS_ (ParseTreeNode_ const &hps, ParseTreeNode_::Type action_type, std::uint32_t action_data);
    // Recreates the parse tree (i.e. the contents of m_hypothetical_state_) from the top of the
    // branch set stack of m_realized_state_, specifically, creates an HPS corresponding to each
    // branch, adding each created HPS as a child to the root node.
    void                    CreateParseTreeFromRealizedState_ ();

    static bool             CompareTokenId_             (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }

    // This doesn't reset the error state.
    void                    ClearStack_                 ();
    // This resets the error state.
    void                    CleanUpAllInternals_        ();

    RealizedState_     *    m_realized_state_;
    HypotheticalState_ *    m_hypothetical_state_;

    // ///////////////////////////////////////////////////////////////////////
    // end of internal trison-generated parser guts
    // ///////////////////////////////////////////////////////////////////////

    friend std::ostream &operator << (std::ostream &stream, Parser::ParserReturnCode parser_return_code);
    friend std::ostream &operator << (std::ostream &stream, Parser::Token const &token);
}; // end of class Parser

std::ostream &operator << (std::ostream &stream, Parser::ParserReturnCode parser_return_code);

std::ostream &operator << (std::ostream &stream, Parser::Token const &token);

#line 53 "barf_preprocessor_parser.trison"

} // end of namespace Preprocessor
} // end of namespace Barf

#endif // !defined(BARF_PREPROCESSOR_PARSER_HPP_)

#line 987 "barf_preprocessor_parser.hpp"
