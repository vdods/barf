// 2016.08.31 - Victor Dods

%targets cpp

// ///////////////////////////////////////////////////////////////////////////
// cpp parser header-file-related directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.header_filename "Parser.hpp"
%target.cpp.implementation_filename "Parser.cpp"

%target.cpp.top_of_header_file %{
#include <iostream>

class Scanner;
%}
%target.cpp.class_name Parser
%target.cpp.parse_method_access "public"
%target.cpp.bottom_of_class {
    void attach_istream (std::istream &in);

private:

    Scanner *m_scanner;
}

// ///////////////////////////////////////////////////////////////////////////
// cpp parser implementation-file-related directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.top_of_implementation_file %{
#include <cmath>
#include <sstream>
#include "Scanner.hpp"
%}
%target.cpp.constructor_actions {
    m_scanner = new Scanner();
    m_scanner->SetDebugSpewStream(&std::cerr);
}
%target.cpp.destructor_actions {
    delete m_scanner;
    m_scanner = NULL;
}
%target.cpp.bottom_of_implementation_file %{
void Parser::attach_istream (std::istream &in)
{
    assert(m_scanner != NULL);
    m_scanner->attach_istream(in);
}

Parser::ParserReturnCode parse (std::string const &s, double &parsed_value)
{
    std::istringstream in(s);
    Parser parser;
    parser.attach_istream(in);
    parser.SetDebugSpewStream(&std::cerr);
    Parser::ParserReturnCode return_code = parser.Parse(&parsed_value);
    return return_code;
}

int main (int argc, char **argv)
{
    if (argc >= 2)
    {
        double parsed_value;
        Parser::ParserReturnCode return_code = parse(argv[1], parsed_value);
        std::cout << "string to parse was \"" << argv[1] << "\"\n";
        std::cout << "return code was " << return_code << '\n';
        std::cout << "parsed value was " << parsed_value << '\n';
    }
    else
    {
        std::cout << "Usage: " << argv[0] << " <expr>\n";
    }
    return 0;
}
%}

// ///////////////////////////////////////////////////////////////////////////
// cpp parser token-specific directives
// ///////////////////////////////////////////////////////////////////////////

%target.cpp.token_data_type "double"
%target.cpp.token_data_default "0.0"
%target.cpp.throw_away_token_actions { } // none are necessary because token_data_type is a POD
%target.cpp.scan_actions {
    assert(m_scanner != NULL);
    return m_scanner->Scan();
}

// ///////////////////////////////////////////////////////////////////////////
// cpp parser misc directives
// ///////////////////////////////////////////////////////////////////////////

// this adds a lot of string content to parser source
%target.cpp.generate_debug_spew_code

// ///////////////////////////////////////////////////////////////////////////
// cpp parser terminal directives
// ///////////////////////////////////////////////////////////////////////////

%terminal '+' '-' '*' '^'
%terminal '(' ')' ';' '?'
%terminal NUM BAD_TOKEN

// ///////////////////////////////////////////////////////////////////////////
// cpp parser precedence directives
// ///////////////////////////////////////////////////////////////////////////

// Lowest precedence is first, highest is last.

%prec.left      %default
%prec.left      LOWEST
%prec.left      LOW
%prec.left      ADDITIVE
%prec.left      MULTIPLICATIVE
%prec.nonassoc  QUESTION
%prec.right     UNARY
%prec.right     EXPONENTIATION
%prec.left      HIGHEST

// ///////////////////////////////////////////////////////////////////////////
// cpp parser grammar specification
// ///////////////////////////////////////////////////////////////////////////

%default_parse_nonterminal stmt_then_end

%%

%nonterminal stmt_then_end
:
    stmt:st %end                                                %target.cpp { std::cout << "stmt_then_end <- stmt %end\n"; return st; }
|
    %error[%end] %end                                           %target.cpp { std::cout << "stmt_then_end <- %error[%end] %end\n"; return 0.0; }
;

%nonterminal stmt
:
    expr:ex ';'                                                 %target.cpp { std::cout << "stmt <- expr ';'\n"; return ex; }
|
    %error[%end|';'] ';'                                        %target.cpp { std::cout << "stmt <- %error ';'\n"; return 0.0; }
;

%nonterminal expr
:
    '(' expr:e ')'                                              %target.cpp { std::cout << "expr <- '(' expr ')'\n"; return e; }
|
    '(' %error[%end|')'] ')'                                    %target.cpp { std::cout << "expr <- '(' %error[%end|')'] ')'\n"; return 0.0; }
|
    // This will match everything until %end or ';' during error panic.
    '(' %error[%end|';']                                        %target.cpp { std::cout << "expr <- '(' %error[%end|';']\n"; return 0.0; }
|
    NUM:num                                                     %target.cpp { std::cout << "expr <- NUM(" << num << ")\n"; return num; }
|
    expr:lhs '+' expr:rhs               %prec ADDITIVE          %target.cpp { std::cout << "expr <- expr(" << lhs << ") '+' expr(" << rhs << ")\n"; return lhs + rhs; }
|
    expr:lhs '+' '+' '+' '+' expr:rhs   %prec LOWEST            %target.cpp { std::cout << "expr <- expr(" << lhs << ") '+' '+' '+' '+' expr(" << rhs << ")\n"; return lhs / rhs; }
|
    expr:lhs '+' '+' '+' expr:rhs       %prec LOW               %target.cpp { std::cout << "expr <- expr(" << lhs << ") '+' '+' '+' expr(" << rhs << ")\n"; return std::pow(lhs, rhs); }
|
    expr:lhs '+' '+' expr:rhs           %prec HIGHEST           %target.cpp { std::cout << "expr <- expr(" << lhs << ") '+' '+' expr(" << rhs << ")\n"; return lhs * rhs; }
|
    expr:lhs '*' expr:rhs               %prec MULTIPLICATIVE    %target.cpp { std::cout << "expr <- expr(" << lhs << ") '*' expr(" << rhs << ")\n"; return lhs * rhs; }
|
    expr:lhs '?' expr:rhs               %prec QUESTION          %target.cpp { std::cout << "expr <- expr(" << lhs << ") '?' expr(" << rhs << ")\n"; return lhs - rhs; }
|
    '-' expr:op                         %prec UNARY             %target.cpp { std::cout << "expr <- '-' expr(" << op << ")\n"; return -op; }
|
    expr:lhs '^' expr:rhs               %prec EXPONENTIATION    %target.cpp { std::cout << "expr <- expr(" << lhs << ") '^' expr(" << rhs << ")\n"; return std::pow(lhs, rhs); }
|
    %error[%end|';']                                            %target.cpp { std::cout << "expr <- %error[%end|';']\n"; return 0.0; }
;
