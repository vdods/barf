// 2016.08.31 - Victor Dods

%targets cpp

/* ***************************************************************************
/* cpp parser header-file-related directives
/* **************************************************************************/

%target.cpp.header_filename "Parser.hpp"
%target.cpp.implementation_filename "Parser.cpp"

%target.cpp.top_of_header_file %{
#include <iostream>

class Scanner;
%}
%target.cpp.class_name Parser
%target.cpp.parse_method_access "public"
%target.cpp.bottom_of_class {
    void attach_istream (std::istream &in);

private:

    Scanner *m_scanner;
}
// %target.cpp.bottom_of_header_file %{
// } // end of namespace Text
// %}

/* ***************************************************************************
/* cpp parser implementation-file-related directives
/* **************************************************************************/

%target.cpp.top_of_implementation_file %{
#include <cmath>
#include <sstream>
#include "Scanner.hpp"
%}
%target.cpp.constructor_actions {
    m_scanner = new Scanner();
    m_scanner->DebugSpew(true);
}
%target.cpp.destructor_actions {
    delete m_scanner;
    m_scanner = NULL;
}
// %target.cpp.top_of_parse_method_actions %{
//     EmitExecutionMessage("starting parser");
// %}
// %target.cpp.bottom_of_parse_method_actions %{
//     if (parse_return_code == PRC_SUCCESS)
//         EmitExecutionMessage("parse was successful");
// %}
%target.cpp.bottom_of_implementation_file %{
void Parser::attach_istream (std::istream &in)
{
    assert(m_scanner != NULL);
    m_scanner->attach_istream(in);
}
// FiLoc const &Parser::GetFiLoc () const
// {
//     assert(m_scanner != nullptr);
//     return m_scanner->GetFiLoc();
// }

// bool Parser::ScannerDebugSpew () const
// {
//     return m_scanner->DebugSpew();
// }

// void Parser::ScannerDebugSpew (bool debug_spew)
// {
//     m_scanner->DebugSpew(debug_spew);
// }

// bool Parser::OpenFile (std::string const &input_filename)
// {
//     assert(m_scanner != nullptr);
//     ResetForNewInput();
//     EmitExecutionMessage("opening file \"" + input_filename + "\" for input");
//     bool scanner_open_file_succeeded = m_scanner->OpenFile(input_filename);
//     if (scanner_open_file_succeeded)
//         EmitExecutionMessage("opened file \"" + input_filename + "\" successfully");
//     return scanner_open_file_succeeded;
// }

// void Parser::OpenString (std::string const &input_string, std::string const &input_name, bool use_line_numbers)
// {
//     assert(m_scanner != nullptr);
//     ResetForNewInput();
//     return m_scanner->OpenString(input_string, input_name, use_line_numbers);
// }

// void Parser::OpenUsingStream (std::istream *input_stream, std::string const &input_name, bool use_line_numbers)
// {
//     assert(m_scanner != nullptr);
//     ResetForNewInput();
//     return m_scanner->OpenUsingStream(input_stream, input_name, use_line_numbers);
// }

// } // end of namespace Text

Parser::ParserReturnCode parse (std::string const &s, double &parsed_value)
{
    std::istringstream in(s);
    Parser parser;
    parser.attach_istream(in);
    Parser::ParserReturnCode return_code = parser.Parse(&parsed_value);
    return return_code;
}

int main (int argc, char **argv)
{
    if (argc >= 2)
    {
        double parsed_value;
        Parser::ParserReturnCode return_code = parse(argv[1], parsed_value);
        std::cout << "string to parse was \"" << argv[1] << "\"\n";
        std::cout << "return code was ";
        switch (return_code)
        {
            case Parser::PRC_SUCCESS: std::cout << "PRC_SUCCESS"; break;
            case Parser::PRC_UNHANDLED_PARSE_ERROR: std::cout << "PRC_UNHANDLED_PARSE_ERROR"; break;
            case Parser::PRC_INTERNAL_ERROR: std::cout << "PRC_INTERNAL_ERROR"; break;
        }
        std::cout << '\n';
        std::cout << "parsed value was " << parsed_value << '\n';
    }
    else
    {
        std::cout << "Usage: " << argv[0] << " <expr>\n";
    }
    return 0;
}
%}

/* ***************************************************************************
/* cpp parser token-specific directives
/* **************************************************************************/

%target.cpp.token_data_type "double"
%target.cpp.token_data_default "0.0"
// %target.cpp.custom_token_data_type_cast "???"
%target.cpp.throw_away_token_actions { } // none are necessary because std::shared_ptr is used
%target.cpp.scan_actions {
    assert(m_scanner != NULL);
    return m_scanner->Scan();
}
%target.cpp.reset_for_new_input_actions {
    // m_recoverable_error_encountered = false;
}

/* ***************************************************************************
/* cpp parser misc directives
/* **************************************************************************/

// this adds a lot of string content to parser source
%target.cpp.generate_debug_spew_code
%target.cpp.debug_spew_prefix {"Parser"}
%target.cpp.dont_generate_timestamps

/* ***************************************************************************
/* cpp parser terminal directives
/* **************************************************************************/

%terminal '+' '-' '*' '^'
%terminal '(' ')' ';' '?'
%terminal NUM BAD_TOKEN

/* ***************************************************************************
/* cpp parser precedence directives
/* **************************************************************************/

// Lowest precedence is first, highest is last.

%prec.left      LOWEST
%prec.left      LOW
%prec.left      ADDITIVE
%prec.left      MULTIPLICATIVE
%prec.nonassoc  QUESTION
%prec.right     UNARY
%prec.right     EXPONENTIATION
%prec.left      HIGHEST

/* ***************************************************************************
/* cpp parser grammar specification
/* **************************************************************************/

%default_parse_nonterminal statement_then_end

%%

%nonterminal statement_then_end
:
    statement:st %end                                                       %target.cpp { std::cout << "statement_then_end <- statement %end\n"; return st; }
|
    %error %end                                                             %target.cpp { std::cout << "statement_then_end <- %error %end\n"; return 0.0; }
;

%nonterminal statement
:
    expression:ex ';'                                                       %target.cpp { std::cout << "statement <- expression ';'\n"; return ex; }
|
    %error ';'                                                              %target.cpp { std::cout << "statement <- %error ';'\n"; return 0.0; }
;

%nonterminal expression
:
    '(' expression:e ')'                                                    %target.cpp { std::cout << "expression <- '(' expression ')'\n"; return e; }
|
    '(' %error ')'                                                          %target.cpp { std::cout << "expression <- '(' %error ')'\n"; return 0.0; }
|
    // NOTE: This will match everything until %end.
    // This rule prevents ';' from being the error-stopper in statements, since
    // the %error token matches everything including ';'.
    // If %error_until(%end, ';') were added, this situation could be handled better.
    '(' %error                                                              %target.cpp { std::cout << "expression <- '(' %error\n"; return 0.0; }
|
    NUM:num                                                                 %target.cpp { std::cout << "expression <- NUM(" << num << ")\n"; return num; }
|
    expression:lhs '+' expression:rhs               %prec ADDITIVE          %target.cpp { std::cout << "expression <- expression(" << lhs << ") '+' expression(" << rhs << ")\n"; return lhs + rhs; }
|
    expression:lhs '+' '+' '+' '+' expression:rhs   %prec LOWEST            %target.cpp { std::cout << "expression <- expression(" << lhs << ") '+' '+' '+' '+' expression(" << rhs << ")\n"; return lhs / rhs; }
|
    expression:lhs '+' '+' '+' expression:rhs       %prec LOW               %target.cpp { std::cout << "expression <- expression(" << lhs << ") '+' '+' '+' expression(" << rhs << ")\n"; return std::pow(lhs, rhs); }
|
    expression:lhs '+' '+' expression:rhs           %prec HIGHEST           %target.cpp { std::cout << "expression <- expression(" << lhs << ") '+' '+' expression(" << rhs << ")\n"; return lhs * rhs; }
|
    expression:lhs '*' expression:rhs               %prec MULTIPLICATIVE    %target.cpp { std::cout << "expression <- expression(" << lhs << ") '*' expression(" << rhs << ")\n"; return lhs * rhs; }
|
    expression:lhs '?' expression:rhs               %prec QUESTION          %target.cpp { std::cout << "expression <- expression(" << lhs << ") '?' expression(" << rhs << ")\n"; return lhs - rhs; }
|
    '-' expression:op                               %prec UNARY             %target.cpp { std::cout << "expression <- '-' expression(" << op << ")\n"; return -op; }
|
    expression:lhs '^' expression:rhs               %prec EXPONENTIATION    %target.cpp { std::cout << "expression <- expression(" << lhs << ") '^' expression(" << rhs << ")\n"; return std::pow(lhs, rhs); }
// |
//     // This just screws everything up.  It seems like there should just never be
//     // a lone %error in a rule.  Though %error_until(%end, ';') could solve this.
//     %error                                                                  %target.cpp { std::cout << "expression <- %error\n"; return 0.0; }
;
