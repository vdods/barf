// 2016.09.08 - Victor Dods

%targets cpp

/* ***************************************************************************
/* cpp scanner header-file-related directives
/* **************************************************************************/

%target.cpp.header_filename "Scanner.hpp"
%target.cpp.implementation_filename "Scanner.cpp"
%target.cpp.top_of_header_file %{
#include <cstdint>
#include <iostream>
#include "Parser.hpp"
%}
%target.cpp.class_name Scanner
// %target.cpp.class_inheritance { protected InputBase }
// %target.cpp.top_of_class {
// }
%target.cpp.bottom_of_class {
    void attach_istream (std::istream &in);
}
// %target.cpp.bottom_of_header_file %{
// %}

/* ***************************************************************************
/* cpp scanner implementation-file-related directives
/* **************************************************************************/

%target.cpp.top_of_implementation_file %{
void Scanner::attach_istream (std::istream &in)
{
    IstreamIterator(std::istream_iterator<char>(in));
}
%}
// %target.cpp.constructor_actions {
// }
// %target.cpp.destructor_actions {
// }
%target.cpp.bottom_of_scan_method_actions %{
    assert(false && "you didn't handle EOF properly");
    return Parser::Token(Parser::Terminal::END_);
%}
// %target.cpp.bottom_of_implementation_file %{
// %}

/* ***************************************************************************
/* cpp scanner I/O parameters
/* **************************************************************************/

%target.cpp.return_type "Parser::Token"
%target.cpp.rejection_actions {
    std::cerr << "unrecognized character " << std::uint32_t(rejected_atom) << '\n';;
}
// %target.cpp.reset_for_new_input_actions {
// }

/* ***************************************************************************
/* cpp scanner misc directives
/* **************************************************************************/

%target.cpp.generate_debug_spew_code
%target.cpp.debug_spew_prefix {"Scanner:"}

/* ***************************************************************************
/* target-independent scanner directives
/* **************************************************************************/

// all operators that should be returned by ascii value
%macro OPERATOR             ([()+*\-;\^?])
// integer literal
%macro INTEGER_LITERAL      (0|[1-9][0-9]*)
// decimal literal has an optional decimal point and possibly also fractional part
%macro DECIMAL_LITERAL      ({INTEGER_LITERAL}(\.[0-9]*)?)
// numeric literal includes possible scientific notation
%macro NUMERIC_LITERAL      ({DECIMAL_LITERAL}([eE][+\-]?[0-9]+)?)
// non-newline whitespace
%macro WHITESPACE           ([ \t\n])
// any char
%macro ANY                  (\n|.)
// end-of-file condition
%macro END_OF_FILE          (\z)

%start_with_state_machine MAIN

%%

/* ***************************************************************************
/* state machines and constituent regex rules
/* **************************************************************************/

%state_machine MAIN
:
    ({OPERATOR})            %target.cpp { return Parser::Token(Parser::Terminal::Name(accepted_string[0])); }
|   ({NUMERIC_LITERAL})     %target.cpp { return Parser::Token(Parser::Terminal::NUM, std::stod(accepted_string)); }
|   ({WHITESPACE})          %target.cpp { } // ignore all whitespace
|   ({END_OF_FILE})         %target.cpp { return Parser::Token(Parser::Terminal::END_); }
|   ({ANY})                 %target.cpp { return Parser::Token(Parser::Terminal::BAD_TOKEN); }
;
