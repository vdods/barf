<*{if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<*{error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<*{end_if
<*{if(is_defined(parse_method_definition_parameters) && !is_defined(parse_method_parameters))
<*{error("can't specify parse_method_definition_parameters without specifying parse_method_parameters")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by trison at <{_creation_timestamp}
// from <{_source_filename} using <{_langspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<*{if(is_defined(generate_debug_spew_code))

#define TRISON_CPP_DEBUG_SPEW_(spew_code) if (DebugSpew()) { spew_code; }
<*{end_if
<*{if(is_defined(top_of_implementation_file))

<*{top_of_implementation_file
<*{end_if

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
<*{if(is_defined(superclass_and_member_constructors))
    :
<*{superclass_and_member_constructors
<*{end_if
{
    // one-time initializations
    m_tree_root_ = NULL;
<*{if(is_defined(generate_debug_spew_code))
    DebugSpew(false);
<*{end_if
    // per-input initializations
    ResetForNewInput_();

<*{if(is_defined(constructor_actions))

<*{constructor_actions
<*{end_if
}

<{class_name}::~<{class_name} ()
{
/*
    ClearBranches_();
    ClearTokenStack_();
    ClearLookaheadQueue_();
    ClearMostRecentReturnState_();
    ClearReturnToken_();
*/
<*{if(is_defined(destructor_actions))

<*{destructor_actions
<*{end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse (StartNonterminal::Name nonterminal_to_parse_)
{
<*{if(is_defined(start_of_parse_method_actions))
<*{start_of_parse_method_actions

<*{end_if
<*{if(is_defined(end_of_parse_method_actions))
    ParserReturnCode parser_return_code_ = Parse_(nonterminal_to_parse_);

<*{end_of_parse_method_actions

    return parser_return_code_;
<*{else
    return Parse_(nonterminal_to_parse_);
<*{end_if
}
/*
void <{class_name}::ClearBranches_ ()
{
    // delete branches if any exist, and clear the set.
    for (BranchSet_::iterator it_ = m_branch_set_.begin(), it_end_ = m_branch_set_.end(); it_ != it_end_; ++it_)
        delete *it_;
    m_branch_set_.clear();
}

void <{class_name}::ClearTokenStack_ ()
{
    // throw away all tokens remaining in the token stack and clear it.
    for (TokenBuffer_::iterator it_ = m_token_stack_.begin(), it_end_ = m_token_stack_.end(); it_ != it_end_; ++it_)
        ThrowAwayToken_(it_->m_token_data_);
    m_token_stack_.clear();
}

void <{class_name}::ClearLookaheadQueue_ ()
{
    // throw away all tokens remaining in the lookahead queue and clear it
    for (TokenBuffer_::iterator it_ = m_lookahead_queue_.begin(), it_end_ = m_lookahead_queue_.end(); it_ != it_end_; ++it_)
        ThrowAwayToken_(it_->m_token_data_);
    m_lookahead_queue_.clear();
    // also reset the cursor
    m_lookahead_queue_cursor_ = 0;
}

void <{class_name}::ClearMostRecentReturnState_ ()
{
    m_most_recent_return_state_ = NULL;
}

void <{class_name}::ClearReturnToken_ ()
{
    // clear the return token's members to neutral values
    m_return_token_.m_token_id_ = 0; // TODO: make an ERROR_ token (nonterminal? terminal?)
    m_return_token_.m_token_data_ = <{token_data_type_sentinel};
}
*/
void <{class_name}::ThrowAwayToken_ (TokenData_ &token)
{
<*{token_throw_away_actions?
}

void <{class_name}::ResetForNewInput_ ()
{
//     TrisonCpp_::Npda_::ResetForNewInput_();
    m_lookahead_queue_.clear();
    m_lookahead_queue_cursor_ = 0;
/*
    ClearBranches_();
    ClearTokenStack_();
    ClearLookaheadQueue_();
    ClearMostRecentReturnState_();
    ClearReturnToken_();
*/
<*{if(is_defined(reset_for_new_input_actions))

<*{reset_for_new_input_actions
<*{end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse_ (StartNonterminal::Name nonterminal_to_parse_)
{
    ParserReturnCode parser_return_code_ = PRC_SUCCESS;

    // TODO: clear any existing tree/branches

    assert(m_tree_root_ == NULL);
    assert(m_branch_set_.empty());

    // create the tree root
    m_tree_root_ = new ActionTreeNode_(ACTION_NONE_, NULL, m_nonassoc_error_encountered_, 0, 0);
    {
        // create the initial branch with a rule stack level of 0
        BranchTreeNode_ *initial_branch_ = new BranchTreeNode_(ms_state_table_ + nonterminal_to_parse_, 0);
        // add the initial nonterminal state as a child to the tree
        m_tree_root_->AddChild_(initial_branch_);
        // initialize the current branch set with the created branch
        m_branch_set_.insert(initial_branch_);
    }
    // initialize other members
    m_is_shift_blocked_ = false;
    m_nonassoc_error_encountered_ = false;
//     m_scheduled_transition_list_.clear();
    m_dead_branch_list_.clear();
    m_return_state_encountered_ = false;
    m_saved_return_action_queue_.clear();

    std::cerr << "!!! start !!!" << std::endl;
    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);

    while (true)
    {
        std::cerr << std::endl << std::endl << "!!! iteration !!!" << std::endl;
        // e-closure nodes should not be added for self-recursive rules.  e-closures
        // should only be done on non-closed branches.  the rule stack level should
        // be incremented on the transition after an e-closure.
        std::cerr << "*** e-close ***" << std::endl;
        PerformEpsilonClosure_();
        m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
        // only schedule reduce transitions if no branches have nonterminal lookaheads
        // (equivalent to not being shift-blocked)
        std::cerr << "*** transitions ***" << std::endl;
        m_reduce_transitions_were_performed_ = false;
        if (!m_is_shift_blocked_)
            PerformReduceTransitions_();
        // we can only ever schedule shift transitions if no reduce transitions were
        // scheduled, because we want to keep all branches' lookahead reading in sync.
        if (!m_reduce_transitions_were_performed_)
        {
            // if we are currently shift-blocked, only schedule shift transitions for
            // branches which have a nonterminal lookahead.  during shift-transition
            // scheduling, if a branch has no transitions, it is scheduled to be pruned.
            PerformShiftTransitionsAndSaveReturnActions_();
            m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
            // if no transitions were scheduled at all (reduce OR shift), then we must
            // either return or go into error-handling mode.
            if (m_dead_branch_list_.size() == m_branch_set_.size())
            {
                // if there are no saved return actions, then go into error-recovery mode.
                if (!m_return_state_encountered_)
                {
                    assert(false && "error recovery mode not implemented yet");
                }
                // otherwise, execute saved return actions and return the single stack token
                else
                {
                    std::cerr << "executing saved return actions:";
                    for (ActionQueue_::iterator it = m_saved_return_action_queue_.begin(), it_end = m_saved_return_action_queue_.end();
                         it != it_end;
                         ++it)
                    {
                        Action_ const &action = *it;
                        switch (action.m_action_type_)
                        {
                            default: assert(false); break;

                            case ACTION_SHIFT_:
                                std::cerr << " shift,";
                                std::cout << " shift,";
                                break;

                            case ACTION_REDUCE_:
                                std::cerr << " reduce " << action.m_reduction_rule_->m_description_ << ",";
                                std::cout << " reduce " << action.m_reduction_rule_->m_description_ << ",";
                                break;
                        }
                    }
                    std::cerr << std::endl;
                    std::cout << std::endl;
                    return PRC_SUCCESS;
                }
            }
            // otherwise, prune dead branches (branches which had no scheduled transitions).
            else
            {
                std::cerr << "*** pruning dead branches ***" << std::endl;
                PruneDeadBranches_();
                m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
            }
        }
        else
            m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
        // TODO: handle nonassoc errors -- should this be
        // detected before PerformScheduledTransitions_ ?
        assert(!m_nonassoc_error_encountered_ && "nonassoc error handling not implemented yet");
        m_nonassoc_error_encountered_ = false;
        // Because the action tree represents all possible valid parses of the input
        // read so far, the "trunk" of the tree represents the actions which all of
        // the branches agree upon.  therefore, there is no reason not to execute said
        // actions now.  execute said actions (ignoring e-closure nodes), and then
        // remove the trunk.
        std::cerr << "*** execute trunk ***" << std::endl;
        ExecuteAndRemoveTrunk_();
        m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
    }

    return parser_return_code_;
}

<{class_name}::Token_ &<{class_name}::ShiftLookaheadToken_ ()
{
    assert(m_lookahead_queue_cursor_ <= m_lookahead_queue_.size());
    if (m_lookahead_queue_cursor_ == m_lookahead_queue_.size())
        m_lookahead_queue_.push_back(Scan());
    return m_lookahead_queue_[m_lookahead_queue_cursor_++];
}

void <{class_name}::PerformEpsilonClosure_ ()
{
    // perform epsilon closure on the top stack states
    // of all non-epsilon-closed branches.
    std::vector<State_ const *> extra_state_stack;
    for (BranchSet_::iterator it = m_branch_set_.begin(), it_end = m_branch_set_.end(); it != it_end; ++it)
    {
        BranchTreeNode_ *branch = *it;
        assert(branch != NULL);
        if (!branch->m_is_epsilon_closed_)
        {
            branch->m_is_epsilon_closed_ = true;
            assert(extra_state_stack.empty());
            PerformEpsilonClosure_(*branch, extra_state_stack);
            assert(extra_state_stack.empty());
        }
    }
}

void <{class_name}::PerformEpsilonClosure_ (BranchTreeNode_ const &source_branch, StateStack_ &extra_state_stack)
{
    // iterate through the transitions from the top state of the branch,
    // recursively epsilon-closing epsilon transitions.  also, remember
    // if we have encountered a non-epsilon transition; this indicates
    // that a branch should be cloned and added here.
    bool non_epsilon_transition_encountered = false;
    for (Transition_ const *transition = (extra_state_stack.empty() ? source_branch.Top_().m_transition_table_ : extra_state_stack.back()->m_transition_table_),
                           *transition_end = transition + (extra_state_stack.empty() ? source_branch.Top_().m_transition_count_ : extra_state_stack.back()->m_transition_count_);
         transition != transition_end;
         ++transition)
    {
        if (transition->m_transition_type_ == Transition_::TT_EPSILON_)
        {
            extra_state_stack.push_back(transition->m_target_state_);
            PerformEpsilonClosure_(source_branch, extra_state_stack);
            extra_state_stack.pop_back();
        }
        else
            non_epsilon_transition_encountered = true;
    }

    // we don't clone the source branch if the extra state stack is empty
    // because it would be identical to the source branch which is already
    // contained in m_branch_set_.
    if (!extra_state_stack.empty() && non_epsilon_transition_encountered)
    {
        // create all necessary e-closure ancestor nodes for the closed branch.
        // e-closure nodes are NOT created when the epsilon transition occurs
        // within a single nonterminal's rules.  this single characteristic is
        // what allows nonterminal-scope precedence to work.
        ActionTreeNode_ *parent = source_branch.m_parent_;
        Rule_ const *previous_rule = source_branch.Top_().m_associated_rule_;
        Rule_ const *most_recent_rule = source_branch.Top_().m_associated_rule_;
        assert(previous_rule == NULL || previous_rule->m_precedence_ != NULL);
        TrisonCpp_::Uint32_ previously_encountered_precedence_level = previous_rule != NULL ? previous_rule->m_precedence_->m_level_ : 0; // default precedence
        TrisonCpp_::Uint32_ most_recently_encountered_precedence_level = previously_encountered_precedence_level;
        TokenId_ previous_nonterminal_token_id = source_branch.Top_().m_associated_nonterminal_token_id_;
        for (TrisonCpp_::Uint32_ i = 0; i < extra_state_stack.size(); ++i)
        {
            assert(parent != NULL);
            State_ const *next_e_closure_state = extra_state_stack[i];
            assert(next_e_closure_state != NULL);
            if (next_e_closure_state->m_associated_rule_ != NULL)
                most_recent_rule = next_e_closure_state->m_associated_rule_;
            if (next_e_closure_state->m_associated_rule_ != NULL)
                most_recently_encountered_precedence_level = next_e_closure_state->m_associated_rule_->m_precedence_->m_level_;
            TokenId_ most_recent_nonterminal_token_id = next_e_closure_state->m_associated_nonterminal_token_id_;

            // only add an e-closure node if the nonterminal or precedence level varies between the two states
            if (most_recent_nonterminal_token_id != previous_nonterminal_token_id ||
                most_recently_encountered_precedence_level != previously_encountered_precedence_level)
            {
                parent =
                    parent->EnsureChildExists_(
                        ACTION_NONE_,
                        most_recent_rule,
                        m_nonassoc_error_encountered_,
                        next_e_closure_state - ms_state_table_,
                        source_branch.m_rule_stack_level_ + i/2);
                assert(parent != NULL);
                // TODO: figure out if EnsureChildExists_ can fail here (i think it might not be able to fail)
                previous_nonterminal_token_id = most_recent_nonterminal_token_id;
            }

            previous_rule = most_recent_rule;
            previously_encountered_precedence_level = most_recently_encountered_precedence_level;
        }
        // clone the source branch, push the states contained in
        // extra_state_stack and then add it to m_branch_set_.
        BranchTreeNode_ *closed_branch = source_branch.Clone_();
        assert(closed_branch->m_parent_ == NULL);
        closed_branch->m_rule_stack_level_ = source_branch.m_rule_stack_level_ + extra_state_stack.size()/2;
        closed_branch->m_is_epsilon_closed_ = true;
        closed_branch->m_state_stack_.insert(closed_branch->m_state_stack_.end(), extra_state_stack.begin(), extra_state_stack.end());
        // this insertion does not affect the iteration being performed
        // in <{class_name}::PerformEpsilonClosure_() because existing
        // std::set iterators are unaffected by insert().
        m_branch_set_.insert(closed_branch);
        // finally add the e-closed branch to the appropriate node.
        parent->AddChild_(closed_branch);
    }
}

void <{class_name}::PerformReduceTransitions_ ()
{
    assert(!m_is_shift_blocked_);
    for (BranchSet_::iterator it = m_branch_set_.begin(), it_end = m_branch_set_.end(); it != it_end; ++it)
    {
        BranchTreeNode_ *branch = *it;
        assert(branch != NULL);
        assert(branch->m_lookahead_nonterminal_token_id_ == 0);
        assert(branch->m_scheduled_transition_count_ == 0);
        State_ const &state = branch->Top_();
        for (Transition_ const *transition = state.m_transition_table_,
                               *transition_end = transition + state.m_transition_count_;
             transition != transition_end;
             ++transition)
        {
            if (transition->m_transition_type_ == Transition_::TT_REDUCE_)
            {
                m_is_shift_blocked_ = true;
                m_reduce_transitions_were_performed_ = true;
                PerformReduceTransition_(branch, ms_rule_table_ + transition->m_transition_data_);
                break; // there can be only one reduce-action per state
            }
        }
    }
}

void <{class_name}::PerformReduceTransition_ (BranchTreeNode_ *branch, Rule_ const *reduction_rule)
{
    assert(branch != NULL);
    assert(branch->m_lookahead_nonterminal_token_id_ == 0); // none_
    assert(reduction_rule >= ms_rule_table_ && reduction_rule < ms_rule_table_ + ms_rule_count_);
    assert(branch->m_state_stack_.size() > reduction_rule->m_token_count_ + 2);
    ActionTreeNode_ *parent_node = branch->m_parent_;
    assert(parent_node != NULL);
    parent_node->RemoveChild_(branch);
    branch->m_is_epsilon_closed_ = false;
    branch->m_state_stack_.resize(branch->m_state_stack_.size() - (reduction_rule->m_token_count_ + 2));
    branch->m_lookahead_nonterminal_token_id_ = reduction_rule->m_reduction_nonterminal_token_id_;
    ActionTreeNode_ *reduce_action_node =
        parent_node->EnsureChildExists_(
            ACTION_REDUCE_,
            reduction_rule,
            m_nonassoc_error_encountered_,
            0,
            branch->m_rule_stack_level_);
    assert(reduce_action_node != NULL);
    // TODO: can EnsureChildExists_ return NULL in this case?
    --branch->m_rule_stack_level_;
    // add the branch to the reduce-action node and complete it
    reduce_action_node->AddChild_(branch);

    std::cerr << __PRETTY_FUNCTION__ << " added child" << std::endl;
    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 1);
    std::cerr << __PRETTY_FUNCTION__ << " done" << std::endl;

    // it's ok for branches to be pruned here because it's impossible
    // for all branches to die (which would lead to error recovery).
    reduce_action_node->CompleteReduceAction_(m_branch_set_);

    std::cerr << __PRETTY_FUNCTION__ << " completed reduce action" << std::endl;
    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 1);
    std::cerr << __PRETTY_FUNCTION__ << " done" << std::endl;
}

void <{class_name}::PerformShiftTransitionsAndSaveReturnActions_ ()
{
    assert(!m_reduce_transitions_were_performed_);
    assert(m_dead_branch_list_.empty());

    Token_ dummy_lookahead_token;
    Token_ &lookahead_token = m_is_shift_blocked_ ? dummy_lookahead_token : ShiftLookaheadToken_();

    for (BranchSet_::iterator it = m_branch_set_.begin(), it_end = m_branch_set_.end(); it != it_end; ++it)
    {
        BranchTreeNode_ *branch = *it;
//         std::cerr << "branch: " << branch << std::endl;
        assert(branch != NULL);
        assert(m_is_shift_blocked_ || branch->m_lookahead_nonterminal_token_id_ == 0);
        // if we're shift-blocked, then we only want to transition those
        // branches that have a lookahead nonterminal token.
        if (m_is_shift_blocked_ && branch->m_lookahead_nonterminal_token_id_ == 0)
            continue;
        assert(branch->m_scheduled_transition_count_ == 0);
        State_ const &state = branch->Top_();
        bool a_shift_transition_was_performed = false;
        for (Transition_ const *transition = state.m_transition_table_,
                               *transition_end = transition + state.m_transition_count_;
             transition != transition_end;
             ++transition)
        {
            // if we're shift-blocked, only schedule shift-transitions for branches with
            // nonterminal lookaheads, otherwise schedule any valid shift-transition.
            if (m_is_shift_blocked_ &&
                branch->m_lookahead_nonterminal_token_id_ != 0 &&
                TransitionAcceptsTokenId_(transition, branch->m_lookahead_nonterminal_token_id_)
                ||
                !m_is_shift_blocked_ &&
                TransitionAcceptsTokenId_(transition, lookahead_token.m_token_id_))
            {
                PerformShiftTransition_(branch, transition->m_target_state_);
                a_shift_transition_was_performed = true;
                break; // there can be only one shift transition per state
            }
            else if (transition->m_transition_type_ == Transition_::TT_RETURN_)
            {
                SaveReturnActions_(branch);
                break; // there can be only one return transition per state
            }
        }
        if (!a_shift_transition_was_performed)
        {
//             std::cerr << "dead branch: " << branch << std::endl;
            m_dead_branch_list_.push_back(branch);
        }
    }
    m_is_shift_blocked_ = false;
}

void <{class_name}::PerformShiftTransition_ (BranchTreeNode_ *branch, State_ const *target_state)
{
    assert(branch != NULL);
    assert(target_state >= ms_state_table_ && target_state < ms_state_table_ + ms_state_count_);
    ActionTreeNode_ *parent_node = branch->m_parent_;
    assert(parent_node != NULL);
    branch->m_is_epsilon_closed_ = false;
    branch->m_state_stack_.push_back(target_state);
    branch->m_lookahead_nonterminal_token_id_ = 0; // none_
    ActionTreeNode_ *shift_action_node =
        parent_node->EnsureChildExists_(
            ACTION_SHIFT_,
            target_state->m_associated_rule_,
            m_nonassoc_error_encountered_,
            0,
            branch->m_rule_stack_level_);
    if (shift_action_node != NULL)
    {
        parent_node->RemoveChild_(branch);
        shift_action_node->AddChild_(branch);
    }
    else
        m_dead_branch_list_.push_back(branch);

//     std::cerr << __PRETTY_FUNCTION__ << " added child" << std::endl;
//     m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 1);
//     std::cerr << __PRETTY_FUNCTION__ << " done" << std::endl;
}

void <{class_name}::SaveReturnActions_ (BranchTreeNode_ *branch)
{
    assert(branch != NULL);
    assert(branch->m_parent_ != NULL);
    m_saved_return_action_queue_.clear();
    ActionTreeNode_ *node = branch->m_parent_;
    while (node != NULL)
    {
        Rule_ const *reduction_rule = NULL;
        if (node->m_action_type_ == ACTION_REDUCE_)
            reduction_rule = node->m_associated_rule_;
        if (node->m_action_type_ != ACTION_NONE_)
            m_saved_return_action_queue_.push_front(Action_(node->m_action_type_, reduction_rule));
        node = node->m_parent_;
    }
    m_return_state_encountered_ = true;
}

void <{class_name}::PruneDeadBranches_ ()
{
    // NOTE: there can't be any pruning when un-shift-blocking because there's
    // no way for a branch with a lookahead nonterminal to fail to shift it.
    for (BranchVector_::iterator it = m_dead_branch_list_.begin(), it_end = m_dead_branch_list_.end();
         it != it_end;
         ++it)
    {
        BranchTreeNode_ *branch = *it;
        assert(branch != NULL);
        m_branch_set_.erase(branch);
        delete branch;
    }
    m_dead_branch_list_.clear();
}

void <{class_name}::ExecuteAndRemoveTrunk_ ()
{
    std::cerr << "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ executing actions:";
    while (true)
    {
        assert(m_tree_root_ != NULL);
        assert(m_tree_root_->m_parent_ == NULL);

        switch (m_tree_root_->m_action_type_)
        {
            case ACTION_SHIFT_:
                std::cerr << " shift,";
                std::cout << " shift,";
                // pop redundant actions from the saved return action queue
                // TODO: assert that the popped action is identical to the one being executed
                if (!m_saved_return_action_queue_.empty())
                    m_saved_return_action_queue_.pop_front();
                break;

            case ACTION_REDUCE_:
                assert(m_tree_root_->m_associated_rule_ != NULL);
                std::cerr << " reduce " << m_tree_root_->m_associated_rule_->m_description_ << ',';
                std::cout << " reduce " << m_tree_root_->m_associated_rule_->m_description_ << ',';
                // pop redundant actions from the saved return action queue
                // TODO: assert that the popped action is identical to the one being executed
                if (!m_saved_return_action_queue_.empty())
                    m_saved_return_action_queue_.pop_front();
                break;

            case ACTION_NONE_:
                break;

            default:
                assert(false);
                break;
        }

        if (m_tree_root_->m_child_set_.size() == 1 && (*m_tree_root_->m_child_set_.begin())->IsActionTreeNode_())
        {
            ActionTreeNode_ *next_trunk_node = static_cast<ActionTreeNode_ *>(*m_tree_root_->m_child_set_.begin());
            assert(next_trunk_node != NULL);
            m_tree_root_->RemoveChild_(next_trunk_node);
            delete m_tree_root_;
            m_tree_root_ = next_trunk_node;
        }
        else
        {
            m_tree_root_->m_rule_stack_level_ = 0;
            m_tree_root_->m_action_type_ = ACTION_NONE_;
            m_tree_root_->m_associated_rule_ = NULL;
            m_tree_root_->m_is_completed_ = false;
            break;
        }
    }
    std::cerr << std::endl;
}

<*{loop(i, _rule_count)
<{class_name}::TokenData_ <{class_name}::AcceptHandler<{i}_ ()
{
<*{_accept_handler_code[i]
}

<*{end_loop
TrisonCpp_::Npda_::Precedence_ const <{class_name}::ms_precedence_table_[] =
{
<*{loop(i, sizeof(_npda_precedence_level))
    { <*{
<{_npda_precedence_level[i]}<*{", "
TrisonCpp_::Npda_::ASSOCIATIVITY_<{_npda_precedence_associativity_name[i]}_<*{", "
"<{_npda_precedence_name[i]}"<*{
 }<{if(i+1 < sizeof(_npda_precedence_level))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_precedence_count_ = sizeof(<{class_name}::ms_precedence_table_) / sizeof(TrisonCpp_::Npda_::Precedence_);

TrisonCpp_::Npda_::Rule_ const <{class_name}::ms_rule_table_[] =
{
<*{loop(i, sizeof(_npda_rule_reduction_nonterminal_index))
    { <*{
<{class_name}::Nonterminal::<{_npda_rule_reduction_nonterminal_name[i]}<*{", "
<{if(_npda_rule_precedence_index[i] < _npda_precedence_count)}ms_precedence_table_+<{_npda_rule_precedence_index[i]}<{else}NULL<{end_if}<*{", "
<{_npda_rule_token_count[i]}<*{", "
<*{_npda_rule_description[i]
 }<{if(i+1 < sizeof(_npda_rule_reduction_nonterminal_index))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_rule_count_ = sizeof(<{class_name}::ms_rule_table_) / sizeof(TrisonCpp_::Npda_::Rule_);

TrisonCpp_::Npda_::State_ const <{class_name}::ms_state_table_[] =
{
<*{loop(i, sizeof(_npda_node_rule_index))
    { <*{
<{if(_npda_node_rule_index[i] < _rule_count)}ms_rule_table_+<{_npda_node_rule_index[i]}<{else}NULL<{end_if}<*{", "
<{_npda_node_rule_stage[i]}<*{", "
<{class_name}::Nonterminal::<{_npda_node_nonterminal_name[i]}<*{", "
<{_npda_node_transition_count[i]}<*{", "
ms_transition_table_+<{_npda_node_transition_offset[i]}<*{", "
<*{_npda_node_description[i]
 }<{if(i+1 < sizeof(_npda_node_rule_index))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(TrisonCpp_::Npda_::State_);

TrisonCpp_::Npda_::Transition_ const <{class_name}::ms_transition_table_[] =
{
<*{loop(i, sizeof(_npda_transition_type_name))
    { <*{
TrisonCpp_::Npda_::Transition_::<{_npda_transition_type_name[i]}_<*{", "
<*{if(_npda_transition_type_name[i] == "TT_SHIFT")
<*{if(sizeof(_terminal_index_list) > 0 && _npda_transition_data_index[i] >= _terminal_index_list[0] && _npda_transition_data_index[i] <= _terminal_index_list[sizeof(_terminal_index_list)-1])
<{class_name}::Terminal::<*{
<*{else_if(sizeof(_nonterminal_index_list) > 0 && (_npda_transition_data_index[i] == 0 || _npda_transition_data_index[i] >= 256 && _npda_transition_data_index[i] <= _nonterminal_index_list[sizeof(_nonterminal_index_list)-1]))
<{class_name}::Nonterminal::<*{
<*{end_if
<*{_npda_transition_data_name[i]
<*{else
<*{_npda_transition_data_index[i]
<*{end_if
<*{", "
<{if(_npda_transition_target_node_index[i] < 0)}NULL<{else}ms_state_table_+<{_npda_transition_target_node_index[i]}<*{end_if
 }<{if(i+1 < sizeof(_npda_transition_type_name))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(TrisonCpp_::Npda_::Transition_);

enum
{
    TABLE_SIZE_ASSERTIONS_ =
        TrisonCpp_::Assert_<<{class_name}::ms_precedence_count_ == <{_npda_precedence_count}>::v &&
        TrisonCpp_::Assert_<<{class_name}::ms_rule_count_ == <{_rule_count}>::v &&
        TrisonCpp_::Assert_<<{class_name}::ms_state_count_ == <{_npda_node_count}>::v &&
        TrisonCpp_::Assert_<<{class_name}::ms_transition_count_ == <{_npda_transition_count}>::v
};
<*{if(is_defined(bottom_of_implementation_file))

<*{bottom_of_implementation_file
<*{end_if
