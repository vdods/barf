<*{if(header_filename == implementation_filename)
<*{error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison at <{_creation_timestamp}
// from <{_source_filename} using <{_langspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <algorithm>
#include <cassert>
#include <deque>
#include <iostream> // TEMP
#include <set>
#include <vector>

#if !defined(TrisonCpp_namespace_)
#define TrisonCpp_namespace_
namespace TrisonCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// a bunch of template metaprogramming to intelligently determine
// what type to use for an integer of the given bit width
// /////////////////////////////////////////////////////////////////////////////

template <bool condition_, typename Then_, typename Else_> struct If_;
template <typename Then_, typename Else_> struct If_<true,Then_,Else_> { typedef Then_ T; };
template <typename Then_, typename Else_> struct If_<false,Then_,Else_> { typedef Else_ T; };

template <bool condition_> struct Assert_;
template <> struct Assert_<true> { static bool const v = true; operator bool () { return v; } };

template <typename Sint_, typename Uint_> struct IntPair_ { typedef Sint_ S; typedef Uint_ U; };

template <int bits_> struct Integer_ {
    typedef
        typename If_<bits_ == 8*sizeof(char),      IntPair_<char,unsigned char>,
        typename If_<bits_ == 8*sizeof(short),     IntPair_<short,unsigned short>,
        typename If_<bits_ == 8*sizeof(int),       IntPair_<int,unsigned int>,
        typename If_<bits_ == 8*sizeof(long),      IntPair_<long,unsigned long>,
        typename If_<bits_ == 8*sizeof(long long), IntPair_<long long,unsigned long long>,
        Integer_<0> // if no match, cause a compile error
        >::T >::T >::T >::T >::T IntPair;
    typedef typename IntPair::S Signed;
    typedef typename IntPair::U Unsigned;
    static bool const assert_size =
        Assert_<bits_ == 8*sizeof(Signed) && bits_ == 8*sizeof(Unsigned)>::v;
};
template <> struct Integer_<0> { }; // empty for intentional compile errors

// /////////////////////////////////////////////////////////////////////////////
// typedefs for the integer types used in the "cpp" trison target
// /////////////////////////////////////////////////////////////////////////////

typedef Integer_<8> ::Signed   Sint8_;
typedef Integer_<8> ::Unsigned Uint8_;
typedef Integer_<16>::Signed   Sint16_;
typedef Integer_<16>::Unsigned Uint16_;
typedef Integer_<32>::Signed   Sint32_;
typedef Integer_<32>::Unsigned Uint32_;
typedef Integer_<8*sizeof(void*)>::Signed   Diff_;
typedef Integer_<8*sizeof(void*)>::Unsigned Size_;

enum
{
    TYPE_SIZE_ASSERTIONS_ =
        Assert_<sizeof(Sint8_) == 1>::v &&
        Assert_<sizeof(Uint8_) == 1>::v &&
        Assert_<sizeof(Sint16_) == 2>::v &&
        Assert_<sizeof(Uint16_) == 2>::v &&
        Assert_<sizeof(Sint32_) == 4>::v &&
        Assert_<sizeof(Uint32_) == 4>::v &&
        Assert_<sizeof(Diff_) == sizeof(void*)>::v &&
        Assert_<sizeof(Size_) == sizeof(void*)>::v
};

template <typename T>
class WeakReference
{
public:

    WeakReference () : m_instance(NULL) { }
    WeakReference (T *pointer) : m_instance(new Instance<T>(pointer)) { m_instance->IncrementReferenceCount(); }
    WeakReference (WeakReference<T> const &r) { m_instance = r.m_instance; if (m_instance != NULL) m_instance->IncrementReferenceCount(); }
    ~WeakReference () { if (m_instance != NULL) m_instance->DecrementReferenceCount(); }
    void operator = (WeakReference<T> const &r)
    {
        if (m_instance != NULL)
            m_instance->DecrementReferenceCount();
        m_instance = r.m_instance;
        if (m_instance != NULL)
            m_instance->IncrementReferenceCount();
    }

    T &operator * () { assert(m_instance != NULL); return **m_instance; }
    T const &operator * () const { assert(m_instance != NULL); return **m_instance; }

    T *operator -> () { assert(m_instance != NULL); return &**m_instance; }
    T const *operator -> () const { assert(m_instance != NULL); return &**m_instance; }

    bool IsValid () const { return m_instance != NULL; }
    void Release () { if (m_instance != NULL) { m_instance->DecrementReferenceCount(); m_instance = NULL; } }

    bool InstanceIsValid () const { assert(m_instance != NULL); return m_instance->IsValid(); }
    void ReleaseInstance () { assert(m_instance != NULL); m_instance->Release(); }
    Uint32_ ReferenceCount () const { assert(m_instance != NULL); return m_instance->ReferenceCount(); }

private:

    template <typename U>
    class Instance
    {
    public:

        Instance (U *pointer) : m_pointer(pointer), m_reference_count(0) { }
        ~Instance () { assert(m_reference_count == 0); }

        U &operator * () { assert(m_pointer != NULL && "dereferenced a NULL pointer"); return *m_pointer; }
        U const &operator * () const { assert(m_pointer != NULL && "dereferenced a NULL pointer"); return *m_pointer; }

        bool IsValid () const { return m_pointer != NULL; }
        void Release () { m_pointer = NULL; }
        Uint32_ ReferenceCount () const { return m_reference_count; }

        void IncrementReferenceCount () { assert(m_reference_count < Uint32_(-1)); ++m_reference_count; }
        void DecrementReferenceCount () { assert(m_reference_count > 0); if (--m_reference_count == 0) delete this; }

    private:

        Instance (Instance const &) { assert(false && "this should never be called"); }
        void operator = (Instance const &) { assert(false && "this should never be called"); }

        U *m_pointer;
        Uint32_ m_reference_count;
    }; // end of class TrisonCpp_::WeakReference<T>::Instance<U>

    Instance<T> *m_instance;
}; // end of class TrisonCpp_::WeakReference<T>

// TODO: enums should be in TrisonCpp_ namespace

enum BranchListType_ { BLT_PARSER_ = 0, BLT_ACTION_, BLT_COUNT_ };
enum ListNodeClassType_ { LNCT_FLOATY_ = 0|0, LNCT_HEAD_ = 0|1, LNCT_TAIL_ = 2|0, LNCT_BODY_ = 2|1 };

template <typename ListNodeSubclass_>
struct ListNode_
{
    ~ListNode_ ()
    {
        // remove this node from its list if it's a body
        if (NodeClass_() == LNCT_BODY_)
            Remove_();
        // now ensure this node is a floaty or it is a head or tail of an empty list
        assert(NodeClass_() == LNCT_FLOATY_ ||
               NodeClass_() == LNCT_HEAD_ && m_next_->NodeClass_() == LNCT_TAIL_ && m_next_->m_prev_ == this ||
               NodeClass_() == LNCT_TAIL_ && m_prev_->NodeClass_() == LNCT_HEAD_ && m_prev_->m_next_ == this);
    }

    ListNodeClassType_ NodeClass_ () const { return ListNodeClassType_((m_prev_ != NULL ? 2 : 0) | (m_next_ != NULL ? 1 : 0)); }
    ListNodeSubclass_ *Prev_ ()
    {
        assert(NodeClass_() != LNCT_HEAD_ && "can't call Prev_() on a head node");
        return m_prev_->NodeClass_() != LNCT_HEAD_ ? m_prev_ : NULL;
    }
    ListNodeSubclass_ const *Prev_ () const
    {
        assert(NodeClass_() != LNCT_HEAD_ && "can't call Prev_() on a head node");
        return m_prev_->NodeClass_() != LNCT_HEAD_ ? m_prev_ : NULL;
    }
    ListNodeSubclass_ *Next_ ()
    {
        assert(NodeClass_() != LNCT_TAIL_ && "can't call Next_() on a tail node");
        return m_next_->NodeClass_() != LNCT_TAIL_ ? m_next_ : NULL;
    }
    ListNodeSubclass_ const *Next_ () const
    {
        assert(NodeClass_() != LNCT_TAIL_ && "can't call Next_() on a tail node");
        return m_next_->NodeClass_() != LNCT_TAIL_ ? m_next_ : NULL;
    }

    void InsertPrev_ (ListNodeSubclass_ *node)
    {
        assert(node != NULL);
        assert(node->NodeClass_() == LNCT_FLOATY_ && "can't insert a node that is already in a list");
        assert(NodeClass_() == LNCT_BODY_ || NodeClass_() == LNCT_TAIL_ && "can't insert a node before the head or a floaty");
        m_prev_->m_next_ = node;
        node->m_prev_ = m_prev_;
        node->m_next_ = static_cast<ListNodeSubclass_ *>(this);
        m_prev_ = node;
    }
    void InsertNext_ (ListNodeSubclass_ *node)
    {
        assert(node != NULL);
        assert(node->NodeClass_() == LNCT_FLOATY_ && "can't insert a node that is already in a list");
        assert(NodeClass_() == LNCT_HEAD_ || NodeClass_() == LNCT_BODY_ && "can't insert a node after the tail or a floaty");
        m_next_->m_prev_ = node;
        node->m_next_ = m_next_;
        node->m_prev_ = static_cast<ListNodeSubclass_ *>(this);
        m_next_ = node;
    }
    ListNodeSubclass_ *Remove_ ()
    {
        assert(NodeClass_() == LNCT_BODY_);
        assert(m_prev_->m_next_ == this);
        assert(m_next_->m_prev_ == this);
        m_prev_->m_next_ = m_next_;
        m_next_->m_prev_ = m_prev_;
        m_next_ = NULL;
        m_prev_ = NULL;
        assert(NodeClass_() == LNCT_FLOATY_);
        return static_cast<ListNodeSubclass_ *>(this);
    }

protected:

    // the constructor is protected so the only way you can use this class is by inheritance.
    ListNode_ () : m_prev_(NULL), m_next_(NULL) { assert(NodeClass_() == LNCT_FLOATY_); }

private:

    ListNodeSubclass_ *m_prev_;
    ListNodeSubclass_ *m_next_;

    template <typename ElementType_> friend struct List_;
}; // end of struct TrisonCpp_::ListNode_<ListNodeSubclass_>

template <typename ElementType_>
struct List_
{
    List_ ()
    {
        assert(sizeof(m_head_) == 2*sizeof(void *)); // TODO: make into compile-time asserts
        assert(sizeof(m_tail_) == 2*sizeof(void *));
        // these two casts are technically unsafe, but we'll be responsible.
        m_head_.m_next_ = static_cast<ElementType_ *>(&m_tail_);
        m_tail_.m_prev_ = static_cast<ElementType_ *>(&m_head_);
        assert(m_head_.NodeClass_() == LNCT_HEAD_);
        assert(m_tail_.NodeClass_() == LNCT_TAIL_);
    }
    ~List_ () { assert(IsEmpty_() && "list not empty upon destruction"); }

    bool IsEmpty_ () const
    {
        assert(m_head_.NodeClass_() == LNCT_HEAD_);
        assert(m_tail_.NodeClass_() == LNCT_TAIL_);
        return m_head_.m_next_ == &m_tail_;
    }
    ElementType_ *Front_ () { return m_head_.Next_(); }
    ElementType_ const *Front_ () const { return m_head_.Next_(); }
    ElementType_ *Back_ () { return m_tail_.Prev_(); }
    ElementType_ const *Back_ () const { return m_tail_.Prev_(); }

    void InsertFront_ (ElementType_ *node) { m_head_.InsertNext_(node); }
    void InsertBack_ (ElementType_ *node) { m_tail_.InsertPrev_(node); }
    ElementType_ *RemoveFront_ () { assert(Front_() != NULL && "can't remove from an empty list"); return Front_()->Remove_(); }
    ElementType_ *RemoveBack_ () { assert(Back_() != NULL && "can't remove from an empty list"); return Back_()->Remove_(); }

private:

    ListNode_<ElementType_> m_head_;
    ListNode_<ElementType_> m_tail_;
}; // end of struct TrisonCpp_::List_<ElementType_>

class Npda_
{
protected:


    struct Action_;
    struct ActionBranch_ : public ListNode_<ActionBranch_> { protected: ActionBranch_ () { } };
    struct ParserBranch_ : public ListNode_<ParserBranch_> { protected: ParserBranch_ () { } };
    struct Reduce_;
    struct Rule_;
    struct Shift_;
    struct State_;
    struct Transition_;

    typedef std::vector<State_ const *> StateStack_;
    typedef Uint32_ TokenId_;

    enum Associativity_
    {
        ASSOCIATIVITY_LEFT_ = 0,
        ASSOCIATIVITY_NONASSOC_,
        ASSOCIATIVITY_RIGHT_
    }; // end of enum TrisonCpp_::Npda_::Associativity_
    struct Precedence_
    {
        Uint32_ m_level_;
        Associativity_ m_associativity_;
        char const *m_name_;
    }; // end of struct TrisonCpp_::Npda_::Precedence_
    struct Rule_
    {
        TokenId_ m_reduction_nonterminal_token_id_;
        Precedence_ const *m_precedence_;
        Uint32_ m_token_count_;
        char const *m_description_;

        static bool IsHigherPriority (Rule_ const &left, Rule_ const &right)
        {
            // order by higher precedence, and then lower rule index
            return left.m_precedence_->m_level_ > right.m_precedence_->m_level_
                   ||
                   left.m_precedence_->m_level_ == right.m_precedence_->m_level_ &&
                   &left < &right;
        }
    }; // end of struct TrisonCpp_::Npda_::Rule_
    struct State_
    {
        Rule_ const *m_associated_rule_;
        Uint32_ m_associated_rule_stage_;
        TokenId_ m_associated_nonterminal_token_id_;
        Size_ m_transition_count_;
        Transition_ const *m_transition_table_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::State_
    struct Transition_
    {
        enum Type_ { TT_EPSILON_ = 0, TT_REDUCE_, TT_RETURN_, TT_SHIFT_ };
        Uint8_ m_transition_type_;
        Uint32_ m_transition_data_;
        State_ const *m_target_state_;
    }; // end of struct TrisonCpp_::Npda_::Transition_
    /*
    struct ShiftActionTreeNodeRulePair_
    {
        Shift_ &m_shift_action_tree_node_;
        Rule_ const &m_rule_;

        ShiftActionTreeNodeRulePair_ (Shift_ *shift_action_tree_node, Rule_ const *rule)
            :
            m_shift_action_tree_node_(assert(shift_action_tree_node != NULL), *shift_action_tree_node),
            m_rule_(assert(rule != NULL), *rule)
        { }

        static bool IsLessThan (ActionTreeNodeRulePair_ const &left, ActionTreeNodeRulePair_ const &right)
        {
            // order by higher precedence, then lower rule index
            return left.m_rule_.m_precedence_->m_level_ > right.m_rule_.m_precedence_->m_level_
                   ||
                   left.m_rule_.m_precedence_->m_level_ == right.m_rule_.m_precedence_->m_level_ &&
                   &left.m_rule_ < &right.m_rule_;
        }
    }; // end of struct TrisonCpp_::Npda_::ActionTreeNodeRulePair_
    */
    struct TreeNode_
    {
        // TODO: make non-public
        enum TreeNodeType_ { ROOT_TREE_NODE_ = 0, BRANCH_TREE_NODE_, REDUCE_ACTION_TREE_NODE_, SHIFT_ACTION_TREE_NODE_ };
        TreeNodeType_ const m_tree_node_type_;
        Action_ *m_parent_;

        TreeNode_ (TreeNodeType_ tree_node_type)
            :
            m_tree_node_type_(tree_node_type),
            m_parent_(NULL)
        { }
    }; // end of struct TrisonCpp_::Npda_::TreeNode_
    struct Branch_ : public TreeNode_, public ActionBranch_, public ParserBranch_
    {
//         typedef std::list<WeakReference<ShiftActionTreeNodeRulePair_> > ConflictReferenceList_;
//         ConflictReferenceList_ m_conflict_reference_list_;
        StateStack_ m_state_stack_;
        TokenId_ m_lookahead_nonterminal_token_id_;
        bool m_is_epsilon_closed_;

        Branch_ (State_ const *starting_state)
            :
            TreeNode_(BRANCH_TREE_NODE_),
            m_lookahead_nonterminal_token_id_(0), // none_
            m_is_epsilon_closed_(false)
        {
            assert(starting_state != NULL);
            m_state_stack_.push_back(starting_state);
        }
        ~Branch_ ()
        {
            // delete the action tree down to the root or the first fork
            TreeNode_ *node = this;
            Action_ *parent = node->m_parent_;
            do
            {
                if (parent != NULL)
                {
                    parent->RemoveChild_(node);
                    assert(node->m_parent_ == NULL);
                }
                if (node != this) // we don't want to recurse
                    delete node;  // into this object's destructor
                node = parent;
                parent = node != NULL ? node->m_parent_ : NULL;
            }
            while (parent != NULL && parent->SingleChild_() == node);
        }

        State_ const &Top_ () const
        {
            assert(!m_state_stack_.empty());
            assert(m_state_stack_.back() != NULL);
            return *m_state_stack_.back();
        }
        Branch_ *Clone_ () const
        {
            Branch_ *cloned = new Branch_(m_state_stack_, m_lookahead_nonterminal_token_id_);
            assert(cloned->m_parent_ == NULL);
            assert(cloned->ParserBranch_::NodeClass_() == LNCT_FLOATY_);
            assert(cloned->ActionBranch_::NodeClass_() == LNCT_FLOATY_);
            return cloned;
        }
        void RemoveFromBranchList_ (BranchListType_ branch_list_type)
        {
            assert(branch_list_type == BLT_PARSER_ || branch_list_type == BLT_ACTION_);
            if (branch_list_type == BLT_PARSER_)
                ParserBranch_::Remove_();
            else // branch_list_type == BLT_ACTION_
                ActionBranch_::Remove_();
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << (m_is_epsilon_closed_ ? 'c' : '_');
            for (StateStack_::const_iterator it = m_state_stack_.begin(), it_end = m_state_stack_.end();
                 it != it_end;
                 ++it)
            {
                State_ const *stack_state = *it;
                assert(stack_state != NULL);
                stream << ' ' << (stack_state - state_table);
            }
            if (m_lookahead_nonterminal_token_id_ != 0) // none_
                stream << " (" << m_lookahead_nonterminal_token_id_ << ')';
            stream << ' ' << this << std::endl;
        }

    private:

        // for use only by Clone_()
        Branch_ (StateStack_ const &state_stack, TokenId_ lookahead_nonterminal_token_id)
            :
            TreeNode_(BRANCH_TREE_NODE_),
            m_state_stack_(state_stack),
            m_lookahead_nonterminal_token_id_(lookahead_nonterminal_token_id),
            m_is_epsilon_closed_(false)
        {
            assert(!m_state_stack_.empty());
        }
    }; // end of struct TrisonCpp_::Npda_::Branch_
    struct ActionBranchList_ : public List_<ActionBranch_>
    {
        void InsertFront_ (Branch_ *node) { List_<ActionBranch_>::InsertFront_(static_cast<ActionBranch_ *>(node)); }
        void InsertBack_ (Branch_ *node) { List_<ActionBranch_>::InsertBack_(static_cast<ActionBranch_ *>(node)); }
    }; // end of struct TrisonCpp_::Npda_::ActionBranchList_
    struct ParserBranchList_ : public List_<ParserBranch_>
    {
        void InsertFront_ (Branch_ *node) { List_<ParserBranch_>::InsertFront_(static_cast<ParserBranch_ *>(node)); }
        void InsertBack_ (Branch_ *node) { List_<ParserBranch_>::InsertBack_(static_cast<ParserBranch_ *>(node)); }
    }; // end of struct TrisonCpp_::Npda_::ParserBranchList_
    struct Action_ : public TreeNode_
    {
        // TODO: make non-public
        // there can only ever be up to 2 children, one of each type.
        Reduce_ *m_reduce_child_;
        Shift_ *m_shift_child_;
        ActionBranchList_ m_action_branch_list_;

        Action_ (TreeNodeType_ tree_node_type)
            :
            TreeNode_(tree_node_type),
            m_reduce_child_(NULL),
            m_shift_child_(NULL)
        { }
        ~Action_ ()
        {
            // delete this and all children out to the leaves
            if (m_parent_ != NULL)
                m_parent_->RemoveChild_(this);

            delete m_reduce_child_;
            delete m_shift_child_;

            ActionBranch_ *action_branch;
            while ((action_branch = m_action_branch_list_.Front_()) != NULL)
            {
                Branch_ *branch = static_cast<Branch_ *>(static_cast<ActionBranch_ *>(action_branch));
                branch->m_parent_ = NULL; // to stop ~Branch_() from interfering
                delete branch;
                assert(m_action_branch_list_.Front_() != action_branch);
            }
        }

        TreeNode_ const *SingleChild_ () const
        {
            if (m_reduce_child_ != NULL && m_shift_child_ == NULL && m_action_branch_list_.IsEmpty_())
                return m_reduce_child_;
            else if (m_reduce_child_ == NULL && m_shift_child_ != NULL && m_action_branch_list_.IsEmpty_())
                return m_shift_child_;
            else if (m_reduce_child_ == NULL && m_shift_child_ == NULL && !m_action_branch_list_.IsEmpty_() && m_action_branch_list_.Front_() == m_action_branch_list_.Back_())
                return static_cast<Branch_ const *>(m_action_branch_list_.Front_());
            else
                return NULL;
        }
        bool ReduceActionWouldSucceed_ (Rule_ const *reduction_rule) const
        {
            assert(reduction_rule != NULL);
            assert(m_shift_child_ == NULL && "this should never happen");
            return m_reduce_child_ == NULL || Rule_::IsHigherPriority(*reduction_rule, *m_reduce_child_->m_reduction_rule_);
        }

        void AddChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == NULL);
            switch (child->m_tree_node_type_)
            {
                default:
                case ROOT_TREE_NODE_         : assert(false && "this should never happen"); break;
                case BRANCH_TREE_NODE_       : m_action_branch_list_.InsertBack_(static_cast<Branch_ *>(child)); break;
                case REDUCE_ACTION_TREE_NODE_: assert(m_reduce_child_ == NULL); m_reduce_child_ = static_cast<Reduce_ *>(child); break;
                case SHIFT_ACTION_TREE_NODE_ : assert(m_shift_child_ == NULL); m_shift_child_ = static_cast<Shift_ *>(child); break;
            }
            child->m_parent_ = this;
        }
        void RemoveChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == this);
            switch (child->m_tree_node_type_)
            {
                default:
                case ROOT_TREE_NODE_         : assert(false && "this should never happen"); break;
                case BRANCH_TREE_NODE_       : static_cast<Branch_ *>(child)->RemoveFromBranchList_(BLT_ACTION_); break;
                case REDUCE_ACTION_TREE_NODE_: assert(child == m_reduce_child_); m_reduce_child_ = NULL; break;
                case SHIFT_ACTION_TREE_NODE_ : assert(child == m_shift_child_); m_shift_child_ = NULL; break;
            }
            child->m_parent_ = NULL;
            // TODO: conflict resolution checking time!
        }
        void SetReduce_ (Branch_ *reduced_branch, Rule_ const *reduction_rule)
        {
            assert(reduced_branch != NULL);
            assert(reduction_rule != NULL);
            assert(ReduceActionWouldSucceed_(reduction_rule) && "nice try, jerk");
            // if we have a reduce child (which will necessary be overridden
            // by the incoming reduce action), delete it, causing all its
            // children out to the leaves (branches) to be deleted.
            delete m_reduce_child_;
            // add the new reduce child and add the branch to it
            m_reduce_child_ = new Reduce_(reduction_rule);
            m_reduce_child_->AddChild_(reduced_branch);
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            assert(m_tree_node_type_ == ROOT_TREE_NODE_);
            stream << std::string(2*indent_level, ' ') << "root " << this << std::endl;
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }
        void PrintChildNodes_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            for (ActionBranch_ const *action_branch = m_action_branch_list_.Front_(); action_branch != NULL; action_branch = action_branch->Next_())
                static_cast<Branch_ const *>(action_branch)->Print_(stream, rule_table, state_table, indent_level);
            if (m_reduce_child_ != NULL)
                m_reduce_child_->Print_(stream, rule_table, state_table, indent_level);
            if (m_shift_child_ != NULL)
                m_shift_child_->Print_(stream, rule_table, state_table, indent_level);
        }
    }; // end of struct TrisonCpp_::Npda_::Action_
    struct Reduce_ : public Action_
    {
        Rule_ const *m_reduction_rule_;

        Reduce_ (Rule_ const *reduction_rule)
            :
            Action_(REDUCE_ACTION_TREE_NODE_),
            m_reduction_rule_(reduction_rule)
        {
            assert(m_reduction_rule_ != NULL);
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << "reduce " << this << " \"" << m_reduction_rule_->m_description_ << '\"' << std::endl;
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }
    }; // end of struct TrisonCpp_::Npda_::Reduce_
    struct Shift_ : public Action_
    {
//         typedef std::list<WeakReference> RefCountList_;
//         RefCountList_ m_ref_count_list_;

        Shift_ () : Action_(SHIFT_ACTION_TREE_NODE_) { }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << "shift " << this << std::endl;
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }
    }; // end of struct TrisonCpp_::Npda_::Shift_
}; // end of class TrisonCpp_::Npda_

} // end of namespace TrisonCpp_
#endif // !defined(TrisonCpp_namespace_)
<*{if(is_defined(top_of_header_file))

<*{top_of_header_file
<*{end_if

class <{class_name} : private TrisonCpp_::Npda_<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    typedef <{token_data_type} TokenData_;

    enum ParserReturnCode
    {
        PRC_SUCCESS = 0,
        PRC_UNHANDLED_PARSE_ERROR = 1
    }; // end of enum <{class_name}::ParserReturnCode

    struct Terminal
    {
        enum Name
        {
<*{if(sizeof(_terminal_name_list) < 1)
<*{error("the terminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<*{error("mismatch in size of _terminal_name_list and _terminal_index_list")
<*{end_if
<*{loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    struct Nonterminal
    {
        enum Name
        {
<*{if(sizeof(_nonterminal_name_list) < 1)
<*{error("the nonterminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<*{error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<*{end_if
<*{loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    struct StartNonterminal
    {
        enum Name
        {
<*{for_each(key, _npda_initial_node_index)
            <{key} = <{_npda_initial_node_index[key]},
<*{end_for_each
            // default starting nonterminal
            START_ = <{_start}
        }; // end of enum <{class_name}::StartNonterminal::Name
    }; // end of struct <{class_name}::StartNonterminal

    struct Token_
    {
        TokenId_ m_token_id_;
        TokenData_ m_token_data_;

        Token_ () : m_token_id_(Nonterminal::none_) { }
        Token_ (TokenId_ token_id, TokenData_ const &token_data)
            :
            m_token_id_(token_id),
            m_token_data_(token_data)
        {
            assert(m_token_id_ != Nonterminal::none_);
        }
    }; // end of struct <{class_name}::Token

private:

    typedef std::deque<Token_> TokenBuffer_;

<*{if(is_defined(top_of_class))
public:

<*{top_of_class

<*{end_if
public:

    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<*{if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<*{end_if
<*{if(is_defined(parse_method_access))
<*{if(!(parse_method_access == "public:" || parse_method_access == "protected:" || parse_method_access == "private:"))
<*{error("invalid parse_method_access \"" . parse_method_access . "\"")
<*{end_if
<{parse_method_access}

<*{end_if
    ParserReturnCode Parse (StartNonterminal::Name nonterminal_to_parse_ = StartNonterminal::<{_start});

private:

    static bool TransitionAcceptsTokenId_ (Transition_ const *transition, TokenId_ token_id)
    {
        assert(transition >= ms_transition_table_ && transition < ms_transition_table_ + ms_transition_count_);
        return transition->m_transition_type_ == Transition_::TT_SHIFT_ &&
               transition->m_transition_data_ == token_id;
    }

/*
    void ClearBranches_ ();
    void ClearTokenStack_ ();
    void ClearLookaheadQueue_ ();
    void ClearMostRecentReturnState_ ();
    void ClearReturnToken_ ();
*/
    void ThrowAwayToken_ (TokenData_ &token);
    void ResetForNewInput_ ();


    // blah
    ParserReturnCode Parse_ (StartNonterminal::Name nonterminal_to_parse_);
    Token_ &ShiftLookaheadToken_ ();
    void PerformEpsilonClosure_ ();
    void PerformEpsilonClosure_ (Branch_ const &source_branch, StateStack_ &extra_state_stack);
    void PerformReduceTransitions_ ();
    void PerformReduceTransition_ (Branch_ const &source_branch, Rule_ const *reduction_rule);
//     void PerformShiftTransitionsAndSaveReturnActions_ ();
//     void PerformShiftTransition_ (Branch_ *branch, State_ const *target_state);
//     void SaveReturnActions_ (Branch_ *branch);
//     void PruneAllDoomedBranches_ ();
//     void PruneNonReturnStateDoomedBranches_ ();
//     void ExecuteAndRemoveTrunk_ ();
    // end blah



<*{loop(i, _rule_count)
    TokenData_ AcceptHandler<{i}_ ();
<*{end_loop

    // TODO: move as much stuff to the base class as possible
    Action_ *m_tree_root_;
    ParserBranchList_ m_parser_branch_list_;
    bool m_is_shift_blocked_;
    bool m_reduce_transitions_were_performed_;
    bool m_shift_transitions_were_performed_;
    bool m_nonassoc_error_encountered_;
    bool m_there_are_doomed_branches_at_a_return_state_;
//     BranchVector_ m_doomed_branch_list_;
    TokenBuffer_ m_token_stack_;
    TokenBuffer_ m_lookahead_queue_; // TODO: make the lookahead queue into its own class/object so it's a separate API
    TokenBuffer_::size_type m_lookahead_queue_cursor_;
<*{if(is_defined(generate_debug_spew_code))
    bool m_debug_spew_;

<*{end_if
    static TrisonCpp_::Npda_::Precedence_ const ms_precedence_table_[];
    static TrisonCpp_::Size_ const ms_precedence_count_;
    static TrisonCpp_::Npda_::Rule_ const ms_rule_table_[];
    static TrisonCpp_::Size_ const ms_rule_count_;
    static TrisonCpp_::Npda_::State_ const ms_state_table_[];
    static TrisonCpp_::Size_ const ms_state_count_;
    static TrisonCpp_::Npda_::Transition_ const ms_transition_table_[];
    static TrisonCpp_::Size_ const ms_transition_count_;
<*{if(is_defined(bottom_of_class))

public:
<{bottom_of_class}
<*{end_if
}; // end of class <{class_name}
<*{if(is_defined(bottom_of_header_file))

<*{bottom_of_header_file
<*{end_if
