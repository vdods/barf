<*{if(header_filename == implementation_filename)
<*{error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison at <{_creation_timestamp}
// from <{_source_filename} using <{_langspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <algorithm>
#include <cassert>
#include <deque>
#include <iostream> // TEMP
#include <set>
#include <vector>

#if !defined(TrisonCpp_namespace_)
#define TrisonCpp_namespace_
namespace TrisonCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// a bunch of template metaprogramming to intelligently determine
// what type to use for an integer of the given bit width
// /////////////////////////////////////////////////////////////////////////////

template <bool condition_, typename Then_, typename Else_> struct If_;
template <typename Then_, typename Else_> struct If_<true,Then_,Else_> { typedef Then_ T; };
template <typename Then_, typename Else_> struct If_<false,Then_,Else_> { typedef Else_ T; };

template <bool condition_> struct Assert_;
template <> struct Assert_<true> { static bool const v = true; operator bool () { return v; } };

template <typename Sint_, typename Uint_> struct IntPair_ { typedef Sint_ S; typedef Uint_ U; };

template <int bits_> struct Integer_ {
    typedef
        typename If_<bits_ == 8*sizeof(char),      IntPair_<char,unsigned char>,
        typename If_<bits_ == 8*sizeof(short),     IntPair_<short,unsigned short>,
        typename If_<bits_ == 8*sizeof(int),       IntPair_<int,unsigned int>,
        typename If_<bits_ == 8*sizeof(long),      IntPair_<long,unsigned long>,
        typename If_<bits_ == 8*sizeof(long long), IntPair_<long long,unsigned long long>,
        Integer_<0> // if no match, cause a compile error
        >::T >::T >::T >::T >::T IntPair;
    typedef typename IntPair::S Signed;
    typedef typename IntPair::U Unsigned;
    static bool const assert_size =
        Assert_<bits_ == 8*sizeof(Signed) && bits_ == 8*sizeof(Unsigned)>::v;
};
template <> struct Integer_<0> { }; // empty for intentional compile errors

// /////////////////////////////////////////////////////////////////////////////
// typedefs for the integer types used in the "cpp" trison target
// /////////////////////////////////////////////////////////////////////////////

typedef Integer_<8> ::Signed   Sint8_;
typedef Integer_<8> ::Unsigned Uint8_;
typedef Integer_<16>::Signed   Sint16_;
typedef Integer_<16>::Unsigned Uint16_;
typedef Integer_<32>::Signed   Sint32_;
typedef Integer_<32>::Unsigned Uint32_;
typedef Integer_<8*sizeof(void*)>::Signed   Diff_;
typedef Integer_<8*sizeof(void*)>::Unsigned Size_;

enum
{
    TYPE_SIZE_ASSERTIONS_ =
        Assert_<sizeof(Sint8_) == 1>::v &&
        Assert_<sizeof(Uint8_) == 1>::v &&
        Assert_<sizeof(Sint16_) == 2>::v &&
        Assert_<sizeof(Uint16_) == 2>::v &&
        Assert_<sizeof(Sint32_) == 4>::v &&
        Assert_<sizeof(Uint32_) == 4>::v &&
        Assert_<sizeof(Diff_) == sizeof(void*)>::v &&
        Assert_<sizeof(Size_) == sizeof(void*)>::v
};

class Npda_
{
protected:

    typedef Uint32_ TokenId_;

    enum ActionType_
    {
        ACTION_SHIFT_ = 0,
        ACTION_REDUCE_,
        ACTION_NONE_
    }; // end of enum TrisonCpp_::Npda_::ActionType_
    struct Rule_;
    struct Action_
    {
        ActionType_ m_action_type_;
        Rule_ const *m_reduction_rule_;

        Action_ (ActionType_ action_type, Rule_ const *reduction_rule = NULL)
            :
            m_action_type_(action_type),
            m_reduction_rule_(reduction_rule)
        {
            assert(m_action_type_ != ACTION_NONE_);
            assert(m_action_type_ == ACTION_SHIFT_ && m_reduction_rule_ == NULL ||
                   m_action_type_ == ACTION_REDUCE_ && m_reduction_rule_ != NULL);
        }
    }; // end of struct TrisonCpp_::Npda_::Action_
    typedef std::deque<Action_> ActionQueue_;
    enum Associativity_
    {
        ASSOCIATIVITY_LEFT_ = 0,
        ASSOCIATIVITY_NONASSOC_,
        ASSOCIATIVITY_RIGHT_
    }; // end of enum TrisonCpp_::Npda_::Associativity_
    struct Precedence_
    {
        Uint32_ m_level_;
        Associativity_ m_associativity_;
        char const *m_name_;
    }; // end of struct TrisonCpp_::Npda_::Precedence_
    struct Rule_
    {
        TokenId_ m_reduction_nonterminal_token_id_;
        Precedence_ const *m_precedence_;
        Uint32_ m_token_count_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::Rule_
    struct Transition_;
    struct State_
    {
        Rule_ const *m_associated_rule_;
        Uint32_ m_associated_rule_stage_;
        TokenId_ m_associated_nonterminal_token_id_;
        Size_ m_transition_count_;
        Transition_ const *m_transition_table_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::State_
    typedef std::vector<State_ const *> StateStack_;
    struct Transition_
    {
        enum Type_ { TT_EPSILON_ = 0, TT_REDUCE_, TT_RETURN_, TT_SHIFT_ };
        Uint8_ m_transition_type_;
        TokenId_ m_transition_data_;
        State_ const *m_target_state_;
    }; // end of struct TrisonCpp_::Npda_::Transition_
    struct BranchTreeNode_;
    typedef std::vector<BranchTreeNode_ *> BranchVector_;
    /*
    struct ScheduledTransition_
    {
        ActionType_ m_action_type_;
        Uint32_ m_data_;
        BranchTreeNode_ *m_branch_;

        ScheduledTransition_ (ActionType_ action_type, Uint32_ data, BranchTreeNode_ *branch)
            :
            m_action_type_(action_type),
            m_data_(data),
            m_branch_(branch)
        {
            assert(m_branch_ != NULL);
        }
    }; // end of struct TrisonCpp_::Npda_::ScheduledTransition_
    typedef std::vector<ScheduledTransition_> ScheduledTransitionList_;
    */
    struct ActionTreeNode_;
    typedef std::set<ActionTreeNode_ *> NodeSet_;
    struct TreeNode_ // TODO: make non-virtual
    {
        enum TreeNodeType_ { ACTION_TREE_NODE_ = 0, BRANCH_TREE_NODE_ };
        TreeNodeType_ m_tree_node_type_;
        ActionTreeNode_ *m_parent_;
        Uint32_ m_rule_stack_level_;

        TreeNode_ (Uint32_ rule_stack_level, TreeNodeType_ tree_node_type)
            :
            m_tree_node_type_(tree_node_type),
            m_parent_(NULL),
            m_rule_stack_level_(rule_stack_level)
        { }
        virtual ~TreeNode_ ()
        {
            if (m_parent_ != NULL)
            {
                assert(m_parent_->IsActionTreeNode_());
                ActionTreeNode_ *parent = static_cast<ActionTreeNode_ *>(m_parent_);
                parent->RemoveChild_(this);
                // delete parent node if it has no children, but not if it's the root node
                if (parent->m_child_set_.empty() && parent->m_parent_ != NULL)
                    delete parent;
            }
        }

        bool IsActionTreeNode_ () const { return m_tree_node_type_ == ACTION_TREE_NODE_; }
        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const = 0;
    }; // end of struct TrisonCpp_::Npda_::TreeNode_
    struct TreeNodeOrder_
    {
        bool operator () (TreeNode_ const *n0, TreeNode_ const *n1) { return LessThan_(n0, n1); }
        static bool LessThan_ (TreeNode_ const *n0, TreeNode_ const *n1)
        {
            assert(n0 != NULL);
            assert(n1 != NULL);

            // obviously a node is not less than itself
            if (n0 == n1)
                return false;

            // BranchTreeNode_ elements should move to the front
            bool n0_is_action_tree_node = n0->IsActionTreeNode_();
            bool n1_is_action_tree_node = n1->IsActionTreeNode_();
            if (!n0_is_action_tree_node && !n1_is_action_tree_node)
                return n0 < n1; // but BranchTreeNode_ relative ordering is arbitrary
            if (n0_is_action_tree_node && !n1_is_action_tree_node)
                return false;
            if (!n0_is_action_tree_node && n1_is_action_tree_node)
                return true;

            ActionTreeNode_ const &atn0 = *static_cast<ActionTreeNode_ const *>(n0);
            ActionTreeNode_ const &atn1 = *static_cast<ActionTreeNode_ const *>(n1);
            assert(&atn0.m_nonassoc_error_encountered_ == &atn1.m_nonassoc_error_encountered_);

            // if either of the nodes have no associated rule, then we're
            // at the root of the action tree, and ActionTreeNode_ objects
            // can only be epsilon-closure or shift-to-a-return-state nodes
            if (atn0.m_associated_rule_ == NULL || atn1.m_associated_rule_ == NULL)
            {
                assert(atn0.m_action_type_ == ACTION_NONE_ || atn0.m_action_type_ == ACTION_SHIFT_);
                assert(atn1.m_action_type_ == ACTION_NONE_ || atn1.m_action_type_ == ACTION_SHIFT_);
                // prefer shift-to-a-return-state over epsilon-closure nodes
                return atn0.m_action_type_ < atn1.m_action_type_;
            }

            Precedence_ const &p0 = *atn0.m_associated_rule_->m_precedence_;
            Precedence_ const &p1 = *atn1.m_associated_rule_->m_precedence_;

            // higher precedence elements move to the front
            if (p0.m_level_ != p1.m_level_)
                return p0.m_level_ > p1.m_level_;

            // associativity ordering; for left-assoc, reduce is preferred,
            // while for right-assoc, shift is preferred.  nonassoc grouping
            // will cause the nonassoc error flag to be set.
            assert(p0.m_associativity_ == p1.m_associativity_ &&
                   "rules with the same precedence must have the same associativity");
            if (atn0.m_action_type_ == ACTION_SHIFT_ && atn1.m_action_type_ == ACTION_REDUCE_)
            {
                if (p0.m_associativity_ == ASSOCIATIVITY_NONASSOC_)
                    atn0.m_nonassoc_error_encountered_ = true;
                return p0.m_associativity_ == ASSOCIATIVITY_RIGHT_;
            }
            else if (atn0.m_action_type_ == ACTION_REDUCE_ && atn1.m_action_type_ == ACTION_SHIFT_)
            {
                if (p0.m_associativity_ == ASSOCIATIVITY_NONASSOC_)
                    atn0.m_nonassoc_error_encountered_ = true;
                return p0.m_associativity_ == ASSOCIATIVITY_LEFT_;
            }

            // the final (fail-safe) criteria is preference of lower rule index
            return atn0.m_associated_rule_ < atn1.m_associated_rule_;
        }
    }; // end of struct TrisonCpp_::Npda_::TreeNodeOrder_
    struct BranchTreeNode_;
    typedef std::set<BranchTreeNode_ *> BranchSet_;
    struct ActionTreeNode_ : public TreeNode_
    {
        typedef std::set<TreeNode_ *, TreeNodeOrder_> ChildSet_;

        ChildSet_ m_child_set_;
        ActionType_ m_action_type_;
        Rule_ const *m_associated_rule_;
        bool &m_nonassoc_error_encountered_;
        Uint32_ m_e_closure_state_; // TODO: this is going away soon
        bool m_is_completed_;

        ActionTreeNode_ (ActionType_ action_type, Rule_ const *associated_rule, bool &nonassoc_error_encountered, Uint32_ e_closure_state /* TODO: going away soon */, Uint32_ rule_stack_level)
            :
            TreeNode_(rule_stack_level, ACTION_TREE_NODE_),
            m_action_type_(action_type),
            m_associated_rule_(associated_rule),
            m_nonassoc_error_encountered_(nonassoc_error_encountered),
            m_e_closure_state_(e_closure_state), // TODO: going away soon
            m_is_completed_(false)
        { }
        virtual ~ActionTreeNode_ ()
        {
            assert(m_child_set_.empty());
        }

        virtual bool IsActionTreeNode_ () const { return true; }
        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            std::string tab_string(2*indent_level, ' ');
            stream << tab_string << (m_is_completed_ ? '@' : '~') << '(' << m_rule_stack_level_ << 'r';
            if (m_associated_rule_ != NULL)
                stream << m_associated_rule_ - rule_table;
            else
                stream << 'X';
            stream << ") ";
            if (m_parent_ == NULL)
                stream << "root";
            else switch (m_action_type_)
            {
                default: assert(false);
                case ACTION_NONE_  : stream << "e-close " << m_e_closure_state_; break;
                case ACTION_SHIFT_ : stream << "shift"; break;
                case ACTION_REDUCE_: stream << "reduce " << (m_associated_rule_ - rule_table); break;
            }
            stream << ' ' << this << std::endl;
            for (ChildSet_::const_iterator it = m_child_set_.begin(), it_end = m_child_set_.end();
                 it != it_end;
                 ++it)
            {
                TreeNode_ const *child = *it;
                if (child != NULL)
                    child->Print_(stream, rule_table, state_table, indent_level+1);
            }
        }

        void AddChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == NULL);
            assert(!TreeNodeOrder_::LessThan_(child, child));
            if (!m_child_set_.empty() && (*m_child_set_.rbegin())->IsActionTreeNode_() && static_cast<ActionTreeNode_ *>(*m_child_set_.rbegin())->m_is_completed_)
                assert(!TreeNodeOrder_::LessThan_(*m_child_set_.rbegin(), child) && "can't add a child below a completed child");
            child->m_parent_ = this;
            assert(m_child_set_.find(child) == m_child_set_.end());
            m_child_set_.insert(child);
        }
        void RemoveChild_ (TreeNode_ *child)
        {
            /*
            std::cerr << __PRETTY_FUNCTION__ << " start -- this = " << this << ", child = " << child << std::endl;
            for (ChildSet_::const_iterator it = m_child_set_.begin(), it_end = m_child_set_.end();
                 it != it_end;
                 ++it)
            {
                TreeNode_ const *ch = *it;
                bool less_than = TreeNodeOrder_::LessThan_(child, ch);
                bool greater_than = TreeNodeOrder_::LessThan_(ch, child);
                std::cerr << "    " << ch << ' ';
                switch ((less_than ? 2 : 0) + (greater_than ? 1 : 0))
                {
                    case 0: std::cerr << "it == child"; break;
                    case 1: std::cerr << "it < child"; break;
                    case 2: std::cerr << "child < it"; break;
                    case 3: assert(false && "inconsistent TreeNodeOrder_"); break;
                }
                std::cerr << std::endl;
            }
            */
            assert(child != NULL);
            assert(child->m_parent_ == this);
            assert(!TreeNodeOrder_::LessThan_(child, child));
            child->m_parent_ = NULL;
            assert(m_child_set_.find(child) != m_child_set_.end());
//             std::cerr << __PRETTY_FUNCTION__ << " end" << std::endl;
            m_child_set_.erase(child);
        }
        ActionTreeNode_ *EnsureChildExists_ (ActionType_ action_type, Rule_ const *associated_rule, bool &nonassoc_error_encountered, Uint32_ e_closure_state, Uint32_ rule_stack_level)
        {
            /*
            // TODO: see if this can be optimized with std::set::find() -- create an ActionTreeNode_ on the stack and call find on it
            for (ChildSet_::iterator it = m_child_set_.begin(), it_end = m_child_set_.end();
                 it != it_end;
                 ++it)
            {
                TreeNode_ *child = *it;
                if (child != NULL &&
                    child->IsActionTreeNode_() &&
                    static_cast<ActionTreeNode_ *>(child)->m_action_type_ == action_type &&
                    static_cast<ActionTreeNode_ *>(child)->m_associated_rule_ == associated_rule)
                {
                    child->m_rule_stack_level_ = std::max(child->m_rule_stack_level_, rule_stack_level);
                    return static_cast<ActionTreeNode_ *>(child);
                }
            }
            */
            // check for child equivalent to the one requested
            ActionTreeNode_ dummy_node(action_type, associated_rule, nonassoc_error_encountered, e_closure_state, rule_stack_level);
            ChildSet_::iterator it = m_child_set_.find(&dummy_node);
            // if there is an equivalent child, update the rule stack level and return it.
            if (it != m_child_set_.end())
            {
                assert(*it != NULL);
                assert((*it)->IsActionTreeNode_());
                (*it)->m_rule_stack_level_ = std::max((*it)->m_rule_stack_level_, rule_stack_level);
                return static_cast<ActionTreeNode_ *>(*it);
            }
            // otherwise, if the child-to-be-created would be immediately out-completed,
            // return NULL, indicating that the relevant branch should be pruned.
            if (!m_child_set_.empty() &&
                (*m_child_set_.rbegin())->IsActionTreeNode_() &&
                static_cast<ActionTreeNode_ *>(*m_child_set_.rbegin())->m_is_completed_ &&
                TreeNodeOrder_::LessThan_(*m_child_set_.rbegin(), &dummy_node))
            {
                return NULL;
            }
            // otherwise, create, add, and return the requested child
            ActionTreeNode_ *child = new ActionTreeNode_(action_type, associated_rule, nonassoc_error_encountered, e_closure_state, rule_stack_level);
            AddChild_(child);
            return child;
        }
        void CompleteReduceAction_ (BranchSet_ &branch_set)
        {
            assert(m_action_type_ == ACTION_REDUCE_);
            assert(m_parent_ != NULL);
            assert(m_rule_stack_level_ > 0);
            Uint32_ min_rule_stack_level_ = m_rule_stack_level_;
            ActionTreeNode_ *node = this;
            while (node->m_rule_stack_level_ >= min_rule_stack_level_)
            {
                assert(node != NULL);
                assert(node->m_rule_stack_level_ > 0);
                assert(node->m_parent_ != NULL);
                node->m_is_completed_ = true;
                ChildSet_::iterator it_start = node->m_parent_->m_child_set_.find(node);
                ChildSet_::iterator it_end = node->m_parent_->m_child_set_.end();
                assert(it_start != it_end);
                while (true)
                {
                    ChildSet_::iterator it = it_start;
                    ++it;
                    if (it == it_end)
                        break;
                    assert(*it != NULL);
                    assert((*it)->IsActionTreeNode_());
                    ActionTreeNode_ *outcompleted_sibling = static_cast<ActionTreeNode_ *>(*it);
                    Prune_(outcompleted_sibling, branch_set);
                }
                node = node->m_parent_;
            }
        }
        static void Prune_ (ActionTreeNode_ *node, BranchSet_ &branch_set)
        {
            assert(node != NULL);
            assert(node->m_parent_ != NULL);
            while (!node->m_child_set_.empty())
            {
                ChildSet_::iterator it = node->m_child_set_.begin();
                TreeNode_ *child = *it;
                assert(child != NULL);
                if (child->IsActionTreeNode_())
                    Prune_(static_cast<ActionTreeNode_ *>(child), branch_set);
                else
                {
                    node->m_child_set_.erase(it);
                    child->m_parent_ = NULL; // to prevent meddling by ~TreeNode_()
                    assert(branch_set.find(static_cast<BranchTreeNode_ *>(child)) != branch_set.end());
                    branch_set.erase(static_cast<BranchTreeNode_ *>(child));
                    delete child;
                }
            }
            node->m_parent_->RemoveChild_(node);
            delete node;
        }
    }; // end of struct TrisonCpp_::Npda_::ActionTreeNode_
    struct BranchTreeNode_ : public TreeNode_
    {
        StateStack_ m_state_stack_;
        TokenId_ m_lookahead_nonterminal_token_id_;
        bool m_is_epsilon_closed_;
        bool m_is_scheduled_to_die_;
        Uint32_ m_scheduled_transition_count_;

        BranchTreeNode_ (State_ const *starting_state, Uint32_ rule_stack_level)
            :
            TreeNode_(rule_stack_level, BRANCH_TREE_NODE_),
            m_lookahead_nonterminal_token_id_(0), // none_
            m_is_epsilon_closed_(false),
            m_is_scheduled_to_die_(false),
            m_scheduled_transition_count_(0)
        {
            assert(starting_state != NULL);
            m_state_stack_.push_back(starting_state);
        }

        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            std::string tab_string(2*indent_level, ' ');
            stream << tab_string << (m_is_epsilon_closed_ ? 'c' : '_') << '(' << m_rule_stack_level_ << 'r';
            Rule_ const *associated_rule = Top_().m_associated_rule_;
            if (associated_rule != NULL)
                stream << associated_rule - rule_table;
            else
                stream << 'X';
            stream << ')';
            for (StateStack_::const_iterator it = m_state_stack_.begin(), it_end = m_state_stack_.end();
                 it != it_end;
                 ++it)
            {
                State_ const *stack_state = *it;
                assert(stack_state != NULL);
                stream << ' ' << (stack_state - state_table);
            }
            if (m_lookahead_nonterminal_token_id_ != 0) // none_
                stream << " (" << m_lookahead_nonterminal_token_id_ << ')';
            stream << ' ' << this << std::endl;
        }

        State_ const &Top_ () const
        {
            assert(!m_state_stack_.empty());
            assert(m_state_stack_.back() != NULL);
            return *m_state_stack_.back();
        }
        BranchTreeNode_ *Clone_ () const
        {
            assert(m_scheduled_transition_count_ == 0);
            BranchTreeNode_ *cloned = new BranchTreeNode_(*this);
            cloned->m_parent_ = NULL;
            cloned->m_is_epsilon_closed_ = false;
            return cloned;
        }
        /*
        BranchTreeNode_ *Fork_ ()
        {
            assert(m_scheduled_transition_count_ > 0);
            if (--m_scheduled_transition_count_ == 0)
                return this;
            BranchTreeNode_ *forked = new BranchTreeNode_(*this);
            forked->m_parent_ = NULL;
            forked->m_is_epsilon_closed_ = false;
            forked->m_scheduled_transition_count_ = 0;
            return forked;
        }
        */
    }; // end of struct TrisonCpp_::Npda_::BranchTreeNode_
}; // end of class TrisonCpp_::Npda_

} // end of namespace TrisonCpp_
#endif // !defined(TrisonCpp_namespace_)
<*{if(is_defined(top_of_header_file))

<*{top_of_header_file
<*{end_if

class <{class_name} : private TrisonCpp_::Npda_<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    typedef <{token_data_type} TokenData_;

    enum ParserReturnCode
    {
        PRC_SUCCESS = 0,
        PRC_UNHANDLED_PARSE_ERROR = 1
    }; // end of enum <{class_name}::ParserReturnCode

    struct Terminal
    {
        enum Name
        {
<*{if(sizeof(_terminal_name_list) < 1)
<*{error("the terminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<*{error("mismatch in size of _terminal_name_list and _terminal_index_list")
<*{end_if
<*{loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    struct Nonterminal
    {
        enum Name
        {
<*{if(sizeof(_nonterminal_name_list) < 1)
<*{error("the nonterminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<*{error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<*{end_if
<*{loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    struct StartNonterminal
    {
        enum Name
        {
<*{for_each(key, _npda_initial_node_index)
            <{key} = <{_npda_initial_node_index[key]},
<*{end_for_each
            // default starting nonterminal
            START_ = <{_start}
        }; // end of enum <{class_name}::StartNonterminal::Name
    }; // end of struct <{class_name}::StartNonterminal

    struct Token_
    {
        TokenId_ m_token_id_;
        TokenData_ m_token_data_;

        Token_ () : m_token_id_(Nonterminal::none_) { }
        Token_ (TokenId_ token_id, TokenData_ const &token_data)
            :
            m_token_id_(token_id),
            m_token_data_(token_data)
        {
            assert(m_token_id_ != Nonterminal::none_);
        }
    }; // end of struct <{class_name}::Token

private:

    typedef std::deque<Token_> TokenBuffer_;

<*{if(is_defined(top_of_class))
public:

<*{top_of_class

<*{end_if
public:

    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<*{if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<*{end_if
<*{if(is_defined(parse_method_access))
<*{if(!(parse_method_access == "public:" || parse_method_access == "protected:" || parse_method_access == "private:"))
<*{error("invalid parse_method_access \"" . parse_method_access . "\"")
<*{end_if
<{parse_method_access}

<*{end_if
    ParserReturnCode Parse (StartNonterminal::Name nonterminal_to_parse_ = StartNonterminal::<{_start});

private:

    static bool TransitionAcceptsTokenId_ (Transition_ const *transition, TokenId_ token_id)
    {
        assert(transition >= ms_transition_table_ && transition < ms_transition_table_ + ms_transition_count_);
        return transition->m_transition_type_ == Transition_::TT_SHIFT_ &&
               transition->m_transition_data_ == token_id;
    }

/*
    void ClearBranches_ ();
    void ClearTokenStack_ ();
    void ClearLookaheadQueue_ ();
    void ClearMostRecentReturnState_ ();
    void ClearReturnToken_ ();
*/
    void ThrowAwayToken_ (TokenData_ &token);
    void ResetForNewInput_ ();


    // blah
    ParserReturnCode Parse_ (StartNonterminal::Name nonterminal_to_parse_);
    Token_ &ShiftLookaheadToken_ ();
    void PerformEpsilonClosure_ ();
    void PerformEpsilonClosure_ (BranchTreeNode_ const &source_branch, StateStack_ &extra_state_stack);
    void PerformReduceTransitions_ ();
    void PerformReduceTransition_ (BranchTreeNode_ *branch, Rule_ const *reduction_rule);
    void PerformShiftTransitionsAndSaveReturnActions_ ();
    void PerformShiftTransition_ (BranchTreeNode_ *branch, State_ const *target_state);
    void SaveReturnActions_ (BranchTreeNode_ *branch);
    void PruneDeadBranches_ ();
    void ExecuteAndRemoveTrunk_ ();
    // end blah



<*{loop(i, _rule_count)
    TokenData_ AcceptHandler<{i}_ ();
<*{end_loop

    // TODO: move as much stuff to the base class as possible
    ActionTreeNode_ *m_tree_root_;
    BranchSet_ m_branch_set_;
    bool m_is_shift_blocked_;
    bool m_reduce_transitions_were_performed_;
    bool m_nonassoc_error_encountered_;
//     ScheduledTransitionList_ m_scheduled_transition_list_;
    BranchVector_ m_dead_branch_list_;
    TokenBuffer_ m_token_stack_;
    TokenBuffer_ m_lookahead_queue_;
    TokenBuffer_::size_type m_lookahead_queue_cursor_;
    bool m_return_state_encountered_;
    ActionQueue_ m_saved_return_action_queue_;
//     State_ const *m_most_recent_return_state_;
//     Token_ m_return_token_;
<*{if(is_defined(generate_debug_spew_code))
    bool m_debug_spew_;

<*{end_if
    static TrisonCpp_::Npda_::Precedence_ const ms_precedence_table_[];
    static TrisonCpp_::Size_ const ms_precedence_count_;
    static TrisonCpp_::Npda_::Rule_ const ms_rule_table_[];
    static TrisonCpp_::Size_ const ms_rule_count_;
    static TrisonCpp_::Npda_::State_ const ms_state_table_[];
    static TrisonCpp_::Size_ const ms_state_count_;
    static TrisonCpp_::Npda_::Transition_ const ms_transition_table_[];
    static TrisonCpp_::Size_ const ms_transition_count_;
<*{if(is_defined(bottom_of_class))

public:
<{bottom_of_class}
<*{end_if
}; // end of class <{class_name}
<*{if(is_defined(bottom_of_header_file))

<*{bottom_of_header_file
<*{end_if
