<*{if(header_filename == implementation_filename)
<*{error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison at <{_creation_timestamp}
// from <{_source_filename} using <{_langspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <algorithm>
#include <cassert>
#include <deque>
#include <iostream> // TEMP
#include <set>
#include <vector>

#if !defined(TrisonCpp_namespace_)
#define TrisonCpp_namespace_
namespace TrisonCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// a bunch of template metaprogramming to intelligently determine
// what type to use for an integer of the given bit width
// /////////////////////////////////////////////////////////////////////////////

template <bool condition_, typename Then_, typename Else_> struct If_;
template <typename Then_, typename Else_> struct If_<true,Then_,Else_> { typedef Then_ T; };
template <typename Then_, typename Else_> struct If_<false,Then_,Else_> { typedef Else_ T; };

template <bool condition_> struct Assert_;
template <> struct Assert_<true> { static bool const v = true; operator bool () { return v; } };

template <typename Sint_, typename Uint_> struct IntPair_ { typedef Sint_ S; typedef Uint_ U; };

template <int bits_> struct Integer_ {
    typedef
        typename If_<bits_ == 8*sizeof(char),      IntPair_<char,unsigned char>,
        typename If_<bits_ == 8*sizeof(short),     IntPair_<short,unsigned short>,
        typename If_<bits_ == 8*sizeof(int),       IntPair_<int,unsigned int>,
        typename If_<bits_ == 8*sizeof(long),      IntPair_<long,unsigned long>,
        typename If_<bits_ == 8*sizeof(long long), IntPair_<long long,unsigned long long>,
        Integer_<0> // if no match, cause a compile error
        >::T >::T >::T >::T >::T IntPair;
    typedef typename IntPair::S Signed;
    typedef typename IntPair::U Unsigned;
    static bool const assert_size =
        Assert_<bits_ == 8*sizeof(Signed) && bits_ == 8*sizeof(Unsigned)>::v;
};
template <> struct Integer_<0> { }; // empty for intentional compile errors

// /////////////////////////////////////////////////////////////////////////////
// typedefs for the integer types used in the "cpp" trison target
// /////////////////////////////////////////////////////////////////////////////

typedef Integer_<8> ::Signed   Sint8_;
typedef Integer_<8> ::Unsigned Uint8_;
typedef Integer_<16>::Signed   Sint16_;
typedef Integer_<16>::Unsigned Uint16_;
typedef Integer_<32>::Signed   Sint32_;
typedef Integer_<32>::Unsigned Uint32_;
typedef Integer_<8*sizeof(void*)>::Signed   Diff_;
typedef Integer_<8*sizeof(void*)>::Unsigned Size_;

enum
{
    TYPE_SIZE_ASSERTIONS_ =
        Assert_<sizeof(Sint8_) == 1>::v &&
        Assert_<sizeof(Uint8_) == 1>::v &&
        Assert_<sizeof(Sint16_) == 2>::v &&
        Assert_<sizeof(Uint16_) == 2>::v &&
        Assert_<sizeof(Sint32_) == 4>::v &&
        Assert_<sizeof(Uint32_) == 4>::v &&
        Assert_<sizeof(Diff_) == sizeof(void*)>::v &&
        Assert_<sizeof(Size_) == sizeof(void*)>::v
};

class Npda_
{
protected:

    typedef Uint32_ TokenId_;

    enum ActionType_
    {
        ACTION_SHIFT_ = 0,
        ACTION_REDUCE_,
        ACTION_NONE_
    }; // end of enum TrisonCpp_::Npda_::ActionType_
    struct Rule_;
    struct Action_
    {
        ActionType_ m_action_type_;
        Rule_ const *m_reduction_rule_;

        Action_ (ActionType_ action_type, Rule_ const *reduction_rule = NULL)
            :
            m_action_type_(action_type),
            m_reduction_rule_(reduction_rule)
        {
            assert(m_action_type_ != ACTION_NONE_);
            assert(m_action_type_ == ACTION_SHIFT_ && m_reduction_rule_ == NULL ||
                   m_action_type_ == ACTION_REDUCE_ && m_reduction_rule_ != NULL);
        }
    }; // end of struct TrisonCpp_::Npda_::Action_
    typedef std::deque<Action_> ActionQueue_;
    enum Associativity_
    {
        ASSOCIATIVITY_LEFT_ = 0,
        ASSOCIATIVITY_NONASSOC_,
        ASSOCIATIVITY_RIGHT_
    }; // end of enum TrisonCpp_::Npda_::Associativity_
    struct Precedence_
    {
        Uint32_ m_level_;
        Associativity_ m_associativity_;
        char const *m_name_;
    }; // end of struct TrisonCpp_::Npda_::Precedence_
    struct Rule_
    {
        TokenId_ m_reduction_nonterminal_token_id_;
        Precedence_ const *m_precedence_;
        Uint32_ m_token_count_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::Rule_
    struct Transition_;
    struct State_
    {
        Rule_ const *m_associated_rule_;
        Uint32_ m_associated_rule_stage_;
        TokenId_ m_associated_nonterminal_token_id_;
        Size_ m_transition_count_;
        Transition_ const *m_transition_table_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::State_
    typedef std::vector<State_ const *> StateStack_;
    struct Transition_
    {
        enum Type_ { TT_EPSILON_ = 0, TT_REDUCE_, TT_RETURN_, TT_SHIFT_ };
        Uint8_ m_transition_type_;
        TokenId_ m_transition_data_;
        State_ const *m_target_state_;
    }; // end of struct TrisonCpp_::Npda_::Transition_
    struct BranchTreeNode_;
    typedef std::vector<BranchTreeNode_ *> BranchVector_;
    struct ActionTreeNode_;
    struct TreeNode_ // TODO: make non-virtual
    {
        // TODO: make non-public
        enum TreeNodeType_ { ACTION_TREE_NODE_ = 0, BRANCH_TREE_NODE_ };
        TreeNodeType_ m_tree_node_type_;
        ActionTreeNode_ *m_parent_;
        Uint32_ m_rule_stack_level_;

        TreeNode_ (Uint32_ rule_stack_level, TreeNodeType_ tree_node_type)
            :
            m_tree_node_type_(tree_node_type),
            m_parent_(NULL),
            m_rule_stack_level_(rule_stack_level)
        { }
        virtual ~TreeNode_ ()
        {
            /*
            if (m_parent_ != NULL)
            {
                m_parent_->RemoveChild_(this);
                // delete parent node if it has no children, but not if it's the root node
                if (!m_parent->HasChildren_() && m_parent_->m_parent_ != NULL)
                    delete m_parent_;
            }
            */
        }

        bool IsActionTreeNode_ () const { return m_tree_node_type_ == ACTION_TREE_NODE_; }
        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const = 0;
    }; // end of struct TrisonCpp_::Npda_::TreeNode_
    struct BranchTreeNode_;
    struct BranchTreeNodeLessThan_
    {
        // a consequence of this ordering functor using the branches' parent
        // nodes is that the branch must have its m_parent_ member set to the
        // involved parent when this functor is called (e.g. set insert, erase)
        bool operator () (BranchTreeNode_ const *b0, BranchTreeNode_ const *b1)
        {
            assert(b0 != NULL);
            assert(b1 != NULL);
            assert(b0->m_parent_ != NULL);
            assert(b1->m_parent_ != NULL);
            assert(b0->m_parent_ == b1->m_parent_);
            assert(b0->Top_().m_associated_rule_ == NULL && b0->m_parent_->IsRootNode_() ||
                   b0->Top_().m_associated_rule_ != NULL && !b0->m_parent_->IsRootNode_());
            assert(b1->Top_().m_associated_rule_ == NULL && b1->m_parent_->IsRootNode_() ||
                   b1->Top_().m_associated_rule_ != NULL && !b1->m_parent_->IsRootNode_());

            // a branch is not less than itself
            if (b0 == b1)
                return false;

            // ordering of child branches at the root node is arbitrary.
            // ordering of child branches of an ACTION_REDUCE_ node is arbitrary
            // (because the reduce action node takes its prioritizing values from
            // the reduction rule directly, instead of its child nodes/branches).
            if (b0->m_parent_->IsRootNode_() || b0->m_parent_->m_action_type_ == ACTION_REDUCE_)
                return b0 < b1;

            State_ const &b0_top_state = b0->Top_();
            State_ const &b1_top_state = b1->Top_();
            assert(b0_top_state.m_associated_rule_ != NULL);
            assert(b1_top_state.m_associated_rule_ != NULL);
            Rule_ const &b0_associated_rule = *b0_top_state.m_associated_rule_;
            Rule_ const &b1_associated_rule = *b1_top_state.m_associated_rule_;
            assert(b0_associated_rule.m_precedence_ != NULL);
            assert(b1_associated_rule.m_precedence_ != NULL);

            // higher precedence level takes priority (moves to front)
            if (b0_associated_rule.m_precedence_->m_level_ != b1_associated_rule.m_precedence_->m_level_)
                return b0_associated_rule.m_precedence_->m_level_ > b1_associated_rule.m_precedence_->m_level_;

            // lower rule index takes priority (moves to front)
            if (&b0_associated_rule != &b1_associated_rule)
                return &b0_associated_rule < &b1_associated_rule;

            // otherwise, ordering is arbitrary
            return b0 < b1;
        }
    }; // end of struct TrisonCpp_::Npda_::BranchTreeNodeLessThan_
    // NOTE: the BranchSet_ ordering isn't required for the branch set kept by the parser itself; only ActionTreeNode_s
    typedef std::set<BranchTreeNode_ */*, BranchTreeNodeLessThan_*/> BranchSet_;
    struct ActionTreeNode_ : public TreeNode_
    {
        // TODO: make non-public
        // there can only ever be up to 2 children, one of each type.
        TreeNode_ *m_reduce_child_;
        TreeNode_ *m_shift_child_;
        // there can be arbitrarily many branch children
        BranchSet_ m_child_branch_set_;
        // indicates what type of node this is -- ACTION_SHIFT_, ACTION_REDUCE_,
        // or ACTION_NONE_ (which is only valid for the root node).
        ActionType_ m_action_type_;
        // precedence range - primary criteria for node priority
        Uint32_ m_precedence_level_range_lower_;
        Uint32_ m_precedence_level_range_upper_;
        // associativity - secondary criteria for node priority (N/A unless the precedence range is 1 value)
        Associativity_ m_associativity_;
        // rule index range - tertiary criteria for node priority (N/A unless the precedence range is 1 value)
        Uint32_ m_rule_index_range_lower_;
        Uint32_ m_rule_index_range_upper_;

        // for constructing the root node only
        ActionTreeNode_ ()
            :
            TreeNode_(0, ACTION_TREE_NODE_),
            m_reduce_child_(NULL),
            m_shift_child_(NULL),
            m_action_type_(ACTION_NONE_)
        { }
        ActionTreeNode_ (
            ActionType_ action_type,
            Uint32_ precedence_level_range_lower,
            Uint32_ precedence_level_range_upper,
            Associativity_ associativity,
            Uint32_ rule_index_range_lower,
            Uint32_ rule_index_range_upper,
            Uint32_ rule_stack_level)
            :
            TreeNode_(rule_stack_level, ACTION_TREE_NODE_),
            m_reduce_child_(NULL),
            m_shift_child_(NULL),
            m_action_type_(action_type),
            m_precedence_level_range_lower_(precedence_level_range_lower),
            m_precedence_level_range_upper_(precedence_level_range_upper),
            m_associativity_(associativity),
            m_rule_index_range_lower_(rule_index_range_lower),
            m_rule_index_range_upper_(rule_index_range_upper)
        {
            assert(m_action_type_ == ACTION_REDUCE_ || m_action_type_ == ACTION_SHIFT_);
            assert(m_action_type_ == ACTION_REDUCE_ &&
                   precedence_level_range_lower == precedence_level_range_upper &&
                   rule_index_range_lower == rule_index_range_upper
                   ||
                   m_action_type_ == ACTION_SHIFT_ &&
                   precedence_level_range_lower <= precedence_level_range_upper &&
                   rule_index_range_lower <= rule_index_range_upper);
        }
        virtual ~ActionTreeNode_ ()
        {
            assert(m_reduce_child_ == NULL);
            assert(m_shift_child_ == NULL);
            assert(m_child_branch_set_.empty());
        }

        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            std::string tab_string(2*indent_level, ' ');
            stream << tab_string << '(' << m_rule_stack_level_ << ')';
            switch (m_action_type_)
            {
                default: assert(false);
                case ACTION_NONE_  : stream << "root"; break;
                case ACTION_SHIFT_ : stream << "shift"; break;
                case ACTION_REDUCE_: stream << "reduce \"" << rule_table[m_rule_index_range_lower_].m_description_ << '\"'; break;
            }
            stream << ' ' << this << std::endl;
            for (BranchSet_::const_iterator it = m_child_branch_set_.begin(), it_end = m_child_branch_set_.end();
                 it != it_end;
                 ++it)
            {
                BranchTreeNode_ const *child_branch = *it;
                assert (child_branch != NULL);
                child_branch->Print_(stream, rule_table, state_table, indent_level+1);
            }
            if (m_reduce_child_ != NULL)
                m_reduce_child_->Print_(stream, rule_table, state_table, indent_level+1);
            if (m_shift_child_ != NULL)
                m_shift_child_->Print_(stream, rule_table, state_table, indent_level+1);
        }

        bool IsRootNode_ () const { return m_parent_ == NULL; }
        bool HasChildren_ () const { return m_reduce_child_ != NULL || m_shift_child_ != NULL || !m_child_branch_set_.empty(); }
        /*
        void PerformReduceTransition_ (
            BranchTreeNode_ *child_branch,
            BranchSet_ &branch_set,
            StateStack_ const &epsilon_closure_state_stack,
            ActionTreeNode_ *reduce_child)
        {
            assert(child_branch != NULL);
            assert(reduce_child != NULL);
            if (m_reduce_child_ != NULL)
            {
                if (reduce_child->m_precedence_level_range_lower_ > m_reduce_child_->m_precedence_level_range_lower_
                    ||
                    reduce_child->m_precedence_level_range_lower_ == m_reduce_child_->m_precedence_level_range_lower_ &&
                    reduce_child->m_precedence_level_range_upper_ < m_reduce_child_->m_rule_index_range_lower_)
                {
                    Prune_(m_reduce_child_, branch_set);
                }
                else if (reduce_child->m_precedence_level_range_lower_ == m_reduce_child_->m_precedence_level_range_lower_ &&
                         reduce_child->m_precedence_level_range_upper_ == m_reduce_child_->m_rule_index_range_lower_)
                {
                }
                else
                {
                }
            }
        }
        void StealChildBranch_ (BranchTreeNode_ *child_branch)
        {
            assert(child_branch != NULL);
            assert(m_parent_ != NULL && "the root node can't steal a child branch because it has no parent");
            assert(child_branch->m_parent_ == m_parent_ && "a branch can only be passed down to the child of its former parent");
            assert(m_parent_->m_child_branch_set_.find(child_branch) != m_parent->m_child_branch_set_.end());
            assert(m_child_branch_set_.find(child_branch) == m_child_branch_set_.end());
            m_parent_->m_child_branch_set_.erase(child_branch);
            child_branch->m_parent_ = this;
            m_child_branch_set_.insert(child_branch);
            // if this is a shift node, then we must re-figure-out the precedence-range, associativity and rule index range
            if (m_action_type_ == ACTION_SHIFT_)
            {

            }
        }
        void RemoveChildBranch_ (BranchTreeNode_ *child_branch)
        {
            assert(child_branch != NULL);
            assert(child_branch->m_parent_ == this);
            assert(m_child_branch_set_.find(child_branch) != m_child_branch_set_.end());
            child_branch->m_parent_ = NULL;
            m_child_branch_set_.erase(child_branch);
        }
        void SetShiftChild_ (ActionTreeNode_ *shift_child, BranchSet_ &branch_set)
        {
            assert(shift_child != NULL);
            assert(shift_child->m_parent_ == NULL);
            assert(shift_child->m_reduce_child_ == NULL);
            assert(shift_child->m_shift_child_ == NULL);
            assert(shift_child->m_child_branch_set_.empty());
            assert(m_shift_child_ == NULL);
            shift_child->m_parent_ = this;
            m_shift_child_ = shift_child;
            PerformShiftReduceConflictResolution_(branch_set);
        }
        void SetReduceChild_ (ActionTreeNode_ *reduce_child, BranchSet_ &branch_set)
        {
            assert(reduce_child != NULL);
            assert(reduce_child->m_parent_ == NULL);
            assert(reduce_child->m_reduce_child_ == NULL);
            assert(reduce_child->m_shift_child_ == NULL);
            assert(reduce_child->m_child_branch_set_.empty());
            if (m_reduce_child_ != NULL)
            {
                TODO: start here

                assert(m_reduce_child_ and reduce_child have unequal priorities && "it should be impossible for 2 different reduce actions to have the same priority");
                if (m_reduce_child_ has lower priority than reduce_child)
                {
                    get ridda m_reduce_child_ (and pass in branch_set)
                    m_reduce_child_ = reduce_child;
                }
                else if (reduce_child has lower priority than m_reduce_child_)
                {
                    get ridda reduce_child
                }
            }
            PerformShiftReduceConflictResolution_(branch_set);
        }
        */
/*
        void AddChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == NULL);
            assert(!TreeNodeOrder_::LessThan_(child, child));
            if (!m_child_set_.empty() && (*m_child_set_.rbegin())->IsActionTreeNode_() && static_cast<ActionTreeNode_ *>(*m_child_set_.rbegin())->m_is_completed_)
                assert(!TreeNodeOrder_::LessThan_(*m_child_set_.rbegin(), child) && "can't add a child below a completed child");
            child->m_parent_ = this;
            assert(m_child_set_.find(child) == m_child_set_.end());
            m_child_set_.insert(child);
        }
        void RemoveChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == this);
            assert(!TreeNodeOrder_::LessThan_(child, child));
            child->m_parent_ = NULL;
            assert(m_child_set_.find(child) != m_child_set_.end());
            m_child_set_.erase(child);
        }
        ActionTreeNode_ *EnsureChildExists_ (ActionType_ action_type, Rule_ const *associated_rule, bool &nonassoc_error_encountered, Uint32_ e_closure_state, Uint32_ rule_stack_level)
        {
            // check for child equivalent to the one requested
            ActionTreeNode_ dummy_node(action_type, associated_rule, nonassoc_error_encountered, e_closure_state, rule_stack_level);
            ChildSet_::iterator it = m_child_set_.find(&dummy_node);
            // if there is an equivalent child, update the rule stack level and return it.
            if (it != m_child_set_.end())
            {
                assert(*it != NULL);
                assert((*it)->IsActionTreeNode_());
                (*it)->m_rule_stack_level_ = std::max((*it)->m_rule_stack_level_, rule_stack_level);
                return static_cast<ActionTreeNode_ *>(*it);
            }
            // otherwise, if the child-to-be-created would be immediately out-completed,
            // return NULL, indicating that the relevant branch should be pruned.
            if (!m_child_set_.empty() &&
                (*m_child_set_.rbegin())->IsActionTreeNode_() &&
                static_cast<ActionTreeNode_ *>(*m_child_set_.rbegin())->m_is_completed_ &&
                TreeNodeOrder_::LessThan_(*m_child_set_.rbegin(), &dummy_node))
            {
                return NULL;
            }
            // otherwise, create, add, and return the requested child
            ActionTreeNode_ *child = new ActionTreeNode_(action_type, associated_rule, nonassoc_error_encountered, e_closure_state, rule_stack_level);
            AddChild_(child);
            return child;
        }
        void CompleteReduceAction_ (BranchSet_ &branch_set)
        {
            assert(m_action_type_ == ACTION_REDUCE_);
            assert(m_parent_ != NULL);
            assert(m_rule_stack_level_ > 0);
            Uint32_ min_rule_stack_level_ = m_rule_stack_level_;
            ActionTreeNode_ *node = this;
            while (node->m_rule_stack_level_ >= min_rule_stack_level_)
            {
                assert(node != NULL);
                assert(node->m_rule_stack_level_ > 0);
                assert(node->m_parent_ != NULL);
                node->m_is_completed_ = true;
                ChildSet_::iterator it_start = node->m_parent_->m_child_set_.find(node);
                ChildSet_::iterator it_end = node->m_parent_->m_child_set_.end();
                assert(it_start != it_end);
                while (true)
                {
                    ChildSet_::iterator it = it_start;
                    ++it;
                    if (it == it_end)
                        break;
                    assert(*it != NULL);
                    assert((*it)->IsActionTreeNode_());
                    ActionTreeNode_ *outcompleted_sibling = static_cast<ActionTreeNode_ *>(*it);
                    Prune_(outcompleted_sibling, branch_set);
                }
                node = node->m_parent_;
            }
        }
*/
    /*
        static void Prune_ (ActionTreeNode_ *node, BranchSet_ &branch_set)
        {
            assert(node != NULL);
            assert(node->m_parent_ != NULL);
            while (!node->m_child_set_.empty())
            {
                ChildSet_::iterator it = node->m_child_set_.begin();
                TreeNode_ *child = *it;
                assert(child != NULL);
                if (child->IsActionTreeNode_())
                    Prune_(static_cast<ActionTreeNode_ *>(child), branch_set);
                else
                {
                    node->m_child_set_.erase(it);
                    child->m_parent_ = NULL; // to prevent meddling by ~TreeNode_()
                    assert(branch_set.find(static_cast<BranchTreeNode_ *>(child)) != branch_set.end());
                    branch_set.erase(static_cast<BranchTreeNode_ *>(child));
                    delete child;
                }
            }
            node->m_parent_->RemoveChild_(node);
            delete node;
        }
    */
    }; // end of struct TrisonCpp_::Npda_::ActionTreeNode_
    struct BranchTreeNode_ : public TreeNode_
    {
        StateStack_ m_state_stack_;
        TokenId_ m_lookahead_nonterminal_token_id_;
        bool m_is_epsilon_closed_;

        BranchTreeNode_ (State_ const *starting_state, Uint32_ rule_stack_level)
            :
            TreeNode_(rule_stack_level, BRANCH_TREE_NODE_),
            m_lookahead_nonterminal_token_id_(0), // none_
            m_is_epsilon_closed_(false)
        {
            assert(starting_state != NULL);
            m_state_stack_.push_back(starting_state);
        }

        virtual void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            std::string tab_string(2*indent_level, ' ');
            stream << tab_string << (m_is_epsilon_closed_ ? 'c' : '_') << '(' << m_rule_stack_level_ << ')';
            for (StateStack_::const_iterator it = m_state_stack_.begin(), it_end = m_state_stack_.end();
                 it != it_end;
                 ++it)
            {
                State_ const *stack_state = *it;
                assert(stack_state != NULL);
                stream << ' ' << (stack_state - state_table);
            }
            if (m_lookahead_nonterminal_token_id_ != 0) // none_
                stream << " (" << m_lookahead_nonterminal_token_id_ << ')';
            stream << ' ' << this << std::endl;
        }

        State_ const &Top_ () const
        {
            assert(!m_state_stack_.empty());
            assert(m_state_stack_.back() != NULL);
            return *m_state_stack_.back();
        }
        BranchTreeNode_ *Clone_ () const
        {
            BranchTreeNode_ *cloned = new BranchTreeNode_(*this);
            cloned->m_parent_ = NULL;
            cloned->m_is_epsilon_closed_ = false;
            return cloned;
        }
    }; // end of struct TrisonCpp_::Npda_::BranchTreeNode_
}; // end of class TrisonCpp_::Npda_

} // end of namespace TrisonCpp_
#endif // !defined(TrisonCpp_namespace_)
<*{if(is_defined(top_of_header_file))

<*{top_of_header_file
<*{end_if

class <{class_name} : private TrisonCpp_::Npda_<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    typedef <{token_data_type} TokenData_;

    enum ParserReturnCode
    {
        PRC_SUCCESS = 0,
        PRC_UNHANDLED_PARSE_ERROR = 1
    }; // end of enum <{class_name}::ParserReturnCode

    struct Terminal
    {
        enum Name
        {
<*{if(sizeof(_terminal_name_list) < 1)
<*{error("the terminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<*{error("mismatch in size of _terminal_name_list and _terminal_index_list")
<*{end_if
<*{loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    struct Nonterminal
    {
        enum Name
        {
<*{if(sizeof(_nonterminal_name_list) < 1)
<*{error("the nonterminal list should always have at least one element")
<*{end_if
<*{if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<*{error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<*{end_if
<*{loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<*{end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    struct StartNonterminal
    {
        enum Name
        {
<*{for_each(key, _npda_initial_node_index)
            <{key} = <{_npda_initial_node_index[key]},
<*{end_for_each
            // default starting nonterminal
            START_ = <{_start}
        }; // end of enum <{class_name}::StartNonterminal::Name
    }; // end of struct <{class_name}::StartNonterminal

    struct Token_
    {
        TokenId_ m_token_id_;
        TokenData_ m_token_data_;

        Token_ () : m_token_id_(Nonterminal::none_) { }
        Token_ (TokenId_ token_id, TokenData_ const &token_data)
            :
            m_token_id_(token_id),
            m_token_data_(token_data)
        {
            assert(m_token_id_ != Nonterminal::none_);
        }
    }; // end of struct <{class_name}::Token

private:

    typedef std::deque<Token_> TokenBuffer_;

<*{if(is_defined(top_of_class))
public:

<*{top_of_class

<*{end_if
public:

    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<*{if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<*{end_if
<*{if(is_defined(parse_method_access))
<*{if(!(parse_method_access == "public:" || parse_method_access == "protected:" || parse_method_access == "private:"))
<*{error("invalid parse_method_access \"" . parse_method_access . "\"")
<*{end_if
<{parse_method_access}

<*{end_if
    ParserReturnCode Parse (StartNonterminal::Name nonterminal_to_parse_ = StartNonterminal::<{_start});

private:

    static bool TransitionAcceptsTokenId_ (Transition_ const *transition, TokenId_ token_id)
    {
        assert(transition >= ms_transition_table_ && transition < ms_transition_table_ + ms_transition_count_);
        return transition->m_transition_type_ == Transition_::TT_SHIFT_ &&
               transition->m_transition_data_ == token_id;
    }

/*
    void ClearBranches_ ();
    void ClearTokenStack_ ();
    void ClearLookaheadQueue_ ();
    void ClearMostRecentReturnState_ ();
    void ClearReturnToken_ ();
*/
    void ThrowAwayToken_ (TokenData_ &token);
    void ResetForNewInput_ ();


    // blah
    ParserReturnCode Parse_ (StartNonterminal::Name nonterminal_to_parse_);
    Token_ &ShiftLookaheadToken_ ();
    void PerformEpsilonClosure_ ();
    void PerformEpsilonClosure_ (BranchTreeNode_ const &source_branch, StateStack_ &extra_state_stack);
//     void PerformReduceTransitions_ ();
//     void PerformReduceTransition_ (BranchTreeNode_ *branch, Rule_ const *reduction_rule);
//     void PerformShiftTransitionsAndSaveReturnActions_ ();
//     void PerformShiftTransition_ (BranchTreeNode_ *branch, State_ const *target_state);
//     void SaveReturnActions_ (BranchTreeNode_ *branch);
//     void PruneAllDoomedBranches_ ();
//     void PruneNonReturnStateDoomedBranches_ ();
//     void ExecuteAndRemoveTrunk_ ();
    // end blah



<*{loop(i, _rule_count)
    TokenData_ AcceptHandler<{i}_ ();
<*{end_loop

    // TODO: move as much stuff to the base class as possible
    ActionTreeNode_ *m_tree_root_;
    BranchSet_ m_branch_set_;
    bool m_is_shift_blocked_;
    bool m_reduce_transitions_were_performed_;
    bool m_shift_transitions_were_performed_;
    bool m_nonassoc_error_encountered_;
    bool m_there_are_doomed_branches_at_a_return_state_;
    BranchVector_ m_doomed_branch_list_;
    TokenBuffer_ m_token_stack_;
    TokenBuffer_ m_lookahead_queue_;
    TokenBuffer_::size_type m_lookahead_queue_cursor_;
<*{if(is_defined(generate_debug_spew_code))
    bool m_debug_spew_;

<*{end_if
    static TrisonCpp_::Npda_::Precedence_ const ms_precedence_table_[];
    static TrisonCpp_::Size_ const ms_precedence_count_;
    static TrisonCpp_::Npda_::Rule_ const ms_rule_table_[];
    static TrisonCpp_::Size_ const ms_rule_count_;
    static TrisonCpp_::Npda_::State_ const ms_state_table_[];
    static TrisonCpp_::Size_ const ms_state_count_;
    static TrisonCpp_::Npda_::Transition_ const ms_transition_table_[];
    static TrisonCpp_::Size_ const ms_transition_count_;
<*{if(is_defined(bottom_of_class))

public:
<{bottom_of_class}
<*{end_if
}; // end of class <{class_name}
<*{if(is_defined(bottom_of_header_file))

<*{bottom_of_header_file
<*{end_if
