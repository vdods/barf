// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// Parser.cpp generated by trison
// from Parser.trison using trison.cpp.targetspec and trison.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "Parser.hpp"



#define TRISON_CPP_DEBUG_CODE_(flags, spew_code) if (DebugSpewIsEnabled() && ((flags) & ActiveDebugSpewFlags()) != 0) { spew_code; }

#include <algorithm>
#include <limits>
#include <sstream>
#include <utility>


#line 76 "../bin/barftest/text/Parser.trison"

#include "barftest/literal.hpp"
#include "barftest/sem/Assignment.hpp"
#include "barftest/sem/BinaryOperation.hpp"
#include "barftest/sem/Break.hpp"
#include "barftest/sem/Conditional.hpp"
#include "barftest/sem/Declaration.hpp"
#include "barftest/sem/Definition.hpp"
#include "barftest/sem/Dummy.hpp"
#include "barftest/sem/ElementAccess.hpp"
#include "barftest/sem/ErrorDummy.hpp"
#include "barftest/sem/Function.hpp"
#include "barftest/sem/FunctionEvaluation.hpp"
#include "barftest/sem/FunctionPrototype.hpp"
#include "barftest/sem/FunctionType.hpp"
#include "barftest/sem/Identifier.hpp"
#include "barftest/sem/Initialization.hpp"
#include "barftest/sem/LLVMCast.hpp"
#include "barftest/sem/Loop.hpp"
#include "barftest/sem/NullPtr.hpp"
#include "barftest/sem/PointerType.hpp"
#include "barftest/sem/ReferenceType.hpp"
#include "barftest/sem/Return.hpp"
#include "barftest/sem/Specifier.hpp"
#include "barftest/sem/SymbolSpecifier.hpp"
#include "barftest/sem/Type.hpp"
#include "barftest/sem/TypeIdentifier.hpp"
#include "barftest/sem/UnaryOperation.hpp"
#include "barftest/sem/Vector.hpp"
#include "barftest/text/Scanner.hpp"

namespace barftest {
namespace text {

#line 54 "../bin/barftest/text/Parser.cpp"

Parser::Parser ()
{
    m_max_allowable_lookahead_count = 1;
    m_max_allowable_lookahead_queue_size = 2;
    m_max_allowable_parse_tree_depth = 64;
    m_realized_state_ = NULL;
    m_hypothetical_state_ = NULL;
    SetDebugSpewStream(NULL);
    SetActiveDebugSpewFlags(DSF__ALL);


#line 110 "../bin/barftest/text/Parser.trison"

    m_scanner = std::make_unique<Scanner>();
    // Passing `this` within this closure is fine because this Parser instance
    // will live beyond m_scanner.
    m_scanner->set_handler__record_message(
        [this](FiRange const &firange, std::string const &message){
            this->record_message(firange, message);
        }
    );
    m_scanner->set_handler__record_recoverable_error(
        [this](FiRange const &firange, std::string const &message){
            this->record_recoverable_error(firange, message);
        }
    );
    m_log_out = nullptr;
    m_recoverable_error_encountered = false;

#line 85 "../bin/barftest/text/Parser.cpp"
}

Parser::~Parser ()
{
    // Perform all the internal cleanup needed.
    CleanUpAllInternals_();
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 95 "../bin/barftest/text/Parser.cpp"
 << "Executing destructor actions\n")


#line 127 "../bin/barftest/text/Parser.trison"


#line 102 "../bin/barftest/text/Parser.cpp"
}

bool Parser::IsAtEndOfInput ()
{
    return true; // TEMP
}

std::string Parser::DebugSpewPrefix () const
{
    std::ostringstream out;
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 116 "../bin/barftest/text/Parser.cpp"
;
    return out.str();
}

void Parser::ResetForNewInput ()
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 126 "../bin/barftest/text/Parser.cpp"
 << "Executing reset-for-new-input actions\n")

    // Perform all the internal cleanup needed.
    CleanUpAllInternals_();


#line 325 "../bin/barftest/text/Parser.trison"

    m_recoverable_error_encountered = false;

#line 137 "../bin/barftest/text/Parser.cpp"
}

Parser::ParserReturnCode Parser::Parse (nnup<sem::Base> *return_token, Nonterminal::Name nonterminal_to_parse)
{

#line 129 "../bin/barftest/text/Parser.trison"

    assert(m_scanner != nullptr);
    record_message(m_scanner->firange(), "starting parser");

#line 148 "../bin/barftest/text/Parser.cpp"

    ParserReturnCode const parse_return_code = Parse_(return_token, nonterminal_to_parse);


#line 133 "../bin/barftest/text/Parser.trison"

    if (parse_return_code == PRC_SUCCESS)
        record_message(m_scanner->firange(), "parse was successful");

#line 158 "../bin/barftest/text/Parser.cpp"

    return parse_return_code;
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

void Parser::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 173 "../bin/barftest/text/Parser.cpp"
 << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 181 "../bin/barftest/text/Parser.cpp"
 << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, Parser::ParserReturnCode parser_return_code)
{
    if (std::size_t(parser_return_code) < Parser::ms_parser_return_code_string_count_)
        stream << Parser::ms_parser_return_code_string_table_[std::size_t(parser_return_code)];
    else
        stream << "!INVALID!ParserReturnCode!";
    return stream;
}

std::ostream &operator << (std::ostream &stream, Parser::Token const &token)
{
    if (token.m_id < Parser::ms_token_name_count_)
        stream << Parser::ms_token_name_table_[token.m_id];
    else
        stream << "!INVALID!TOKEN!";
    return stream;
}

char const *const Parser::ms_parser_return_code_string_table_[] =
{
    "PRC_SUCCESS",
    "PRC_UNHANDLED_PARSE_ERROR",
    "PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT",
    "PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE",
    "PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH",
    "PRC_INTERNAL_ERROR",
};
std::size_t const Parser::ms_parser_return_code_string_count_ = sizeof(Parser::ms_parser_return_code_string_table_) / sizeof(*Parser::ms_parser_return_code_string_table_);

char const *const Parser::ms_token_name_table_[] =
{
    "'\\0'",
    "'\\x01'",
    "'\\x02'",
    "'\\x03'",
    "'\\x04'",
    "'\\x05'",
    "'\\x06'",
    "'\\a'",
    "'\\b'",
    "'\\t'",
    "'\\n'",
    "'\\v'",
    "'\\f'",
    "'\\r'",
    "'\\x0E'",
    "'\\x0F'",
    "'\\x10'",
    "'\\x11'",
    "'\\x12'",
    "'\\x13'",
    "'\\x14'",
    "'\\x15'",
    "'\\x16'",
    "'\\x17'",
    "'\\x18'",
    "'\\x19'",
    "'\\x1A'",
    "'\\x1B'",
    "'\\x1C'",
    "'\\x1D'",
    "'\\x1E'",
    "'\\x1F'",
    "' '",
    "'!'",
    "'\"'",
    "'#'",
    "'$'",
    "'%'",
    "'&'",
    "'\\''",
    "'('",
    "')'",
    "'*'",
    "'+'",
    "','",
    "'-'",
    "'.'",
    "'/'",
    "'0'",
    "'1'",
    "'2'",
    "'3'",
    "'4'",
    "'5'",
    "'6'",
    "'7'",
    "'8'",
    "'9'",
    "':'",
    "';'",
    "'<'",
    "'='",
    "'>'",
    "'?'",
    "'@'",
    "'A'",
    "'B'",
    "'C'",
    "'D'",
    "'E'",
    "'F'",
    "'G'",
    "'H'",
    "'I'",
    "'J'",
    "'K'",
    "'L'",
    "'M'",
    "'N'",
    "'O'",
    "'P'",
    "'Q'",
    "'R'",
    "'S'",
    "'T'",
    "'U'",
    "'V'",
    "'W'",
    "'X'",
    "'Y'",
    "'Z'",
    "'['",
    "'\\\\'",
    "']'",
    "'^'",
    "'_'",
    "'`'",
    "'a'",
    "'b'",
    "'c'",
    "'d'",
    "'e'",
    "'f'",
    "'g'",
    "'h'",
    "'i'",
    "'j'",
    "'k'",
    "'l'",
    "'m'",
    "'n'",
    "'o'",
    "'p'",
    "'q'",
    "'r'",
    "'s'",
    "'t'",
    "'u'",
    "'v'",
    "'w'",
    "'x'",
    "'y'",
    "'z'",
    "'{'",
    "'|'",
    "'}'",
    "'~'",
    "'\\x7F'",
    "'\\x80'",
    "'\\x81'",
    "'\\x82'",
    "'\\x83'",
    "'\\x84'",
    "'\\x85'",
    "'\\x86'",
    "'\\x87'",
    "'\\x88'",
    "'\\x89'",
    "'\\x8A'",
    "'\\x8B'",
    "'\\x8C'",
    "'\\x8D'",
    "'\\x8E'",
    "'\\x8F'",
    "'\\x90'",
    "'\\x91'",
    "'\\x92'",
    "'\\x93'",
    "'\\x94'",
    "'\\x95'",
    "'\\x96'",
    "'\\x97'",
    "'\\x98'",
    "'\\x99'",
    "'\\x9A'",
    "'\\x9B'",
    "'\\x9C'",
    "'\\x9D'",
    "'\\x9E'",
    "'\\x9F'",
    "'\\xA0'",
    "'\\xA1'",
    "'\\xA2'",
    "'\\xA3'",
    "'\\xA4'",
    "'\\xA5'",
    "'\\xA6'",
    "'\\xA7'",
    "'\\xA8'",
    "'\\xA9'",
    "'\\xAA'",
    "'\\xAB'",
    "'\\xAC'",
    "'\\xAD'",
    "'\\xAE'",
    "'\\xAF'",
    "'\\xB0'",
    "'\\xB1'",
    "'\\xB2'",
    "'\\xB3'",
    "'\\xB4'",
    "'\\xB5'",
    "'\\xB6'",
    "'\\xB7'",
    "'\\xB8'",
    "'\\xB9'",
    "'\\xBA'",
    "'\\xBB'",
    "'\\xBC'",
    "'\\xBD'",
    "'\\xBE'",
    "'\\xBF'",
    "'\\xC0'",
    "'\\xC1'",
    "'\\xC2'",
    "'\\xC3'",
    "'\\xC4'",
    "'\\xC5'",
    "'\\xC6'",
    "'\\xC7'",
    "'\\xC8'",
    "'\\xC9'",
    "'\\xCA'",
    "'\\xCB'",
    "'\\xCC'",
    "'\\xCD'",
    "'\\xCE'",
    "'\\xCF'",
    "'\\xD0'",
    "'\\xD1'",
    "'\\xD2'",
    "'\\xD3'",
    "'\\xD4'",
    "'\\xD5'",
    "'\\xD6'",
    "'\\xD7'",
    "'\\xD8'",
    "'\\xD9'",
    "'\\xDA'",
    "'\\xDB'",
    "'\\xDC'",
    "'\\xDD'",
    "'\\xDE'",
    "'\\xDF'",
    "'\\xE0'",
    "'\\xE1'",
    "'\\xE2'",
    "'\\xE3'",
    "'\\xE4'",
    "'\\xE5'",
    "'\\xE6'",
    "'\\xE7'",
    "'\\xE8'",
    "'\\xE9'",
    "'\\xEA'",
    "'\\xEB'",
    "'\\xEC'",
    "'\\xED'",
    "'\\xEE'",
    "'\\xEF'",
    "'\\xF0'",
    "'\\xF1'",
    "'\\xF2'",
    "'\\xF3'",
    "'\\xF4'",
    "'\\xF5'",
    "'\\xF6'",
    "'\\xF7'",
    "'\\xF8'",
    "'\\xF9'",
    "'\\xFA'",
    "'\\xFB'",
    "'\\xFC'",
    "'\\xFD'",
    "'\\xFE'",
    "'\\xFF'",
    "END_",
    "ERROR_",
    "FANCYOP",
    "CT",
    "RT",
    "LOCAL",
    "GLOBAL",
    "EXTERNAL",
    "INTERNAL",
    "PRIVATE",
    "DEFINE",
    "INITIALIZE",
    "ASSIGN",
    "MAPS_TO",
    "IF",
    "THEN",
    "OTHERWISE",
    "WHILE",
    "DO",
    "STATEMENT_DELIMITER",
    "EQUALS",
    "NOT_EQUALS",
    "LESS_THAN",
    "GREATER_THAN",
    "LESS_OR_EQUAL",
    "GREATER_OR_EQUAL",
    "NOT",
    "AND",
    "OR",
    "XOR",
    "NULLPTR",
    "BAD_TOKEN",
    "END_OF_FILE",
    "BREAK",
    "RETURN",
    "IDENTIFIER",
    "BOOLEAN",
    "SINT8",
    "SINT16",
    "SINT32",
    "SINT64",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "FLOAT32",
    "FLOAT64",
    "TYPE_KEYWORD",
    "VALUE_LITERAL",
    "VOID_TYPE",
    "NULL_TYPE",
    "LLVM_CAST_KEYWORD",
    "STRING_LITERAL",
    "VALUE_KIND_SPECIFIER",
    "VALUE_LIFETIME_SPECIFIER",
    "root",
    "expression_then_end",
    "expression_then_lookahead_end",
    "parenthesized_expression",
    "parenthesized_expression_ender",
    "expression_tuple",
    "expression_tuple_ender",
    "expression_tuple_body",
    "expression_tuple_body_element",
    "expression_tuple_body_element_ender",
    "expression",
    "element_access_key_ender",
    "element_access_key_body_element",
    "element_access_key_body_element_ender",
    "parameter_list_ender",
    "parameter_list_body",
    "parameter_list_body_element",
    "parameter_list_body_element_ender",
    "function_literal",
    "function_prototype",
    "function_prototype_domain_declaration_tuple",
    "type_tuple",
    "type_tuple_ender",
    "type_tuple_body",
    "type_tuple_body_element",
    "type_tuple_body_element_ender",
    "type_expression",
    "function_type",
    "function_type_domain",
    "function_type_then_end",
    "symbol_specifier",
    "declaration_statement",
    "declaration_statement_type",
    "initialization_statement",
    "initialization_id",
    "initialization_statement_content",
    "definition_statement",
    "definition_symbol_specifier",
    "definition_statement_content",
    "assignment_statement",
    "assignment_target",
    "assignment_statement_content",
    "declaration_tuple",
    "declaration_tuple_ender",
    "declaration_tuple_body",
    "declaration_tuple_body_element",
    "declaration_symbol_specifier",
    "declaration_tuple_body_element_type",
    "declaration_tuple_body_element_ender",
    "statement_then_end",
    "statement",
    "statement_ender",
    "bracketed_statement_list",
    "bracketed_statement_list_ender",
    "statement_list_then_end",
    "statement_list",
    "lookahead_test_expression_then_end",
    "lookahead_test_expression",
    "id_list_then_end",
    "id_list",
    "parenthesized_id_list"
};
std::size_t const Parser::ms_token_name_count_ = sizeof(Parser::ms_token_name_table_) / sizeof(*Parser::ms_token_name_table_);

void Parser::ThrowAwayToken_ (Token &&token_) throw()
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 600 "../bin/barftest/text/Parser.cpp"
 << "Executing throw-away-token actions on token " << token_ << '\n')
    ThrowAwayTokenData_(std::move(token_.m_data));
}

void Parser::ThrowAwayTokenData_ (Token::Data &&token_data) throw()
{

#line 294 "../bin/barftest/text/Parser.trison"
 
#line 610 "../bin/barftest/text/Parser.cpp"
}

Parser::Token::Data Parser::InsertLookaheadErrorActions_ (Token const &noconsume_lookahead_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 618 "../bin/barftest/text/Parser.cpp"
 << "Executing insert-lookahead-error actions on lookahead token " << ms_token_name_table_[noconsume_lookahead_token.m_id] << '\n')

#line 295 "../bin/barftest/text/Parser.trison"

    // Make a 0-char FiRange from the start of the lookahead's FiRange to use for the error.
    return sem::make_error_dummy(noconsume_lookahead_token.m_data->firange().start_as_firange());

#line 626 "../bin/barftest/text/Parser.cpp"
}

Parser::Token::Data Parser::DiscardLookaheadActions_ (Token &&consume_stack_top_error_token, Token &&consume_lookahead_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 634 "../bin/barftest/text/Parser.cpp"
 << "Executing discard-lookahead actions on stack top error token " << ms_token_name_table_[consume_stack_top_error_token.m_id] << " and lookahead token " << ms_token_name_table_[consume_lookahead_token.m_id] << '\n')

#line 299 "../bin/barftest/text/Parser.trison"

    // Use the union of the FiRanges for the stack top and lookahead for the error.
    // No need to delete anything, since we're using nnup.
    assert(consume_lookahead_token.m_id != Terminal::END_);
    return sem::make_error_dummy(firange_of(consume_lookahead_token.m_data) + firange_of(consume_stack_top_error_token.m_data));

#line 644 "../bin/barftest/text/Parser.cpp"
}

Parser::Token::Data Parser::PopStack1Actions_ (std::vector<Token> &&consume_stack_top_tokens, Token &&consume_lookahead_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 652 "../bin/barftest/text/Parser.cpp"
 << "Executing pop-stack-1 actions on stack top token " << ms_token_name_table_[consume_stack_top_tokens[0].m_id] << " and lookahead token " << ms_token_name_table_[consume_lookahead_token.m_id] << '\n')

#line 305 "../bin/barftest/text/Parser.trison"

    // Use the union of the FiRanges for the stack top and lookahead for the error.
    // No need to delete anything, since we're using nnup.
    return sem::make_error_dummy(firange_of(consume_lookahead_token.m_data) + firange_of(consume_stack_top_tokens[0].m_data));

#line 661 "../bin/barftest/text/Parser.cpp"
}

Parser::Token::Data Parser::PopStack2Actions_ (std::vector<Token> &&consume_stack_top_tokens, Token const &noconsume_lookahead_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 669 "../bin/barftest/text/Parser.cpp"
 << "Executing pop-stack-2 actions on stack top tokens [" << ms_token_name_table_[consume_stack_top_tokens[0].m_id] << ", " << ms_token_name_table_[consume_stack_top_tokens[1].m_id] << "] and lookahead token " << ms_token_name_table_[noconsume_lookahead_token.m_id] << '\n')

#line 310 "../bin/barftest/text/Parser.trison"

    // Use the union of the FiRanges for the 2 top stack tokens for the error.
    // No need to delete anything, since we're using nnup.
    assert(consume_stack_top_tokens.size() == 2);
    return sem::make_error_dummy(firange_of(consume_stack_top_tokens[0].m_data) + firange_of(consume_stack_top_tokens[1].m_data));

#line 679 "../bin/barftest/text/Parser.cpp"
}

Parser::Token::Data Parser::RunNonassocErrorActions_ (Token const &noconsume_lookahead_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 687 "../bin/barftest/text/Parser.cpp"
 << "Executing nonassoc-error actions on lookahead token " << ms_token_name_table_[noconsume_lookahead_token.m_id] << '\n')

#line 320 "../bin/barftest/text/Parser.trison"

    auto err = sem::make_error_dummy(noconsume_lookahead_token.m_data->firange().start_as_firange());
    record_recoverable_error(err->firange(), "operator " + TokenIdAsString(noconsume_lookahead_token.m_id) + " is non-associative and therefore can't be composed; use parentheses to disambiguate the expression if this usage is not a mistake");
    return err;

#line 696 "../bin/barftest/text/Parser.cpp"
}

Parser::Token Parser::Scan_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(DSF_SCANNER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 704 "../bin/barftest/text/Parser.cpp"
 << "Executing scan actions to retrieve next token...\n")


#line 316 "../bin/barftest/text/Parser.trison"

    assert(m_scanner != nullptr);
    return m_scanner->Scan();

#line 713 "../bin/barftest/text/Parser.cpp"

    TRISON_CPP_DEBUG_CODE_(DSF_PROGRAMMER_ERROR, *DebugSpewStream() << "PROGRAMMER ERROR: No value returned from scan_actions code block\n")
    assert(false && "no value returned from scan_actions code block");
}

template <typename T>
std::ostream &operator << (std::ostream &out, std::set<T> const &s)
{
    out << "{ ";
    for (typename std::set<T>::const_iterator it = s.begin(), it_end = s.end(); it != it_end; ++it)
        out << *it << ", ";
    out << '}';
    return out;
}

template <typename T>
std::ostream &operator << (std::ostream &out, std::vector<T> const &s)
{
    out << "[ ";
    for (typename std::vector<T>::const_iterator it = s.begin(), it_end = s.end(); it != it_end; ++it)
        out << *it << ", ";
    out << ']';
    return out;
}

std::uint32_t Parser::NonterminalStartStateIndex_ (Parser::Nonterminal::Name nonterminal)
{
    switch (nonterminal)
    {
        case Nonterminal::assignment_statement: return 557;
        case Nonterminal::assignment_statement_content: return 572;
        case Nonterminal::assignment_target: return 562;
        case Nonterminal::bracketed_statement_list: return 17;
        case Nonterminal::bracketed_statement_list_ender: return 24;
        case Nonterminal::declaration_statement: return 32;
        case Nonterminal::declaration_statement_type: return 73;
        case Nonterminal::declaration_symbol_specifier: return 37;
        case Nonterminal::declaration_tuple: return 144;
        case Nonterminal::declaration_tuple_body: return 150;
        case Nonterminal::declaration_tuple_body_element: return 156;
        case Nonterminal::declaration_tuple_body_element_ender: return 168;
        case Nonterminal::declaration_tuple_body_element_type: return 162;
        case Nonterminal::declaration_tuple_ender: return 184;
        case Nonterminal::definition_statement: return 525;
        case Nonterminal::definition_statement_content: return 540;
        case Nonterminal::definition_symbol_specifier: return 530;
        case Nonterminal::element_access_key_body_element: return 464;
        case Nonterminal::element_access_key_body_element_ender: return 470;
        case Nonterminal::element_access_key_ender: return 480;
        case Nonterminal::expression: return 277;
        case Nonterminal::expression_then_end: return 637;
        case Nonterminal::expression_then_lookahead_end: return 646;
        case Nonterminal::expression_tuple: return 304;
        case Nonterminal::expression_tuple_body: return 310;
        case Nonterminal::expression_tuple_body_element: return 316;
        case Nonterminal::expression_tuple_body_element_ender: return 322;
        case Nonterminal::expression_tuple_ender: return 335;
        case Nonterminal::function_literal: return 488;
        case Nonterminal::function_prototype: return 134;
        case Nonterminal::function_prototype_domain_declaration_tuple: return 139;
        case Nonterminal::function_type: return 118;
        case Nonterminal::function_type_domain: return 123;
        case Nonterminal::function_type_then_end: return 653;
        case Nonterminal::id_list: return 709;
        case Nonterminal::id_list_then_end: return 704;
        case Nonterminal::initialization_id: return 259;
        case Nonterminal::initialization_statement: return 254;
        case Nonterminal::initialization_statement_content: return 269;
        case Nonterminal::lookahead_test_expression: return 676;
        case Nonterminal::lookahead_test_expression_then_end: return 671;
        case Nonterminal::parameter_list_body: return 429;
        case Nonterminal::parameter_list_body_element: return 435;
        case Nonterminal::parameter_list_body_element_ender: return 441;
        case Nonterminal::parameter_list_ender: return 454;
        case Nonterminal::parenthesized_expression: return 282;
        case Nonterminal::parenthesized_expression_ender: return 289;
        case Nonterminal::parenthesized_id_list: return 720;
        case Nonterminal::root: return 1;
        case Nonterminal::statement: return 12;
        case Nonterminal::statement_ender: return 79;
        case Nonterminal::statement_list: return 6;
        case Nonterminal::statement_list_then_end: return 665;
        case Nonterminal::statement_then_end: return 659;
        case Nonterminal::symbol_specifier: return 42;
        case Nonterminal::type_expression: return 87;
        case Nonterminal::type_tuple: return 196;
        case Nonterminal::type_tuple_body: return 202;
        case Nonterminal::type_tuple_body_element: return 208;
        case Nonterminal::type_tuple_body_element_ender: return 214;
        case Nonterminal::type_tuple_ender: return 227;
        default: assert(false && "invalid nonterminal"); return 0;
    }
}

bool Parser::HasEncounteredErrorState () const
{
    return (m_realized_state_ == NULL) ? false : m_realized_state_->HasEncounteredErrorState();
}

std::int64_t Parser::MaxAllowableLookaheadCount () const
{
    return m_max_allowable_lookahead_count;
}

std::size_t Parser::MaxRealizedLookaheadCount () const
{
    return (m_realized_state_ == NULL) ? 0 : m_realized_state_->MaxRealizedLookaheadCount();
}

std::int64_t Parser::MaxAllowableLookaheadQueueSize () const
{
    return m_max_allowable_lookahead_queue_size;
}

std::size_t Parser::MaxRealizedLookaheadQueueSize () const
{
    return (m_realized_state_ == NULL) ? 0 : m_realized_state_->MaxRealizedLookaheadQueueSize();
}

std::int64_t Parser::MaxAllowableParseTreeDepth () const
{
    return m_max_allowable_parse_tree_depth;
}

std::uint32_t Parser::MaxRealizedParseTreeDepth () const
{
    return (m_hypothetical_state_ == NULL) ? 0 : m_hypothetical_state_->m_max_realized_parse_tree_depth;
}

void Parser::SetMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count)
{
    m_max_allowable_lookahead_count = max_allowable_lookahead_count;
}

void Parser::SetMaxAllowableLookaheadQueueSize (std::int64_t max_allowable_lookahead_queue_size)
{
    m_max_allowable_lookahead_queue_size = max_allowable_lookahead_queue_size;
}

void Parser::SetMaxAllowableParseTreeDepth (std::int64_t max_allowable_parse_tree_depth)
{
    m_max_allowable_parse_tree_depth = max_allowable_parse_tree_depth;
}

Parser::ParserReturnCode Parser::Parse_ (Token::Data *return_token, Nonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

    TRISON_CPP_DEBUG_CODE_(DSF_START_END_PARSE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 865 "../bin/barftest/text/Parser.cpp"
 << "Starting parse\n")

    ParserReturnCode parser_return_code_ = PRC_INTERNAL_ERROR;
    *return_token = parser_static_move_cast<nnup<sem::Base>>(sem::make_dummy());


    std::uint32_t start_state_index = NonterminalStartStateIndex_(nonterminal_to_parse);

    if (m_realized_state_ != NULL) // This happens when parsing again, not from scratch.
    {
        assert(m_hypothetical_state_ == NULL);
        // Note that this resets the error state.
        m_realized_state_->Reinitialize(start_state_index);
        // Delete this entirely to be initialized anew, since it has no state that
        // carries over between parses.
        delete m_hypothetical_state_;
        m_hypothetical_state_ = NULL;
    }
    else // This happens when parsing for the first time.
        m_realized_state_ = new RealizedState_(start_state_index);

    assert(m_realized_state_->BranchVectorStack().size() == 2);
    assert(m_realized_state_->BranchVectorStack().back().size() == 1);

    m_hypothetical_state_ = new HypotheticalState_(m_realized_state_->BranchVectorStack().back()[0]);

    TRISON_CPP_DEBUG_CODE_(DSF_STACK_AND_LOOKAHEADS,
        *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 896 "../bin/barftest/text/Parser.cpp"
 << "<stack> . <lookaheads>: ";
        m_realized_state_->PrintStackAndLookaheads(*DebugSpewStream());
        *DebugSpewStream() << '\n';
    )

    bool should_return = false;
    std::size_t iteration_index = 0;
    while (!should_return)
    {
        TRISON_CPP_DEBUG_CODE_(
            DSF_ITERATION_COUNT,
            *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 911 "../bin/barftest/text/Parser.cpp"
 << "\n";
            *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 916 "../bin/barftest/text/Parser.cpp"
 << "---------- ITERATION " << iteration_index << " --------------\n";
            PrintParserStatus_(*DebugSpewStream());
            *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 922 "../bin/barftest/text/Parser.cpp"
 << '\n';
        )

        if (m_realized_state_->HasExceededMaxAllowableLookaheadCount(m_max_allowable_lookahead_count))
        {
            TRISON_CPP_DEBUG_CODE_(DSF_LIMIT_EXCEEDED, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 931 "../bin/barftest/text/Parser.cpp"
 << "Max realized lookahead count (" << m_realized_state_->MaxRealizedLookaheadCount() << ") has exceeded max allowable lookahead token count (" << m_max_allowable_lookahead_count << "); modify this limit using the default_max_allowable_lookahead_count directive (see trison.cpp.targetspec), or using the SetMaxAllowableLookaheadCount method.  Returning with error.\n")
            parser_return_code_ = PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT;
            break;
        }

        if (m_realized_state_->HasExceededMaxAllowableLookaheadQueueSize(m_max_allowable_lookahead_queue_size))
        {
            TRISON_CPP_DEBUG_CODE_(DSF_LIMIT_EXCEEDED, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 942 "../bin/barftest/text/Parser.cpp"
 << "Max realized lookahead queue size (" << m_realized_state_->MaxRealizedLookaheadQueueSize() << ") has exceeded max allowable lookahead queue size (" << m_max_allowable_lookahead_queue_size << "); modify this limit using the default_max_allowable_lookahead_queue_size directive (see trison.cpp.targetspec), or using the SetMaxAllowableLookaheadQueueSize method.  Returning with error.\n")
            parser_return_code_ = PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE;
            break;
        }

        if (m_hypothetical_state_->HasExceededMaxAllowableParseTreeDepth(m_max_allowable_parse_tree_depth))
        {
            TRISON_CPP_DEBUG_CODE_(DSF_LIMIT_EXCEEDED, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 953 "../bin/barftest/text/Parser.cpp"
 << "Parse tree depth (" << m_hypothetical_state_->ParseTreeDepth() << ") has exceeded max allowable parse tree depth (" << m_max_allowable_parse_tree_depth << "); modify this limit using the default_max_allowable_parse_tree_depth directive (see trison.cpp.targetspec), or using the SetMaxAllowableParseTreeDepth method.  Returning with error.\n")
            parser_return_code_ = PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH;
            break;
        }

        if (m_hypothetical_state_->m_root->HasTrunkChild())
            ExecuteAndRemoveTrunkActions_(should_return, parser_return_code_, return_token);
        else
            ContinueNPDAParse_(should_return);

        TRISON_CPP_DEBUG_CODE_(DSF_ITERATION_COUNT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 967 "../bin/barftest/text/Parser.cpp"
 << '\n')
        ++iteration_index;
    }

    TRISON_CPP_DEBUG_CODE_(
        DSF_ITERATION_COUNT,
        *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 977 "../bin/barftest/text/Parser.cpp"
 << "\n";
        *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 982 "../bin/barftest/text/Parser.cpp"
 << "---------- RETURNING --------------\n";
        PrintParserStatus_(*DebugSpewStream());
        *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 988 "../bin/barftest/text/Parser.cpp"
 << '\n';
    )

    assert(std::size_t(parser_return_code_) < ms_parser_return_code_string_count_ && "this should never happen");
    TRISON_CPP_DEBUG_CODE_(
        DSF_START_END_PARSE,
        *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 998 "../bin/barftest/text/Parser.cpp"
 << "Parse() is returning " << ms_parser_return_code_string_table_[parser_return_code_] << '\n';
    )

    return parser_return_code_;
}

void Parser::ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code_, Token::Data *&return_token)
{
    TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1010 "../bin/barftest/text/Parser.cpp"
 << "Parse stack tree has trunk; executing trunk actions.\n")
    TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1015 "../bin/barftest/text/Parser.cpp"
 << '\n')

    if (m_hypothetical_state_->m_root->HasTrunkChild())
    {
        // The trunk_child is popped and then will die by the end of this function.
        // Using std::unique_ptr for exception safety -- if an exception is thrown within
        // this function, then trunk_child still needs to be deleted.
        std::unique_ptr<ParseTreeNode_> trunk_child(m_hypothetical_state_->m_root->PopTrunkChild());
        assert(trunk_child->m_parent_node == NULL);
        assert(trunk_child->m_child_nodes.empty());

        bool destroy_and_recreate_parse_tree = false;

        switch (trunk_child->m_spec.m_type)
        {
            case ParseTreeNode_::RETURN: {
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1035 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action RETURN.\n")
                assert(m_realized_state_->TokenStack().size() == 3);
                parser_return_code_ = PRC_SUCCESS;
                // This doesn't change the structure of the stack but does take ownership of the top stack token.
                // This must be done so that the return token isn't destroyed with the parser.
                m_realized_state_->StealTokenStackTop(return_token);
                should_return = true;
                break;
            }
            case ParseTreeNode_::ABORT: {
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1049 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action ABORT.\n")
                assert(m_realized_state_->TokenStack().size() == 1);
                parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
                should_return = true;
                break;
            }
            case ParseTreeNode_::REDUCE: {
                // Execute the appropriate rule on the top tokens in the stack
                std::uint32_t const &rule_index = trunk_child->m_spec.m_single_data;
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1062 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action REDUCE rule " << rule_index << "; " << Grammar_::ms_rule_table_[rule_index].m_description << '\n')
                Grammar_::Rule_ const &rule = Grammar_::ms_rule_table_[rule_index];
                Token const *lookahead = NULL;
                if (rule.m_has_lookahead_directive)
                {
                    assert(!m_realized_state_->LookaheadQueue().empty());
                    lookahead = &m_realized_state_->LookaheadQueue().front();
                }
                Token::Data reduced_nonterminal_token_data = ExecuteReductionRule_(rule_index, m_realized_state_->TokenStack(), lookahead);
                m_realized_state_->ExecuteActionReduce(rule, std::move(reduced_nonterminal_token_data), m_hypothetical_state_->m_hps_queue);
                // This is done essentially so that m_realized_lookahead_cursor can be reset.
                destroy_and_recreate_parse_tree = true;
                break;
            }
            case ParseTreeNode_::SHIFT: {
                std::uint32_t const &shifted_token_id = trunk_child->m_spec.m_single_data;
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1082 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action SHIFT " << Token(shifted_token_id) << '\n')
                m_realized_state_->ExecuteActionShift(trunk_child->m_child_branch_vector, m_hypothetical_state_->m_hps_queue);
                break;
            }
            case ParseTreeNode_::INSERT_LOOKAHEAD_ERROR: {
                // INSERT_LOOKAHEAD_ERROR -- this should have access to the lookahead that
                // caused the error to be generated, and it should return a token that will
                // be used as the %error token.
                //
                // Start:  <realized-stack-tokens> . <lookahead>
                //                                 ^~~~~~~~~~^
                //                                 input to handler code
                //
                // Result: <realized-stack-tokens> . <%error> <lookahead>
                //                                   ^~~~~~~^
                //                                   output from handler code

                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1103 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action INSERT_LOOKAHEAD_ERROR, and setting has-encountered-error-state flag.\n")
                Token const &lookahead = Lookahead_(0);
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1109 "../bin/barftest/text/Parser.cpp"
 << "Lookahead retrieved from Lookahead_(0) for INSERT_LOOKAHEAD_ERROR action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                {   // This code block is just to limit the scope of resulting_error_token
                    Token resulting_error_token(Terminal::ERROR_, InsertLookaheadErrorActions_(lookahead));
                    m_realized_state_->PushFrontLookahead(std::move(resulting_error_token), m_hypothetical_state_->m_hps_queue);
                }
                m_realized_state_->SetHasEncounteredErrorState();
                //m_realized_state_->ExecuteActionInsertLookaheadError(m_hypothetical_state_->m_hps_queue);
                break;
            }
            case ParseTreeNode_::DISCARD_LOOKAHEAD: {
                // DISCARD_LOOKAHEAD -- this can only happen if the top of the realized stack
                // is %error; it should have access to the %error token and the lookahead
                // token, and it should return a token that will be used as the resulting
                // %error token (e.g. combining the file locations of the two input tokens).
                //
                // Start:  <realized-stack-tokens> <%error> . <lookahead0> <rest-of-lookaheads>
                //                                 ^~~~~~~~~~~~~~~~~~~~~~^
                //                                 inputs to handler code
                //
                // Result: <realized-stack-tokens> <%error> . <rest-of-lookaheads>
                //                                 ^~~~~~~^
                //                                 output from handler code (old stack top is replaced)

                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1136 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action DISCARD_LOOKAHEAD.\n")
                assert(m_realized_state_->TokenStack().back().m_id == Terminal::ERROR_);
                Token lookahead(m_realized_state_->PopFrontLookahead(m_hypothetical_state_->m_hps_queue));
                Token resulting_error_token = Token(Terminal::ERROR_, DiscardLookaheadActions_(std::move(m_realized_state_->TokenStack().back()), std::move(lookahead)));
                m_realized_state_->ReplaceTokenStackTopWith(std::move(resulting_error_token));
                //m_realized_state_->ExecuteActionDiscardLookahead(m_hypothetical_state_->m_hps_queue);
                break;
            }
            case ParseTreeNode_::POP_STACK: {
                // POP_STACK 1 -- this can only happen when the lookahead is %error (and in
                // this case, the top of the realized stack is not %error); it should have
                // access to the token about to be popped and the lookahead %error token, and
                // it should return a token that will be used as the resulting %error token
                // (e.g. combining the file locations of the two input tokens).
                //
                // Start:  <realized-stack-tokens> <token0> . <%error> <rest-of-lookaheads>
                //                                 ^~~~~~~~~~~~~~~~~~^
                //                                 inputs to handler code
                //
                // Result: <realized-stack-tokens> . <%error> <rest-of-lookaheads>
                //                                   ^~~~~~~^
                //                                   output from handler code
                //
                // POP_STACK 2 -- this can only happen when the lookahead is %end; it should
                // have access to the 2 tokens about to be popped and the lookahead %end token,
                // and it should return a token that will be used as the resulting %error token
                // (e.g. combining the file locations of the three input tokens).
                //
                // Start:  <realized-stack-tokens> <token1> <token0> . <%end>
                //                                 ^~~~~~~~~~~~~~~~~~~~~~~~~^
                //                                 inputs to handler code
                //
                // Result: <realized-stack-tokens> . <%error> <%end>
                //                                   ^~~~~~~^
                //                                   output from handler code
                //
                // NOTE: The semantics for POP_STACK 1 and POP_STACK 2 are different; the handler
                // code is expected to consume (e.g. delete, aggregate, etc) all inputs for
                // POP_STACK 1, and is expected to only consume the popped stack tokens for
                // POP_STACK 2 (and only read from the lookahead).

                std::uint32_t const &pop_count = trunk_child->m_spec.m_single_data;
                TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1182 "../bin/barftest/text/Parser.cpp"
 << "Executing trunk action POP_STACK " << pop_count << ".\n")
                assert(pop_count == 1 || pop_count == 2);
                assert(m_realized_state_->TokenStack().size() > pop_count);

                if (pop_count == 1)
                {
                    std::vector<Token> popped_tokens;
                    popped_tokens.emplace_back(m_realized_state_->PopStack());
                    assert(popped_tokens.size() == pop_count);
                    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1195 "../bin/barftest/text/Parser.cpp"
 << "Lookahead for POP_STACK action is " << ms_token_name_table_[Lookahead_(0).m_id] << '\n')

                    Token lookahead(std::move(m_realized_state_->PopFrontLookahead(m_hypothetical_state_->m_hps_queue)));
                    TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1202 "../bin/barftest/text/Parser.cpp"
 << "lookahead for POP_STACK " << pop_count << " action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                    assert(lookahead.m_id == Terminal::ERROR_);
                    {   // This code block is just to limit the scope of resulting_error_token
                        Token resulting_error_token(Terminal::ERROR_, PopStack1Actions_(std::move(popped_tokens), std::move(lookahead)));
                        m_realized_state_->PushFrontLookahead(std::move(resulting_error_token), m_hypothetical_state_->m_hps_queue);
                    }
                }
                else
                {
                    assert(pop_count == 2);

                    if (false)
                    {
                        // plain ol' pop stack 2 times -- this is the old behavior

                        std::vector<Token> popped_tokens;
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens[1] = std::move(m_realized_state_->PopStack());
                        popped_tokens[0] = std::move(m_realized_state_->PopStack());
                        assert(popped_tokens.size() == pop_count);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1227 "../bin/barftest/text/Parser.cpp"
 << "Lookahead for POP_STACK action is " << ms_token_name_table_[Lookahead_(0).m_id] << '\n')

                        Token const &lookahead = Lookahead_(0);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1234 "../bin/barftest/text/Parser.cpp"
 << "lookahead for POP_STACK " << pop_count << " action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                        PopStack2Actions_(std::move(popped_tokens), lookahead);
                    }
                    else if (true)
                    {
                        // pop stack 2 times, then push the result onto the front of the lookahead queue.

                        std::vector<Token> popped_tokens;
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens[1] = std::move(m_realized_state_->PopStack());
                        popped_tokens[0] = std::move(m_realized_state_->PopStack());
                        assert(popped_tokens.size() == pop_count);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1251 "../bin/barftest/text/Parser.cpp"
 << "Lookahead for POP_STACK action is " << ms_token_name_table_[Lookahead_(0).m_id] << '\n')

                        Token const &lookahead = Lookahead_(0);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1258 "../bin/barftest/text/Parser.cpp"
 << "lookahead for POP_STACK " << pop_count << " action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                        {   // This code block is just to limit the scope of resulting_error_token
                            Token resulting_error_token(Terminal::ERROR_, PopStack2Actions_(std::move(popped_tokens), lookahead));
                            m_realized_state_->PushFrontLookahead(std::move(resulting_error_token), m_hypothetical_state_->m_hps_queue);
                        }
                    }
                    else if (false)
                    {
                        // pop stack 2 times and push resulting error token onto stack -- this is new behavior

                        std::vector<Token> popped_tokens;
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens[1] = std::move(m_realized_state_->PopStack());
                        popped_tokens[0] = std::move(m_realized_state_->TokenStack().back()); // Don't pop this one; will replace.
                        assert(popped_tokens.size() == pop_count);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1278 "../bin/barftest/text/Parser.cpp"
 << "Lookahead for POP_STACK action is " << ms_token_name_table_[Lookahead_(0).m_id] << '\n')

                        Token const &lookahead = Lookahead_(0);
                        //assert(lookahead.m_id == Terminal::END_);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1286 "../bin/barftest/text/Parser.cpp"
 << "lookahead for POP_STACK " << pop_count << " action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                        {   // This code block is just to limit the scope of resulting_error_token
                            Token resulting_error_token(Terminal::ERROR_, PopStack2Actions_(std::move(popped_tokens), lookahead));
                            m_realized_state_->ReplaceTokenStackTopWith(std::move(resulting_error_token));
                        }
                    }
                    else
                    {
                        // TEMP: pop 3 times

                        // pop stack 2 times and push resulting error token onto stack -- this is new behavior

                        std::uint32_t pop_count = 3; // shadowing earlier one
                        assert(m_realized_state_->TokenStack().size() >= pop_count);

                        std::vector<Token> popped_tokens;
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens.emplace_back(Token(Nonterminal::none_));
                        popped_tokens[2] = std::move(m_realized_state_->PopStack());
                        popped_tokens[1] = std::move(m_realized_state_->PopStack());
                        popped_tokens[0] = std::move(m_realized_state_->TokenStack().back()); // Don't pop this one; will replace.
                        assert(popped_tokens.size() == pop_count);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1313 "../bin/barftest/text/Parser.cpp"
 << "Lookahead for POP_STACK action is " << ms_token_name_table_[Lookahead_(0).m_id] << '\n')

                        Token const &lookahead = Lookahead_(0);
                        //assert(lookahead.m_id == Terminal::END_);
                        TRISON_CPP_DEBUG_CODE_(DSF_PARSER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1321 "../bin/barftest/text/Parser.cpp"
 << "lookahead for POP_STACK " << pop_count << " action is " << ms_token_name_table_[lookahead.m_id] << '\n')
                        {   // This code block is just to limit the scope of resulting_error_token
                            Token resulting_error_token(Terminal::ERROR_, PopStack2Actions_(std::move(popped_tokens), lookahead));
                            m_realized_state_->ReplaceTokenStackTopWith(std::move(resulting_error_token));
                        }
                    }
                }

                // Because POP_STACK involves popping the stack, the parse tree should be destroyed and
                // recreated (from the branches in the top of the realized state stack).  This is somewhat
                // draconian and non-optimal, but simple and effective.
                destroy_and_recreate_parse_tree = true;
                // TODO: Because HPS branches are blocked right after POP_STACK, maybe don't bother adding any
                // additional children below POP_STACK nodes (i.e. one HPS child of POP_STACK is sufficient to
                // keep it alive probably).  This would reduce the number of memory operations.
                break;
            }

            default:
                assert(false && "this should not happen");
                break;
        }

        TRISON_CPP_DEBUG_CODE_(DSF_STACK_AND_LOOKAHEADS,
            *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1349 "../bin/barftest/text/Parser.cpp"
 << "<stack> . <lookaheads>: ";
            m_realized_state_->PrintStackAndLookaheads(*DebugSpewStream());
            *DebugSpewStream() << '\n';
        )

        if (destroy_and_recreate_parse_tree)
        {
            TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1360 "../bin/barftest/text/Parser.cpp"
 << "    Destroying and recreating parse tree based on top of branch stack of of realized state.\n")
            m_hypothetical_state_->DestroyParseTree();
            CreateParseTreeFromRealizedState_();
        }
    }
}

void Parser::ContinueNPDAParse_ (bool &should_return)
{
    // If there are no non-blocked hps-es, then the parse should stop.  If any non-blocked hps-es
    // are processed, then this flag will be set to false.
    should_return = true;

    TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1377 "../bin/barftest/text/Parser.cpp"
 << "Parse stack tree does not have trunk; continuing parse.\n")

    // If there's a SHIFT/REDUCE conflict, then see if it can be resolved first.
    {
        ParseTreeNode_ *shift  = NULL;
        ParseTreeNode_ *reduce = NULL;
        // TODO: Move this handling into its own function
        // NOTE: This only works at the root.  If that were to change, then various things
        // would need to scan over only the HPSes that are contained within the relevant subtree.
        bool has_shift_reduce_conflict = m_hypothetical_state_->m_root->HasShiftReduceConflict(shift, reduce);
        bool has_shift_reduce_conflict_and_should_resolve = false;
        if (has_shift_reduce_conflict)
        {
            // Should not do anything unless the shift and reduce branches have the same
            // m_realized_lookahead_cursor (e.g. a REDUCE action will start out with
            // m_realized_lookahead_cursor == 0, while a SHIFT action will start out with
            // m_realized_lookahead_cursor == 1, but the REDUCE action branch needs to be
            // allowed to catch up before having any chance at the SHIFT/REDUCE conflict
            // being resolvable).
            if (m_hypothetical_state_->MinAndMaxRealizedLookaheadCursorsAreEqual())
                has_shift_reduce_conflict_and_should_resolve = true;
            else
            {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1404 "../bin/barftest/text/Parser.cpp"
 << "    SHIFT/REDUCE conflict encountered, but the min and max realized lookahead cursors for all HPSes are not equal, so it's not ready for the conflict to be resolved.\n")
            }
        }

        if (has_shift_reduce_conflict_and_should_resolve)
        {
            assert(shift != NULL);
            assert(reduce != NULL);
            ParseTreeNode_::PrecedenceIndexRange shift_precedence_index_range = shift->ComputePrecedenceIndexRange(1);
            ParseTreeNode_::PrecedenceIndexRange reduce_precedence_index_range = reduce->ComputePrecedenceIndexRange(1);
            assert(reduce_precedence_index_range.first == reduce_precedence_index_range.second);

            TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1420 "../bin/barftest/text/Parser.cpp"
 << "    SHIFT/REDUCE conflict encountered. REDUCE precedence level range: [" << Grammar_::ms_precedence_table_[reduce_precedence_index_range.first].m_name << ", " << Grammar_::ms_precedence_table_[reduce_precedence_index_range.second].m_name << "], SHIFT precedence level range: [" << Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_name << ", " << Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_name << "]\n")

            // 6 possibilities (the higher lines indicate higher precedence level.  same line
            // indicates equality).  there is always exactly one reduce hps, and at least
            // one shift hps.
            //
            // note that if a shift and a reduce have the same precedence level, then they also
            // have the same associativity.
            //
            // 1.     shift        2.     shift        3.
            //        shift               shift
            // reduce              reduce shift        reduce shift
            //
            // 4.                  5.                  6.
            //                                                shift
            // reduce shift        reduce              reduce shift
            //        shift               shift               shift
            //        shift               shift
            //
            // cases 1 and 5 can be trivially resolved -- by pruning the reduce
            // and by pruning the shift respectively.
            //
            // case 2 can only be resolved if the associativity of the reduction rule
            // is RIGHT, in which case the reduce is pruned.  otherwise no resolution
            // can be reached at this point.
            //
            // case 3 may be trivially resolved via rule associativity (LEFT causes the
            // shift to be pruned, RIGHT causes the reduce to be pruned, and NONASSOC
            // should cause an error).
            //
            // case 4 can only be resolved if the associativity of the reduction rule
            // is LEFT, in which case the shift is pruned.  otherwise no resolution
            // can be reached at this point.
            //
            // case 6 can not be resolved at this point.

            bool conflict_resolved = false;

            // Case 1
            if (Grammar_::ms_precedence_table_[reduce_precedence_index_range.second].m_level < Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level)
            {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1465 "../bin/barftest/text/Parser.cpp"
 << "        Case 1; REDUCE < SHIFT; pruning REDUCE and continuing.\n")
                // TODO: Use std::unique_ptr and pass in via move so that the `reduce = NULL` is unnecessary.
                m_hypothetical_state_->DeleteBranch(reduce);
                reduce = NULL;
                conflict_resolved = true;
            }
            // Case 2
            else if (Grammar_::ms_precedence_table_[reduce_precedence_index_range.first].m_level == Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level &&
                     Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level < Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level)
            {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1479 "../bin/barftest/text/Parser.cpp"
 << "        Case 2; REDUCE <= SHIFT;\n")
                Grammar_::Rule_ const &reduction_rule = Grammar_::ms_rule_table_[reduce->m_spec.m_single_data];
                Grammar_::Precedence_ const &reduction_rule_precedence = Grammar_::ms_precedence_table_[reduction_rule.m_precedence_index];
                if (reduction_rule_precedence.m_associativity == Grammar_::ASSOC_RIGHT)
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1488 "../bin/barftest/text/Parser.cpp"
 << "        Pruning REDUCE (because it is right-associative) and continuing.\n")
                    m_hypothetical_state_->DeleteBranch(reduce);
                    reduce = NULL;
                    conflict_resolved = true;
                }
                else
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1499 "../bin/barftest/text/Parser.cpp"
 << "        Can't resolve conflict at this time.\n")
                }
            }
            // Case 3
            else if (Grammar_::ms_precedence_table_[reduce_precedence_index_range.second].m_level == Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level &&
                     Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level == Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level)
            {
                Grammar_::Rule_ const &reduction_rule = Grammar_::ms_rule_table_[reduce->m_spec.m_single_data];
                Grammar_::Precedence_ const &reduction_rule_precedence = Grammar_::ms_precedence_table_[reduction_rule.m_precedence_index];
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1512 "../bin/barftest/text/Parser.cpp"
 << "        Case 3; REDUCE == SHIFT; rule " << reduce->m_spec.m_single_data << " associativity: " <<
 Grammar_::ms_associativity_string_table_[reduction_rule_precedence.m_associativity] << '\n')
                switch (reduction_rule_precedence.m_associativity)
                {
                    case Grammar_::ASSOC_LEFT:
                        TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1521 "../bin/barftest/text/Parser.cpp"
 << "        Pruning SHIFT (because REDUCE is left-associative) and continuing.\n")
                        m_hypothetical_state_->DeleteBranch(shift);
                        shift = NULL;
                        conflict_resolved = true;
                        break;

                    case Grammar_::ASSOC_NONASSOC:
                    {
                        TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1533 "../bin/barftest/text/Parser.cpp"
 << "        Composition of nonassoc rules with the same precedence is an error.  Pruning both SHIFT and REDUCE.  Recreating parse tree under INSERT_LOOKAHEAD_ERROR action.\n")
                        // Neither SHIFT nor REDUCE should survive.  Instead, invoke the nonassoc error actions
                        // on the lookahead, and insert an %error token using the returned Token::Data value.
                        //
                        // Start:  <realized-stack-tokens> . <lookahead>
                        //                                 ^~~~~~~~~~^
                        //                                 input to handler code
                        //
                        // Result: <realized-stack-tokens> . <%error> <lookahead>
                        //                                   ^~~~~~~^
                        //                                   output from handler code

                        {   // This code block is just to limit the scope of resulting_error_token
                            Token resulting_error_token(Terminal::ERROR_, RunNonassocErrorActions_(Lookahead_(0)));
                            m_realized_state_->PushFrontLookahead(std::move(resulting_error_token), m_hypothetical_state_->m_hps_queue);
                        }
                        m_realized_state_->SetHasEncounteredErrorState();

                        m_hypothetical_state_->DeleteBranch(shift);
                        m_hypothetical_state_->DeleteBranch(reduce);
                        // Just verify that the HPS queue has been totally nullified by the above actions.
                        for (HPSQueue_::iterator hps_it = m_hypothetical_state_->m_hps_queue.begin(), hps_it_end = m_hypothetical_state_->m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
                        {
                            assert(*hps_it == NULL);
                        }
                        m_hypothetical_state_->m_hps_queue.clear();
                        assert(m_hypothetical_state_->m_new_hps_queue.empty());
                        assert(m_hypothetical_state_->m_root->m_child_nodes.empty());

                        // Create fresh HPSes at the root from the realized state.
                        CreateParseTreeFromRealizedState_();

                        // The processing later in this function (see `if (conflict_resolved)` block)
                        // is expecting the HPSes to be in m_hps_queue, and m_new_hps_queue to be empty.
                        assert(!m_hypothetical_state_->m_hps_queue.empty());
                        assert(m_hypothetical_state_->m_new_hps_queue.empty());

                        // Mark the conflict as resolved.
                        conflict_resolved = true;
                        break;
                    }

                    case Grammar_::ASSOC_RIGHT:
                        TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1580 "../bin/barftest/text/Parser.cpp"
 << "        Pruning REDUCE (because it is right-associative) and continuing.\n")
                        m_hypothetical_state_->DeleteBranch(reduce);
                        reduce = NULL;
                        conflict_resolved = true;
                        break;

                    default:
                        assert(false && "this should never happen");
                        break;
                }
            }
            // Case 4
            else if (Grammar_::ms_precedence_table_[reduce_precedence_index_range.second].m_level == Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level &&
                     Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level < Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level)
            {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1599 "../bin/barftest/text/Parser.cpp"
 << "        Case 4; REDUCE >= SHIFT;\n")
                Grammar_::Rule_ const &reduction_rule = Grammar_::ms_rule_table_[reduce->m_spec.m_single_data];
                Grammar_::Precedence_ const &reduction_rule_precedence = Grammar_::ms_precedence_table_[reduction_rule.m_precedence_index];
                if (reduction_rule_precedence.m_associativity == Grammar_::ASSOC_LEFT)
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1608 "../bin/barftest/text/Parser.cpp"
 << "        Pruning SHIFT (because REDUCE is left-associative) and continuing.\n")
                    m_hypothetical_state_->DeleteBranch(shift);
                    shift = NULL;
                    conflict_resolved = true;
                }
                else
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1619 "../bin/barftest/text/Parser.cpp"
 << "        Can't resolve conflict at this time.\n")
                }
            }
            // Case 5
            else if (Grammar_::ms_precedence_table_[reduce_precedence_index_range.first].m_level > Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level)
            {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1629 "../bin/barftest/text/Parser.cpp"
 << "        Case 5; REDUCE > SHIFT; pruning SHIFT and continuing.\n")
                m_hypothetical_state_->DeleteBranch(shift);
                shift = NULL;
                conflict_resolved = true;
            }
            // Case 6
            else {
                TRISON_CPP_DEBUG_CODE_(DSF_SHIFT_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1640 "../bin/barftest/text/Parser.cpp"
 << "        Case 6; ambiguous SHIFT/REDUCE precedence comparison; can't resolve conflict at this time.\n")
                assert(Grammar_::ms_precedence_table_[reduce_precedence_index_range.first].m_level > Grammar_::ms_precedence_table_[shift_precedence_index_range.first].m_level);
                assert(Grammar_::ms_precedence_table_[reduce_precedence_index_range.second].m_level < Grammar_::ms_precedence_table_[shift_precedence_index_range.second].m_level);
            }

            if (conflict_resolved)
            {
                should_return = false;

                assert(m_hypothetical_state_->m_new_hps_queue.empty());
                // Take new hps-es and clear old ones.
                for (HPSQueue_::iterator hps_it = m_hypothetical_state_->m_hps_queue.begin(), hps_it_end = m_hypothetical_state_->m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
                {
                    ParseTreeNode_ *hps = *hps_it;
                    if (hps != NULL)
                        m_hypothetical_state_->m_new_hps_queue.push_back(hps);
                }
                m_hypothetical_state_->m_hps_queue.clear();
                std::swap(m_hypothetical_state_->m_hps_queue, m_hypothetical_state_->m_new_hps_queue);
                assert(m_hypothetical_state_->m_new_hps_queue.empty());
                // TODO: Break this large function up into smaller logical units
                return;
            }
        }
    }

    // Compute the minimum of all hps-es' m_realized_lookahead_cursor values, in order
    // to determine which ones have processed the lowest number of lookaheads.  This is
    // done so that one hps doesn't get way ahead of the others.
    std::uint32_t min_realized_lookahead_cursor;
    m_hypothetical_state_->ComputeMinAndMaxRealizedLookaheadCursors(&min_realized_lookahead_cursor, NULL);

    // Process transitions in order of their SortedTypeIndex.  Only process HPSes that are at min_realized_lookahead_cursor.
    assert(m_hypothetical_state_->m_new_hps_queue.empty()); // This is the starting condition
    for (std::uint32_t current_sorted_type_index = Npda_::Transition_::Order::MIN_SORTED_TYPE_INDEX; current_sorted_type_index <= Npda_::Transition_::Order::MAX_SORTED_TYPE_INDEX; ++current_sorted_type_index)
    {
        TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1680 "../bin/barftest/text/Parser.cpp"
 << "    Processing transitions having SortedTypeIndex equal to " << current_sorted_type_index << " and m_realized_lookahead_cursor equal to " << min_realized_lookahead_cursor << ".\n")

        if (!m_hypothetical_state_->m_new_hps_queue.empty())
        {
            TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1688 "../bin/barftest/text/Parser.cpp"
 << "        Early-out based on sorted type index.\n")
            break;
        }

        // Process non-blocked hps-es.
        for (HPSQueue_::iterator hps_it = m_hypothetical_state_->m_hps_queue.begin(), hps_it_end = m_hypothetical_state_->m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
        {
            // Skip nullified HPS nodes.
            if (*hps_it == NULL)
                continue;

            ParseTreeNode_ &hps = **hps_it;

            assert(hps.m_spec.m_type == ParseTreeNode_::HPS);
            TRISON_CPP_DEBUG_CODE_(
                DSF_TRANSITION_PROCESSING,
                *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1708 "../bin/barftest/text/Parser.cpp"
 << "        Processing ";
                hps.Print(*DebugSpewStream(), this, DebugSpewPrefix(), 0, true);
            )

            // If a hps is blocked, then save it for the next parse iteration but don't do anything with it.
            if (hps.IsBlockedHPS())
            {
                TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1719 "../bin/barftest/text/Parser.cpp"
 << "            Hypothetical Parser State is blocked; preserving for next iteration.\n")
                m_hypothetical_state_->m_new_hps_queue.push_back(&hps);
                *hps_it = NULL;
                continue;
            }

            // If a hps' m_realized_lookahead_cursor is greater than min_realized_lookahead_cursor, then
            // save it for the next parse iteration but don't do anything with it.
            if (hps.m_realized_lookahead_cursor > min_realized_lookahead_cursor)
            {
                TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1733 "../bin/barftest/text/Parser.cpp"
 << "            Hypothetical Parser State isn't at min_realized_lookahead_cursor (which is " << min_realized_lookahead_cursor << "); preserving for next iteration.\n")
                m_hypothetical_state_->m_new_hps_queue.push_back(&hps);
                *hps_it = NULL;
                continue;
            }

            // This hps isn't blocked, so indicate that the parse should continue.
            should_return = false;

            std::uint32_t hps_state_index = hps.m_hypothetical_head.StatePtr()->Data();

            // Retrieve all transitions whose SortedTypeIndex is current_sorted_type_index.
            Npda_::TransitionVector_ const &non_epsilon_transitions = Npda_::NonEpsilonTransitionsOfState_(hps_state_index, current_sorted_type_index);
            // Exercise all valid transitions whose SortedTypeIndex is current_sorted_type_index.
            for (Npda_::TransitionVector_::const_iterator transition_it = non_epsilon_transitions.begin(), transition_it_end = non_epsilon_transitions.end(); transition_it != transition_it_end; ++transition_it)
            {
                Npda_::Transition_ const &transition = *transition_it;
                assert(transition.m_type >= Npda_::Transition_::RETURN);
                assert(transition.m_type <= Npda_::Transition_::POP_STACK);
                assert(Npda_::Transition_::Order::SortedTypeIndex(transition) == current_sorted_type_index);


                TRISON_CPP_DEBUG_CODE_(
                    DSF_TRANSITION_PROCESSING,
                    *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1761 "../bin/barftest/text/Parser.cpp"
 << "            Processing transition " << ParseTreeNode_::AsString(ParseTreeNode_::Type(transition.m_type)) << " with transition token " << Token(transition.m_token_index) << " and data ";
                    if (transition.m_data_index == ParseTreeNode_::UNUSED_DATA)
                        *DebugSpewStream() << "<N/A>";
                    else
                        *DebugSpewStream() << transition.m_data_index;
                    *DebugSpewStream() << " and sorted type index " << Npda_::Transition_::Order::SortedTypeIndex(transition) << '\n';
                )


                ParseTreeNode_ *resulting_hps = NULL;
                // If it's a default transition, there's no need to access the lookahead (except in a couple of particular cases).
                if (transition.m_token_index == Nonterminal::none_)
                {
                    // Logic regarding empty reduction rules -- if this transition is REDUCE for an empty reduction rule
                    // and the lookahead is the nonterminal for that REDUCE action, then don't reduce, since that
                    // would produce an infinite loop.  There is a case where it's not necessary to access the lookahead:
                    // if this HPS is the child of a REDUCE action for the same nonterminal, then we know the lookahead
                    // is that nonterminal, so it's not necessary to check the lookahead (we don't want to access the
                    // lookahead unnecessarily).  But it's not an if-and-only-if condition; we could have just REDUCE'd
                    // that nonterminal but the HPS has no parent because the trunk action was executed and then popped,
                    // meaning that the parent of this HPS would be the parse tree root.
                    bool take_action = true;

                    assert(hps.m_parent_node != NULL);
                    if (transition.m_type == Npda_::Transition_::REDUCE)
                    {
                        Grammar_::Rule_ const &rule = Grammar_::ms_rule_table_[transition.m_data_index];
                        bool is_empty_reduction_rule = rule.m_token_count == 0;
                        bool just_reduced_this_nonterminal = hps.m_parent_node->m_spec.m_type == ParseTreeNode_::REDUCE && hps.m_parent_node->m_spec.m_single_data == rule.m_reduction_nonterminal_token_id;
                        // The fancy logical construction here is to avoid accessing the lookahead unless necessary
                        // (and technically this is not optimal, since really when executing the trunk actions,
                        // the information of "parent is REDUCE and the reduction rule nonterminal is this one"
                        // is lost in the current implementation.
                        if (is_empty_reduction_rule &&
                            (just_reduced_this_nonterminal ||
                             rule.m_reduction_nonterminal_token_id == hps.LookaheadTokenId(*this))) // lookahead is this nonterminal
                        {
                            TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1802 "../bin/barftest/text/Parser.cpp"
 << "            Skipping default action REDUCE on empty reduction rule because the lookahead matches the reduction nonterminal.\n")
                            take_action = false;
                        }

                        //
                        // The following is a hacky way to check for transitions that SHOULD block a default REDUCE action.
                        // In particular, for a reduction rule ending with %lookahead[![A|B]], there will be transitions
                        //     default: REDUCE
                        //     A: INSERT_LOOKAHEAD_ERROR
                        //     B: INSERT_LOOKAHEAD_ERROR
                        // and the intent of this was for the A and B transitions to "block" the default transition, but
                        // this was not implemented correctly.  So this hack is meant to fix that bug without doing the
                        // larger refactor that would implement this correctly and robustly.
                        //

                        // Check all higher SortedTypeIndex values (higher than the SortedTypeIndex value of REDUCE) for
                        // transitions that match the lookahead -- these would block the default REDUCE action.
                        for (std::uint32_t blocking_sorted_type_index = current_sorted_type_index+1; blocking_sorted_type_index <= Npda_::Transition_::Order::MAX_SORTED_TYPE_INDEX; ++blocking_sorted_type_index)
                        {
                            Npda_::TransitionVector_ const &blocking_non_epsilon_transitions = Npda_::NonEpsilonTransitionsOfState_(hps_state_index, blocking_sorted_type_index);
                            for (Npda_::TransitionVector_::const_iterator blocking_transition_it = blocking_non_epsilon_transitions.begin(), blocking_transition_it_end = blocking_non_epsilon_transitions.end(); blocking_transition_it != blocking_transition_it_end; ++blocking_transition_it)
                            {
                                Npda_::Transition_ const &blocking_transition = *blocking_transition_it;
                                if (blocking_transition.m_token_index == hps.LookaheadTokenId(*this))
                                {
                                    // This transition is blocking the default REDUCE action, so do not take action.
                                    TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_PROCESSING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1832 "../bin/barftest/text/Parser.cpp"
 << "            Skipping default action REDUCE because the negated lookahead directive was matched and therefore prevents it.\n")
                                    take_action = false;
                                }
                                if (!take_action)
                                    break; // No reason to keep looping.
                            }
                            if (!take_action)
                                break; // No reason to keep looping.
                        }
                    }

                    if (take_action)
                    {
                        TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_EXERCISING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1849 "../bin/barftest/text/Parser.cpp"
 << "            Exercising transition without accessing lookahead... ")
                        resulting_hps = TakeHypotheticalActionOnHPS_(hps, ParseTreeNode_::Type(transition.m_type), transition.m_data_index);
                        TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_EXERCISING, *DebugSpewStream() << '\n')
                    }
                }
                // Otherwise, the lookahead must be accessed.
                else
                {
                    Token::Id lookahead_token_id = hps.LookaheadTokenId(*this);
                    if (transition.m_token_index == lookahead_token_id)
                    {
                        TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_EXERCISING, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1864 "../bin/barftest/text/Parser.cpp"
 << "            Exercising transition using lookahead " << Token(lookahead_token_id) << " ... ")
                        resulting_hps = TakeHypotheticalActionOnHPS_(hps, ParseTreeNode_::Type(transition.m_type), transition.m_data_index);
                        TRISON_CPP_DEBUG_CODE_(DSF_TRANSITION_EXERCISING, *DebugSpewStream() << '\n')
                    }
                }
                if (resulting_hps != NULL)
                    m_hypothetical_state_->m_new_hps_queue.push_back(resulting_hps);
            }
        }
    }

    // Take new hps-es and clear old ones.
    assert(!m_hypothetical_state_->m_new_hps_queue.empty());
    TRISON_CPP_DEBUG_CODE_(DSF_HPS_REMOVE_DEFUNCT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 1881 "../bin/barftest/text/Parser.cpp"
 << "    Removing defunct HPSes...\n")
    for (HPSQueue_::iterator hps_it = m_hypothetical_state_->m_hps_queue.begin(), hps_it_end = m_hypothetical_state_->m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseTreeNode_ *hps = *hps_it;
        if (hps != NULL)
        {
            TRISON_CPP_DEBUG_CODE_(
                DSF_HPS_REMOVE_DEFUNCT,
                hps->Print(*DebugSpewStream(), this, DebugSpewPrefix(), 2);
            )
            m_hypothetical_state_->DeleteBranch(hps);
        }
    }
    m_hypothetical_state_->m_hps_queue.clear();
    std::swap(m_hypothetical_state_->m_hps_queue, m_hypothetical_state_->m_new_hps_queue);
    assert(m_hypothetical_state_->m_new_hps_queue.empty());
}

Parser::Token::Data Parser::ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ &token_stack_, Token const *lookahead_) throw()
{
    assert(rule_index_ < Grammar_::ms_rule_count_);
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return parser_static_move_cast<nnup<sem::Base>>(sem::make_dummy());

        case 0:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 428 "../bin/barftest/text/Parser.trison"
 return sl; 
#line 1916 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 1:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());

#line 430 "../bin/barftest/text/Parser.trison"
 return sem::make_statement_list(); 
#line 1926 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 2:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 435 "../bin/barftest/text/Parser.trison"
 return e; 
#line 1937 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 3:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());

#line 437 "../bin/barftest/text/Parser.trison"
 return sem::make_error_dummy(); 
#line 1947 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 4:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 442 "../bin/barftest/text/Parser.trison"
 return e; 
#line 1958 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 5:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());

#line 444 "../bin/barftest/text/Parser.trison"
 return sem::make_error_dummy(); 
#line 1968 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 6:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 450 "../bin/barftest/text/Parser.trison"

        e->grow_firange(open_paren->firange());
        e->grow_firange(ender->firange());
        return e;
    
#line 1985 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 7:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 457 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in parenthesized expression");
        err->grow_firange(open_paren->firange());
        err->grow_firange(ender->firange());
        return err;
    
#line 2003 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 8:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 468 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2016 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 9:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 473 "../bin/barftest/text/Parser.trison"

        auto error_dummy = sem::make_error_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(error_dummy->firange(), "unterminated parethesized expression -- missing ')'");
        return error_dummy;
    
#line 2031 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 10:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_bracket(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Tuple> et(parser_static_move_cast<nnup<sem::Tuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 483 "../bin/barftest/text/Parser.trison"

        et->grow_firange(open_bracket->firange());
        et->grow_firange(ender->firange());
        return et;
    
#line 2048 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 11:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 493 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2061 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 12:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 498 "../bin/barftest/text/Parser.trison"

        auto type_dummy = sem::make_type_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(type_dummy->firange(), "unterminated tuple -- missing ']'");
        return type_dummy;
    
#line 2076 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 13:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Tuple> et(parser_static_move_cast<nnup<sem::Tuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 508 "../bin/barftest/text/Parser.trison"

        et->push_back(std::move(e));
        return et;
    
#line 2091 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 14:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 514 "../bin/barftest/text/Parser.trison"

        return sem::make_tuple(std::move(e));
    
#line 2104 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 15:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 519 "../bin/barftest/text/Parser.trison"

        auto et = sem::make_tuple();
        et->set_firange(la.m_data->firange().start_as_firange());
        return et;
    
#line 2119 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 16:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 550 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 2132 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 17:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 555 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in tuple");
        return sem::make_type_dummy(err->firange());
    
#line 2146 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 18:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 564 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2159 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 19:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 569 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 2172 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 20:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 577 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 2185 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 21:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Dummy> close_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 582 "../bin/barftest/text/Parser.trison"

        e->grow_firange(close_paren->firange());
        record_recoverable_error(e->firange(), "mismatched ')' in expression");
        return e;
    
#line 2201 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 22:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Tuple> et(parser_static_move_cast<nnup<sem::Tuple>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 595 "../bin/barftest/text/Parser.trison"

        return et;
    
#line 2214 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 23:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 601 "../bin/barftest/text/Parser.trison"

        return id;
    
#line 2227 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 24:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::ValueBase> val(parser_static_move_cast<nnup<sem::ValueBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 606 "../bin/barftest/text/Parser.trison"

        return val;
    
#line 2240 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 25:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StringLiteral> str(parser_static_move_cast<nnup<sem::StringLiteral>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 611 "../bin/barftest/text/Parser.trison"

        return str;
    
#line 2253 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 26:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> positive_expression(std::move(token_stack_[token_stack_.size()-5].m_data));
            nnup<sem::Base> condition(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> negative_expression(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 616 "../bin/barftest/text/Parser.trison"

        return sem::make_conditional_expression(std::move(condition), std::move(positive_expression), std::move(negative_expression));
    
#line 2268 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 27:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 621 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::LOGICAL_OR, std::move(lhs), std::move(rhs));
    
#line 2282 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 28:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 626 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::LOGICAL_XOR, std::move(lhs), std::move(rhs));
    
#line 2296 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 29:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 631 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::LOGICAL_AND, std::move(lhs), std::move(rhs));
    
#line 2310 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 30:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 636 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::EQUALS, std::move(lhs), std::move(rhs));
    
#line 2324 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 31:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 641 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::NOT_EQUALS, std::move(lhs), std::move(rhs));
    
#line 2338 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 32:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 646 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::LESS_THAN, std::move(lhs), std::move(rhs));
    
#line 2352 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 33:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 651 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::GREATER_THAN, std::move(lhs), std::move(rhs));
    
#line 2366 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 34:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 656 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::LESS_OR_EQUAL, std::move(lhs), std::move(rhs));
    
#line 2380 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 35:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 661 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::GREATER_OR_EQUAL, std::move(lhs), std::move(rhs));
    
#line 2394 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 36:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 666 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::ADD, std::move(lhs), std::move(rhs));
    
#line 2408 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 37:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 671 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::SUB, std::move(lhs), std::move(rhs));
    
#line 2422 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 38:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 676 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::MUL, std::move(lhs), std::move(rhs));
    
#line 2436 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 39:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 681 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::DIV, std::move(lhs), std::move(rhs));
    
#line 2450 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 40:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 686 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::MOD, std::move(lhs), std::move(rhs));
    
#line 2464 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 41:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> minus(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> op(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 691 "../bin/barftest/text/Parser.trison"

        return sem::make_unary_operation(minus->firange() + op->firange(), sem::UnaryOperationType::NEGATE, std::move(op));
    
#line 2478 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 42:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> logical_not(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> op(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 696 "../bin/barftest/text/Parser.trison"

        return sem::make_unary_operation(logical_not->firange() + op->firange(), sem::UnaryOperationType::LOGICAL_NOT, std::move(op));
    
#line 2492 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 43:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 701 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::POW, std::move(lhs), std::move(rhs));
    
#line 2506 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 44:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> op(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Dummy> asterisk(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 706 "../bin/barftest/text/Parser.trison"

        return sem::make_unary_operation(op->firange() + asterisk->firange(), sem::UnaryOperationType::AT_SYMBOL, std::move(op));
    
#line 2520 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 45:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> op(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Dummy> ampersand(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 711 "../bin/barftest/text/Parser.trison"

        return sem::make_unary_operation(op->firange() + ampersand->firange(), sem::UnaryOperationType::HASH_SYMBOL, std::move(op));
    
#line 2534 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 46:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> f(std::move(token_stack_[token_stack_.size()-4].m_data));
            nnup<sem::Dummy> open_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::ParameterList> pl(parser_static_move_cast<nnup<sem::ParameterList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 719 "../bin/barftest/text/Parser.trison"

        pl->grow_firange(open_paren->firange());
        pl->grow_firange(ender->firange());
        return sem::make_function_evaluation(std::move(f), std::move(pl));
    
#line 2552 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 47:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> r(std::move(token_stack_[token_stack_.size()-4].m_data));
            nnup<sem::Dummy> open_bracket(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> k(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 729 "../bin/barftest/text/Parser.trison"

        k->grow_firange(open_bracket->firange());
        k->grow_firange(ender->firange());
        return sem::make_element_access(std::move(r), std::move(k));
    
#line 2570 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 48:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Function> fl(parser_static_move_cast<nnup<sem::Function>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 736 "../bin/barftest/text/Parser.trison"

        return fl;
    
#line 2583 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 49:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::LLVMCastKeyword> k(parser_static_move_cast<nnup<sem::LLVMCastKeyword>>(std::move(token_stack_[token_stack_.size()-6].m_data)));
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-4].m_data));
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 741 "../bin/barftest/text/Parser.trison"

        return sem::make_llvm_cast(k->firange() + dummy->firange(), k->instruction(), std::move(e), std::move(t));
    
#line 2599 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 50:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::LLVMCastKeyword> k(parser_static_move_cast<nnup<sem::LLVMCastKeyword>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 746 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), LVD_FMT("parse error in argument for " << k->instruction() << " builtin"));
        return sem::make_llvm_cast(k->firange() + dummy->firange(), k->instruction(), sem::make_dummy(err->firange()), sem::make_type_dummy(err->firange()));
    
#line 2615 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 51:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> n(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 752 "../bin/barftest/text/Parser.trison"

        return sem::make_nullptr(n->firange() + t->firange() + dummy->firange(), std::move(t));
    
#line 2630 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 52:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> n(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 757 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in argument for __nullptr__ builtin");
        return sem::make_nullptr(n->firange() + err->firange() + dummy->firange(), sem::make_pointer_type(err->firange(), sem::make_sint64(err->firange())));
    
#line 2646 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 53:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 786 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2659 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 54:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 791 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 2672 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 55:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 820 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 2685 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 56:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 825 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in element access key");
        return err;
    
#line 2699 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 57:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 834 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2712 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 58:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 839 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 2725 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 59:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 847 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2738 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 60:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 852 "../bin/barftest/text/Parser.trison"

        auto dummy = sem::make_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(dummy->firange(), "unterminated parameter list -- missing ')'");
        return dummy;
    
#line 2753 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 61:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::ParameterList> pl(parser_static_move_cast<nnup<sem::ParameterList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> p(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 862 "../bin/barftest/text/Parser.trison"

        pl->push_back(std::move(p));
        return pl;
    
#line 2768 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 62:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> p(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 868 "../bin/barftest/text/Parser.trison"

        return sem::make_parameter_list(std::move(p));
    
#line 2781 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 63:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 873 "../bin/barftest/text/Parser.trison"

        auto pl = sem::make_parameter_list();
        pl->set_firange(la.m_data->firange().start_as_firange());
        return pl;
    
#line 2796 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 64:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 883 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 2809 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 65:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 888 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in parameter list");
        return err;
    
#line 2823 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 66:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> comma(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 897 "../bin/barftest/text/Parser.trison"

        return comma;
    
#line 2836 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 67:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 902 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 2849 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 68:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::FunctionPrototype> fpe(parser_static_move_cast<nnup<sem::FunctionPrototype>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::StatementList> body(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 910 "../bin/barftest/text/Parser.trison"

        return sem::make_function(std::move(fpe), std::move(body));
    
#line 2863 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 69:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::DeclarationTuple> domain_dt(parser_static_move_cast<nnup<sem::DeclarationTuple>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::TypeBase> codomain(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 918 "../bin/barftest/text/Parser.trison"

        return sem::make_function_prototype(std::move(domain_dt), std::move(codomain));
    
#line 2877 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 70:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::DeclarationTuple> domain_dt(parser_static_move_cast<nnup<sem::DeclarationTuple>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 926 "../bin/barftest/text/Parser.trison"

        return domain_dt;
    
#line 2890 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 71:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 931 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in function prototype expression before '->'");
        auto domain_dt = sem::make_declaration_tuple();
        domain_dt->set_firange(err->firange());
        return domain_dt;
    
#line 2906 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 72:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_bracket(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::TypeTuple> tt(parser_static_move_cast<nnup<sem::TypeTuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 942 "../bin/barftest/text/Parser.trison"

        tt->grow_firange(open_bracket->firange());
        tt->grow_firange(ender->firange());
        return tt;
    
#line 2923 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 73:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 952 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 2936 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 74:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 957 "../bin/barftest/text/Parser.trison"

        auto type_dummy = sem::make_type_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(type_dummy->firange(), "unterminated type tuple -- missing ']'");
        return type_dummy;
    
#line 2951 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 75:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeTuple> tt(parser_static_move_cast<nnup<sem::TypeTuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 967 "../bin/barftest/text/Parser.trison"

        tt->push_back(std::move(t));
        return tt;
    
#line 2966 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 76:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 973 "../bin/barftest/text/Parser.trison"

        return sem::make_type_tuple(std::move(t));
    
#line 2979 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 77:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 978 "../bin/barftest/text/Parser.trison"

        auto tt = sem::make_type_tuple();
        tt->set_firange(la.m_data->firange().start_as_firange());
        return tt;
    
#line 2994 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 78:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 988 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3007 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 79:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 993 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in type tuple");
        return sem::make_type_dummy(err->firange());
    
#line 3021 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 80:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1002 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 3034 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 81:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1007 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 3047 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 82:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::VoidType> t(parser_static_move_cast<nnup<sem::VoidType>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1014 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3058 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 83:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::NullType> t(parser_static_move_cast<nnup<sem::NullType>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1016 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3069 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 84:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Boolean> t(parser_static_move_cast<nnup<sem::Boolean>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1018 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3080 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 85:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Sint8> t(parser_static_move_cast<nnup<sem::Sint8>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1020 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3091 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 86:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Sint16> t(parser_static_move_cast<nnup<sem::Sint16>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1022 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3102 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 87:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Sint32> t(parser_static_move_cast<nnup<sem::Sint32>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1024 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3113 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 88:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Sint64> t(parser_static_move_cast<nnup<sem::Sint64>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1026 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3124 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 89:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Uint8> t(parser_static_move_cast<nnup<sem::Uint8>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1028 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3135 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 90:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Uint16> t(parser_static_move_cast<nnup<sem::Uint16>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1030 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3146 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 91:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Uint32> t(parser_static_move_cast<nnup<sem::Uint32>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1032 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3157 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 92:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Uint64> t(parser_static_move_cast<nnup<sem::Uint64>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1034 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3168 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 93:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Float32> t(parser_static_move_cast<nnup<sem::Float32>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1036 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3179 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 94:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Float64> t(parser_static_move_cast<nnup<sem::Float64>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1038 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3190 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 95:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::FunctionType> t(parser_static_move_cast<nnup<sem::FunctionType>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1040 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3201 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 96:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::FunctionPrototype> t(parser_static_move_cast<nnup<sem::FunctionPrototype>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1042 "../bin/barftest/text/Parser.trison"
 return t; 
#line 3212 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 97:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeTuple> tt(parser_static_move_cast<nnup<sem::TypeTuple>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1045 "../bin/barftest/text/Parser.trison"

        // Convert into TypeArray if possible.
        return tt->regularized();
    
#line 3226 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 98:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeTuple> tt(parser_static_move_cast<nnup<sem::TypeTuple>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::ValueBase> val(parser_static_move_cast<nnup<sem::ValueBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1052 "../bin/barftest/text/Parser.trison"

        if (val->type_enum__raw() != sem::TypeEnum::SINT64_VALUE)
        {
            record_recoverable_error(val->firange(), "expected integer operand for array/tuple product syntax");
            return (*tt)*(*sem::make_sint64_value(val->firange(), 0));
        }
        else
            return (*tt)*(*lvd::dynamic_move_cast<sem::Sint64Value>(val));
    
#line 3246 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 99:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1062 "../bin/barftest/text/Parser.trison"
 return sem::make_type_identifier(std::move(id)); 
#line 3257 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 100:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> te(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> asterisk(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1065 "../bin/barftest/text/Parser.trison"

        return sem::make_pointer_type(te->firange()+asterisk->firange(), std::move(te));
    
#line 3271 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 101:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> te(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> ampersand(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1070 "../bin/barftest/text/Parser.trison"

        return sem::make_reference_type(te->firange()+ampersand->firange(), std::move(te));
    
#line 3285 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 102:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeTuple> domain_tt(parser_static_move_cast<nnup<sem::TypeTuple>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::TypeBase> codomain(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1078 "../bin/barftest/text/Parser.trison"

        return sem::make_function_type(std::move(domain_tt), std::move(codomain));
    
#line 3299 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 103:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> domain(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1086 "../bin/barftest/text/Parser.trison"

        // If the type is already a tuple, don't wrap it in additional tuplage.
        if (domain->type_enum__raw() == sem::TypeEnum::TYPE_TUPLE)
            return domain;
        else
            return sem::make_type_tuple(std::move(domain));
    
#line 3316 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 104:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1095 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in function type expression before '->'");
        auto domain_tt = sem::make_type_tuple();
        domain_tt->set_firange(err->firange());
        return domain_tt;
    
#line 3332 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 105:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::FunctionType> fte(parser_static_move_cast<nnup<sem::FunctionType>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1106 "../bin/barftest/text/Parser.trison"

        return fte;
    
#line 3345 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 106:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1114 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_value_kind(sem::ValueKind::CONSTANT, dummy->firange());
    
#line 3359 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 107:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1119 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_value_kind(sem::ValueKind::VARIABLE, dummy->firange());
    
#line 3373 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 108:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1124 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_value_lifetime(sem::ValueLifetime::LOCAL, dummy->firange());
    
#line 3387 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 109:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1129 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_value_lifetime(sem::ValueLifetime::GLOBAL, dummy->firange());
    
#line 3401 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 110:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1134 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_global_value_linkage(sem::GlobalValueLinkage::EXTERNAL, dummy->firange());
    
#line 3415 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 111:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1139 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_global_value_linkage(sem::GlobalValueLinkage::INTERNAL, dummy->firange());
    
#line 3429 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 112:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1144 "../bin/barftest/text/Parser.trison"

        return ss->with_specified_global_value_linkage(sem::GlobalValueLinkage::PRIVATE, dummy->firange());
    
#line 3443 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 113:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1149 "../bin/barftest/text/Parser.trison"

        return sem::make_symbol_specifier(
            std::move(id),
            sem::make_value_kind_specifier(id->firange().end_as_firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
            sem::make_value_lifetime_specifier(id->firange().end_as_firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
            sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
        );
    
#line 3461 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 114:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::TypeBaseOrTypeKeyword> t(parser_static_move_cast<nnup<sem::TypeBaseOrTypeKeyword>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1163 "../bin/barftest/text/Parser.trison"

        return sem::make_declaration(std::move(ss), std::move(t));
    
#line 3475 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 115:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1168 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in declaration statement");
        return sem::make_declaration(
            sem::make_symbol_specifier(
                sem::make_identifier(err->firange(), "<dummy>"),
                sem::make_value_kind_specifier(err->firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
                sem::make_value_lifetime_specifier(err->firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
                sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
            ),
            sem::make_type_dummy(err->firange())
        );
    
#line 3497 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 116:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeKeyword> t(parser_static_move_cast<nnup<sem::TypeKeyword>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1187 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3510 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 117:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1192 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3523 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 118:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1197 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error after ':' in declaration statement");
        return sem::make_type_dummy(err->firange());
    
#line 3537 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 119:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> content(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1207 "../bin/barftest/text/Parser.trison"

        return sem::make_initialization(std::move(id), std::move(content));
    
#line 3551 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 120:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1212 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in initialization statement");
        return sem::make_initialization(
            sem::make_identifier(err->firange(), "<dummy>"),
            sem::make_type_dummy(err->firange())
        );
    
#line 3568 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 121:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1225 "../bin/barftest/text/Parser.trison"

        return id;
    
#line 3581 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 122:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1230 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error before ':=' in initialization");
        return sem::make_identifier(err->firange(), "<dummy>");
    
#line 3595 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 123:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1241 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3608 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 124:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1246 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 3621 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 125:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1251 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error after ':=' in initialization statement");
        return sem::make_type_dummy(err->firange());
    
#line 3635 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 126:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> symbol_specifier(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> content(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1261 "../bin/barftest/text/Parser.trison"

        return sem::make_definition(std::move(symbol_specifier), std::move(content));
    
#line 3649 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 127:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1266 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in definition statement");
        return sem::make_definition(
            sem::make_symbol_specifier(
                sem::make_identifier(err->firange(), "<dummy>"),
                sem::make_value_kind_specifier(err->firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
                sem::make_value_lifetime_specifier(err->firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
                sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
            ),
            sem::make_type_dummy(err->firange())
        );
    
#line 3671 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 128:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1284 "../bin/barftest/text/Parser.trison"

        return ss;
    
#line 3684 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 129:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1289 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error before '::=' in definition");
        return sem::make_symbol_specifier(
            sem::make_identifier(err->firange(), "<dummy>"),
            sem::make_value_kind_specifier(err->firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
            sem::make_value_lifetime_specifier(err->firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
            sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
        );
    
#line 3703 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 130:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1305 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3716 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 131:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1310 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 3729 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 132:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1315 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error after '::=' in definition statement");
        return sem::make_type_dummy(err->firange());
    
#line 3743 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 133:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> target(std::move(token_stack_[token_stack_.size()-2].m_data));
            nnup<sem::Base> content(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1325 "../bin/barftest/text/Parser.trison"

        return sem::make_assignment(std::move(target), std::move(content));
    
#line 3757 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 134:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> target(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1334 "../bin/barftest/text/Parser.trison"

        return target;
    
#line 3770 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 135:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1339 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error before '=' in assignment");
        return sem::make_identifier(err->firange(), "<dummy>");
    
#line 3784 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 136:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1350 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3797 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 137:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1355 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 3810 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 138:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1360 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error after '=' in assignment statement");
        return sem::make_type_dummy(err->firange());
    
#line 3824 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 139:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_bracket(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::DeclarationTuple> dt(parser_static_move_cast<nnup<sem::DeclarationTuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1369 "../bin/barftest/text/Parser.trison"

        dt->grow_firange(open_bracket->firange());
        dt->grow_firange(ender->firange());
        return dt;
    
#line 3841 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 140:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1380 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 3854 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 141:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1385 "../bin/barftest/text/Parser.trison"

        auto dummy = sem::make_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(dummy->firange(), "unterminated declaration tuple -- missing ')'");
        return dummy;
    
#line 3869 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 142:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::DeclarationTuple> dt(parser_static_move_cast<nnup<sem::DeclarationTuple>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Declaration> d(parser_static_move_cast<nnup<sem::Declaration>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1395 "../bin/barftest/text/Parser.trison"

        dt->push_back(std::move(d));
        return dt;
    
#line 3884 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 143:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Declaration> d(parser_static_move_cast<nnup<sem::Declaration>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1401 "../bin/barftest/text/Parser.trison"

        return sem::make_declaration_tuple(std::move(d));
    
#line 3897 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 144:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1406 "../bin/barftest/text/Parser.trison"

        auto dt = sem::make_declaration_tuple();
        dt->set_firange(la.m_data->firange().start_as_firange());
        return dt;
    
#line 3912 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 145:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1437 "../bin/barftest/text/Parser.trison"

        return sem::make_declaration(std::move(ss), std::move(t));
    
#line 3926 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 146:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1442 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in declaration");
        return sem::make_declaration(
            sem::make_symbol_specifier(
                sem::make_identifier(err->firange(), "<dummy>"),
                sem::make_value_kind_specifier(err->firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
                sem::make_value_lifetime_specifier(err->firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
                sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
            ),
            sem::make_type_dummy(err->firange())
        );
    
#line 3948 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 147:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::SymbolSpecifier> ss(parser_static_move_cast<nnup<sem::SymbolSpecifier>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1460 "../bin/barftest/text/Parser.trison"

        return ss;
    
#line 3961 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 148:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1465 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error before ':' in declaration");
        return sem::make_symbol_specifier(
            sem::make_identifier(err->firange(), "<dummy>"),
            sem::make_value_kind_specifier(err->firange(), sem::ValueKindContextual::DETERMINE_FROM_CONTEXT),
            sem::make_value_lifetime_specifier(err->firange(), sem::ValueLifetimeContextual::DETERMINE_FROM_CONTEXT),
            sem::make_global_value_linkage_specifier(sem::GlobalValueLinkageContextual::DETERMINE_FROM_CONTEXT)
        );
    
#line 3980 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 149:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::TypeBase> t(parser_static_move_cast<nnup<sem::TypeBase>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1481 "../bin/barftest/text/Parser.trison"

        return t;
    
#line 3993 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 150:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1486 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error after ':' in declaration");
        return sem::make_type_dummy(err->firange());
    
#line 4007 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 151:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1496 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 4020 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 152:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1503 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 4033 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 153:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> s(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1511 "../bin/barftest/text/Parser.trison"

        return s;
    
#line 4046 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 154:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1519 "../bin/barftest/text/Parser.trison"

        return sl;
    
#line 4059 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 155:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Declaration> d(parser_static_move_cast<nnup<sem::Declaration>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1524 "../bin/barftest/text/Parser.trison"

        return d;
    
#line 4072 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 156:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Initialization> i(parser_static_move_cast<nnup<sem::Initialization>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1529 "../bin/barftest/text/Parser.trison"

        return i;
    
#line 4085 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 157:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Definition> d(parser_static_move_cast<nnup<sem::Definition>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1534 "../bin/barftest/text/Parser.trison"

        return d;
    
#line 4098 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 158:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Assignment> a(parser_static_move_cast<nnup<sem::Assignment>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1539 "../bin/barftest/text/Parser.trison"

        return a;
    
#line 4111 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 159:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> if_token(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-6].m_data)));
            nnup<sem::Base> condition(std::move(token_stack_[token_stack_.size()-5].m_data));
            nnup<sem::Base> then_statement(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> otherwise_statement(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1544 "../bin/barftest/text/Parser.trison"

        auto conditional = sem::make_conditional_statement(std::move(condition), std::move(then_statement), std::move(otherwise_statement));
        conditional->grow_firange(if_token->firange());
        return conditional;
    
#line 4129 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 160:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> if_token(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::Base> condition(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> then_statement(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1552 "../bin/barftest/text/Parser.trison"

        auto conditional = sem::make_conditional_statement(std::move(condition), std::move(then_statement));
        conditional->grow_firange(if_token->firange());
        return conditional;
    
#line 4146 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 161:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> while_token(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::Base> condition(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> loop_body(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1559 "../bin/barftest/text/Parser.trison"

        auto w = sem::make_loop(sem::LoopType::WHILE_DO, std::move(condition));
        w->grow_firange(while_token->firange());
        if (loop_body->type_enum__raw() == sem::TypeEnum::STATEMENT_LIST)
            w->set_body(lvd::dynamic_move_cast<sem::StatementList>(loop_body));
        else
        {
            auto sl = sem::make_statement_list(std::move(loop_body));
            w->set_body(std::move(sl));
        }
        return w;
    
#line 4170 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 162:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> do_token(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-4].m_data)));
            nnup<sem::Base> loop_body(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> condition(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1573 "../bin/barftest/text/Parser.trison"

        auto w = sem::make_loop(sem::LoopType::DO_WHILE, std::move(condition));
        w->grow_firange(do_token->firange());
        if (loop_body->type_enum__raw() == sem::TypeEnum::STATEMENT_LIST)
            w->set_body(lvd::dynamic_move_cast<sem::StatementList>(loop_body));
        else
        {
            auto sl = sem::make_statement_list(std::move(loop_body));
            w->set_body(std::move(sl));
        }
        return w;
    
#line 4194 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 163:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Break> break_token(parser_static_move_cast<nnup<sem::Break>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1587 "../bin/barftest/text/Parser.trison"

        return break_token;
    
#line 4207 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 164:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Break> break_token(parser_static_move_cast<nnup<sem::Break>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1592 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "unexpected tokens in break statement");
        return break_token;
    
#line 4222 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 165:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Return> return_token(parser_static_move_cast<nnup<sem::Return>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1599 "../bin/barftest/text/Parser.trison"

        return return_token;
    
#line 4235 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 166:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Return> return_token(parser_static_move_cast<nnup<sem::Return>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> return_expression(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1604 "../bin/barftest/text/Parser.trison"

        return_token->set_return_expression(std::move(return_expression));
        return return_token;
    
#line 4250 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 167:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Return> return_token(parser_static_move_cast<nnup<sem::Return>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1610 "../bin/barftest/text/Parser.trison"

        auto error_dummy = sem::make_error_dummy(return_token->firange() + err->firange());
        record_recoverable_error(err->firange(), "parse error in return statement");
        return_token->set_return_expression(std::move(error_dummy));
        return return_token;
    
#line 4267 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 168:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> e(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1619 "../bin/barftest/text/Parser.trison"

        return e;
    
#line 4280 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 169:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> err(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1624 "../bin/barftest/text/Parser.trison"

        record_recoverable_error(err->firange(), "parse error in statement");
        return err;
    
#line 4294 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 170:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> sd(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1633 "../bin/barftest/text/Parser.trison"

        return sd;
    
#line 4307 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 171:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1638 "../bin/barftest/text/Parser.trison"

        return sem::make_dummy(la.m_data->firange().start_as_firange());
    
#line 4320 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 172:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_bracket(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> ender(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1646 "../bin/barftest/text/Parser.trison"

        sl->grow_firange(open_bracket->firange());
        sl->grow_firange(ender->firange());
        return sl;
    
#line 4337 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 173:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> dummy(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1656 "../bin/barftest/text/Parser.trison"

        return dummy;
    
#line 4350 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 174:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1661 "../bin/barftest/text/Parser.trison"

        auto dummy = sem::make_dummy(la.m_data->firange().start_as_firange());
        record_recoverable_error(dummy->firange(), "unterminated bracketed statement list -- missing '}'");
        return dummy;
    
#line 4365 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 175:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1670 "../bin/barftest/text/Parser.trison"
 return sl; 
#line 4376 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 176:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Base> s(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1676 "../bin/barftest/text/Parser.trison"

        sl->push_back(std::move(s));
        return sl;
    
#line 4391 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 177:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> sl(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1682 "../bin/barftest/text/Parser.trison"

        return sl;
    
#line 4404 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 178:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            Token const &la = *lookahead_;

#line 1690 "../bin/barftest/text/Parser.trison"

        auto sl = sem::make_statement_list();
        // Take the start of the lookahead FiRange.
        sl->set_firange(la.m_data->firange().start_as_firange());
        return sl;
    
#line 4420 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 179:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lte(std::move(token_stack_[token_stack_.size()-2].m_data));

#line 1742 "../bin/barftest/text/Parser.trison"

        return lte;
    
#line 4433 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 180:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Identifier> identifier(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1750 "../bin/barftest/text/Parser.trison"

        return identifier;
    
#line 4446 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 181:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-6].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1755 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::TIN, std::move(lhs), std::move(rhs));
    
#line 4460 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 182:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-4].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1760 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::SPLUNGE, std::move(lhs), std::move(rhs));
    
#line 4474 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 183:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-3].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1765 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::WOOD, std::move(lhs), std::move(rhs));
    
#line 4488 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 184:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Base> lhs(std::move(token_stack_[token_stack_.size()-5].m_data));
            nnup<sem::Base> rhs(std::move(token_stack_[token_stack_.size()-1].m_data));

#line 1770 "../bin/barftest/text/Parser.trison"

        return sem::make_binary_operation(sem::BinaryOperationType::DINSDALE, std::move(lhs), std::move(rhs));
    
#line 4502 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 185:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> list(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1780 "../bin/barftest/text/Parser.trison"

        return list;
    
#line 4515 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 186:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> list(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Identifier> id(parser_static_move_cast<nnup<sem::Identifier>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1788 "../bin/barftest/text/Parser.trison"

        list->push_back(std::move(id));
        return list;
    
#line 4530 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 187:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::StatementList> list(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));

#line 1794 "../bin/barftest/text/Parser.trison"

        auto error_dummy = sem::make_error_dummy(FiRange(list->firange().filename(), list->firange().start(), fipos()));
        record_recoverable_error(error_dummy->firange(), "parse error in id_list");
        list->push_back(std::move(error_dummy));
        return list;
    
#line 4546 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 188:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());

#line 1803 "../bin/barftest/text/Parser.trison"

        auto sl = sem::make_statement_list();
        sl->set_firange(FiRange(filoc().filename(), fipos(), fipos()));
        return sl;
    
#line 4560 "../bin/barftest/text/Parser.cpp"
            break;
        }

        case 189:
        {
            assert(Grammar_::ms_rule_table_[rule_index_].m_token_count < token_stack_.size());
            nnup<sem::Dummy> open_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-3].m_data)));
            nnup<sem::StatementList> list(parser_static_move_cast<nnup<sem::StatementList>>(std::move(token_stack_[token_stack_.size()-2].m_data)));
            nnup<sem::Dummy> close_paren(parser_static_move_cast<nnup<sem::Dummy>>(std::move(token_stack_[token_stack_.size()-1].m_data)));

#line 1813 "../bin/barftest/text/Parser.trison"

        list->grow_firange(open_paren->firange());
        list->grow_firange(close_paren->firange());
        return list;
    
#line 4577 "../bin/barftest/text/Parser.cpp"
            break;
        }

    }

    TRISON_CPP_DEBUG_CODE_(DSF_PROGRAMMER_ERROR, *DebugSpewStream() << "PROGRAMMER ERROR: No value returned from reduction rule code block; rule " << rule_index_ << ": " << Grammar_::ms_rule_table_[rule_index_].m_description << '\n')
    assert(false && "no value returned from reduction rule code block");
    return parser_static_move_cast<nnup<sem::Base>>(sem::make_dummy());
}

void Parser::PrintParserStatus_ (std::ostream &out) const
{
    assert(m_hypothetical_state_->m_root != NULL);

    // TODO: Print full stack (this is quite a lot)
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4596 "../bin/barftest/text/Parser.cpp"
 << "Realized state branch node stacks are (each listed bottom to top):\n";
    for (BranchVector_::const_iterator it = m_realized_state_->BranchVectorStack().back().begin(),
                                       it_end = m_realized_state_->BranchVectorStack().back().end();
         it != it_end;
         ++it)
    {
        Branch_ const &branch = *it;
        out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4607 "../bin/barftest/text/Parser.cpp"
 << "    (";
        branch.StatePtr()->PrintRootToLeaf(out, IdentityTransform_<Npda_::StateIndex_>);
        out << ")\n";
    }

    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4616 "../bin/barftest/text/Parser.cpp"
 << "Max realized lookahead count (so far) is:\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4621 "../bin/barftest/text/Parser.cpp"
 << "    " << m_realized_state_->MaxRealizedLookaheadCount();
    if (m_max_allowable_lookahead_count >= 0)
        out << " (max allowable lookahead count is " << m_max_allowable_lookahead_count << ")\n";
    else
        out << " (allowable lookahead count is unlimited)\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4630 "../bin/barftest/text/Parser.cpp"
 << "Max realized lookahead queue size (so far) is:\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4635 "../bin/barftest/text/Parser.cpp"
 << "    " << m_realized_state_->MaxRealizedLookaheadQueueSize();
    if (m_max_allowable_lookahead_queue_size >= 0)
        out << " (max allowable lookahead queue size is " << m_max_allowable_lookahead_queue_size << ")\n";
    else
        out << " (allowable lookahead queue size is unlimited)\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4644 "../bin/barftest/text/Parser.cpp"
 << "Max realized parse tree depth (so far) is:\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4649 "../bin/barftest/text/Parser.cpp"
 << "    " << m_hypothetical_state_->MaxRealizedParseTreeDepth();
    if (m_max_allowable_parse_tree_depth >= 0)
        out << " (max allowable parse tree depth is " << m_max_allowable_parse_tree_depth << ")\n";
    else
        out << " (allowable parse tree depth is unlimited)\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4658 "../bin/barftest/text/Parser.cpp"
 << "Has-encountered-error-state (so far) is:\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4663 "../bin/barftest/text/Parser.cpp"
 << "    " << (m_realized_state_->HasEncounteredErrorState() ? "true" : "false") << '\n';
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4668 "../bin/barftest/text/Parser.cpp"
 << "Realized stack tokens then . delimiter then realized lookahead queue is:\n";
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4673 "../bin/barftest/text/Parser.cpp"
 << "    ";
    for (TokenStack_::const_iterator it = m_realized_state_->TokenStack().begin(),
                                     it_end = m_realized_state_->TokenStack().end();
         it != it_end;
         ++it)
    {
        Token const &token = *it;
        out << token << ' ';
    }
    out << ". ";
    for (TokenQueue_::const_iterator it = m_realized_state_->LookaheadQueue().begin(),
                                     it_end = m_realized_state_->LookaheadQueue().end();
         it != it_end;
         ++it)
    {
        Token const &token = *it;
        out << token << ' ';
    }
    out << '\n';
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4696 "../bin/barftest/text/Parser.cpp"
 << '\n';

    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4702 "../bin/barftest/text/Parser.cpp"
 << "Parse tree (hypothetical parser states); Notation legend: <real-stack> <hyp-stack> . <hyp-lookaheads> , <real-lookaheads>\n";
    m_hypothetical_state_->m_root->Print(out, this, DebugSpewPrefix());
    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4708 "../bin/barftest/text/Parser.cpp"
 << '\n';

    out << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 4714 "../bin/barftest/text/Parser.cpp"
 << "HPS queue:\n";
    for (HPSQueue_::const_iterator it = m_hypothetical_state_->m_hps_queue.begin(), it_end = m_hypothetical_state_->m_hps_queue.end(); it != it_end; ++it)
    {
        ParseTreeNode_ *hps = *it;
        //assert(hps != NULL);
        if (hps != NULL)
            hps->Print(out, this, DebugSpewPrefix(), 1);
    }
}

// ////////////////////////////////////////////////////////////////////////////
// Parser::RealizedState_
// ////////////////////////////////////////////////////////////////////////////

Parser::RealizedState_::RealizedState_ (Npda_::StateIndex_ initial_state)
    :   m_max_realized_lookahead_count(0)
    ,   m_max_realized_lookahead_queue_size(0)
    ,   m_has_encountered_error_state(false)
{
    Initialize(initial_state);
}

void Parser::RealizedState_::PushBackLookahead (Token &&lookahead, HPSQueue_ const &hps_queue)
{
    // NOTE: For now, during this RealizedState_ and HypotheticalState_ refactor,
    // this RealizedState_ method will be responsible for handling some HypotheticalState_
    // logic (regarding the lookahead cursors of the HPS queue).  But perhaps this should
    // be factored out.

    m_lookahead_queue.emplace_back(std::move(lookahead));
    UpdateMaxRealizedLookaheadCount();
}

Parser::Token Parser::RealizedState_::PopStack ()
{
    assert(!m_token_stack.empty());

    Token popped_token(std::move(m_token_stack.back()));
    m_token_stack.pop_back();

    assert(!m_branch_vector_stack.empty());
    m_branch_vector_stack.pop_back();

    assert(m_branch_vector_stack.size() == m_token_stack.size());

    return popped_token;
}

void Parser::RealizedState_::ReplaceTokenStackTopWith (Token &&replacement)
{
    assert(!m_token_stack.empty());
//    m_token_stack.back() = replacement;
    m_token_stack.pop_back();
    m_token_stack.emplace_back(std::move(replacement));
}

Parser::Token Parser::RealizedState_::PopFrontLookahead (HPSQueue_ &hps_queue)
{
    // NOTE: For now, during this RealizedState_ and HypotheticalState_ refactor,
    // this RealizedState_ method will be responsible for handling some HypotheticalState_
    // logic (regarding the lookahead cursors of the HPS queue).  But perhaps this should
    // be factored out.

    assert(!m_lookahead_queue.empty());
    // Because the contents of m_lookahead_queue are changing, and each hps's
    // m_realized_lookahead_cursor is an index into that queue, each must be updated.
    for (HPSQueue_::iterator hps_it = hps_queue.begin(), hps_it_end = hps_queue.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseTreeNode_ &hps = **hps_it;
        if (hps.m_realized_lookahead_cursor > 0)
            --hps.m_realized_lookahead_cursor;
    }
    Token retval(std::move(m_lookahead_queue.front()));
    m_lookahead_queue.pop_front();
    return retval;
}

void Parser::RealizedState_::StealTokenStackTop (Token::Data *&return_token)
{
    assert(return_token != NULL);
    assert(!m_token_stack.empty());
    *return_token = std::move(m_token_stack.back().m_data);
    // Assign the token default so that the actual return token isn't destroyed when the parser is destroyed.
    m_token_stack.back().m_data = parser_static_move_cast<nnup<sem::Base>>(sem::make_dummy());
}

// void Parser::RealizedState_::ExecuteAction (Npda_::Transition_::Type action, ActionData_ action_data)
// {
// }

void Parser::RealizedState_::ExecuteActionReduce (Grammar_::Rule_ const &rule, Token::Data &&reduced_nonterminal_token_data, HPSQueue_ &hps_queue)
{
    for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
        PopStack();
    // Push the reduced nonterminal token data onto the front of the lookahead queue
    PushFrontLookahead(Token(rule.m_reduction_nonterminal_token_id, std::move(reduced_nonterminal_token_data)), hps_queue);
}

void Parser::RealizedState_::ExecuteActionShift (BranchVector_ const &shifted_branch_vector, HPSQueue_ &hps_queue)
{
    // Ensure that each of the branch nodes in the shifted vector are actually children of
    // the current set of branch nodes.
    assert(!m_branch_vector_stack.empty());
    // Ensure that the stack is actually consistent with regard to the parent/child relationships.
    for (BranchVector_::const_iterator it = shifted_branch_vector.begin(), it_end = shifted_branch_vector.end(); it != it_end; ++it)
    {
        // Note that m_branch_vector_stack.back() is the top of the branch vector stack.
        assert(std::any_of(m_branch_vector_stack.back().begin(), m_branch_vector_stack.back().end(), [it](Branch_ const &stack_top_branch){ return stack_top_branch == it->Parent(); }));
    }
    // Ensure that there's actually a lookahead.
    assert(!m_lookahead_queue.empty());

    // Push onto the branch node stack.
    m_branch_vector_stack.push_back(shifted_branch_vector);
    // Pop the shifted lookahead from the queue and push it onto the stack.
    m_token_stack.emplace_back(PopFrontLookahead(hps_queue));
}

void Parser::RealizedState_::ExecuteActionInsertLookaheadError (HPSQueue_ &hps_queue)
{
    PushFrontLookahead(Token(Terminal::ERROR_), hps_queue);
    SetHasEncounteredErrorState();
}

void Parser::RealizedState_::ExecuteActionDiscardLookahead (HPSQueue_ &hps_queue)
{
    assert(!m_lookahead_queue.empty());
    PopFrontLookahead(hps_queue);
}

void Parser::RealizedState_::PrintStackAndLookaheads (std::ostream &out) const
{
    for (TokenStack_::const_iterator it = TokenStack().begin(), it_end = TokenStack().end(); it != it_end; ++it)
    {
        Token const &token = *it;
        out << token << ' ';
    }
    out << '.';
    for (TokenQueue_::const_iterator it = LookaheadQueue().begin(), it_end = LookaheadQueue().end(); it != it_end; ++it)
    {
        Token const &token = *it;
        out << ' ' << token;
    }
}

void Parser::RealizedState_::ClearStack ()
{
    m_branch_vector_stack.clear();
    m_token_stack.clear();
}

void Parser::RealizedState_::Reinitialize (Npda_::StateIndex_ initial_state)
{
    // Clear the stack(s) and reset the error state.
    ClearStack();
    m_has_encountered_error_state = false;
    // But preserve m_lookahead_queue, m_max_realized_lookahead_count, and m_max_realized_lookahead_queue_size

    Initialize(initial_state);
}

void Parser::RealizedState_::Initialize (Npda_::StateIndex_ initial_state)
{
    assert(m_branch_vector_stack.empty());
    assert(m_token_stack.empty());

    BranchVector_ fallback_branch_vector;
    // State 0 is the fallback state which always results in action ABORT.
    BranchStatePtr_ fallback_state_ptr = BranchState_::CreateOrphan(0);
    // The Nonterminal::none_ is just a dummy Token::Id to go along with fallback_state_ptr.
    BranchTokenIdPtr_ fallback_token_id_ptr = BranchTokenId_::CreateOrphan(Nonterminal::none_);
    fallback_branch_vector.emplace_back(Branch_(fallback_state_ptr, fallback_token_id_ptr));
    // TODO: This probably should be emplace_back
    m_branch_vector_stack.push_back(fallback_branch_vector);

    // Put a dummy token in to correspond with the fallback state.
    m_token_stack.push_back(Token(Nonterminal::none_));

    assert(m_branch_vector_stack.size() == m_token_stack.size());

    BranchVector_ initial_branch_vector;
    // The Nonterminal::none_ is just a dummy Token::Id to go along with initial_state.
    initial_branch_vector.emplace_back(Branch_(BranchState_::CreateWithParent(fallback_state_ptr, initial_state), BranchTokenId_::CreateWithParent(fallback_token_id_ptr, Nonterminal::none_)));
    // TODO: This probably should be emplace_back
    m_branch_vector_stack.push_back(initial_branch_vector);

    // Put a dummy token in to correspond with the start state.
    m_token_stack.push_back(Token(Nonterminal::none_));

    assert(m_branch_vector_stack.size() == m_token_stack.size());

    // Ensure the parent/child relationships actually hold within m_branch_vector_stack.
    assert(m_branch_vector_stack.size() == 2);
    // Ensure that the stack is actually consistent with regard to the parent/child relationships.
    for (BranchVector_::const_iterator it = m_branch_vector_stack[1].begin(), it_end = m_branch_vector_stack[1].end(); it != it_end; ++it)
    {
        assert(std::any_of(m_branch_vector_stack[0].begin(), m_branch_vector_stack[0].end(), [it](Branch_ const &branch){ return branch == it->Parent(); }));
    }
}

void Parser::RealizedState_::PushFrontLookahead (Token &&lookahead, HPSQueue_ &hps_queue)
{
    // NOTE: For now, during this RealizedState_ and HypotheticalState_ refactor,
    // this RealizedState_ method will be responsible for handling some HypotheticalState_
    // logic (regarding the lookahead cursors of the HPS queue).  But perhaps this should
    // be factored out.

    m_lookahead_queue.emplace_front(std::move(lookahead));
    // Because the contents of m_lookahead_queue_ are changing, and each hps's
    // m_realized_lookahead_cursor is an index into that queue, each must be updated.
    for (HPSQueue_::iterator hps_it = hps_queue.begin(), hps_it_end = hps_queue.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseTreeNode_ &hps = **hps_it;
        ++hps.m_realized_lookahead_cursor;
    }
    UpdateMaxRealizedLookaheadCount();
}

void Parser::RealizedState_::UpdateMaxRealizedLookaheadCount ()
{
    // Subtract the number of parser-generated tokens from the length of m_lookahead_queue.
    std::size_t parser_generated_token_count = 0;
    for ( ; parser_generated_token_count < m_lookahead_queue.size(); ++parser_generated_token_count)
    {
        Token const &lookahead = m_lookahead_queue[parser_generated_token_count];
        if (IsScannerGeneratedTokenId(lookahead.m_id))
            break;
    }
    m_max_realized_lookahead_count = std::max(m_max_realized_lookahead_count, m_lookahead_queue.size() - parser_generated_token_count);

    m_max_realized_lookahead_queue_size = std::max(m_max_realized_lookahead_queue_size, m_lookahead_queue.size());
}

// ////////////////////////////////////////////////////////////////////////////
// Parser::HypotheticalState_
// ////////////////////////////////////////////////////////////////////////////

Parser::HypotheticalState_::HypotheticalState_ (Branch_ const &initial_branch)
{
    m_root = new ParseTreeNode_(ParseTreeNode_::Spec(ParseTreeNode_::ROOT));

    ParseTreeNode_ *hps             = new ParseTreeNode_(ParseTreeNode_::Spec(ParseTreeNode_::HPS));
    hps->m_hypothetical_head        = initial_branch;

    m_root->AddChild(hps);
    m_hps_queue.push_back(hps);
    m_max_realized_parse_tree_depth = 0;
}

Parser::HypotheticalState_::~HypotheticalState_ ()
{
    m_hps_queue.clear();
    m_new_hps_queue.clear();

    delete m_root;
    m_root = NULL;
}

bool Parser::HypotheticalState_::MinAndMaxRealizedLookaheadCursorsAreEqual () const
{
    std::uint32_t min;
    std::uint32_t max;
    ComputeMinAndMaxRealizedLookaheadCursors(&min, &max);
    return min == max;
}

bool Parser::HypotheticalState_::HasExceededMaxAllowableParseTreeDepth (std::int64_t max_allowable_parse_tree_depth) const
{
    // If the limit is negative, then excess is not possible.
    return max_allowable_parse_tree_depth >= 0 && std::int64_t(ParseTreeDepth()) > max_allowable_parse_tree_depth;
}

void Parser::HypotheticalState_::DeleteBranch (ParseTreeNode_ *branch_node)
{
    assert(!branch_node->IsRoot());

    // Find the most root-ward ancestor that is an only child that isn't the root node.
    ParseTreeNode_ *branch_root = branch_node->BranchRoot();
    assert(branch_root != NULL);
    assert(!branch_root->IsRoot());
    assert(branch_root->HasParent());

    branch_root->RemoveFromParent();
    branch_node->NullifyHPSNodeDescendantsInHPSQueue(m_hps_queue);
    delete branch_root;
}

void Parser::HypotheticalState_::DestroyParseTree ()
{
    assert(m_new_hps_queue.empty());
    // Clear all HPSes, which represent the leaf nodes of the parse tree.
    m_hps_queue.clear();
    // Delete the parse tree root, which deletes all nodes.
    delete m_root;
    // At this point, the parse tree has been destroyed.  Create a new root node.
    m_root = new ParseTreeNode_(ParseTreeNode_::Spec(ParseTreeNode_::ROOT));
}

void Parser::HypotheticalState_::ComputeMinAndMaxRealizedLookaheadCursors (std::uint32_t *min, std::uint32_t *max) const
{
    if (min != NULL)
        *min = std::numeric_limits<std::uint32_t>::max();
    if (max != NULL)
        *max = std::numeric_limits<std::uint32_t>::min();

    for (HPSQueue_::const_iterator hps_it = m_hps_queue.begin(), hps_it_end = m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
    {
        // Skip nullified HPS nodes.
        if (*hps_it == NULL)
            continue;

        ParseTreeNode_ const &hps = **hps_it;
        if (min != NULL && hps.m_realized_lookahead_cursor < *min)
            *min = hps.m_realized_lookahead_cursor;
        if (max != NULL && hps.m_realized_lookahead_cursor > *max)
            *max = hps.m_realized_lookahead_cursor;
    }
}

std::uint32_t Parser::HypotheticalState_::ParseTreeDepth () const
{
    std::uint32_t parse_tree_depth = 0;

    for (HPSQueue_::const_iterator hps_it = m_hps_queue.begin(), hps_it_end = m_hps_queue.end(); hps_it != hps_it_end; ++hps_it)
    {
        // Skip nullified HPS nodes.
        if (*hps_it == NULL)
            continue;

        ParseTreeNode_ const &hps = **hps_it;
        std::uint32_t branch_depth = hps.m_depth - m_root->m_depth;
        if (branch_depth > parse_tree_depth)
            parse_tree_depth = branch_depth;
    }

    // Update m_max_realized_parse_tree_depth
    if (parse_tree_depth > m_max_realized_parse_tree_depth)
        m_max_realized_parse_tree_depth = parse_tree_depth;

    return parse_tree_depth;
}

// ////////////////////////////////////////////////////////////////////////////
// Parser::ParseTreeNode_
// ////////////////////////////////////////////////////////////////////////////

char const *Parser::ParseTreeNode_::AsString (Type type)
{
    static char const *const LOOKUP_TABLE[COUNT_] =
    {
        "ROOT",
        "RETURN",
        "ABORT",
        "REDUCE",
        "SHIFT",
        "INSERT_LOOKAHEAD_ERROR",
        "DISCARD_LOOKAHEAD",
        "POP_STACK",
        "HPS"
    };
    assert(std::uint32_t(type) < COUNT_);
    return LOOKUP_TABLE[std::uint32_t(type)];
}

bool Parser::ParseTreeNode_::ParseTreeNodeOrder::operator () (Parser::ParseTreeNode_ const *lhs, Parser::ParseTreeNode_ const *rhs) const
{
    assert(lhs != NULL);
    assert(rhs != NULL);
    assert(lhs->m_spec.m_type == rhs->m_spec.m_type); // ParseTreeNodeSet should contain only nodes of the same type.
    // for HPS, their contents must be compared.
    if (lhs->m_spec.m_type == HPS)
    {
        assert(lhs->m_child_nodes.empty());
        assert(rhs->m_child_nodes.empty());
        // hps-es are equal if their m_realized_lookahead_cursor and m_hypothetical_lookahead_token_id_queue members are.
        if (lhs->m_realized_lookahead_cursor != rhs->m_realized_lookahead_cursor)
            return lhs->m_realized_lookahead_cursor < rhs->m_realized_lookahead_cursor;
        else if (lhs->m_hypothetical_head.StatePtr() != rhs->m_hypothetical_head.StatePtr())
            return lhs->m_hypothetical_head.StatePtr() < rhs->m_hypothetical_head.StatePtr();
        else
            return std::lexicographical_compare(
                lhs->m_hypothetical_lookahead_token_id_queue.begin(), lhs->m_hypothetical_lookahead_token_id_queue.end(),
                rhs->m_hypothetical_lookahead_token_id_queue.begin(), rhs->m_hypothetical_lookahead_token_id_queue.end(),
                CompareTokenId_
            );
    }
    // For REDUCE, their contents must be compared.
    else if (lhs->m_spec.m_type == REDUCE)
    {
        // m_single_data contains the reduction rule index.
        Grammar_::Rule_ const &lhs_rule = Grammar_::ms_rule_table_[lhs->m_spec.m_single_data];
        Grammar_::Rule_ const &rhs_rule = Grammar_::ms_rule_table_[rhs->m_spec.m_single_data];
        // Sort first by rule precedence, then by rule index (lower has higher priority).
        if (Grammar_::ms_precedence_table_[lhs_rule.m_precedence_index].m_level != Grammar_::ms_precedence_table_[rhs_rule.m_precedence_index].m_level)
            return Grammar_::ms_precedence_table_[lhs_rule.m_precedence_index].m_level > Grammar_::ms_precedence_table_[rhs_rule.m_precedence_index].m_level;
        else // Sort based on rule index.
            return lhs->m_spec.m_single_data < rhs->m_spec.m_single_data;
    }
    // Otherwise just use pointer value.
    else
        return lhs < rhs;
}

Parser::ParseTreeNode_::~ParseTreeNode_ ()
{
    // TODO: figure out if stack element tokens should be thrown away
    // TODO: figure out if local lookahead queue tokens should be thrown away
    // TODO: are they actually uninitialized (default value)?
    for (ChildMap::iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseTreeNodeSet &child_node_set = it->second;
        for (ParseTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseTreeNode_ *child = *child_it;
            assert(child != NULL);
            assert(child->m_parent_node == this);
            delete child;
        }
        child_node_set.clear(); // not strictly necessary, but is cleaner.
    }
}

bool Parser::ParseTreeNode_::HasTrunkChild () const
{
    if (m_spec.m_type != ROOT || m_child_nodes.size() != 1)
        return false;
    ParseTreeNodeSet const &single_type_child_node_set = m_child_nodes.begin()->second;
    if (single_type_child_node_set.size() != 1)
        return false;
    ParseTreeNode_ *single_child = *single_type_child_node_set.begin();
    assert(single_child != NULL);
    assert(single_child->m_spec.m_type != ROOT);
    return single_child->m_spec.m_type != HPS;
}

Parser::ParseTreeNode_ *Parser::ParseTreeNode_::PopTrunkChild ()
{
    assert(HasTrunkChild());
    ParseTreeNode_ *trunk_child = *m_child_nodes.begin()->second.begin();
    assert(trunk_child != NULL);
    assert(trunk_child->m_parent_node == this);
    // Reassign the children of the trunk child to this node (root).
    m_child_nodes = trunk_child->m_child_nodes;
    trunk_child->m_child_nodes.clear();
    // Set the reassigned child nodes' parent to be this node (root).
    for (ChildMap::iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
    {
        ParseTreeNodeSet &child_node_set = child_map_it->second;
        for (ParseTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseTreeNode_ *child = *child_it;
            assert(child != NULL);
            child->m_parent_node = this;
        }
    }
    trunk_child->m_parent_node = NULL;
    return trunk_child;
}

bool Parser::ParseTreeNode_::HasExactlyOneChild () const
{
    return m_child_nodes.size() == 1 && m_child_nodes.begin()->second.size() == 1;
}

Parser::ParseTreeNode_ *Parser::ParseTreeNode_::BranchRoot ()
{
    assert(!IsRoot());
    assert(HasParent());
    ParseTreeNode_ *node = this;
    while (node->HasParent() && !node->m_parent_node->IsRoot() && node->m_parent_node->HasExactlyOneChild())
    {
        node = node->m_parent_node;
        assert(node->m_spec.m_type != HPS);
    }
    return node;
}

Parser::Token::Id Parser::ParseTreeNode_::LookaheadTokenId (Parser &parser) const
{
    if (m_hypothetical_lookahead_token_id_queue.empty())
        return parser.Lookahead_(m_realized_lookahead_cursor).m_id;
    else
        return m_hypothetical_lookahead_token_id_queue.front();
}

bool Parser::ParseTreeNode_::IsBlockedHPS () const
{
    assert(m_spec.m_type == HPS);
    if (m_parent_node == NULL)
        return false;
    switch (m_parent_node->m_spec.m_type)
    {
        // Nothing can happen after returning, so this has to be blocking.
        case RETURN:
        case ABORT:
        case POP_STACK: return true;

        default:        return false;
    }
}

Parser::ParseTreeNode_::PrecedenceIndexRange Parser::ParseTreeNode_::ComputePrecedenceIndexRange (std::uint32_t current_child_depth) const
{
    if (m_spec.m_type == HPS)
    {
        // Need to look back at the rule of the (current_child_depth-1)th ancestor of this node in order
        // to get the correct rule precedence, because that's where the conflict occurred.

        assert(current_child_depth >= 2);
        // These asserts are equivalent to checking that the stack depth is at least 2.
        assert(bool(m_hypothetical_head.StatePtr()));
        assert(bool(m_hypothetical_head.StatePtr()->HasParent()));

        // Thinking of m_hypothetical_head.StatePtr() as the top of the state stack, we want to get the
        // (current_child_depth-1)th element from the top.
        BranchStatePtr_ child_branch_node_ptr = m_hypothetical_head.StatePtr();
        for (std::uint32_t i = 0; i < current_child_depth-2; ++i)
        {
            // This assert checks that the stack depth is sufficient.
            assert(child_branch_node_ptr->HasParent());
            child_branch_node_ptr = child_branch_node_ptr->Parent();
        }
        std::uint32_t state_index = child_branch_node_ptr->Data();

        assert(state_index < Npda_::ms_state_count_);
        Npda_::State_ const &state = Npda_::ms_state_table_[state_index];
        // If there's an associated rule, then use the precedence from that.
        if (state.m_associated_rule_index < Grammar_::ms_rule_count_)
        {
            Grammar_::Rule_ const &associated_rule = Grammar_::ms_rule_table_[state.m_associated_rule_index];
            assert(associated_rule.m_precedence_index < Grammar_::ms_precedence_count_);
            return PrecedenceIndexRange(associated_rule.m_precedence_index, associated_rule.m_precedence_index);
        }
        // Otherwise (e.g. a RETURN or ABORT state), return default precedence.
        else
            return PrecedenceIndexRange(Grammar_::ms_default_precedence_index_, Grammar_::ms_default_precedence_index_);
    }
    else if (m_spec.m_type == REDUCE)
    {
        std::uint32_t reduction_rule_index = m_spec.m_single_data;
        Grammar_::Rule_ const &reduction_rule = Grammar_::ms_rule_table_[reduction_rule_index];
        assert(reduction_rule.m_precedence_index < Grammar_::ms_precedence_count_);
        return PrecedenceIndexRange(reduction_rule.m_precedence_index, reduction_rule.m_precedence_index);
    }
    else if (m_spec.m_type == SHIFT)
    {
        PrecedenceIndexRange retval(std::numeric_limits<std::uint32_t>::max(), std::numeric_limits<std::uint32_t>::min());
        assert(!m_child_nodes.empty());
        // The range is the smallest range encompassing the range of each child node.
        for (ChildMap::const_iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
        {
            ParseTreeNodeSet const &child_node_set = child_map_it->second;
            for (ParseTreeNodeSet::const_iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
            {
                assert(*child_it != NULL);
                ParseTreeNode_ const &child = **child_it;
                PrecedenceIndexRange child_precedence_index_range(child.ComputePrecedenceIndexRange(current_child_depth+1));
                retval.first = std::min(retval.first, child_precedence_index_range.first);
                retval.second = std::max(retval.second, child_precedence_index_range.second);
            }
        }
        assert(retval.first <= retval.second);
        return retval;
    }
    else
    {
        // TODO: Probably need to do something to determine if this can't happen or prevent it.
        assert(false);
        return PrecedenceIndexRange(Grammar_::ms_default_precedence_index_, Grammar_::ms_default_precedence_index_);
    }
}

bool Parser::ParseTreeNode_::HasShiftReduceConflict (ParseTreeNode_ *&shift, ParseTreeNode_ *&reduce)
{
    ChildMap::iterator shift_children_it = m_child_nodes.find(Spec(SHIFT));
    ChildMap::iterator reduce_children_it = m_child_nodes.find(Spec(REDUCE));
    if (shift_children_it == m_child_nodes.end() || reduce_children_it == m_child_nodes.end())
        return false;

    ParseTreeNodeSet &shift_children = shift_children_it->second;
    ParseTreeNodeSet &reduce_children = reduce_children_it->second;
    assert(shift_children.size() == 1);
    assert(reduce_children.size() == 1);

    shift = *shift_children.begin();
    reduce = *reduce_children.begin();
    return true;
}

void Parser::ParseTreeNode_::AddChild (ParseTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == NULL);
    assert(child->m_spec.m_type != ROOT);

    m_child_nodes[child->m_spec].insert(child);
    child->m_parent_node = this;
    child->m_depth = m_depth + 1; // Always +1 relative to parent.

    // If this node is SHIFT and the child is HPS, then add the child's NPDA state to this node's
    // m_child_branch_vector.  This is the only situation in which m_child_branch_vector is added to.
    if (m_spec.m_type == SHIFT && child->m_spec.m_type == HPS)
    {
        assert(bool(child->m_hypothetical_head.StatePtr()));
        assert(std::none_of(m_child_branch_vector.begin(), m_child_branch_vector.end(), [child](Branch_ const &node_state){ return node_state.StatePtr() == child->m_hypothetical_head.StatePtr(); }) && "child branch node should not already be in the set");
        m_child_branch_vector.push_back(child->m_hypothetical_head);
    }
}

void Parser::ParseTreeNode_::RemoveChild (ParseTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == this);
    assert(HasChildrenHavingSpec(child->m_spec));
    assert(m_child_nodes[child->m_spec].find(child) != m_child_nodes[child->m_spec].end());
    m_child_nodes[child->m_spec].erase(child);
    if (m_child_nodes[child->m_spec].empty())
        m_child_nodes.erase(child->m_spec);
    child->m_parent_node = NULL;
    child->m_depth = 0; // Reset.

    // If there are no children and this isn't the root node, remove it from its parent.
    if (m_child_nodes.empty() && m_parent_node != NULL)
        RemoveFromParent();
}

void Parser::ParseTreeNode_::RemoveFromParent ()
{
    assert(m_parent_node != NULL);
    m_parent_node->RemoveChild(this);
}

void Parser::ParseTreeNode_::NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const
{
    if (m_spec.m_type == HPS)
    {
        // NOTE: This is a linear search, which is not as efficient as a different way of handling this.
        HPSQueue_::iterator it = std::find(hps_queue.begin(), hps_queue.end(), this);
        if (it != hps_queue.end())
            *it = NULL;
    }
    for (ChildMap::const_iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
    {
        ParseTreeNodeSet const &child_node_set = child_map_it->second;
        for (ParseTreeNodeSet::const_iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            assert(*child_it != NULL);
            ParseTreeNode_ const &child = **child_it;
            child.NullifyHPSNodeDescendantsInHPSQueue(hps_queue);
        }
    }
}

Parser::ParseTreeNode_ *Parser::ParseTreeNode_::CloneLeafNode () const
{
    ParseTreeNode_ *retval = new ParseTreeNode_(m_spec);
    CloneLeafNodeInto(*retval);
    return retval;
}

void Parser::ParseTreeNode_::CloneLeafNodeInto (Parser::ParseTreeNode_ &orphan_target) const
{
    assert(orphan_target.m_parent_node == NULL);
    assert(m_child_nodes.empty());
    orphan_target.m_spec                                    = m_spec;
    orphan_target.m_hypothetical_head                       = m_hypothetical_head;
    orphan_target.m_hypothetical_lookahead_token_id_queue   = m_hypothetical_lookahead_token_id_queue;
    orphan_target.m_realized_lookahead_cursor               = m_realized_lookahead_cursor;
}

void Parser::ParseTreeNode_::Print (std::ostream &out, Parser const *parser, std::string const &prefix, std::uint32_t indent_level, bool suppress_initial_prefix) const
{
    if (!suppress_initial_prefix)
    {
        out << prefix;
        for (std::uint32_t i = 0; i < indent_level; ++i)
            out << "    ";
    }
    out << AsString(m_spec.m_type) << ' ' << this << " (depth = " << m_depth << ')';
    if (m_spec.m_type == HPS)
    {
        out << (IsBlockedHPS() ? " (    blocked," : " (non-blocked,");
        out << " m_realized_lookahead_cursor = " << m_realized_lookahead_cursor << ')';
    }
    switch (m_spec.m_type)
    {
        case REDUCE:    out << " rule " << m_spec.m_single_data << "; " << Grammar_::ms_rule_table_[m_spec.m_single_data].m_description;  break;
        //case SHIFT:     out << " to (?) state " << m_spec.m_single_data << "; " << Npda_::ms_state_table_[m_spec.m_single_data].m_description; break;
        case SHIFT:     out << ' ' << Token(m_spec.m_single_data); break;
        case POP_STACK: out << ' ' << m_spec.m_single_data << " time(s)";                                                       break;
        default:                                                                                                                break;
    }
    if (bool(m_hypothetical_head.StatePtr()))
        out << ' ' << Npda_::ms_state_table_[m_hypothetical_head.StatePtr()->Data()].m_description << ' ';
    if (m_spec.m_type == HPS)
    {
        assert(bool(m_hypothetical_head.StatePtr()));
        assert(bool(m_hypothetical_head.TokenIdPtr()));

        out << "    (";
        m_hypothetical_head.StatePtr()->PrintRootToLeaf(out, IdentityTransform_<Npda_::StateIndex_>);
        out << "); ";

        m_hypothetical_head.TokenIdPtr()->PrintRootToLeaf(out, TokenName_);
        out << " . ";
        for (std::size_t i = 0; i < m_hypothetical_lookahead_token_id_queue.size(); ++i)
            out << ms_token_name_table_[m_hypothetical_lookahead_token_id_queue[i]] << ' ';
        out << ", ";
        if (parser != NULL)
            for (std::size_t i = m_realized_lookahead_cursor; i < parser->m_realized_state_->LookaheadQueue().size(); ++i)
                out << ms_token_name_table_[parser->m_realized_state_->LookaheadQueue()[i].m_id] << ' ';
        else
            out << "<realized-lookaheads-not-printed>";
    }
    out << '\n';

    // Print children recursively with higher indent level
    for (ChildMap::const_iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseTreeNodeSet const &child_node_set = it->second;
        for (ParseTreeNodeSet::const_iterator set_it = child_node_set.begin(), set_it_end = child_node_set.end(); set_it != set_it_end; ++set_it)
            (*set_it)->Print(out, parser, prefix, indent_level+1);
    }
}

// ////////////////////////////////////////////////////////////////////////////
// End of Parser::ParseTreeNode_
// ////////////////////////////////////////////////////////////////////////////

Parser::Token const &Parser::Lookahead_ (TokenQueue_::size_type index) throw()
{
    while (index >= m_realized_state_->LookaheadQueue().size())
    {
        // This does not require updating the hps-es' m_realized_lookahead_cursor.
        m_realized_state_->PushBackLookahead(Scan_(), m_hypothetical_state_->m_hps_queue);

        TRISON_CPP_DEBUG_CODE_(DSF_SCANNER_ACTION, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 5454 "../bin/barftest/text/Parser.cpp"
 << "Retrieved token " << m_realized_state_->LookaheadQueue().back() << " from scan actions; pushing token onto back of lookahead queue\n")
    }
    return m_realized_state_->LookaheadQueue()[index];
}

Parser::ParseTreeNode_ *Parser::TakeHypotheticalActionOnHPS_ (ParseTreeNode_ const &hps, ParseTreeNode_::Type action_type, std::uint32_t action_data)
{
    // TODO: replace individual arguments action_type, action_data with ParseTreeNode_::Spec and just modify that struct below where it needs it.
    assert(hps.m_spec.m_type == ParseTreeNode_::HPS && "Only a HPS type node can take an action");
    assert(hps.m_parent_node != NULL);

    ParseTreeNode_ *new_hps = NULL;

    switch (action_type)
    {
        case ParseTreeNode_::ROOT: {
            assert(false && "ParseTreeNode_::ROOT is an invalid action type.");
            break;
        }
        case ParseTreeNode_::RETURN: {
            new_hps = hps.CloneLeafNode();
            break;
        }
        case ParseTreeNode_::ABORT: {
            new_hps = hps.CloneLeafNode();
            break;
        }
        case ParseTreeNode_::REDUCE: {
            // Execute the appropriate rule on the top tokens in the stack
            std::uint32_t const &rule_index = action_data;
            Grammar_::Rule_ const &rule = Grammar_::ms_rule_table_[rule_index];

            // Avoid creating the new hps altogether if it won't be added due to a REDUCE/REDUCE conflict.
            ParseTreeNode_ *existing_reduce_action_node = NULL;
            ParseTreeNode_ *reduce_hps = NULL;
            ParseTreeNode_::Spec action_spec(action_type, action_data);
            if (hps.m_parent_node->HasChildrenHavingSpec(action_spec)) // Check for an existing REDUCE action
            {
                // This may or may not be a conflict.  Need to determine that.

                ParseTreeNode_::ParseTreeNodeSet &reduce_node_set = hps.m_parent_node->ChildrenHavingSpec(action_spec);
                assert(reduce_node_set.size() == 1);
                existing_reduce_action_node = *reduce_node_set.begin();
                assert(existing_reduce_action_node != NULL);
                assert(existing_reduce_action_node->m_spec.m_type == ParseTreeNode_::REDUCE);

                if (false)
                {
                    // TEMP
                    TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, *DebugSpewStream() << "\n\nHIPPO existing_reduce_action_node child nodes:\n\n")
                    TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, PrintParserStatus_(*DebugSpewStream()))
                    TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, *DebugSpewStream() << "\n\n")
                }

                // If the hypothetical action is identical to the existing one, then there's no problem,
                // just add it as a child to the existing one.
                if (existing_reduce_action_node->m_spec.m_single_data == rule_index)
                {
                    new_hps = hps.CloneLeafNode();
                    reduce_hps = new_hps;
                }
                // Otherwise this is a REDUCE/REDUCE conflict
                else
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 5522 "../bin/barftest/text/Parser.cpp"
 << "TakeHypotheticalActionOnHPS_ - REDUCE/REDUCE conflict encountered ... ")

                    // If the new REDUCE action beats the existing one in a conflict, just replace the existing one
                    // (replacement instead of creating a new one and deleting the old is an optimization which also
                    // avoids an annoying traversal through m_hypothetical_state_->m_hps_queue).
                    // NOTE: This depends on the fact that a REDUCE node has exactly one HPS child,
                    // which is what these three asserts check.  TODO: maybe make abstractions for these sorts of checks.
                    assert(existing_reduce_action_node->m_child_nodes.size() == 1);
                    assert(existing_reduce_action_node->m_child_nodes.begin()->second.size() == 1);
                    assert((*existing_reduce_action_node->m_child_nodes.begin()->second.begin())->m_spec.m_type == ParseTreeNode_::HPS);
                    if (Grammar_::CompareRuleByPrecedence_(action_data, existing_reduce_action_node->m_spec.m_single_data))
                    {
                        TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, *DebugSpewStream() << "resolving in favor of new hps because its REDUCE action has higher precedence.")

                        reduce_hps = *existing_reduce_action_node->m_child_nodes.begin()->second.begin();
                        assert(reduce_hps != NULL);

                        // Remove the nodes from the ParseTreeNode_ tree.
                        assert(existing_reduce_action_node != NULL);
                        existing_reduce_action_node->RemoveFromParent();
                        reduce_hps->RemoveFromParent();
                        // Modify the nodes.
                        existing_reduce_action_node->m_spec = action_spec; // Replace with the winning reduction rule Spec.
                        hps.CloneLeafNodeInto(*reduce_hps); // NOTE: This modifies the existing hps, so no update of m_hypothetical_state_->m_hps_queue is necessary.
                        // Re-add them to the ParseTreeNode_ tree.
                        existing_reduce_action_node->AddChild(reduce_hps);
                        hps.m_parent_node->AddChild(existing_reduce_action_node);
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(DSF_REDUCE_REDUCE_CONFLICT, *DebugSpewStream() << "resolving in favor of existing hps.")
                    }
                    assert(existing_reduce_action_node->m_child_nodes.begin()->second.size() == 1);
                }
            }
            else
            {
                new_hps = hps.CloneLeafNode();
                reduce_hps = new_hps;
            }

            if (reduce_hps != NULL)
            {
                // Pop those stack tokens.
                for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
                {
                    assert(reduce_hps->m_hypothetical_head.HasParent());
                    reduce_hps->m_hypothetical_head = reduce_hps->m_hypothetical_head.Parent();
                }
                // Push the reduced nonterminal token data onto the front of the lookahead queue
                reduce_hps->m_hypothetical_lookahead_token_id_queue.push_front(rule.m_reduction_nonterminal_token_id);
            }

            break;
        }
        case ParseTreeNode_::SHIFT: {
            // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
            std::uint32_t const &state_index = action_data;
            // TODO: probably make "Shift" method for ParseTreeNode_ to do all this bookkeeping and parallel LookaheadTokenId tracking.
            new_hps = hps.CloneLeafNode();
            Token::Id lookahead_token_id = new_hps->LookaheadTokenId(*this);
            // Create a new Branch_ and link it to the parent node's.
            new_hps->m_hypothetical_head = Branch_(BranchState_::CreateWithParent(hps.m_hypothetical_head.StatePtr(), state_index), BranchTokenId_::CreateWithParent(hps.m_hypothetical_head.TokenIdPtr(), lookahead_token_id));
            assert(new_hps->m_hypothetical_head.HasParent());
            assert(new_hps->m_hypothetical_head.Parent() == hps.m_hypothetical_head);

            // Store the lookahead token id in action_data so it can printed.
            action_data = std::uint32_t(lookahead_token_id);
            if (new_hps->m_hypothetical_lookahead_token_id_queue.empty())
                ++new_hps->m_realized_lookahead_cursor;
            else
                new_hps->m_hypothetical_lookahead_token_id_queue.pop_front();
            break;
        }
        case ParseTreeNode_::INSERT_LOOKAHEAD_ERROR: {
            new_hps = hps.CloneLeafNode();
            new_hps->m_hypothetical_lookahead_token_id_queue.push_front(Terminal::ERROR_);
            break;
        }
        case ParseTreeNode_::DISCARD_LOOKAHEAD: {
            new_hps = hps.CloneLeafNode();
            if (new_hps->m_hypothetical_lookahead_token_id_queue.empty())
                ++new_hps->m_realized_lookahead_cursor;
            else
                new_hps->m_hypothetical_lookahead_token_id_queue.pop_front();
            break;
        }
        case ParseTreeNode_::POP_STACK: {
            // TODO: make separate action nodes for each pop, instead of using action data,
            // since for example two branches may agree on popping at least once, even if
            // one of them is killed later.
            std::uint32_t const &pop_count = action_data;
            assert(pop_count == 1 || pop_count == 2);
            assert(pop_count < hps.m_hypothetical_head.StatePtr()->BranchLength());
            // // Check if there are actually enough stack elements to pop successfully.
            // // If not, then don't create an HPS, and break early.
            // if (pop_count >= hps.m_hypothetical_head.StatePtr()->BranchLength())
            // {
            //     new_hps = NULL;
            //     break;
            // }

            new_hps = hps.CloneLeafNode();
            for (std::uint32_t i = 0; i < pop_count; ++i)
            {
                assert(new_hps->m_hypothetical_head.HasParent());
                new_hps->m_hypothetical_head = new_hps->m_hypothetical_head.Parent();
            }
            if (pop_count == 2)
                new_hps->m_hypothetical_lookahead_token_id_queue.push_front(Terminal::ERROR_);
            TRISON_CPP_DEBUG_CODE_(DSF_HPS_NODE_CREATION_DELETION, *DebugSpewStream() << "creating HPS to be child of POP_STACK node... ")
            break;
        }
        case ParseTreeNode_::HPS: {
            assert(false && "ParseTreeNode_::HPS is an invalid action type.");
            break;
        }
        default: {
            assert(false && "invalid ParseTreeNode_::Type");
            break;
        }
    }

    if (new_hps != NULL)
    {
        assert(new_hps->m_parent_node == NULL);

        ParseTreeNode_ *action_node = NULL;

        // Ensure the action node exists, creating it if necessary.
        ParseTreeNode_::Spec action_spec(action_type, action_data);
        if (hps.m_parent_node->HasChildrenHavingSpec(action_spec))
        {
            ParseTreeNode_::ParseTreeNodeSet &children_of_action_type = hps.m_parent_node->ChildrenHavingSpec(action_spec);
            assert(children_of_action_type.size() == 1);
            action_node = *children_of_action_type.begin();
            TRISON_CPP_DEBUG_CODE_(DSF_HPS_NODE_CREATION_DELETION, *DebugSpewStream() << "using existing action node of type " << ParseTreeNode_::AsString(action_spec.m_type) << "... ")

            // If the new hps already exists (can only happen as a child of POP_STACK), then don't add it.
            if (action_type == ParseTreeNode_::POP_STACK && action_node->HasChildrenHavingSpec(new_hps->m_spec))
            {
                ParseTreeNode_::ParseTreeNodeSet const &child_hps_set = action_node->ChildrenHavingSpec(new_hps->m_spec);
                if (child_hps_set.find(new_hps) != child_hps_set.end())
                {
                    TRISON_CPP_DEBUG_CODE_(DSF_HPS_NODE_CREATION_DELETION, *DebugSpewStream() << "not adding duplicate HPS as child of POP_STACK node... ")
                    delete new_hps;
                    new_hps = NULL;
                }
            }
        }
        else
        {
            TRISON_CPP_DEBUG_CODE_(DSF_HPS_NODE_CREATION_DELETION, *DebugSpewStream() << "creating new action node of type " << ParseTreeNode_::AsString(action_spec.m_type) << "... ")
            action_node = new ParseTreeNode_(action_spec);
            TRISON_CPP_DEBUG_CODE_(DSF_HPS_NODE_CREATION_DELETION, *DebugSpewStream() << "(action_node = " << action_node << ") ")
            hps.m_parent_node->AddChild(action_node);
        }

        if (new_hps != NULL)
            action_node->AddChild(new_hps);
    }

    return new_hps;
}

void Parser::CreateParseTreeFromRealizedState_ ()
{
    BranchVector_ const &reconstruct_branch_vector = m_realized_state_->BranchVectorStack().back();

    // Add HPS nodes for each branch in the top of the realized state stack.
    assert(!reconstruct_branch_vector.empty());
    TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 5697 "../bin/barftest/text/Parser.cpp"
 << "        Reconstructing branches:\n")
    for (BranchVector_::const_iterator it = reconstruct_branch_vector.begin(), it_end = reconstruct_branch_vector.end(); it != it_end; ++it)
    {
        Branch_ const &reconstruct_branch = *it;
        TRISON_CPP_DEBUG_CODE_(DSF_PARSE_TREE_MESSAGE, *DebugSpewStream() << 
#line 339 "../bin/barftest/text/Parser.trison"
"Parser" << (filoc().is_valid() ? " ("+filoc().as_string()+")" : std::string()) << ": "
#line 5705 "../bin/barftest/text/Parser.cpp"
 << "            " << reconstruct_branch.StatePtr() << '\n')

        ParseTreeNode_ *hps             = new ParseTreeNode_(ParseTreeNode_::Spec(ParseTreeNode_::HPS));
        hps->m_hypothetical_head        = reconstruct_branch;

        m_hypothetical_state_->m_root->AddChild(hps);
        m_hypothetical_state_->m_hps_queue.push_back(hps);
    }
}

void Parser::ClearStack_ ()
{
    if (m_realized_state_ != NULL)
    {
        // TODO: Could print the m_realized_state_ m_branch_vector_stack element being popped.
        while (!m_realized_state_->TokenStack().empty())
            ThrowAwayToken_(std::move(m_realized_state_->PopStack()));
    }

    delete m_hypothetical_state_;
    m_hypothetical_state_ = NULL;
}

void Parser::CleanUpAllInternals_ ()
{
    if (m_realized_state_ != NULL)
    {
        // TODO: Could print the m_realized_state_ m_branch_vector_stack element being popped.
        while (!m_realized_state_->TokenStack().empty())
            ThrowAwayToken_(std::move(m_realized_state_->PopStack()));

        while (!m_realized_state_->LookaheadQueue().empty())
            ThrowAwayToken_(std::move(m_realized_state_->PopFrontLookahead(m_hypothetical_state_->m_hps_queue)));

        // Note that this implicitly resets the error state (since that's tracked by m_realized_state_).
        delete m_realized_state_;
        m_realized_state_ = NULL;
    }

    delete m_hypothetical_state_;
    m_hypothetical_state_ = NULL;
}

// ////////////////////////////////////////////////////////////////////////////
// Parser::Grammar_
// ////////////////////////////////////////////////////////////////////////////

bool Parser::Grammar_::CompareRuleByPrecedence_ (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index)
{
    if (ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level != ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level)
        return ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level > ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level;
    else
        return lhs_rule_index < rhs_rule_index;
}

// These values are prescribed within trison and can't be changed.
char const *const Parser::Grammar_::ms_associativity_string_table_[] =
{
    "%left",
    "%nonassoc",
    "%right",
};

std::size_t const Parser::Grammar_::ms_associativity_count_ = sizeof(Parser::Grammar_::ms_associativity_string_table_) / sizeof(*Parser::Grammar_::ms_associativity_string_table_);

Parser::Grammar_::Precedence_ const Parser::Grammar_::ms_precedence_table_[] =
{
    { -1, Parser::Grammar_::Associativity(2), "SUPER_LOW" },
    { 0, Parser::Grammar_::Associativity(0), "DEFAULT_" },
    { 2, Parser::Grammar_::Associativity(2), "INITIALIZATION" },
    { 3, Parser::Grammar_::Associativity(2), "ASSIGNMENT" },
    { 4, Parser::Grammar_::Associativity(1), "TYPE_DECLARATION" },
    { 5, Parser::Grammar_::Associativity(2), "MAPPING" },
    { 6, Parser::Grammar_::Associativity(0), "CONDITIONAL_EXPRESSION" },
    { 7, Parser::Grammar_::Associativity(0), "LOGICAL_OR" },
    { 8, Parser::Grammar_::Associativity(0), "LOGICAL_XOR" },
    { 9, Parser::Grammar_::Associativity(0), "LOGICAL_AND" },
    { 10, Parser::Grammar_::Associativity(1), "EQUALITY" },
    { 11, Parser::Grammar_::Associativity(1), "COMPARISON" },
    { 12, Parser::Grammar_::Associativity(0), "ADDITIVE" },
    { 13, Parser::Grammar_::Associativity(0), "MULTIPLICATIVE" },
    { 14, Parser::Grammar_::Associativity(0), "LOW_UNARY" },
    { 15, Parser::Grammar_::Associativity(2), "HIGH_UNARY" },
    { 16, Parser::Grammar_::Associativity(2), "EXPONENTIATION" },
    { 17, Parser::Grammar_::Associativity(2), "POINTY" },
    { 18, Parser::Grammar_::Associativity(0), "AGGREGATE_MULTIPLIER" },
    { 19, Parser::Grammar_::Associativity(0), "FUNCTION_EVALUATION" },
    { 20, Parser::Grammar_::Associativity(0), "TINNY" },
    { 21, Parser::Grammar_::Associativity(0), "SPLUNGITIVE" },
    { 22, Parser::Grammar_::Associativity(0), "WOODY" },
    { 23, Parser::Grammar_::Associativity(0), "DINSDALACIOUS" }
};

std::size_t const Parser::Grammar_::ms_precedence_count_ = sizeof(Parser::Grammar_::ms_precedence_table_) / sizeof(*Parser::Grammar_::ms_precedence_table_);

std::size_t const Parser::Grammar_::ms_default_precedence_index_ = 1;

Parser::Grammar_::Rule_ const Parser::Grammar_::ms_rule_table_[] =
{
    { Parser::Nonterminal::root, 2, false, 1, "root <- statement_list END_" },
    { Parser::Nonterminal::root, 1, false, 1, "root <- END_" },
    { Parser::Nonterminal::expression_then_end, 2, false, 1, "expression_then_end <- expression END_" },
    { Parser::Nonterminal::expression_then_end, 2, false, 1, "expression_then_end <- ERROR_ END_" },
    { Parser::Nonterminal::expression_then_lookahead_end, 1, false, 1, "expression_then_lookahead_end <- expression %lookahead[END_]" },
    { Parser::Nonterminal::expression_then_lookahead_end, 1, false, 1, "expression_then_lookahead_end <- ERROR_ %lookahead[END_]" },
    { Parser::Nonterminal::parenthesized_expression, 3, false, 1, "parenthesized_expression <- '(' expression parenthesized_expression_ender" },
    { Parser::Nonterminal::parenthesized_expression, 3, false, 1, "parenthesized_expression <- '(' ERROR_ parenthesized_expression_ender" },
    { Parser::Nonterminal::parenthesized_expression_ender, 1, false, 1, "parenthesized_expression_ender <- ')'" },
    { Parser::Nonterminal::parenthesized_expression_ender, 0, true, 1, "parenthesized_expression_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::expression_tuple, 3, false, 1, "expression_tuple <- '[' expression_tuple_body expression_tuple_ender" },
    { Parser::Nonterminal::expression_tuple_ender, 1, false, 1, "expression_tuple_ender <- ']'" },
    { Parser::Nonterminal::expression_tuple_ender, 0, true, 1, "expression_tuple_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::expression_tuple_body, 2, false, 1, "expression_tuple_body <- expression_tuple_body expression_tuple_body_element" },
    { Parser::Nonterminal::expression_tuple_body, 1, false, 1, "expression_tuple_body <- expression_tuple_body_element" },
    { Parser::Nonterminal::expression_tuple_body, 0, true, 1, "expression_tuple_body <- %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { Parser::Nonterminal::expression_tuple_body_element, 2, false, 1, "expression_tuple_body_element <- expression expression_tuple_body_element_ender" },
    { Parser::Nonterminal::expression_tuple_body_element, 2, false, 1, "expression_tuple_body_element <- ERROR_ expression_tuple_body_element_ender" },
    { Parser::Nonterminal::expression_tuple_body_element_ender, 1, false, 1, "expression_tuple_body_element_ender <- ','" },
    { Parser::Nonterminal::expression_tuple_body_element_ender, 0, true, 1, "expression_tuple_body_element_ender <- %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- parenthesized_expression" },
    { Parser::Nonterminal::expression, 2, false, 1, "expression <- expression ')'" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- expression_tuple" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- IDENTIFIER %lookahead[![':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]]" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- VALUE_LITERAL" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- STRING_LITERAL" },
    { Parser::Nonterminal::expression, 5, false, 6, "expression <- expression IF expression OTHERWISE expression" },
    { Parser::Nonterminal::expression, 3, false, 7, "expression <- expression OR expression" },
    { Parser::Nonterminal::expression, 3, false, 8, "expression <- expression XOR expression" },
    { Parser::Nonterminal::expression, 3, false, 9, "expression <- expression AND expression" },
    { Parser::Nonterminal::expression, 3, false, 10, "expression <- expression EQUALS expression" },
    { Parser::Nonterminal::expression, 3, false, 10, "expression <- expression NOT_EQUALS expression" },
    { Parser::Nonterminal::expression, 3, false, 11, "expression <- expression LESS_THAN expression" },
    { Parser::Nonterminal::expression, 3, false, 11, "expression <- expression GREATER_THAN expression" },
    { Parser::Nonterminal::expression, 3, false, 11, "expression <- expression LESS_OR_EQUAL expression" },
    { Parser::Nonterminal::expression, 3, false, 11, "expression <- expression GREATER_OR_EQUAL expression" },
    { Parser::Nonterminal::expression, 3, false, 12, "expression <- expression '+' expression" },
    { Parser::Nonterminal::expression, 3, false, 12, "expression <- expression '-' expression" },
    { Parser::Nonterminal::expression, 3, false, 13, "expression <- expression '*' expression" },
    { Parser::Nonterminal::expression, 3, false, 13, "expression <- expression '/' expression" },
    { Parser::Nonterminal::expression, 3, false, 13, "expression <- expression '%' expression" },
    { Parser::Nonterminal::expression, 2, false, 15, "expression <- '-' expression" },
    { Parser::Nonterminal::expression, 2, false, 15, "expression <- NOT expression" },
    { Parser::Nonterminal::expression, 3, false, 16, "expression <- expression '^' expression" },
    { Parser::Nonterminal::expression, 2, false, 17, "expression <- expression '@'" },
    { Parser::Nonterminal::expression, 2, false, 17, "expression <- expression '#'" },
    { Parser::Nonterminal::expression, 4, false, 19, "expression <- expression '(' parameter_list_body parameter_list_ender" },
    { Parser::Nonterminal::expression, 4, false, 19, "expression <- expression '[' element_access_key_body_element element_access_key_ender" },
    { Parser::Nonterminal::expression, 1, false, 1, "expression <- function_literal" },
    { Parser::Nonterminal::expression, 6, false, 19, "expression <- LLVM_CAST_KEYWORD '(' expression ',' type_expression ')'" },
    { Parser::Nonterminal::expression, 4, false, 19, "expression <- LLVM_CAST_KEYWORD '(' ERROR_ ')'" },
    { Parser::Nonterminal::expression, 4, false, 19, "expression <- NULLPTR '{' type_expression '}'" },
    { Parser::Nonterminal::expression, 4, false, 19, "expression <- NULLPTR '{' ERROR_ '}'" },
    { Parser::Nonterminal::element_access_key_ender, 1, false, 1, "element_access_key_ender <- ']'" },
    { Parser::Nonterminal::element_access_key_ender, 0, true, 1, "element_access_key_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::element_access_key_body_element, 2, false, 1, "element_access_key_body_element <- expression element_access_key_body_element_ender" },
    { Parser::Nonterminal::element_access_key_body_element, 2, false, 1, "element_access_key_body_element <- ERROR_ element_access_key_body_element_ender" },
    { Parser::Nonterminal::element_access_key_body_element_ender, 1, false, 1, "element_access_key_body_element_ender <- ','" },
    { Parser::Nonterminal::element_access_key_body_element_ender, 0, true, 1, "element_access_key_body_element_ender <- %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { Parser::Nonterminal::parameter_list_ender, 1, false, 1, "parameter_list_ender <- ')'" },
    { Parser::Nonterminal::parameter_list_ender, 0, true, 1, "parameter_list_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::parameter_list_body, 2, false, 1, "parameter_list_body <- parameter_list_body parameter_list_body_element" },
    { Parser::Nonterminal::parameter_list_body, 1, false, 1, "parameter_list_body <- parameter_list_body_element" },
    { Parser::Nonterminal::parameter_list_body, 0, true, 1, "parameter_list_body <- %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { Parser::Nonterminal::parameter_list_body_element, 2, false, 1, "parameter_list_body_element <- expression parameter_list_body_element_ender" },
    { Parser::Nonterminal::parameter_list_body_element, 2, false, 1, "parameter_list_body_element <- ERROR_ parameter_list_body_element_ender" },
    { Parser::Nonterminal::parameter_list_body_element_ender, 1, false, 1, "parameter_list_body_element_ender <- ','" },
    { Parser::Nonterminal::parameter_list_body_element_ender, 0, true, 1, "parameter_list_body_element_ender <- %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { Parser::Nonterminal::function_literal, 2, false, 1, "function_literal <- function_prototype bracketed_statement_list" },
    { Parser::Nonterminal::function_prototype, 3, false, 5, "function_prototype <- function_prototype_domain_declaration_tuple MAPS_TO type_expression" },
    { Parser::Nonterminal::function_prototype_domain_declaration_tuple, 1, false, 1, "function_prototype_domain_declaration_tuple <- declaration_tuple %lookahead[MAPS_TO]" },
    { Parser::Nonterminal::function_prototype_domain_declaration_tuple, 1, false, 1, "function_prototype_domain_declaration_tuple <- ERROR_ %lookahead[MAPS_TO]" },
    { Parser::Nonterminal::type_tuple, 3, false, 1, "type_tuple <- '[' type_tuple_body type_tuple_ender" },
    { Parser::Nonterminal::type_tuple_ender, 1, false, 1, "type_tuple_ender <- ']'" },
    { Parser::Nonterminal::type_tuple_ender, 0, true, 1, "type_tuple_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::type_tuple_body, 2, false, 1, "type_tuple_body <- type_tuple_body type_tuple_body_element" },
    { Parser::Nonterminal::type_tuple_body, 1, false, 1, "type_tuple_body <- type_tuple_body_element" },
    { Parser::Nonterminal::type_tuple_body, 0, true, 1, "type_tuple_body <- %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { Parser::Nonterminal::type_tuple_body_element, 2, false, 1, "type_tuple_body_element <- type_expression type_tuple_body_element_ender" },
    { Parser::Nonterminal::type_tuple_body_element, 2, false, 1, "type_tuple_body_element <- ERROR_ type_tuple_body_element_ender" },
    { Parser::Nonterminal::type_tuple_body_element_ender, 1, false, 1, "type_tuple_body_element_ender <- ','" },
    { Parser::Nonterminal::type_tuple_body_element_ender, 0, true, 1, "type_tuple_body_element_ender <- %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- VOID_TYPE" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- NULL_TYPE" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- BOOLEAN" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- SINT8" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- SINT16" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- SINT32" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- SINT64" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- UINT8" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- UINT16" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- UINT32" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- UINT64" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- FLOAT32" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- FLOAT64" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- function_type" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- function_prototype" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- type_tuple" },
    { Parser::Nonterminal::type_expression, 3, false, 18, "type_expression <- type_tuple '*' VALUE_LITERAL" },
    { Parser::Nonterminal::type_expression, 1, false, 1, "type_expression <- IDENTIFIER" },
    { Parser::Nonterminal::type_expression, 2, false, 17, "type_expression <- type_expression '@'" },
    { Parser::Nonterminal::type_expression, 2, false, 17, "type_expression <- type_expression '#'" },
    { Parser::Nonterminal::function_type, 3, false, 5, "function_type <- function_type_domain MAPS_TO type_expression" },
    { Parser::Nonterminal::function_type_domain, 1, false, 1, "function_type_domain <- type_expression %lookahead[MAPS_TO]" },
    { Parser::Nonterminal::function_type_domain, 1, false, 1, "function_type_domain <- ERROR_ %lookahead[MAPS_TO]" },
    { Parser::Nonterminal::function_type_then_end, 2, false, 1, "function_type_then_end <- function_type END_" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier CT" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier RT" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier LOCAL" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier GLOBAL" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier EXTERNAL" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier INTERNAL" },
    { Parser::Nonterminal::symbol_specifier, 2, false, 14, "symbol_specifier <- symbol_specifier PRIVATE" },
    { Parser::Nonterminal::symbol_specifier, 1, false, 1, "symbol_specifier <- IDENTIFIER %lookahead[':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]" },
    { Parser::Nonterminal::declaration_statement, 2, false, 4, "declaration_statement <- declaration_symbol_specifier declaration_statement_type" },
    { Parser::Nonterminal::declaration_statement, 2, false, 4, "declaration_statement <- ERROR_ statement_ender" },
    { Parser::Nonterminal::declaration_statement_type, 2, false, 1, "declaration_statement_type <- TYPE_KEYWORD statement_ender" },
    { Parser::Nonterminal::declaration_statement_type, 2, false, 1, "declaration_statement_type <- type_expression statement_ender" },
    { Parser::Nonterminal::declaration_statement_type, 2, false, 1, "declaration_statement_type <- ERROR_ statement_ender" },
    { Parser::Nonterminal::initialization_statement, 2, false, 4, "initialization_statement <- initialization_id initialization_statement_content" },
    { Parser::Nonterminal::initialization_statement, 2, false, 4, "initialization_statement <- ERROR_ statement_ender" },
    { Parser::Nonterminal::initialization_id, 2, false, 1, "initialization_id <- IDENTIFIER INITIALIZE" },
    { Parser::Nonterminal::initialization_id, 2, false, 1, "initialization_id <- ERROR_ INITIALIZE" },
    { Parser::Nonterminal::initialization_statement_content, 2, false, 1, "initialization_statement_content <- type_expression statement_ender" },
    { Parser::Nonterminal::initialization_statement_content, 2, false, 1, "initialization_statement_content <- expression statement_ender" },
    { Parser::Nonterminal::initialization_statement_content, 2, false, 1, "initialization_statement_content <- ERROR_ statement_ender" },
    { Parser::Nonterminal::definition_statement, 2, false, 4, "definition_statement <- definition_symbol_specifier definition_statement_content" },
    { Parser::Nonterminal::definition_statement, 2, false, 4, "definition_statement <- ERROR_ statement_ender" },
    { Parser::Nonterminal::definition_symbol_specifier, 2, false, 1, "definition_symbol_specifier <- symbol_specifier DEFINE" },
    { Parser::Nonterminal::definition_symbol_specifier, 2, false, 1, "definition_symbol_specifier <- ERROR_ DEFINE" },
    { Parser::Nonterminal::definition_statement_content, 2, false, 1, "definition_statement_content <- type_expression statement_ender" },
    { Parser::Nonterminal::definition_statement_content, 2, false, 1, "definition_statement_content <- expression statement_ender" },
    { Parser::Nonterminal::definition_statement_content, 2, false, 1, "definition_statement_content <- ERROR_ statement_ender" },
    { Parser::Nonterminal::assignment_statement, 2, false, 3, "assignment_statement <- assignment_target assignment_statement_content" },
    { Parser::Nonterminal::assignment_target, 2, false, 1, "assignment_target <- expression ASSIGN" },
    { Parser::Nonterminal::assignment_target, 2, false, 1, "assignment_target <- ERROR_ ASSIGN" },
    { Parser::Nonterminal::assignment_statement_content, 2, false, 1, "assignment_statement_content <- type_expression statement_ender" },
    { Parser::Nonterminal::assignment_statement_content, 2, false, 1, "assignment_statement_content <- expression statement_ender" },
    { Parser::Nonterminal::assignment_statement_content, 2, false, 1, "assignment_statement_content <- ERROR_ statement_ender" },
    { Parser::Nonterminal::declaration_tuple, 3, false, 1, "declaration_tuple <- '(' declaration_tuple_body declaration_tuple_ender" },
    { Parser::Nonterminal::declaration_tuple_ender, 1, false, 1, "declaration_tuple_ender <- ')'" },
    { Parser::Nonterminal::declaration_tuple_ender, 0, true, 1, "declaration_tuple_ender <- %lookahead[END_|STATEMENT_DELIMITER]" },
    { Parser::Nonterminal::declaration_tuple_body, 2, false, 1, "declaration_tuple_body <- declaration_tuple_body declaration_tuple_body_element" },
    { Parser::Nonterminal::declaration_tuple_body, 1, false, 1, "declaration_tuple_body <- declaration_tuple_body_element" },
    { Parser::Nonterminal::declaration_tuple_body, 0, true, 1, "declaration_tuple_body <- %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { Parser::Nonterminal::declaration_tuple_body_element, 2, false, 4, "declaration_tuple_body_element <- declaration_symbol_specifier declaration_tuple_body_element_type" },
    { Parser::Nonterminal::declaration_tuple_body_element, 2, false, 4, "declaration_tuple_body_element <- ERROR_ declaration_tuple_body_element_ender" },
    { Parser::Nonterminal::declaration_symbol_specifier, 2, false, 1, "declaration_symbol_specifier <- symbol_specifier ':'" },
    { Parser::Nonterminal::declaration_symbol_specifier, 2, false, 1, "declaration_symbol_specifier <- ERROR_ ':'" },
    { Parser::Nonterminal::declaration_tuple_body_element_type, 2, false, 1, "declaration_tuple_body_element_type <- type_expression declaration_tuple_body_element_ender" },
    { Parser::Nonterminal::declaration_tuple_body_element_type, 2, false, 1, "declaration_tuple_body_element_type <- ERROR_ declaration_tuple_body_element_ender" },
    { Parser::Nonterminal::declaration_tuple_body_element_ender, 1, false, 1, "declaration_tuple_body_element_ender <- ','" },
    { Parser::Nonterminal::declaration_tuple_body_element_ender, 0, true, 0, "declaration_tuple_body_element_ender <- %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { Parser::Nonterminal::statement_then_end, 2, false, 1, "statement_then_end <- statement END_" },
    { Parser::Nonterminal::statement, 1, false, 1, "statement <- bracketed_statement_list" },
    { Parser::Nonterminal::statement, 1, false, 1, "statement <- declaration_statement" },
    { Parser::Nonterminal::statement, 1, false, 1, "statement <- initialization_statement" },
    { Parser::Nonterminal::statement, 1, false, 1, "statement <- definition_statement" },
    { Parser::Nonterminal::statement, 1, false, 1, "statement <- assignment_statement" },
    { Parser::Nonterminal::statement, 6, false, 1, "statement <- IF expression THEN statement OTHERWISE statement" },
    { Parser::Nonterminal::statement, 4, false, 1, "statement <- IF expression THEN statement %lookahead[![OTHERWISE]]" },
    { Parser::Nonterminal::statement, 4, false, 1, "statement <- WHILE expression DO statement" },
    { Parser::Nonterminal::statement, 4, false, 1, "statement <- DO statement WHILE expression" },
    { Parser::Nonterminal::statement, 2, false, 1, "statement <- BREAK statement_ender" },
    { Parser::Nonterminal::statement, 3, false, 1, "statement <- BREAK ERROR_ statement_ender" },
    { Parser::Nonterminal::statement, 2, false, 1, "statement <- RETURN statement_ender" },
    { Parser::Nonterminal::statement, 3, false, 1, "statement <- RETURN expression statement_ender" },
    { Parser::Nonterminal::statement, 3, false, 1, "statement <- RETURN ERROR_ statement_ender" },
    { Parser::Nonterminal::statement, 2, false, 1, "statement <- expression statement_ender" },
    { Parser::Nonterminal::statement, 2, false, 1, "statement <- ERROR_ statement_ender" },
    { Parser::Nonterminal::statement_ender, 1, false, 1, "statement_ender <- STATEMENT_DELIMITER" },
    { Parser::Nonterminal::statement_ender, 0, true, 1, "statement_ender <- %lookahead[END_|'}']" },
    { Parser::Nonterminal::bracketed_statement_list, 3, false, 1, "bracketed_statement_list <- '{' statement_list bracketed_statement_list_ender" },
    { Parser::Nonterminal::bracketed_statement_list_ender, 1, false, 1, "bracketed_statement_list_ender <- '}'" },
    { Parser::Nonterminal::bracketed_statement_list_ender, 0, true, 1, "bracketed_statement_list_ender <- %lookahead[END_]" },
    { Parser::Nonterminal::statement_list_then_end, 2, false, 1, "statement_list_then_end <- statement_list END_" },
    { Parser::Nonterminal::statement_list, 2, false, 1, "statement_list <- statement_list statement" },
    { Parser::Nonterminal::statement_list, 2, false, 1, "statement_list <- statement_list STATEMENT_DELIMITER" },
    { Parser::Nonterminal::statement_list, 0, true, 1, "statement_list <- %lookahead[![ERROR_]]" },
    { Parser::Nonterminal::lookahead_test_expression_then_end, 2, false, 1, "lookahead_test_expression_then_end <- lookahead_test_expression END_" },
    { Parser::Nonterminal::lookahead_test_expression, 1, false, 1, "lookahead_test_expression <- IDENTIFIER" },
    { Parser::Nonterminal::lookahead_test_expression, 6, false, 20, "lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { Parser::Nonterminal::lookahead_test_expression, 4, false, 21, "lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP lookahead_test_expression" },
    { Parser::Nonterminal::lookahead_test_expression, 3, false, 22, "lookahead_test_expression <- lookahead_test_expression FANCYOP lookahead_test_expression" },
    { Parser::Nonterminal::lookahead_test_expression, 5, false, 23, "lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { Parser::Nonterminal::id_list_then_end, 2, false, 1, "id_list_then_end <- id_list END_" },
    { Parser::Nonterminal::id_list, 2, false, 1, "id_list <- id_list IDENTIFIER" },
    { Parser::Nonterminal::id_list, 2, false, 1, "id_list <- id_list ERROR_" },
    { Parser::Nonterminal::id_list, 0, false, 1, "id_list <-" },
    { Parser::Nonterminal::parenthesized_id_list, 3, false, 1, "parenthesized_id_list <- '(' id_list ')'" }
};
std::size_t const Parser::Grammar_::ms_rule_count_ = sizeof(Parser::Grammar_::ms_rule_table_) / sizeof(*Parser::Grammar_::ms_rule_table_);

// ////////////////////////////////////////////////////////////////////////////
// Parser::Npda_
// ////////////////////////////////////////////////////////////////////////////

Parser::Npda_::StateIndexVector_ const &Parser::Npda_::EpsilonClosureOfState_ (StateIndex_ state_index)
{
    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<StateIndex_,StateIndexVector_> LookupTable;
    static LookupTable s_lookup_table;

    LookupTable::iterator find_it = s_lookup_table.find(state_index);
    if (find_it != s_lookup_table.end())
        return find_it->second;

    // Compute the epsilon closure as a set
    StateIndexSet_ epsilon_closure_set;
    ComputeEpsilonClosureOfState_(state_index, epsilon_closure_set);

    // Copy the states in the set into the memoized vector.
//    std::cerr << "EpsilonClosureOfState_(" << state_index << "):"; // HIPPO
    StateIndexVector_ &epsilon_closure = s_lookup_table[state_index];
    epsilon_closure.reserve(epsilon_closure_set.size());
    for (StateIndexSet_::const_iterator it = epsilon_closure_set.begin(), it_end = epsilon_closure_set.end(); it != it_end; ++it)
    {
//        std::cerr << ' ' << *it; // HIPPO
        epsilon_closure.push_back(*it);
    }
//    std::cerr << ";\n"; // HIPPO
    // Return the memoized value.
    return epsilon_closure;
}

void Parser::Npda_::ComputeEpsilonClosureOfState_ (StateIndex_ state_index, StateIndexSet_ &epsilon_closure)
{
    // NOTE: The working definition of epsilon closure in this implementation used to only include
    // states that had non-epsilon transitions, but has been changed to include all epsilon-reachable
    // states, including those having no non-epsilon transitions.

    // This implementation allows epsilon cycles.

    // If this state has already been visited, there's no reason to continue.
    if (epsilon_closure.find(state_index) != epsilon_closure.end())
        return;
    // Otherwise, mark it as visited.  This also prevents infinite recursion.
    else
        epsilon_closure.insert(state_index);

    // This set collects the epsilon closure with no duplicates
    State_ const &state = ms_state_table_[state_index];
    for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count;
         transition != transition_end;
         ++transition)
    {
        if (transition->m_type == Transition_::EPSILON)
            ComputeEpsilonClosureOfState_(transition->m_data_index, epsilon_closure);
    }
}

Parser::Npda_::TransitionVector_ const &Parser::Npda_::NonEpsilonTransitionsOfState_ (StateIndex_ state_index, std::uint32_t sorted_type_index)
{
    assert(Transition_::Order::MIN_SORTED_TYPE_INDEX <= sorted_type_index && sorted_type_index <= Transition_::Order::MAX_SORTED_TYPE_INDEX);

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::pair<StateIndex_,std::uint32_t> KeyType;
    typedef std::map<KeyType,TransitionVector_> LookupTable;
    static LookupTable s_lookup_table;

    KeyType key(state_index, sorted_type_index);
    LookupTable::iterator it = s_lookup_table.find(key);
    if (it != s_lookup_table.end())
        return it->second;

    // TODO: probably don't need to memoize epsilon closures because non-epsilon transitions is memoized.
    TransitionSet_ non_epsilon_transition_set;
    StateIndexVector_ const &epsilon_closure = EpsilonClosureOfState_(state_index);
    for (StateIndexVector_::const_iterator it = epsilon_closure.begin(), it_end = epsilon_closure.end(); it != it_end; ++it)
    {
        State_ const &state = ms_state_table_[*it];
        for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count; transition != transition_end; ++transition)
        {
            std::uint32_t transition_sorted_type_index = Transition_::Order::SortedTypeIndex(*transition);
            if (transition->m_type != Transition_::EPSILON && transition_sorted_type_index == sorted_type_index)
                non_epsilon_transition_set.insert(*transition);
        }
    }

    TransitionVector_ &non_epsilon_transitions = s_lookup_table[key];
    non_epsilon_transitions.reserve(non_epsilon_transition_set.size());
    for (TransitionSet_::const_iterator it = non_epsilon_transition_set.begin(), it_end = non_epsilon_transition_set.end(); it != it_end; ++it)
        non_epsilon_transitions.push_back(*it);
    return non_epsilon_transitions;
}

Parser::Npda_::State_ const Parser::Npda_::ms_state_table_[] =
{
    { 1, ms_transition_table_+0, 190, "FALLBACK" },
    { 2, ms_transition_table_+1, 190, "START root" },
    { 1, ms_transition_table_+3, 190, "RETURN root" },
    { 2, ms_transition_table_+4, 190, "head of: root" },
    { 4, ms_transition_table_+6, 0, "rule 0: root <- . statement_list END_" },
    { 3, ms_transition_table_+10, 0, "rule 0: root <- statement_list . END_" },
    { 2, ms_transition_table_+13, 190, "START statement_list" },
    { 1, ms_transition_table_+15, 190, "RETURN statement_list" },
    { 3, ms_transition_table_+16, 190, "head of: statement_list" },
    { 3, ms_transition_table_+19, 176, "rule 176: statement_list <- . statement_list statement" },
    { 4, ms_transition_table_+22, 176, "rule 176: statement_list <- statement_list . statement" },
    { 1, ms_transition_table_+26, 176, "rule 176: statement_list <- statement_list statement ." },
    { 2, ms_transition_table_+27, 190, "START statement" },
    { 1, ms_transition_table_+29, 190, "RETURN statement" },
    { 16, ms_transition_table_+30, 190, "head of: statement" },
    { 4, ms_transition_table_+46, 154, "rule 154: statement <- . bracketed_statement_list" },
    { 1, ms_transition_table_+50, 154, "rule 154: statement <- bracketed_statement_list ." },
    { 2, ms_transition_table_+51, 190, "START bracketed_statement_list" },
    { 1, ms_transition_table_+53, 190, "RETURN bracketed_statement_list" },
    { 1, ms_transition_table_+54, 190, "head of: bracketed_statement_list" },
    { 3, ms_transition_table_+55, 172, "rule 172: bracketed_statement_list <- . '{' statement_list bracketed_statement_list_ender" },
    { 4, ms_transition_table_+58, 172, "rule 172: bracketed_statement_list <- '{' . statement_list bracketed_statement_list_ender" },
    { 4, ms_transition_table_+62, 172, "rule 172: bracketed_statement_list <- '{' statement_list . bracketed_statement_list_ender" },
    { 1, ms_transition_table_+66, 172, "rule 172: bracketed_statement_list <- '{' statement_list bracketed_statement_list_ender ." },
    { 2, ms_transition_table_+67, 190, "START bracketed_statement_list_ender" },
    { 1, ms_transition_table_+69, 190, "RETURN bracketed_statement_list_ender" },
    { 2, ms_transition_table_+70, 190, "head of: bracketed_statement_list_ender" },
    { 3, ms_transition_table_+72, 173, "rule 173: bracketed_statement_list_ender <- . '}'" },
    { 1, ms_transition_table_+75, 173, "rule 173: bracketed_statement_list_ender <- '}' ." },
    { 3, ms_transition_table_+76, 174, "rule 174: bracketed_statement_list_ender <- . %lookahead[END_]" },
    { 4, ms_transition_table_+79, 155, "rule 155: statement <- . declaration_statement" },
    { 1, ms_transition_table_+83, 155, "rule 155: statement <- declaration_statement ." },
    { 2, ms_transition_table_+84, 190, "START declaration_statement" },
    { 1, ms_transition_table_+86, 190, "RETURN declaration_statement" },
    { 2, ms_transition_table_+87, 190, "head of: declaration_statement" },
    { 4, ms_transition_table_+89, 114, "rule 114: declaration_statement <- . declaration_symbol_specifier declaration_statement_type" },
    { 4, ms_transition_table_+93, 114, "rule 114: declaration_statement <- declaration_symbol_specifier . declaration_statement_type" },
    { 2, ms_transition_table_+97, 190, "START declaration_symbol_specifier" },
    { 1, ms_transition_table_+99, 190, "RETURN declaration_symbol_specifier" },
    { 2, ms_transition_table_+100, 190, "head of: declaration_symbol_specifier" },
    { 4, ms_transition_table_+102, 147, "rule 147: declaration_symbol_specifier <- . symbol_specifier ':'" },
    { 3, ms_transition_table_+106, 147, "rule 147: declaration_symbol_specifier <- symbol_specifier . ':'" },
    { 2, ms_transition_table_+109, 190, "START symbol_specifier" },
    { 1, ms_transition_table_+111, 190, "RETURN symbol_specifier" },
    { 8, ms_transition_table_+112, 190, "head of: symbol_specifier" },
    { 3, ms_transition_table_+120, 106, "rule 106: symbol_specifier <- . symbol_specifier CT" },
    { 3, ms_transition_table_+123, 106, "rule 106: symbol_specifier <- symbol_specifier . CT" },
    { 1, ms_transition_table_+126, 106, "rule 106: symbol_specifier <- symbol_specifier CT ." },
    { 3, ms_transition_table_+127, 107, "rule 107: symbol_specifier <- . symbol_specifier RT" },
    { 3, ms_transition_table_+130, 107, "rule 107: symbol_specifier <- symbol_specifier . RT" },
    { 1, ms_transition_table_+133, 107, "rule 107: symbol_specifier <- symbol_specifier RT ." },
    { 3, ms_transition_table_+134, 108, "rule 108: symbol_specifier <- . symbol_specifier LOCAL" },
    { 3, ms_transition_table_+137, 108, "rule 108: symbol_specifier <- symbol_specifier . LOCAL" },
    { 1, ms_transition_table_+140, 108, "rule 108: symbol_specifier <- symbol_specifier LOCAL ." },
    { 3, ms_transition_table_+141, 109, "rule 109: symbol_specifier <- . symbol_specifier GLOBAL" },
    { 3, ms_transition_table_+144, 109, "rule 109: symbol_specifier <- symbol_specifier . GLOBAL" },
    { 1, ms_transition_table_+147, 109, "rule 109: symbol_specifier <- symbol_specifier GLOBAL ." },
    { 3, ms_transition_table_+148, 110, "rule 110: symbol_specifier <- . symbol_specifier EXTERNAL" },
    { 3, ms_transition_table_+151, 110, "rule 110: symbol_specifier <- symbol_specifier . EXTERNAL" },
    { 1, ms_transition_table_+154, 110, "rule 110: symbol_specifier <- symbol_specifier EXTERNAL ." },
    { 3, ms_transition_table_+155, 111, "rule 111: symbol_specifier <- . symbol_specifier INTERNAL" },
    { 3, ms_transition_table_+158, 111, "rule 111: symbol_specifier <- symbol_specifier . INTERNAL" },
    { 1, ms_transition_table_+161, 111, "rule 111: symbol_specifier <- symbol_specifier INTERNAL ." },
    { 3, ms_transition_table_+162, 112, "rule 112: symbol_specifier <- . symbol_specifier PRIVATE" },
    { 3, ms_transition_table_+165, 112, "rule 112: symbol_specifier <- symbol_specifier . PRIVATE" },
    { 1, ms_transition_table_+168, 112, "rule 112: symbol_specifier <- symbol_specifier PRIVATE ." },
    { 3, ms_transition_table_+169, 113, "rule 113: symbol_specifier <- . IDENTIFIER %lookahead[':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]" },
    { 11, ms_transition_table_+172, 113, "rule 113: symbol_specifier <- IDENTIFIER . %lookahead[':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]" },
    { 1, ms_transition_table_+183, 147, "rule 147: declaration_symbol_specifier <- symbol_specifier ':' ." },
    { 2, ms_transition_table_+184, 148, "rule 148: declaration_symbol_specifier <- . ERROR_ ':'" },
    { 4, ms_transition_table_+186, 148, "rule 148: declaration_symbol_specifier <- ERROR_ . ':'" },
    { 1, ms_transition_table_+190, 148, "rule 148: declaration_symbol_specifier <- ERROR_ ':' ." },
    { 1, ms_transition_table_+191, 114, "rule 114: declaration_statement <- declaration_symbol_specifier declaration_statement_type ." },
    { 2, ms_transition_table_+192, 190, "START declaration_statement_type" },
    { 1, ms_transition_table_+194, 190, "RETURN declaration_statement_type" },
    { 3, ms_transition_table_+195, 190, "head of: declaration_statement_type" },
    { 3, ms_transition_table_+198, 116, "rule 116: declaration_statement_type <- . TYPE_KEYWORD statement_ender" },
    { 4, ms_transition_table_+201, 116, "rule 116: declaration_statement_type <- TYPE_KEYWORD . statement_ender" },
    { 1, ms_transition_table_+205, 116, "rule 116: declaration_statement_type <- TYPE_KEYWORD statement_ender ." },
    { 2, ms_transition_table_+206, 190, "START statement_ender" },
    { 1, ms_transition_table_+208, 190, "RETURN statement_ender" },
    { 2, ms_transition_table_+209, 190, "head of: statement_ender" },
    { 3, ms_transition_table_+211, 170, "rule 170: statement_ender <- . STATEMENT_DELIMITER" },
    { 1, ms_transition_table_+214, 170, "rule 170: statement_ender <- STATEMENT_DELIMITER ." },
    { 4, ms_transition_table_+215, 171, "rule 171: statement_ender <- . %lookahead[END_|'}']" },
    { 4, ms_transition_table_+219, 117, "rule 117: declaration_statement_type <- . type_expression statement_ender" },
    { 4, ms_transition_table_+223, 117, "rule 117: declaration_statement_type <- type_expression . statement_ender" },
    { 2, ms_transition_table_+227, 190, "START type_expression" },
    { 1, ms_transition_table_+229, 190, "RETURN type_expression" },
    { 20, ms_transition_table_+230, 190, "head of: type_expression" },
    { 3, ms_transition_table_+250, 82, "rule 82: type_expression <- . VOID_TYPE" },
    { 1, ms_transition_table_+253, 82, "rule 82: type_expression <- VOID_TYPE ." },
    { 3, ms_transition_table_+254, 83, "rule 83: type_expression <- . NULL_TYPE" },
    { 1, ms_transition_table_+257, 83, "rule 83: type_expression <- NULL_TYPE ." },
    { 3, ms_transition_table_+258, 84, "rule 84: type_expression <- . BOOLEAN" },
    { 1, ms_transition_table_+261, 84, "rule 84: type_expression <- BOOLEAN ." },
    { 3, ms_transition_table_+262, 85, "rule 85: type_expression <- . SINT8" },
    { 1, ms_transition_table_+265, 85, "rule 85: type_expression <- SINT8 ." },
    { 3, ms_transition_table_+266, 86, "rule 86: type_expression <- . SINT16" },
    { 1, ms_transition_table_+269, 86, "rule 86: type_expression <- SINT16 ." },
    { 3, ms_transition_table_+270, 87, "rule 87: type_expression <- . SINT32" },
    { 1, ms_transition_table_+273, 87, "rule 87: type_expression <- SINT32 ." },
    { 3, ms_transition_table_+274, 88, "rule 88: type_expression <- . SINT64" },
    { 1, ms_transition_table_+277, 88, "rule 88: type_expression <- SINT64 ." },
    { 3, ms_transition_table_+278, 89, "rule 89: type_expression <- . UINT8" },
    { 1, ms_transition_table_+281, 89, "rule 89: type_expression <- UINT8 ." },
    { 3, ms_transition_table_+282, 90, "rule 90: type_expression <- . UINT16" },
    { 1, ms_transition_table_+285, 90, "rule 90: type_expression <- UINT16 ." },
    { 3, ms_transition_table_+286, 91, "rule 91: type_expression <- . UINT32" },
    { 1, ms_transition_table_+289, 91, "rule 91: type_expression <- UINT32 ." },
    { 3, ms_transition_table_+290, 92, "rule 92: type_expression <- . UINT64" },
    { 1, ms_transition_table_+293, 92, "rule 92: type_expression <- UINT64 ." },
    { 3, ms_transition_table_+294, 93, "rule 93: type_expression <- . FLOAT32" },
    { 1, ms_transition_table_+297, 93, "rule 93: type_expression <- FLOAT32 ." },
    { 3, ms_transition_table_+298, 94, "rule 94: type_expression <- . FLOAT64" },
    { 1, ms_transition_table_+301, 94, "rule 94: type_expression <- FLOAT64 ." },
    { 4, ms_transition_table_+302, 95, "rule 95: type_expression <- . function_type" },
    { 1, ms_transition_table_+306, 95, "rule 95: type_expression <- function_type ." },
    { 2, ms_transition_table_+307, 190, "START function_type" },
    { 1, ms_transition_table_+309, 190, "RETURN function_type" },
    { 1, ms_transition_table_+310, 190, "head of: function_type" },
    { 4, ms_transition_table_+311, 102, "rule 102: function_type <- . function_type_domain MAPS_TO type_expression" },
    { 3, ms_transition_table_+315, 102, "rule 102: function_type <- function_type_domain . MAPS_TO type_expression" },
    { 2, ms_transition_table_+318, 190, "START function_type_domain" },
    { 1, ms_transition_table_+320, 190, "RETURN function_type_domain" },
    { 2, ms_transition_table_+321, 190, "head of: function_type_domain" },
    { 4, ms_transition_table_+323, 103, "rule 103: function_type_domain <- . type_expression %lookahead[MAPS_TO]" },
    { 3, ms_transition_table_+327, 103, "rule 103: function_type_domain <- type_expression . %lookahead[MAPS_TO]" },
    { 2, ms_transition_table_+330, 104, "rule 104: function_type_domain <- . ERROR_ %lookahead[MAPS_TO]" },
    { 3, ms_transition_table_+332, 104, "rule 104: function_type_domain <- ERROR_ . %lookahead[MAPS_TO]" },
    { 4, ms_transition_table_+335, 102, "rule 102: function_type <- function_type_domain MAPS_TO . type_expression" },
    { 1, ms_transition_table_+339, 102, "rule 102: function_type <- function_type_domain MAPS_TO type_expression ." },
    { 4, ms_transition_table_+340, 96, "rule 96: type_expression <- . function_prototype" },
    { 1, ms_transition_table_+344, 96, "rule 96: type_expression <- function_prototype ." },
    { 2, ms_transition_table_+345, 190, "START function_prototype" },
    { 1, ms_transition_table_+347, 190, "RETURN function_prototype" },
    { 1, ms_transition_table_+348, 190, "head of: function_prototype" },
    { 4, ms_transition_table_+349, 69, "rule 69: function_prototype <- . function_prototype_domain_declaration_tuple MAPS_TO type_expression" },
    { 3, ms_transition_table_+353, 69, "rule 69: function_prototype <- function_prototype_domain_declaration_tuple . MAPS_TO type_expression" },
    { 2, ms_transition_table_+356, 190, "START function_prototype_domain_declaration_tuple" },
    { 1, ms_transition_table_+358, 190, "RETURN function_prototype_domain_declaration_tuple" },
    { 2, ms_transition_table_+359, 190, "head of: function_prototype_domain_declaration_tuple" },
    { 4, ms_transition_table_+361, 70, "rule 70: function_prototype_domain_declaration_tuple <- . declaration_tuple %lookahead[MAPS_TO]" },
    { 3, ms_transition_table_+365, 70, "rule 70: function_prototype_domain_declaration_tuple <- declaration_tuple . %lookahead[MAPS_TO]" },
    { 2, ms_transition_table_+368, 190, "START declaration_tuple" },
    { 1, ms_transition_table_+370, 190, "RETURN declaration_tuple" },
    { 1, ms_transition_table_+371, 190, "head of: declaration_tuple" },
    { 3, ms_transition_table_+372, 139, "rule 139: declaration_tuple <- . '(' declaration_tuple_body declaration_tuple_ender" },
    { 4, ms_transition_table_+375, 139, "rule 139: declaration_tuple <- '(' . declaration_tuple_body declaration_tuple_ender" },
    { 4, ms_transition_table_+379, 139, "rule 139: declaration_tuple <- '(' declaration_tuple_body . declaration_tuple_ender" },
    { 2, ms_transition_table_+383, 190, "START declaration_tuple_body" },
    { 1, ms_transition_table_+385, 190, "RETURN declaration_tuple_body" },
    { 3, ms_transition_table_+386, 190, "head of: declaration_tuple_body" },
    { 3, ms_transition_table_+389, 142, "rule 142: declaration_tuple_body <- . declaration_tuple_body declaration_tuple_body_element" },
    { 4, ms_transition_table_+392, 142, "rule 142: declaration_tuple_body <- declaration_tuple_body . declaration_tuple_body_element" },
    { 1, ms_transition_table_+396, 142, "rule 142: declaration_tuple_body <- declaration_tuple_body declaration_tuple_body_element ." },
    { 2, ms_transition_table_+397, 190, "START declaration_tuple_body_element" },
    { 1, ms_transition_table_+399, 190, "RETURN declaration_tuple_body_element" },
    { 2, ms_transition_table_+400, 190, "head of: declaration_tuple_body_element" },
    { 4, ms_transition_table_+402, 145, "rule 145: declaration_tuple_body_element <- . declaration_symbol_specifier declaration_tuple_body_element_type" },
    { 4, ms_transition_table_+406, 145, "rule 145: declaration_tuple_body_element <- declaration_symbol_specifier . declaration_tuple_body_element_type" },
    { 1, ms_transition_table_+410, 145, "rule 145: declaration_tuple_body_element <- declaration_symbol_specifier declaration_tuple_body_element_type ." },
    { 2, ms_transition_table_+411, 190, "START declaration_tuple_body_element_type" },
    { 1, ms_transition_table_+413, 190, "RETURN declaration_tuple_body_element_type" },
    { 2, ms_transition_table_+414, 190, "head of: declaration_tuple_body_element_type" },
    { 4, ms_transition_table_+416, 149, "rule 149: declaration_tuple_body_element_type <- . type_expression declaration_tuple_body_element_ender" },
    { 4, ms_transition_table_+420, 149, "rule 149: declaration_tuple_body_element_type <- type_expression . declaration_tuple_body_element_ender" },
    { 1, ms_transition_table_+424, 149, "rule 149: declaration_tuple_body_element_type <- type_expression declaration_tuple_body_element_ender ." },
    { 2, ms_transition_table_+425, 190, "START declaration_tuple_body_element_ender" },
    { 1, ms_transition_table_+427, 190, "RETURN declaration_tuple_body_element_ender" },
    { 2, ms_transition_table_+428, 190, "head of: declaration_tuple_body_element_ender" },
    { 3, ms_transition_table_+430, 151, "rule 151: declaration_tuple_body_element_ender <- . ','" },
    { 1, ms_transition_table_+433, 151, "rule 151: declaration_tuple_body_element_ender <- ',' ." },
    { 5, ms_transition_table_+434, 152, "rule 152: declaration_tuple_body_element_ender <- . %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { 2, ms_transition_table_+439, 150, "rule 150: declaration_tuple_body_element_type <- . ERROR_ declaration_tuple_body_element_ender" },
    { 7, ms_transition_table_+441, 150, "rule 150: declaration_tuple_body_element_type <- ERROR_ . declaration_tuple_body_element_ender" },
    { 1, ms_transition_table_+448, 150, "rule 150: declaration_tuple_body_element_type <- ERROR_ declaration_tuple_body_element_ender ." },
    { 2, ms_transition_table_+449, 146, "rule 146: declaration_tuple_body_element <- . ERROR_ declaration_tuple_body_element_ender" },
    { 7, ms_transition_table_+451, 146, "rule 146: declaration_tuple_body_element <- ERROR_ . declaration_tuple_body_element_ender" },
    { 1, ms_transition_table_+458, 146, "rule 146: declaration_tuple_body_element <- ERROR_ declaration_tuple_body_element_ender ." },
    { 4, ms_transition_table_+459, 143, "rule 143: declaration_tuple_body <- . declaration_tuple_body_element" },
    { 1, ms_transition_table_+463, 143, "rule 143: declaration_tuple_body <- declaration_tuple_body_element ." },
    { 5, ms_transition_table_+464, 144, "rule 144: declaration_tuple_body <- . %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { 1, ms_transition_table_+469, 139, "rule 139: declaration_tuple <- '(' declaration_tuple_body declaration_tuple_ender ." },
    { 2, ms_transition_table_+470, 190, "START declaration_tuple_ender" },
    { 1, ms_transition_table_+472, 190, "RETURN declaration_tuple_ender" },
    { 2, ms_transition_table_+473, 190, "head of: declaration_tuple_ender" },
    { 3, ms_transition_table_+475, 140, "rule 140: declaration_tuple_ender <- . ')'" },
    { 1, ms_transition_table_+478, 140, "rule 140: declaration_tuple_ender <- ')' ." },
    { 4, ms_transition_table_+479, 141, "rule 141: declaration_tuple_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 2, ms_transition_table_+483, 71, "rule 71: function_prototype_domain_declaration_tuple <- . ERROR_ %lookahead[MAPS_TO]" },
    { 3, ms_transition_table_+485, 71, "rule 71: function_prototype_domain_declaration_tuple <- ERROR_ . %lookahead[MAPS_TO]" },
    { 4, ms_transition_table_+488, 69, "rule 69: function_prototype <- function_prototype_domain_declaration_tuple MAPS_TO . type_expression" },
    { 1, ms_transition_table_+492, 69, "rule 69: function_prototype <- function_prototype_domain_declaration_tuple MAPS_TO type_expression ." },
    { 4, ms_transition_table_+493, 97, "rule 97: type_expression <- . type_tuple" },
    { 1, ms_transition_table_+497, 97, "rule 97: type_expression <- type_tuple ." },
    { 2, ms_transition_table_+498, 190, "START type_tuple" },
    { 1, ms_transition_table_+500, 190, "RETURN type_tuple" },
    { 1, ms_transition_table_+501, 190, "head of: type_tuple" },
    { 3, ms_transition_table_+502, 72, "rule 72: type_tuple <- . '[' type_tuple_body type_tuple_ender" },
    { 4, ms_transition_table_+505, 72, "rule 72: type_tuple <- '[' . type_tuple_body type_tuple_ender" },
    { 4, ms_transition_table_+509, 72, "rule 72: type_tuple <- '[' type_tuple_body . type_tuple_ender" },
    { 2, ms_transition_table_+513, 190, "START type_tuple_body" },
    { 1, ms_transition_table_+515, 190, "RETURN type_tuple_body" },
    { 3, ms_transition_table_+516, 190, "head of: type_tuple_body" },
    { 3, ms_transition_table_+519, 75, "rule 75: type_tuple_body <- . type_tuple_body type_tuple_body_element" },
    { 4, ms_transition_table_+522, 75, "rule 75: type_tuple_body <- type_tuple_body . type_tuple_body_element" },
    { 1, ms_transition_table_+526, 75, "rule 75: type_tuple_body <- type_tuple_body type_tuple_body_element ." },
    { 2, ms_transition_table_+527, 190, "START type_tuple_body_element" },
    { 1, ms_transition_table_+529, 190, "RETURN type_tuple_body_element" },
    { 2, ms_transition_table_+530, 190, "head of: type_tuple_body_element" },
    { 4, ms_transition_table_+532, 78, "rule 78: type_tuple_body_element <- . type_expression type_tuple_body_element_ender" },
    { 4, ms_transition_table_+536, 78, "rule 78: type_tuple_body_element <- type_expression . type_tuple_body_element_ender" },
    { 1, ms_transition_table_+540, 78, "rule 78: type_tuple_body_element <- type_expression type_tuple_body_element_ender ." },
    { 2, ms_transition_table_+541, 190, "START type_tuple_body_element_ender" },
    { 1, ms_transition_table_+543, 190, "RETURN type_tuple_body_element_ender" },
    { 2, ms_transition_table_+544, 190, "head of: type_tuple_body_element_ender" },
    { 3, ms_transition_table_+546, 80, "rule 80: type_tuple_body_element_ender <- . ','" },
    { 1, ms_transition_table_+549, 80, "rule 80: type_tuple_body_element_ender <- ',' ." },
    { 5, ms_transition_table_+550, 81, "rule 81: type_tuple_body_element_ender <- . %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { 2, ms_transition_table_+555, 79, "rule 79: type_tuple_body_element <- . ERROR_ type_tuple_body_element_ender" },
    { 7, ms_transition_table_+557, 79, "rule 79: type_tuple_body_element <- ERROR_ . type_tuple_body_element_ender" },
    { 1, ms_transition_table_+564, 79, "rule 79: type_tuple_body_element <- ERROR_ type_tuple_body_element_ender ." },
    { 4, ms_transition_table_+565, 76, "rule 76: type_tuple_body <- . type_tuple_body_element" },
    { 1, ms_transition_table_+569, 76, "rule 76: type_tuple_body <- type_tuple_body_element ." },
    { 5, ms_transition_table_+570, 77, "rule 77: type_tuple_body <- . %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { 1, ms_transition_table_+575, 72, "rule 72: type_tuple <- '[' type_tuple_body type_tuple_ender ." },
    { 2, ms_transition_table_+576, 190, "START type_tuple_ender" },
    { 1, ms_transition_table_+578, 190, "RETURN type_tuple_ender" },
    { 2, ms_transition_table_+579, 190, "head of: type_tuple_ender" },
    { 3, ms_transition_table_+581, 73, "rule 73: type_tuple_ender <- . ']'" },
    { 1, ms_transition_table_+584, 73, "rule 73: type_tuple_ender <- ']' ." },
    { 4, ms_transition_table_+585, 74, "rule 74: type_tuple_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 4, ms_transition_table_+589, 98, "rule 98: type_expression <- . type_tuple '*' VALUE_LITERAL" },
    { 3, ms_transition_table_+593, 98, "rule 98: type_expression <- type_tuple . '*' VALUE_LITERAL" },
    { 3, ms_transition_table_+596, 98, "rule 98: type_expression <- type_tuple '*' . VALUE_LITERAL" },
    { 1, ms_transition_table_+599, 98, "rule 98: type_expression <- type_tuple '*' VALUE_LITERAL ." },
    { 3, ms_transition_table_+600, 99, "rule 99: type_expression <- . IDENTIFIER" },
    { 1, ms_transition_table_+603, 99, "rule 99: type_expression <- IDENTIFIER ." },
    { 3, ms_transition_table_+604, 100, "rule 100: type_expression <- . type_expression '@'" },
    { 3, ms_transition_table_+607, 100, "rule 100: type_expression <- type_expression . '@'" },
    { 1, ms_transition_table_+610, 100, "rule 100: type_expression <- type_expression '@' ." },
    { 3, ms_transition_table_+611, 101, "rule 101: type_expression <- . type_expression '#'" },
    { 3, ms_transition_table_+614, 101, "rule 101: type_expression <- type_expression . '#'" },
    { 1, ms_transition_table_+617, 101, "rule 101: type_expression <- type_expression '#' ." },
    { 1, ms_transition_table_+618, 117, "rule 117: declaration_statement_type <- type_expression statement_ender ." },
    { 2, ms_transition_table_+619, 118, "rule 118: declaration_statement_type <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+621, 118, "rule 118: declaration_statement_type <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+627, 118, "rule 118: declaration_statement_type <- ERROR_ statement_ender ." },
    { 2, ms_transition_table_+628, 115, "rule 115: declaration_statement <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+630, 115, "rule 115: declaration_statement <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+636, 115, "rule 115: declaration_statement <- ERROR_ statement_ender ." },
    { 4, ms_transition_table_+637, 156, "rule 156: statement <- . initialization_statement" },
    { 1, ms_transition_table_+641, 156, "rule 156: statement <- initialization_statement ." },
    { 2, ms_transition_table_+642, 190, "START initialization_statement" },
    { 1, ms_transition_table_+644, 190, "RETURN initialization_statement" },
    { 2, ms_transition_table_+645, 190, "head of: initialization_statement" },
    { 4, ms_transition_table_+647, 119, "rule 119: initialization_statement <- . initialization_id initialization_statement_content" },
    { 4, ms_transition_table_+651, 119, "rule 119: initialization_statement <- initialization_id . initialization_statement_content" },
    { 2, ms_transition_table_+655, 190, "START initialization_id" },
    { 1, ms_transition_table_+657, 190, "RETURN initialization_id" },
    { 2, ms_transition_table_+658, 190, "head of: initialization_id" },
    { 3, ms_transition_table_+660, 121, "rule 121: initialization_id <- . IDENTIFIER INITIALIZE" },
    { 3, ms_transition_table_+663, 121, "rule 121: initialization_id <- IDENTIFIER . INITIALIZE" },
    { 1, ms_transition_table_+666, 121, "rule 121: initialization_id <- IDENTIFIER INITIALIZE ." },
    { 2, ms_transition_table_+667, 122, "rule 122: initialization_id <- . ERROR_ INITIALIZE" },
    { 4, ms_transition_table_+669, 122, "rule 122: initialization_id <- ERROR_ . INITIALIZE" },
    { 1, ms_transition_table_+673, 122, "rule 122: initialization_id <- ERROR_ INITIALIZE ." },
    { 1, ms_transition_table_+674, 119, "rule 119: initialization_statement <- initialization_id initialization_statement_content ." },
    { 2, ms_transition_table_+675, 190, "START initialization_statement_content" },
    { 1, ms_transition_table_+677, 190, "RETURN initialization_statement_content" },
    { 3, ms_transition_table_+678, 190, "head of: initialization_statement_content" },
    { 4, ms_transition_table_+681, 123, "rule 123: initialization_statement_content <- . type_expression statement_ender" },
    { 4, ms_transition_table_+685, 123, "rule 123: initialization_statement_content <- type_expression . statement_ender" },
    { 1, ms_transition_table_+689, 123, "rule 123: initialization_statement_content <- type_expression statement_ender ." },
    { 4, ms_transition_table_+690, 124, "rule 124: initialization_statement_content <- . expression statement_ender" },
    { 4, ms_transition_table_+694, 124, "rule 124: initialization_statement_content <- expression . statement_ender" },
    { 2, ms_transition_table_+698, 190, "START expression" },
    { 1, ms_transition_table_+700, 190, "RETURN expression" },
    { 33, ms_transition_table_+701, 190, "head of: expression" },
    { 4, ms_transition_table_+734, 20, "rule 20: expression <- . parenthesized_expression" },
    { 1, ms_transition_table_+738, 20, "rule 20: expression <- parenthesized_expression ." },
    { 2, ms_transition_table_+739, 190, "START parenthesized_expression" },
    { 1, ms_transition_table_+741, 190, "RETURN parenthesized_expression" },
    { 2, ms_transition_table_+742, 190, "head of: parenthesized_expression" },
    { 3, ms_transition_table_+744, 6, "rule 6: parenthesized_expression <- . '(' expression parenthesized_expression_ender" },
    { 4, ms_transition_table_+747, 6, "rule 6: parenthesized_expression <- '(' . expression parenthesized_expression_ender" },
    { 4, ms_transition_table_+751, 6, "rule 6: parenthesized_expression <- '(' expression . parenthesized_expression_ender" },
    { 1, ms_transition_table_+755, 6, "rule 6: parenthesized_expression <- '(' expression parenthesized_expression_ender ." },
    { 2, ms_transition_table_+756, 190, "START parenthesized_expression_ender" },
    { 1, ms_transition_table_+758, 190, "RETURN parenthesized_expression_ender" },
    { 2, ms_transition_table_+759, 190, "head of: parenthesized_expression_ender" },
    { 3, ms_transition_table_+761, 8, "rule 8: parenthesized_expression_ender <- . ')'" },
    { 1, ms_transition_table_+764, 8, "rule 8: parenthesized_expression_ender <- ')' ." },
    { 4, ms_transition_table_+765, 9, "rule 9: parenthesized_expression_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 3, ms_transition_table_+769, 7, "rule 7: parenthesized_expression <- . '(' ERROR_ parenthesized_expression_ender" },
    { 2, ms_transition_table_+772, 7, "rule 7: parenthesized_expression <- '(' . ERROR_ parenthesized_expression_ender" },
    { 5, ms_transition_table_+774, 7, "rule 7: parenthesized_expression <- '(' ERROR_ . parenthesized_expression_ender" },
    { 1, ms_transition_table_+779, 7, "rule 7: parenthesized_expression <- '(' ERROR_ parenthesized_expression_ender ." },
    { 3, ms_transition_table_+780, 21, "rule 21: expression <- . expression ')'" },
    { 3, ms_transition_table_+783, 21, "rule 21: expression <- expression . ')'" },
    { 1, ms_transition_table_+786, 21, "rule 21: expression <- expression ')' ." },
    { 4, ms_transition_table_+787, 22, "rule 22: expression <- . expression_tuple" },
    { 1, ms_transition_table_+791, 22, "rule 22: expression <- expression_tuple ." },
    { 2, ms_transition_table_+792, 190, "START expression_tuple" },
    { 1, ms_transition_table_+794, 190, "RETURN expression_tuple" },
    { 1, ms_transition_table_+795, 190, "head of: expression_tuple" },
    { 3, ms_transition_table_+796, 10, "rule 10: expression_tuple <- . '[' expression_tuple_body expression_tuple_ender" },
    { 4, ms_transition_table_+799, 10, "rule 10: expression_tuple <- '[' . expression_tuple_body expression_tuple_ender" },
    { 4, ms_transition_table_+803, 10, "rule 10: expression_tuple <- '[' expression_tuple_body . expression_tuple_ender" },
    { 2, ms_transition_table_+807, 190, "START expression_tuple_body" },
    { 1, ms_transition_table_+809, 190, "RETURN expression_tuple_body" },
    { 3, ms_transition_table_+810, 190, "head of: expression_tuple_body" },
    { 3, ms_transition_table_+813, 13, "rule 13: expression_tuple_body <- . expression_tuple_body expression_tuple_body_element" },
    { 4, ms_transition_table_+816, 13, "rule 13: expression_tuple_body <- expression_tuple_body . expression_tuple_body_element" },
    { 1, ms_transition_table_+820, 13, "rule 13: expression_tuple_body <- expression_tuple_body expression_tuple_body_element ." },
    { 2, ms_transition_table_+821, 190, "START expression_tuple_body_element" },
    { 1, ms_transition_table_+823, 190, "RETURN expression_tuple_body_element" },
    { 2, ms_transition_table_+824, 190, "head of: expression_tuple_body_element" },
    { 4, ms_transition_table_+826, 16, "rule 16: expression_tuple_body_element <- . expression expression_tuple_body_element_ender" },
    { 4, ms_transition_table_+830, 16, "rule 16: expression_tuple_body_element <- expression . expression_tuple_body_element_ender" },
    { 1, ms_transition_table_+834, 16, "rule 16: expression_tuple_body_element <- expression expression_tuple_body_element_ender ." },
    { 2, ms_transition_table_+835, 190, "START expression_tuple_body_element_ender" },
    { 1, ms_transition_table_+837, 190, "RETURN expression_tuple_body_element_ender" },
    { 2, ms_transition_table_+838, 190, "head of: expression_tuple_body_element_ender" },
    { 3, ms_transition_table_+840, 18, "rule 18: expression_tuple_body_element_ender <- . ','" },
    { 1, ms_transition_table_+843, 18, "rule 18: expression_tuple_body_element_ender <- ',' ." },
    { 5, ms_transition_table_+844, 19, "rule 19: expression_tuple_body_element_ender <- . %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { 2, ms_transition_table_+849, 17, "rule 17: expression_tuple_body_element <- . ERROR_ expression_tuple_body_element_ender" },
    { 7, ms_transition_table_+851, 17, "rule 17: expression_tuple_body_element <- ERROR_ . expression_tuple_body_element_ender" },
    { 1, ms_transition_table_+858, 17, "rule 17: expression_tuple_body_element <- ERROR_ expression_tuple_body_element_ender ." },
    { 4, ms_transition_table_+859, 14, "rule 14: expression_tuple_body <- . expression_tuple_body_element" },
    { 1, ms_transition_table_+863, 14, "rule 14: expression_tuple_body <- expression_tuple_body_element ." },
    { 5, ms_transition_table_+864, 15, "rule 15: expression_tuple_body <- . %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { 1, ms_transition_table_+869, 10, "rule 10: expression_tuple <- '[' expression_tuple_body expression_tuple_ender ." },
    { 2, ms_transition_table_+870, 190, "START expression_tuple_ender" },
    { 1, ms_transition_table_+872, 190, "RETURN expression_tuple_ender" },
    { 2, ms_transition_table_+873, 190, "head of: expression_tuple_ender" },
    { 3, ms_transition_table_+875, 11, "rule 11: expression_tuple_ender <- . ']'" },
    { 1, ms_transition_table_+878, 11, "rule 11: expression_tuple_ender <- ']' ." },
    { 4, ms_transition_table_+879, 12, "rule 12: expression_tuple_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 3, ms_transition_table_+883, 23, "rule 23: expression <- . IDENTIFIER %lookahead[![':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]]" },
    { 10, ms_transition_table_+886, 23, "rule 23: expression <- IDENTIFIER . %lookahead[![':'|DEFINE|CT|RT|LOCAL|GLOBAL|EXTERNAL|INTERNAL|PRIVATE]]" },
    { 3, ms_transition_table_+896, 24, "rule 24: expression <- . VALUE_LITERAL" },
    { 1, ms_transition_table_+899, 24, "rule 24: expression <- VALUE_LITERAL ." },
    { 3, ms_transition_table_+900, 25, "rule 25: expression <- . STRING_LITERAL" },
    { 1, ms_transition_table_+903, 25, "rule 25: expression <- STRING_LITERAL ." },
    { 3, ms_transition_table_+904, 26, "rule 26: expression <- . expression IF expression OTHERWISE expression" },
    { 3, ms_transition_table_+907, 26, "rule 26: expression <- expression . IF expression OTHERWISE expression" },
    { 4, ms_transition_table_+910, 26, "rule 26: expression <- expression IF . expression OTHERWISE expression" },
    { 3, ms_transition_table_+914, 26, "rule 26: expression <- expression IF expression . OTHERWISE expression" },
    { 4, ms_transition_table_+917, 26, "rule 26: expression <- expression IF expression OTHERWISE . expression" },
    { 1, ms_transition_table_+921, 26, "rule 26: expression <- expression IF expression OTHERWISE expression ." },
    { 3, ms_transition_table_+922, 27, "rule 27: expression <- . expression OR expression" },
    { 3, ms_transition_table_+925, 27, "rule 27: expression <- expression . OR expression" },
    { 4, ms_transition_table_+928, 27, "rule 27: expression <- expression OR . expression" },
    { 1, ms_transition_table_+932, 27, "rule 27: expression <- expression OR expression ." },
    { 3, ms_transition_table_+933, 28, "rule 28: expression <- . expression XOR expression" },
    { 3, ms_transition_table_+936, 28, "rule 28: expression <- expression . XOR expression" },
    { 4, ms_transition_table_+939, 28, "rule 28: expression <- expression XOR . expression" },
    { 1, ms_transition_table_+943, 28, "rule 28: expression <- expression XOR expression ." },
    { 3, ms_transition_table_+944, 29, "rule 29: expression <- . expression AND expression" },
    { 3, ms_transition_table_+947, 29, "rule 29: expression <- expression . AND expression" },
    { 4, ms_transition_table_+950, 29, "rule 29: expression <- expression AND . expression" },
    { 1, ms_transition_table_+954, 29, "rule 29: expression <- expression AND expression ." },
    { 3, ms_transition_table_+955, 30, "rule 30: expression <- . expression EQUALS expression" },
    { 3, ms_transition_table_+958, 30, "rule 30: expression <- expression . EQUALS expression" },
    { 4, ms_transition_table_+961, 30, "rule 30: expression <- expression EQUALS . expression" },
    { 1, ms_transition_table_+965, 30, "rule 30: expression <- expression EQUALS expression ." },
    { 3, ms_transition_table_+966, 31, "rule 31: expression <- . expression NOT_EQUALS expression" },
    { 3, ms_transition_table_+969, 31, "rule 31: expression <- expression . NOT_EQUALS expression" },
    { 4, ms_transition_table_+972, 31, "rule 31: expression <- expression NOT_EQUALS . expression" },
    { 1, ms_transition_table_+976, 31, "rule 31: expression <- expression NOT_EQUALS expression ." },
    { 3, ms_transition_table_+977, 32, "rule 32: expression <- . expression LESS_THAN expression" },
    { 3, ms_transition_table_+980, 32, "rule 32: expression <- expression . LESS_THAN expression" },
    { 4, ms_transition_table_+983, 32, "rule 32: expression <- expression LESS_THAN . expression" },
    { 1, ms_transition_table_+987, 32, "rule 32: expression <- expression LESS_THAN expression ." },
    { 3, ms_transition_table_+988, 33, "rule 33: expression <- . expression GREATER_THAN expression" },
    { 3, ms_transition_table_+991, 33, "rule 33: expression <- expression . GREATER_THAN expression" },
    { 4, ms_transition_table_+994, 33, "rule 33: expression <- expression GREATER_THAN . expression" },
    { 1, ms_transition_table_+998, 33, "rule 33: expression <- expression GREATER_THAN expression ." },
    { 3, ms_transition_table_+999, 34, "rule 34: expression <- . expression LESS_OR_EQUAL expression" },
    { 3, ms_transition_table_+1002, 34, "rule 34: expression <- expression . LESS_OR_EQUAL expression" },
    { 4, ms_transition_table_+1005, 34, "rule 34: expression <- expression LESS_OR_EQUAL . expression" },
    { 1, ms_transition_table_+1009, 34, "rule 34: expression <- expression LESS_OR_EQUAL expression ." },
    { 3, ms_transition_table_+1010, 35, "rule 35: expression <- . expression GREATER_OR_EQUAL expression" },
    { 3, ms_transition_table_+1013, 35, "rule 35: expression <- expression . GREATER_OR_EQUAL expression" },
    { 4, ms_transition_table_+1016, 35, "rule 35: expression <- expression GREATER_OR_EQUAL . expression" },
    { 1, ms_transition_table_+1020, 35, "rule 35: expression <- expression GREATER_OR_EQUAL expression ." },
    { 3, ms_transition_table_+1021, 36, "rule 36: expression <- . expression '+' expression" },
    { 3, ms_transition_table_+1024, 36, "rule 36: expression <- expression . '+' expression" },
    { 4, ms_transition_table_+1027, 36, "rule 36: expression <- expression '+' . expression" },
    { 1, ms_transition_table_+1031, 36, "rule 36: expression <- expression '+' expression ." },
    { 3, ms_transition_table_+1032, 37, "rule 37: expression <- . expression '-' expression" },
    { 3, ms_transition_table_+1035, 37, "rule 37: expression <- expression . '-' expression" },
    { 4, ms_transition_table_+1038, 37, "rule 37: expression <- expression '-' . expression" },
    { 1, ms_transition_table_+1042, 37, "rule 37: expression <- expression '-' expression ." },
    { 3, ms_transition_table_+1043, 38, "rule 38: expression <- . expression '*' expression" },
    { 3, ms_transition_table_+1046, 38, "rule 38: expression <- expression . '*' expression" },
    { 4, ms_transition_table_+1049, 38, "rule 38: expression <- expression '*' . expression" },
    { 1, ms_transition_table_+1053, 38, "rule 38: expression <- expression '*' expression ." },
    { 3, ms_transition_table_+1054, 39, "rule 39: expression <- . expression '/' expression" },
    { 3, ms_transition_table_+1057, 39, "rule 39: expression <- expression . '/' expression" },
    { 4, ms_transition_table_+1060, 39, "rule 39: expression <- expression '/' . expression" },
    { 1, ms_transition_table_+1064, 39, "rule 39: expression <- expression '/' expression ." },
    { 3, ms_transition_table_+1065, 40, "rule 40: expression <- . expression '%' expression" },
    { 3, ms_transition_table_+1068, 40, "rule 40: expression <- expression . '%' expression" },
    { 4, ms_transition_table_+1071, 40, "rule 40: expression <- expression '%' . expression" },
    { 1, ms_transition_table_+1075, 40, "rule 40: expression <- expression '%' expression ." },
    { 3, ms_transition_table_+1076, 41, "rule 41: expression <- . '-' expression" },
    { 4, ms_transition_table_+1079, 41, "rule 41: expression <- '-' . expression" },
    { 1, ms_transition_table_+1083, 41, "rule 41: expression <- '-' expression ." },
    { 3, ms_transition_table_+1084, 42, "rule 42: expression <- . NOT expression" },
    { 4, ms_transition_table_+1087, 42, "rule 42: expression <- NOT . expression" },
    { 1, ms_transition_table_+1091, 42, "rule 42: expression <- NOT expression ." },
    { 3, ms_transition_table_+1092, 43, "rule 43: expression <- . expression '^' expression" },
    { 3, ms_transition_table_+1095, 43, "rule 43: expression <- expression . '^' expression" },
    { 4, ms_transition_table_+1098, 43, "rule 43: expression <- expression '^' . expression" },
    { 1, ms_transition_table_+1102, 43, "rule 43: expression <- expression '^' expression ." },
    { 3, ms_transition_table_+1103, 44, "rule 44: expression <- . expression '@'" },
    { 3, ms_transition_table_+1106, 44, "rule 44: expression <- expression . '@'" },
    { 1, ms_transition_table_+1109, 44, "rule 44: expression <- expression '@' ." },
    { 3, ms_transition_table_+1110, 45, "rule 45: expression <- . expression '#'" },
    { 3, ms_transition_table_+1113, 45, "rule 45: expression <- expression . '#'" },
    { 1, ms_transition_table_+1116, 45, "rule 45: expression <- expression '#' ." },
    { 3, ms_transition_table_+1117, 46, "rule 46: expression <- . expression '(' parameter_list_body parameter_list_ender" },
    { 3, ms_transition_table_+1120, 46, "rule 46: expression <- expression . '(' parameter_list_body parameter_list_ender" },
    { 4, ms_transition_table_+1123, 46, "rule 46: expression <- expression '(' . parameter_list_body parameter_list_ender" },
    { 4, ms_transition_table_+1127, 46, "rule 46: expression <- expression '(' parameter_list_body . parameter_list_ender" },
    { 2, ms_transition_table_+1131, 190, "START parameter_list_body" },
    { 1, ms_transition_table_+1133, 190, "RETURN parameter_list_body" },
    { 3, ms_transition_table_+1134, 190, "head of: parameter_list_body" },
    { 3, ms_transition_table_+1137, 61, "rule 61: parameter_list_body <- . parameter_list_body parameter_list_body_element" },
    { 4, ms_transition_table_+1140, 61, "rule 61: parameter_list_body <- parameter_list_body . parameter_list_body_element" },
    { 1, ms_transition_table_+1144, 61, "rule 61: parameter_list_body <- parameter_list_body parameter_list_body_element ." },
    { 2, ms_transition_table_+1145, 190, "START parameter_list_body_element" },
    { 1, ms_transition_table_+1147, 190, "RETURN parameter_list_body_element" },
    { 2, ms_transition_table_+1148, 190, "head of: parameter_list_body_element" },
    { 4, ms_transition_table_+1150, 64, "rule 64: parameter_list_body_element <- . expression parameter_list_body_element_ender" },
    { 4, ms_transition_table_+1154, 64, "rule 64: parameter_list_body_element <- expression . parameter_list_body_element_ender" },
    { 1, ms_transition_table_+1158, 64, "rule 64: parameter_list_body_element <- expression parameter_list_body_element_ender ." },
    { 2, ms_transition_table_+1159, 190, "START parameter_list_body_element_ender" },
    { 1, ms_transition_table_+1161, 190, "RETURN parameter_list_body_element_ender" },
    { 2, ms_transition_table_+1162, 190, "head of: parameter_list_body_element_ender" },
    { 3, ms_transition_table_+1164, 66, "rule 66: parameter_list_body_element_ender <- . ','" },
    { 1, ms_transition_table_+1167, 66, "rule 66: parameter_list_body_element_ender <- ',' ." },
    { 5, ms_transition_table_+1168, 67, "rule 67: parameter_list_body_element_ender <- . %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { 2, ms_transition_table_+1173, 65, "rule 65: parameter_list_body_element <- . ERROR_ parameter_list_body_element_ender" },
    { 7, ms_transition_table_+1175, 65, "rule 65: parameter_list_body_element <- ERROR_ . parameter_list_body_element_ender" },
    { 1, ms_transition_table_+1182, 65, "rule 65: parameter_list_body_element <- ERROR_ parameter_list_body_element_ender ." },
    { 4, ms_transition_table_+1183, 62, "rule 62: parameter_list_body <- . parameter_list_body_element" },
    { 1, ms_transition_table_+1187, 62, "rule 62: parameter_list_body <- parameter_list_body_element ." },
    { 5, ms_transition_table_+1188, 63, "rule 63: parameter_list_body <- . %lookahead[END_|STATEMENT_DELIMITER|')']" },
    { 1, ms_transition_table_+1193, 46, "rule 46: expression <- expression '(' parameter_list_body parameter_list_ender ." },
    { 2, ms_transition_table_+1194, 190, "START parameter_list_ender" },
    { 1, ms_transition_table_+1196, 190, "RETURN parameter_list_ender" },
    { 2, ms_transition_table_+1197, 190, "head of: parameter_list_ender" },
    { 3, ms_transition_table_+1199, 59, "rule 59: parameter_list_ender <- . ')'" },
    { 1, ms_transition_table_+1202, 59, "rule 59: parameter_list_ender <- ')' ." },
    { 4, ms_transition_table_+1203, 60, "rule 60: parameter_list_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 3, ms_transition_table_+1207, 47, "rule 47: expression <- . expression '[' element_access_key_body_element element_access_key_ender" },
    { 3, ms_transition_table_+1210, 47, "rule 47: expression <- expression . '[' element_access_key_body_element element_access_key_ender" },
    { 4, ms_transition_table_+1213, 47, "rule 47: expression <- expression '[' . element_access_key_body_element element_access_key_ender" },
    { 4, ms_transition_table_+1217, 47, "rule 47: expression <- expression '[' element_access_key_body_element . element_access_key_ender" },
    { 2, ms_transition_table_+1221, 190, "START element_access_key_body_element" },
    { 1, ms_transition_table_+1223, 190, "RETURN element_access_key_body_element" },
    { 2, ms_transition_table_+1224, 190, "head of: element_access_key_body_element" },
    { 4, ms_transition_table_+1226, 55, "rule 55: element_access_key_body_element <- . expression element_access_key_body_element_ender" },
    { 4, ms_transition_table_+1230, 55, "rule 55: element_access_key_body_element <- expression . element_access_key_body_element_ender" },
    { 1, ms_transition_table_+1234, 55, "rule 55: element_access_key_body_element <- expression element_access_key_body_element_ender ." },
    { 2, ms_transition_table_+1235, 190, "START element_access_key_body_element_ender" },
    { 1, ms_transition_table_+1237, 190, "RETURN element_access_key_body_element_ender" },
    { 2, ms_transition_table_+1238, 190, "head of: element_access_key_body_element_ender" },
    { 3, ms_transition_table_+1240, 57, "rule 57: element_access_key_body_element_ender <- . ','" },
    { 1, ms_transition_table_+1243, 57, "rule 57: element_access_key_body_element_ender <- ',' ." },
    { 5, ms_transition_table_+1244, 58, "rule 58: element_access_key_body_element_ender <- . %lookahead[END_|STATEMENT_DELIMITER|']']" },
    { 2, ms_transition_table_+1249, 56, "rule 56: element_access_key_body_element <- . ERROR_ element_access_key_body_element_ender" },
    { 7, ms_transition_table_+1251, 56, "rule 56: element_access_key_body_element <- ERROR_ . element_access_key_body_element_ender" },
    { 1, ms_transition_table_+1258, 56, "rule 56: element_access_key_body_element <- ERROR_ element_access_key_body_element_ender ." },
    { 1, ms_transition_table_+1259, 47, "rule 47: expression <- expression '[' element_access_key_body_element element_access_key_ender ." },
    { 2, ms_transition_table_+1260, 190, "START element_access_key_ender" },
    { 1, ms_transition_table_+1262, 190, "RETURN element_access_key_ender" },
    { 2, ms_transition_table_+1263, 190, "head of: element_access_key_ender" },
    { 3, ms_transition_table_+1265, 53, "rule 53: element_access_key_ender <- . ']'" },
    { 1, ms_transition_table_+1268, 53, "rule 53: element_access_key_ender <- ']' ." },
    { 4, ms_transition_table_+1269, 54, "rule 54: element_access_key_ender <- . %lookahead[END_|STATEMENT_DELIMITER]" },
    { 4, ms_transition_table_+1273, 48, "rule 48: expression <- . function_literal" },
    { 1, ms_transition_table_+1277, 48, "rule 48: expression <- function_literal ." },
    { 2, ms_transition_table_+1278, 190, "START function_literal" },
    { 1, ms_transition_table_+1280, 190, "RETURN function_literal" },
    { 1, ms_transition_table_+1281, 190, "head of: function_literal" },
    { 4, ms_transition_table_+1282, 68, "rule 68: function_literal <- . function_prototype bracketed_statement_list" },
    { 4, ms_transition_table_+1286, 68, "rule 68: function_literal <- function_prototype . bracketed_statement_list" },
    { 1, ms_transition_table_+1290, 68, "rule 68: function_literal <- function_prototype bracketed_statement_list ." },
    { 3, ms_transition_table_+1291, 49, "rule 49: expression <- . LLVM_CAST_KEYWORD '(' expression ',' type_expression ')'" },
    { 3, ms_transition_table_+1294, 49, "rule 49: expression <- LLVM_CAST_KEYWORD . '(' expression ',' type_expression ')'" },
    { 4, ms_transition_table_+1297, 49, "rule 49: expression <- LLVM_CAST_KEYWORD '(' . expression ',' type_expression ')'" },
    { 3, ms_transition_table_+1301, 49, "rule 49: expression <- LLVM_CAST_KEYWORD '(' expression . ',' type_expression ')'" },
    { 4, ms_transition_table_+1304, 49, "rule 49: expression <- LLVM_CAST_KEYWORD '(' expression ',' . type_expression ')'" },
    { 3, ms_transition_table_+1308, 49, "rule 49: expression <- LLVM_CAST_KEYWORD '(' expression ',' type_expression . ')'" },
    { 1, ms_transition_table_+1311, 49, "rule 49: expression <- LLVM_CAST_KEYWORD '(' expression ',' type_expression ')' ." },
    { 3, ms_transition_table_+1312, 50, "rule 50: expression <- . LLVM_CAST_KEYWORD '(' ERROR_ ')'" },
    { 3, ms_transition_table_+1315, 50, "rule 50: expression <- LLVM_CAST_KEYWORD . '(' ERROR_ ')'" },
    { 2, ms_transition_table_+1318, 50, "rule 50: expression <- LLVM_CAST_KEYWORD '(' . ERROR_ ')'" },
    { 5, ms_transition_table_+1320, 50, "rule 50: expression <- LLVM_CAST_KEYWORD '(' ERROR_ . ')'" },
    { 1, ms_transition_table_+1325, 50, "rule 50: expression <- LLVM_CAST_KEYWORD '(' ERROR_ ')' ." },
    { 3, ms_transition_table_+1326, 51, "rule 51: expression <- . NULLPTR '{' type_expression '}'" },
    { 3, ms_transition_table_+1329, 51, "rule 51: expression <- NULLPTR . '{' type_expression '}'" },
    { 4, ms_transition_table_+1332, 51, "rule 51: expression <- NULLPTR '{' . type_expression '}'" },
    { 3, ms_transition_table_+1336, 51, "rule 51: expression <- NULLPTR '{' type_expression . '}'" },
    { 1, ms_transition_table_+1339, 51, "rule 51: expression <- NULLPTR '{' type_expression '}' ." },
    { 3, ms_transition_table_+1340, 52, "rule 52: expression <- . NULLPTR '{' ERROR_ '}'" },
    { 3, ms_transition_table_+1343, 52, "rule 52: expression <- NULLPTR . '{' ERROR_ '}'" },
    { 2, ms_transition_table_+1346, 52, "rule 52: expression <- NULLPTR '{' . ERROR_ '}'" },
    { 5, ms_transition_table_+1348, 52, "rule 52: expression <- NULLPTR '{' ERROR_ . '}'" },
    { 1, ms_transition_table_+1353, 52, "rule 52: expression <- NULLPTR '{' ERROR_ '}' ." },
    { 1, ms_transition_table_+1354, 124, "rule 124: initialization_statement_content <- expression statement_ender ." },
    { 2, ms_transition_table_+1355, 125, "rule 125: initialization_statement_content <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1357, 125, "rule 125: initialization_statement_content <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1363, 125, "rule 125: initialization_statement_content <- ERROR_ statement_ender ." },
    { 2, ms_transition_table_+1364, 120, "rule 120: initialization_statement <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1366, 120, "rule 120: initialization_statement <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1372, 120, "rule 120: initialization_statement <- ERROR_ statement_ender ." },
    { 4, ms_transition_table_+1373, 157, "rule 157: statement <- . definition_statement" },
    { 1, ms_transition_table_+1377, 157, "rule 157: statement <- definition_statement ." },
    { 2, ms_transition_table_+1378, 190, "START definition_statement" },
    { 1, ms_transition_table_+1380, 190, "RETURN definition_statement" },
    { 2, ms_transition_table_+1381, 190, "head of: definition_statement" },
    { 4, ms_transition_table_+1383, 126, "rule 126: definition_statement <- . definition_symbol_specifier definition_statement_content" },
    { 4, ms_transition_table_+1387, 126, "rule 126: definition_statement <- definition_symbol_specifier . definition_statement_content" },
    { 2, ms_transition_table_+1391, 190, "START definition_symbol_specifier" },
    { 1, ms_transition_table_+1393, 190, "RETURN definition_symbol_specifier" },
    { 2, ms_transition_table_+1394, 190, "head of: definition_symbol_specifier" },
    { 4, ms_transition_table_+1396, 128, "rule 128: definition_symbol_specifier <- . symbol_specifier DEFINE" },
    { 3, ms_transition_table_+1400, 128, "rule 128: definition_symbol_specifier <- symbol_specifier . DEFINE" },
    { 1, ms_transition_table_+1403, 128, "rule 128: definition_symbol_specifier <- symbol_specifier DEFINE ." },
    { 2, ms_transition_table_+1404, 129, "rule 129: definition_symbol_specifier <- . ERROR_ DEFINE" },
    { 4, ms_transition_table_+1406, 129, "rule 129: definition_symbol_specifier <- ERROR_ . DEFINE" },
    { 1, ms_transition_table_+1410, 129, "rule 129: definition_symbol_specifier <- ERROR_ DEFINE ." },
    { 1, ms_transition_table_+1411, 126, "rule 126: definition_statement <- definition_symbol_specifier definition_statement_content ." },
    { 2, ms_transition_table_+1412, 190, "START definition_statement_content" },
    { 1, ms_transition_table_+1414, 190, "RETURN definition_statement_content" },
    { 3, ms_transition_table_+1415, 190, "head of: definition_statement_content" },
    { 4, ms_transition_table_+1418, 130, "rule 130: definition_statement_content <- . type_expression statement_ender" },
    { 4, ms_transition_table_+1422, 130, "rule 130: definition_statement_content <- type_expression . statement_ender" },
    { 1, ms_transition_table_+1426, 130, "rule 130: definition_statement_content <- type_expression statement_ender ." },
    { 4, ms_transition_table_+1427, 131, "rule 131: definition_statement_content <- . expression statement_ender" },
    { 4, ms_transition_table_+1431, 131, "rule 131: definition_statement_content <- expression . statement_ender" },
    { 1, ms_transition_table_+1435, 131, "rule 131: definition_statement_content <- expression statement_ender ." },
    { 2, ms_transition_table_+1436, 132, "rule 132: definition_statement_content <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1438, 132, "rule 132: definition_statement_content <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1444, 132, "rule 132: definition_statement_content <- ERROR_ statement_ender ." },
    { 2, ms_transition_table_+1445, 127, "rule 127: definition_statement <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1447, 127, "rule 127: definition_statement <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1453, 127, "rule 127: definition_statement <- ERROR_ statement_ender ." },
    { 4, ms_transition_table_+1454, 158, "rule 158: statement <- . assignment_statement" },
    { 1, ms_transition_table_+1458, 158, "rule 158: statement <- assignment_statement ." },
    { 2, ms_transition_table_+1459, 190, "START assignment_statement" },
    { 1, ms_transition_table_+1461, 190, "RETURN assignment_statement" },
    { 1, ms_transition_table_+1462, 190, "head of: assignment_statement" },
    { 4, ms_transition_table_+1463, 133, "rule 133: assignment_statement <- . assignment_target assignment_statement_content" },
    { 4, ms_transition_table_+1467, 133, "rule 133: assignment_statement <- assignment_target . assignment_statement_content" },
    { 2, ms_transition_table_+1471, 190, "START assignment_target" },
    { 1, ms_transition_table_+1473, 190, "RETURN assignment_target" },
    { 2, ms_transition_table_+1474, 190, "head of: assignment_target" },
    { 4, ms_transition_table_+1476, 134, "rule 134: assignment_target <- . expression ASSIGN" },
    { 3, ms_transition_table_+1480, 134, "rule 134: assignment_target <- expression . ASSIGN" },
    { 1, ms_transition_table_+1483, 134, "rule 134: assignment_target <- expression ASSIGN ." },
    { 2, ms_transition_table_+1484, 135, "rule 135: assignment_target <- . ERROR_ ASSIGN" },
    { 4, ms_transition_table_+1486, 135, "rule 135: assignment_target <- ERROR_ . ASSIGN" },
    { 1, ms_transition_table_+1490, 135, "rule 135: assignment_target <- ERROR_ ASSIGN ." },
    { 1, ms_transition_table_+1491, 133, "rule 133: assignment_statement <- assignment_target assignment_statement_content ." },
    { 2, ms_transition_table_+1492, 190, "START assignment_statement_content" },
    { 1, ms_transition_table_+1494, 190, "RETURN assignment_statement_content" },
    { 3, ms_transition_table_+1495, 190, "head of: assignment_statement_content" },
    { 4, ms_transition_table_+1498, 136, "rule 136: assignment_statement_content <- . type_expression statement_ender" },
    { 4, ms_transition_table_+1502, 136, "rule 136: assignment_statement_content <- type_expression . statement_ender" },
    { 1, ms_transition_table_+1506, 136, "rule 136: assignment_statement_content <- type_expression statement_ender ." },
    { 4, ms_transition_table_+1507, 137, "rule 137: assignment_statement_content <- . expression statement_ender" },
    { 4, ms_transition_table_+1511, 137, "rule 137: assignment_statement_content <- expression . statement_ender" },
    { 1, ms_transition_table_+1515, 137, "rule 137: assignment_statement_content <- expression statement_ender ." },
    { 2, ms_transition_table_+1516, 138, "rule 138: assignment_statement_content <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1518, 138, "rule 138: assignment_statement_content <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1524, 138, "rule 138: assignment_statement_content <- ERROR_ statement_ender ." },
    { 3, ms_transition_table_+1525, 159, "rule 159: statement <- . IF expression THEN statement OTHERWISE statement" },
    { 4, ms_transition_table_+1528, 159, "rule 159: statement <- IF . expression THEN statement OTHERWISE statement" },
    { 3, ms_transition_table_+1532, 159, "rule 159: statement <- IF expression . THEN statement OTHERWISE statement" },
    { 4, ms_transition_table_+1535, 159, "rule 159: statement <- IF expression THEN . statement OTHERWISE statement" },
    { 3, ms_transition_table_+1539, 159, "rule 159: statement <- IF expression THEN statement . OTHERWISE statement" },
    { 4, ms_transition_table_+1542, 159, "rule 159: statement <- IF expression THEN statement OTHERWISE . statement" },
    { 1, ms_transition_table_+1546, 159, "rule 159: statement <- IF expression THEN statement OTHERWISE statement ." },
    { 3, ms_transition_table_+1547, 160, "rule 160: statement <- . IF expression THEN statement %lookahead[![OTHERWISE]]" },
    { 4, ms_transition_table_+1550, 160, "rule 160: statement <- IF . expression THEN statement %lookahead[![OTHERWISE]]" },
    { 3, ms_transition_table_+1554, 160, "rule 160: statement <- IF expression . THEN statement %lookahead[![OTHERWISE]]" },
    { 4, ms_transition_table_+1557, 160, "rule 160: statement <- IF expression THEN . statement %lookahead[![OTHERWISE]]" },
    { 2, ms_transition_table_+1561, 160, "rule 160: statement <- IF expression THEN statement . %lookahead[![OTHERWISE]]" },
    { 3, ms_transition_table_+1563, 161, "rule 161: statement <- . WHILE expression DO statement" },
    { 4, ms_transition_table_+1566, 161, "rule 161: statement <- WHILE . expression DO statement" },
    { 3, ms_transition_table_+1570, 161, "rule 161: statement <- WHILE expression . DO statement" },
    { 4, ms_transition_table_+1573, 161, "rule 161: statement <- WHILE expression DO . statement" },
    { 1, ms_transition_table_+1577, 161, "rule 161: statement <- WHILE expression DO statement ." },
    { 3, ms_transition_table_+1578, 162, "rule 162: statement <- . DO statement WHILE expression" },
    { 4, ms_transition_table_+1581, 162, "rule 162: statement <- DO . statement WHILE expression" },
    { 3, ms_transition_table_+1585, 162, "rule 162: statement <- DO statement . WHILE expression" },
    { 4, ms_transition_table_+1588, 162, "rule 162: statement <- DO statement WHILE . expression" },
    { 1, ms_transition_table_+1592, 162, "rule 162: statement <- DO statement WHILE expression ." },
    { 3, ms_transition_table_+1593, 163, "rule 163: statement <- . BREAK statement_ender" },
    { 4, ms_transition_table_+1596, 163, "rule 163: statement <- BREAK . statement_ender" },
    { 1, ms_transition_table_+1600, 163, "rule 163: statement <- BREAK statement_ender ." },
    { 3, ms_transition_table_+1601, 164, "rule 164: statement <- . BREAK ERROR_ statement_ender" },
    { 2, ms_transition_table_+1604, 164, "rule 164: statement <- BREAK . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1606, 164, "rule 164: statement <- BREAK ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1612, 164, "rule 164: statement <- BREAK ERROR_ statement_ender ." },
    { 3, ms_transition_table_+1613, 165, "rule 165: statement <- . RETURN statement_ender" },
    { 4, ms_transition_table_+1616, 165, "rule 165: statement <- RETURN . statement_ender" },
    { 1, ms_transition_table_+1620, 165, "rule 165: statement <- RETURN statement_ender ." },
    { 3, ms_transition_table_+1621, 166, "rule 166: statement <- . RETURN expression statement_ender" },
    { 4, ms_transition_table_+1624, 166, "rule 166: statement <- RETURN . expression statement_ender" },
    { 4, ms_transition_table_+1628, 166, "rule 166: statement <- RETURN expression . statement_ender" },
    { 1, ms_transition_table_+1632, 166, "rule 166: statement <- RETURN expression statement_ender ." },
    { 3, ms_transition_table_+1633, 167, "rule 167: statement <- . RETURN ERROR_ statement_ender" },
    { 2, ms_transition_table_+1636, 167, "rule 167: statement <- RETURN . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1638, 167, "rule 167: statement <- RETURN ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1644, 167, "rule 167: statement <- RETURN ERROR_ statement_ender ." },
    { 4, ms_transition_table_+1645, 168, "rule 168: statement <- . expression statement_ender" },
    { 4, ms_transition_table_+1649, 168, "rule 168: statement <- expression . statement_ender" },
    { 1, ms_transition_table_+1653, 168, "rule 168: statement <- expression statement_ender ." },
    { 2, ms_transition_table_+1654, 169, "rule 169: statement <- . ERROR_ statement_ender" },
    { 6, ms_transition_table_+1656, 169, "rule 169: statement <- ERROR_ . statement_ender" },
    { 1, ms_transition_table_+1662, 169, "rule 169: statement <- ERROR_ statement_ender ." },
    { 3, ms_transition_table_+1663, 177, "rule 177: statement_list <- . statement_list STATEMENT_DELIMITER" },
    { 3, ms_transition_table_+1666, 177, "rule 177: statement_list <- statement_list . STATEMENT_DELIMITER" },
    { 1, ms_transition_table_+1669, 177, "rule 177: statement_list <- statement_list STATEMENT_DELIMITER ." },
    { 2, ms_transition_table_+1670, 178, "rule 178: statement_list <- . %lookahead[![ERROR_]]" },
    { 1, ms_transition_table_+1672, 0, "rule 0: root <- statement_list END_ ." },
    { 3, ms_transition_table_+1673, 1, "rule 1: root <- . END_" },
    { 1, ms_transition_table_+1676, 1, "rule 1: root <- END_ ." },
    { 2, ms_transition_table_+1677, 190, "START expression_then_end" },
    { 1, ms_transition_table_+1679, 190, "RETURN expression_then_end" },
    { 2, ms_transition_table_+1680, 190, "head of: expression_then_end" },
    { 4, ms_transition_table_+1682, 2, "rule 2: expression_then_end <- . expression END_" },
    { 3, ms_transition_table_+1686, 2, "rule 2: expression_then_end <- expression . END_" },
    { 1, ms_transition_table_+1689, 2, "rule 2: expression_then_end <- expression END_ ." },
    { 2, ms_transition_table_+1690, 3, "rule 3: expression_then_end <- . ERROR_ END_" },
    { 3, ms_transition_table_+1692, 3, "rule 3: expression_then_end <- ERROR_ . END_" },
    { 1, ms_transition_table_+1695, 3, "rule 3: expression_then_end <- ERROR_ END_ ." },
    { 2, ms_transition_table_+1696, 190, "START expression_then_lookahead_end" },
    { 1, ms_transition_table_+1698, 190, "RETURN expression_then_lookahead_end" },
    { 2, ms_transition_table_+1699, 190, "head of: expression_then_lookahead_end" },
    { 4, ms_transition_table_+1701, 4, "rule 4: expression_then_lookahead_end <- . expression %lookahead[END_]" },
    { 3, ms_transition_table_+1705, 4, "rule 4: expression_then_lookahead_end <- expression . %lookahead[END_]" },
    { 2, ms_transition_table_+1708, 5, "rule 5: expression_then_lookahead_end <- . ERROR_ %lookahead[END_]" },
    { 2, ms_transition_table_+1710, 5, "rule 5: expression_then_lookahead_end <- ERROR_ . %lookahead[END_]" },
    { 2, ms_transition_table_+1712, 190, "START function_type_then_end" },
    { 1, ms_transition_table_+1714, 190, "RETURN function_type_then_end" },
    { 1, ms_transition_table_+1715, 190, "head of: function_type_then_end" },
    { 4, ms_transition_table_+1716, 105, "rule 105: function_type_then_end <- . function_type END_" },
    { 3, ms_transition_table_+1720, 105, "rule 105: function_type_then_end <- function_type . END_" },
    { 1, ms_transition_table_+1723, 105, "rule 105: function_type_then_end <- function_type END_ ." },
    { 2, ms_transition_table_+1724, 190, "START statement_then_end" },
    { 1, ms_transition_table_+1726, 190, "RETURN statement_then_end" },
    { 1, ms_transition_table_+1727, 190, "head of: statement_then_end" },
    { 4, ms_transition_table_+1728, 153, "rule 153: statement_then_end <- . statement END_" },
    { 3, ms_transition_table_+1732, 153, "rule 153: statement_then_end <- statement . END_" },
    { 1, ms_transition_table_+1735, 153, "rule 153: statement_then_end <- statement END_ ." },
    { 2, ms_transition_table_+1736, 190, "START statement_list_then_end" },
    { 1, ms_transition_table_+1738, 190, "RETURN statement_list_then_end" },
    { 1, ms_transition_table_+1739, 190, "head of: statement_list_then_end" },
    { 4, ms_transition_table_+1740, 175, "rule 175: statement_list_then_end <- . statement_list END_" },
    { 3, ms_transition_table_+1744, 175, "rule 175: statement_list_then_end <- statement_list . END_" },
    { 1, ms_transition_table_+1747, 175, "rule 175: statement_list_then_end <- statement_list END_ ." },
    { 2, ms_transition_table_+1748, 190, "START lookahead_test_expression_then_end" },
    { 1, ms_transition_table_+1750, 190, "RETURN lookahead_test_expression_then_end" },
    { 1, ms_transition_table_+1751, 190, "head of: lookahead_test_expression_then_end" },
    { 4, ms_transition_table_+1752, 179, "rule 179: lookahead_test_expression_then_end <- . lookahead_test_expression END_" },
    { 3, ms_transition_table_+1756, 179, "rule 179: lookahead_test_expression_then_end <- lookahead_test_expression . END_" },
    { 2, ms_transition_table_+1759, 190, "START lookahead_test_expression" },
    { 1, ms_transition_table_+1761, 190, "RETURN lookahead_test_expression" },
    { 5, ms_transition_table_+1762, 190, "head of: lookahead_test_expression" },
    { 3, ms_transition_table_+1767, 180, "rule 180: lookahead_test_expression <- . IDENTIFIER" },
    { 1, ms_transition_table_+1770, 180, "rule 180: lookahead_test_expression <- IDENTIFIER ." },
    { 3, ms_transition_table_+1771, 181, "rule 181: lookahead_test_expression <- . lookahead_test_expression FANCYOP FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1774, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression . FANCYOP FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1777, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression FANCYOP . FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1780, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP . FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1783, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP . FANCYOP lookahead_test_expression" },
    { 4, ms_transition_table_+1786, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP FANCYOP . lookahead_test_expression" },
    { 1, ms_transition_table_+1790, 181, "rule 181: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP FANCYOP lookahead_test_expression ." },
    { 3, ms_transition_table_+1791, 182, "rule 182: lookahead_test_expression <- . lookahead_test_expression FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1794, 182, "rule 182: lookahead_test_expression <- lookahead_test_expression . FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1797, 182, "rule 182: lookahead_test_expression <- lookahead_test_expression FANCYOP . FANCYOP lookahead_test_expression" },
    { 4, ms_transition_table_+1800, 182, "rule 182: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP . lookahead_test_expression" },
    { 1, ms_transition_table_+1804, 182, "rule 182: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP lookahead_test_expression ." },
    { 3, ms_transition_table_+1805, 183, "rule 183: lookahead_test_expression <- . lookahead_test_expression FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1808, 183, "rule 183: lookahead_test_expression <- lookahead_test_expression . FANCYOP lookahead_test_expression" },
    { 4, ms_transition_table_+1811, 183, "rule 183: lookahead_test_expression <- lookahead_test_expression FANCYOP . lookahead_test_expression" },
    { 1, ms_transition_table_+1815, 183, "rule 183: lookahead_test_expression <- lookahead_test_expression FANCYOP lookahead_test_expression ." },
    { 3, ms_transition_table_+1816, 184, "rule 184: lookahead_test_expression <- . lookahead_test_expression FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1819, 184, "rule 184: lookahead_test_expression <- lookahead_test_expression . FANCYOP FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1822, 184, "rule 184: lookahead_test_expression <- lookahead_test_expression FANCYOP . FANCYOP FANCYOP lookahead_test_expression" },
    { 3, ms_transition_table_+1825, 184, "rule 184: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP . FANCYOP lookahead_test_expression" },
    { 4, ms_transition_table_+1828, 184, "rule 184: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP . lookahead_test_expression" },
    { 1, ms_transition_table_+1832, 184, "rule 184: lookahead_test_expression <- lookahead_test_expression FANCYOP FANCYOP FANCYOP lookahead_test_expression ." },
    { 1, ms_transition_table_+1833, 179, "rule 179: lookahead_test_expression_then_end <- lookahead_test_expression END_ ." },
    { 2, ms_transition_table_+1834, 190, "START id_list_then_end" },
    { 1, ms_transition_table_+1836, 190, "RETURN id_list_then_end" },
    { 1, ms_transition_table_+1837, 190, "head of: id_list_then_end" },
    { 4, ms_transition_table_+1838, 185, "rule 185: id_list_then_end <- . id_list END_" },
    { 3, ms_transition_table_+1842, 185, "rule 185: id_list_then_end <- id_list . END_" },
    { 2, ms_transition_table_+1845, 190, "START id_list" },
    { 1, ms_transition_table_+1847, 190, "RETURN id_list" },
    { 3, ms_transition_table_+1848, 190, "head of: id_list" },
    { 3, ms_transition_table_+1851, 186, "rule 186: id_list <- . id_list IDENTIFIER" },
    { 3, ms_transition_table_+1854, 186, "rule 186: id_list <- id_list . IDENTIFIER" },
    { 1, ms_transition_table_+1857, 186, "rule 186: id_list <- id_list IDENTIFIER ." },
    { 3, ms_transition_table_+1858, 187, "rule 187: id_list <- . id_list ERROR_" },
    { 2, ms_transition_table_+1861, 187, "rule 187: id_list <- id_list . ERROR_" },
    { 3, ms_transition_table_+1863, 187, "rule 187: id_list <- id_list ERROR_ ." },
    { 1, ms_transition_table_+1866, 188, "rule 188: id_list <- ." },
    { 1, ms_transition_table_+1867, 185, "rule 185: id_list_then_end <- id_list END_ ." },
    { 2, ms_transition_table_+1868, 190, "START parenthesized_id_list" },
    { 1, ms_transition_table_+1870, 190, "RETURN parenthesized_id_list" },
    { 1, ms_transition_table_+1871, 190, "head of: parenthesized_id_list" },
    { 3, ms_transition_table_+1872, 189, "rule 189: parenthesized_id_list <- . '(' id_list ')'" },
    { 4, ms_transition_table_+1875, 189, "rule 189: parenthesized_id_list <- '(' . id_list ')'" },
    { 3, ms_transition_table_+1879, 189, "rule 189: parenthesized_id_list <- '(' id_list . ')'" },
    { 1, ms_transition_table_+1882, 189, "rule 189: parenthesized_id_list <- '(' id_list ')' ." }
};
std::size_t const Parser::Npda_::ms_state_count_ = sizeof(Parser::Npda_::ms_state_table_) / sizeof(*Parser::Npda_::ms_state_table_);

Parser::Npda_::Transition_ const Parser::Npda_::ms_transition_table_[] =
{
    { Parser::Npda_::Transition_::ABORT, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 311, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(3) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(4) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(635) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(5) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(8) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(634) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(7) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(8) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(9) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(630) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(633) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(10) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(11) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(176) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(13) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(15) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(30) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(252) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(523) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(555) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(584) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(591) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(596) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(601) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(606) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(609) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(613) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(616) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(620) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(624) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(627) },
    { Parser::Npda_::Transition_::SHIFT, 363, std::uint32_t(16) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(19) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(154) },
    { Parser::Npda_::Transition_::SHIFT, 363, std::uint32_t(18) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(19) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(20) },
    { Parser::Npda_::Transition_::SHIFT, 123, std::uint32_t(21) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(22) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(8) },
    { Parser::Npda_::Transition_::SHIFT, 364, std::uint32_t(23) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(26) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(172) },
    { Parser::Npda_::Transition_::SHIFT, 364, std::uint32_t(25) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(26) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(27) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(29) },
    { Parser::Npda_::Transition_::SHIFT, 125, std::uint32_t(28) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(173) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(174) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 342, std::uint32_t(31) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(34) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(155) },
    { Parser::Npda_::Transition_::SHIFT, 342, std::uint32_t(33) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(34) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(35) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(249) },
    { Parser::Npda_::Transition_::SHIFT, 357, std::uint32_t(36) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(39) },
    { Parser::Npda_::Transition_::SHIFT, 343, std::uint32_t(72) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(75) },
    { Parser::Npda_::Transition_::SHIFT, 357, std::uint32_t(38) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(39) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(40) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(69) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(41) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(44) },
    { Parser::Npda_::Transition_::SHIFT, 58, std::uint32_t(68) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(43) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(44) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(45) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(48) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(51) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(54) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(57) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(60) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(63) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(66) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(46) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 259, std::uint32_t(47) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(106) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(49) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 260, std::uint32_t(50) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(107) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(52) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 261, std::uint32_t(53) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(108) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(55) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 262, std::uint32_t(56) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(109) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(58) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 263, std::uint32_t(59) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(110) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(61) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 264, std::uint32_t(62) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(111) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(64) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 265, std::uint32_t(65) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(112) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(67) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 58, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 259, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 260, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 261, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 262, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 263, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 264, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 265, std::uint32_t(113) },
    { Parser::Npda_::Transition_::REDUCE, 266, std::uint32_t(113) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(147) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(70) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 58, std::uint32_t(71) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 58, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(148) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(114) },
    { Parser::Npda_::Transition_::SHIFT, 343, std::uint32_t(74) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(75) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(76) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(85) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(246) },
    { Parser::Npda_::Transition_::SHIFT, 303, std::uint32_t(77) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(78) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(116) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(80) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(82) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(84) },
    { Parser::Npda_::Transition_::SHIFT, 275, std::uint32_t(83) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(170) },
    { Parser::Npda_::Transition_::REDUCE, 125, std::uint32_t(171) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(171) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(86) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(245) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(88) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(90) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(92) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(94) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(96) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(98) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(100) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(102) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(104) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(106) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(108) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(110) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(112) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(114) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(116) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(132) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(194) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(233) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(237) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(239) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(242) },
    { Parser::Npda_::Transition_::SHIFT, 305, std::uint32_t(91) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(82) },
    { Parser::Npda_::Transition_::SHIFT, 306, std::uint32_t(93) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(83) },
    { Parser::Npda_::Transition_::SHIFT, 292, std::uint32_t(95) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(84) },
    { Parser::Npda_::Transition_::SHIFT, 293, std::uint32_t(97) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(85) },
    { Parser::Npda_::Transition_::SHIFT, 294, std::uint32_t(99) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(86) },
    { Parser::Npda_::Transition_::SHIFT, 295, std::uint32_t(101) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(87) },
    { Parser::Npda_::Transition_::SHIFT, 296, std::uint32_t(103) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(88) },
    { Parser::Npda_::Transition_::SHIFT, 297, std::uint32_t(105) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 298, std::uint32_t(107) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(90) },
    { Parser::Npda_::Transition_::SHIFT, 299, std::uint32_t(109) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(91) },
    { Parser::Npda_::Transition_::SHIFT, 300, std::uint32_t(111) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(92) },
    { Parser::Npda_::Transition_::SHIFT, 301, std::uint32_t(113) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(93) },
    { Parser::Npda_::Transition_::SHIFT, 302, std::uint32_t(115) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(94) },
    { Parser::Npda_::Transition_::SHIFT, 338, std::uint32_t(117) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(120) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(95) },
    { Parser::Npda_::Transition_::SHIFT, 338, std::uint32_t(119) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(120) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(121) },
    { Parser::Npda_::Transition_::SHIFT, 339, std::uint32_t(122) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(125) },
    { Parser::Npda_::Transition_::SHIFT, 269, std::uint32_t(130) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 339, std::uint32_t(124) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(125) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(126) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(128) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(127) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::REDUCE, 269, std::uint32_t(103) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(129) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 269, std::uint32_t(104) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(131) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(102) },
    { Parser::Npda_::Transition_::SHIFT, 330, std::uint32_t(133) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(136) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(96) },
    { Parser::Npda_::Transition_::SHIFT, 330, std::uint32_t(135) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(136) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(137) },
    { Parser::Npda_::Transition_::SHIFT, 331, std::uint32_t(138) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(141) },
    { Parser::Npda_::Transition_::SHIFT, 269, std::uint32_t(192) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 331, std::uint32_t(140) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(141) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(142) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(190) },
    { Parser::Npda_::Transition_::SHIFT, 353, std::uint32_t(143) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(146) },
    { Parser::Npda_::Transition_::REDUCE, 269, std::uint32_t(70) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 353, std::uint32_t(145) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(146) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(147) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(148) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 355, std::uint32_t(149) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(152) },
    { Parser::Npda_::Transition_::SHIFT, 354, std::uint32_t(183) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(186) },
    { Parser::Npda_::Transition_::SHIFT, 355, std::uint32_t(151) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(152) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(153) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(180) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(182) },
    { Parser::Npda_::Transition_::SHIFT, 355, std::uint32_t(154) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 356, std::uint32_t(155) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(158) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(142) },
    { Parser::Npda_::Transition_::SHIFT, 356, std::uint32_t(157) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(158) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(159) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(177) },
    { Parser::Npda_::Transition_::SHIFT, 357, std::uint32_t(160) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(39) },
    { Parser::Npda_::Transition_::SHIFT, 358, std::uint32_t(161) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(164) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(145) },
    { Parser::Npda_::Transition_::SHIFT, 358, std::uint32_t(163) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(164) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(165) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(174) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(166) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 359, std::uint32_t(167) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(170) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(149) },
    { Parser::Npda_::Transition_::SHIFT, 359, std::uint32_t(169) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(170) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(171) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(173) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(172) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(151) },
    { Parser::Npda_::Transition_::REDUCE, 41, std::uint32_t(152) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(152) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(152) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(175) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 359, std::uint32_t(176) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 41, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(170) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(150) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(178) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 359, std::uint32_t(179) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 41, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(170) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(146) },
    { Parser::Npda_::Transition_::SHIFT, 356, std::uint32_t(181) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(158) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(143) },
    { Parser::Npda_::Transition_::REDUCE, 41, std::uint32_t(144) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(144) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(144) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(139) },
    { Parser::Npda_::Transition_::SHIFT, 354, std::uint32_t(185) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(186) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(187) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(189) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(188) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(140) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(141) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(141) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(191) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 269, std::uint32_t(71) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(193) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(69) },
    { Parser::Npda_::Transition_::SHIFT, 332, std::uint32_t(195) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(198) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(97) },
    { Parser::Npda_::Transition_::SHIFT, 332, std::uint32_t(197) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(198) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(199) },
    { Parser::Npda_::Transition_::SHIFT, 91, std::uint32_t(200) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 334, std::uint32_t(201) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(204) },
    { Parser::Npda_::Transition_::SHIFT, 333, std::uint32_t(226) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(229) },
    { Parser::Npda_::Transition_::SHIFT, 334, std::uint32_t(203) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(204) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(205) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(223) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(225) },
    { Parser::Npda_::Transition_::SHIFT, 334, std::uint32_t(206) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 335, std::uint32_t(207) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(210) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(75) },
    { Parser::Npda_::Transition_::SHIFT, 335, std::uint32_t(209) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(210) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(211) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(220) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(212) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 336, std::uint32_t(213) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(216) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(78) },
    { Parser::Npda_::Transition_::SHIFT, 336, std::uint32_t(215) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(216) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(217) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(219) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(218) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(80) },
    { Parser::Npda_::Transition_::REDUCE, 93, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(81) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(221) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 336, std::uint32_t(222) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 93, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(216) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(79) },
    { Parser::Npda_::Transition_::SHIFT, 335, std::uint32_t(224) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(210) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(76) },
    { Parser::Npda_::Transition_::REDUCE, 93, std::uint32_t(77) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(77) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(77) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(72) },
    { Parser::Npda_::Transition_::SHIFT, 333, std::uint32_t(228) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(229) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(230) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(232) },
    { Parser::Npda_::Transition_::SHIFT, 93, std::uint32_t(231) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(73) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(74) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(74) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 332, std::uint32_t(234) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(198) },
    { Parser::Npda_::Transition_::SHIFT, 42, std::uint32_t(235) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 304, std::uint32_t(236) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(98) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(238) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(99) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(240) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 64, std::uint32_t(241) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(100) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(243) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 35, std::uint32_t(244) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(101) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(117) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(247) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(248) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(118) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(250) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(251) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(115) },
    { Parser::Npda_::Transition_::SHIFT, 344, std::uint32_t(253) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(256) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(156) },
    { Parser::Npda_::Transition_::SHIFT, 344, std::uint32_t(255) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(256) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(257) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(520) },
    { Parser::Npda_::Transition_::SHIFT, 345, std::uint32_t(258) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(261) },
    { Parser::Npda_::Transition_::SHIFT, 346, std::uint32_t(268) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(271) },
    { Parser::Npda_::Transition_::SHIFT, 345, std::uint32_t(260) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(261) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(262) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(265) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(263) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 267, std::uint32_t(264) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(121) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(266) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 267, std::uint32_t(267) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 267, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(122) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(119) },
    { Parser::Npda_::Transition_::SHIFT, 346, std::uint32_t(270) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(271) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(272) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(275) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(517) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(273) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(274) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(123) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(276) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(516) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(278) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(280) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(299) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(302) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(341) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(343) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(345) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(347) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(353) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(357) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(361) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(365) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(369) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(373) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(377) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(381) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(385) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(389) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(393) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(397) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(401) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(405) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(409) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(412) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(415) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(419) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(422) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(425) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(460) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(486) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(494) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(501) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(506) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(511) },
    { Parser::Npda_::Transition_::SHIFT, 314, std::uint32_t(281) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(284) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(20) },
    { Parser::Npda_::Transition_::SHIFT, 314, std::uint32_t(283) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(284) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(285) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(295) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(286) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(287) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 315, std::uint32_t(288) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(291) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(6) },
    { Parser::Npda_::Transition_::SHIFT, 315, std::uint32_t(290) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(291) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(292) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(294) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(293) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(8) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(9) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(9) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(296) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(297) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 315, std::uint32_t(298) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 41, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(291) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(7) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(300) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(301) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(21) },
    { Parser::Npda_::Transition_::SHIFT, 316, std::uint32_t(303) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(306) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(22) },
    { Parser::Npda_::Transition_::SHIFT, 316, std::uint32_t(305) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(306) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(307) },
    { Parser::Npda_::Transition_::SHIFT, 91, std::uint32_t(308) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 318, std::uint32_t(309) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(312) },
    { Parser::Npda_::Transition_::SHIFT, 317, std::uint32_t(334) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(337) },
    { Parser::Npda_::Transition_::SHIFT, 318, std::uint32_t(311) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(312) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(313) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(331) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(333) },
    { Parser::Npda_::Transition_::SHIFT, 318, std::uint32_t(314) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 319, std::uint32_t(315) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(318) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(13) },
    { Parser::Npda_::Transition_::SHIFT, 319, std::uint32_t(317) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(318) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(319) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(328) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(320) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 320, std::uint32_t(321) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(324) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(16) },
    { Parser::Npda_::Transition_::SHIFT, 320, std::uint32_t(323) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(324) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(325) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(327) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(326) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(18) },
    { Parser::Npda_::Transition_::REDUCE, 93, std::uint32_t(19) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(19) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(19) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(329) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 320, std::uint32_t(330) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 93, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(324) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(17) },
    { Parser::Npda_::Transition_::SHIFT, 319, std::uint32_t(332) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(318) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::REDUCE, 93, std::uint32_t(15) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(15) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(15) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(10) },
    { Parser::Npda_::Transition_::SHIFT, 317, std::uint32_t(336) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(337) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(338) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(340) },
    { Parser::Npda_::Transition_::SHIFT, 93, std::uint32_t(339) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(11) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(12) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(12) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(342) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(23) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 58, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 259, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 260, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 261, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 262, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 263, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 264, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 265, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 266, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 304, std::uint32_t(344) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(24) },
    { Parser::Npda_::Transition_::SHIFT, 308, std::uint32_t(346) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(25) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(348) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 270, std::uint32_t(349) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(350) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 272, std::uint32_t(351) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(352) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(26) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(354) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 284, std::uint32_t(355) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(356) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(27) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(358) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 285, std::uint32_t(359) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(360) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(28) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(362) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 283, std::uint32_t(363) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(364) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(29) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(366) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 276, std::uint32_t(367) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(368) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(30) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(370) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 277, std::uint32_t(371) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(372) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(31) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(374) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 278, std::uint32_t(375) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(376) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(32) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(378) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 279, std::uint32_t(379) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(380) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(33) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(382) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 280, std::uint32_t(383) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(384) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(34) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(386) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 281, std::uint32_t(387) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(388) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(35) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(390) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 43, std::uint32_t(391) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(392) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(36) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(394) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 45, std::uint32_t(395) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(396) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(37) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(398) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 42, std::uint32_t(399) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(400) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(38) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(402) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 47, std::uint32_t(403) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(404) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(39) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(406) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 37, std::uint32_t(407) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(408) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(40) },
    { Parser::Npda_::Transition_::SHIFT, 45, std::uint32_t(410) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(411) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(41) },
    { Parser::Npda_::Transition_::SHIFT, 282, std::uint32_t(413) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(414) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(42) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(416) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 94, std::uint32_t(417) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(418) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(43) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(420) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 64, std::uint32_t(421) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(44) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(423) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 35, std::uint32_t(424) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(45) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(426) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(427) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 326, std::uint32_t(428) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(431) },
    { Parser::Npda_::Transition_::SHIFT, 325, std::uint32_t(453) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(456) },
    { Parser::Npda_::Transition_::SHIFT, 326, std::uint32_t(430) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(431) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(432) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(450) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(452) },
    { Parser::Npda_::Transition_::SHIFT, 326, std::uint32_t(433) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 327, std::uint32_t(434) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(437) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(61) },
    { Parser::Npda_::Transition_::SHIFT, 327, std::uint32_t(436) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(437) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(438) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(447) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(439) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 328, std::uint32_t(440) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(443) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(64) },
    { Parser::Npda_::Transition_::SHIFT, 328, std::uint32_t(442) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(443) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(444) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(446) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(445) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(66) },
    { Parser::Npda_::Transition_::REDUCE, 41, std::uint32_t(67) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(67) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(67) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(448) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 328, std::uint32_t(449) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 41, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(443) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(65) },
    { Parser::Npda_::Transition_::SHIFT, 327, std::uint32_t(451) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(437) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(62) },
    { Parser::Npda_::Transition_::REDUCE, 41, std::uint32_t(63) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(63) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(63) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(46) },
    { Parser::Npda_::Transition_::SHIFT, 325, std::uint32_t(455) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(456) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(457) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(459) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(458) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(59) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(60) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(60) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(461) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 91, std::uint32_t(462) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 323, std::uint32_t(463) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(466) },
    { Parser::Npda_::Transition_::SHIFT, 322, std::uint32_t(479) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(482) },
    { Parser::Npda_::Transition_::SHIFT, 323, std::uint32_t(465) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(466) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(467) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(476) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(468) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 324, std::uint32_t(469) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(472) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(55) },
    { Parser::Npda_::Transition_::SHIFT, 324, std::uint32_t(471) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(472) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(473) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(475) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(474) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(57) },
    { Parser::Npda_::Transition_::REDUCE, 93, std::uint32_t(58) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(58) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(58) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(477) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 324, std::uint32_t(478) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 44, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 93, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(472) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(56) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(47) },
    { Parser::Npda_::Transition_::SHIFT, 322, std::uint32_t(481) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(482) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(483) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(485) },
    { Parser::Npda_::Transition_::SHIFT, 93, std::uint32_t(484) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(53) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(54) },
    { Parser::Npda_::Transition_::REDUCE, 275, std::uint32_t(54) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 329, std::uint32_t(487) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(490) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(48) },
    { Parser::Npda_::Transition_::SHIFT, 329, std::uint32_t(489) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(490) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(491) },
    { Parser::Npda_::Transition_::SHIFT, 330, std::uint32_t(492) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(136) },
    { Parser::Npda_::Transition_::SHIFT, 363, std::uint32_t(493) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(19) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(68) },
    { Parser::Npda_::Transition_::SHIFT, 307, std::uint32_t(495) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(496) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(497) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 44, std::uint32_t(498) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(499) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(500) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(49) },
    { Parser::Npda_::Transition_::SHIFT, 307, std::uint32_t(502) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(503) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(504) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(505) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 41, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(50) },
    { Parser::Npda_::Transition_::SHIFT, 286, std::uint32_t(507) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 123, std::uint32_t(508) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(509) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 125, std::uint32_t(510) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(51) },
    { Parser::Npda_::Transition_::SHIFT, 286, std::uint32_t(512) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 123, std::uint32_t(513) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(514) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 125, std::uint32_t(515) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(52) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(124) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(518) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(519) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(125) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(521) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(522) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(120) },
    { Parser::Npda_::Transition_::SHIFT, 347, std::uint32_t(524) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(527) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(157) },
    { Parser::Npda_::Transition_::SHIFT, 347, std::uint32_t(526) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(527) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(528) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(552) },
    { Parser::Npda_::Transition_::SHIFT, 348, std::uint32_t(529) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(532) },
    { Parser::Npda_::Transition_::SHIFT, 349, std::uint32_t(539) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(542) },
    { Parser::Npda_::Transition_::SHIFT, 348, std::uint32_t(531) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(532) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(533) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(536) },
    { Parser::Npda_::Transition_::SHIFT, 341, std::uint32_t(534) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(44) },
    { Parser::Npda_::Transition_::SHIFT, 266, std::uint32_t(535) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(128) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(537) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 266, std::uint32_t(538) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 266, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(129) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(126) },
    { Parser::Npda_::Transition_::SHIFT, 349, std::uint32_t(541) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(542) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(543) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(546) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(549) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(544) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(545) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(130) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(547) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(548) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(131) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(550) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(551) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(132) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(553) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(554) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(127) },
    { Parser::Npda_::Transition_::SHIFT, 350, std::uint32_t(556) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(559) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(158) },
    { Parser::Npda_::Transition_::SHIFT, 350, std::uint32_t(558) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(559) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(560) },
    { Parser::Npda_::Transition_::SHIFT, 351, std::uint32_t(561) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(564) },
    { Parser::Npda_::Transition_::SHIFT, 352, std::uint32_t(571) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(574) },
    { Parser::Npda_::Transition_::SHIFT, 351, std::uint32_t(563) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(564) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(565) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(568) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(566) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 268, std::uint32_t(567) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(134) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(569) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 268, std::uint32_t(570) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 268, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(135) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(133) },
    { Parser::Npda_::Transition_::SHIFT, 352, std::uint32_t(573) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(574) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(575) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(578) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(581) },
    { Parser::Npda_::Transition_::SHIFT, 337, std::uint32_t(576) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(89) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(577) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(136) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(579) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(580) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(137) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(582) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(583) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(138) },
    { Parser::Npda_::Transition_::SHIFT, 270, std::uint32_t(585) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(586) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 271, std::uint32_t(587) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(588) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::SHIFT, 272, std::uint32_t(589) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(590) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(159) },
    { Parser::Npda_::Transition_::SHIFT, 270, std::uint32_t(592) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(593) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 271, std::uint32_t(594) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(595) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(160) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 272, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 273, std::uint32_t(597) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(598) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 274, std::uint32_t(599) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(600) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(161) },
    { Parser::Npda_::Transition_::SHIFT, 274, std::uint32_t(602) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(603) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::SHIFT, 273, std::uint32_t(604) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(605) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(162) },
    { Parser::Npda_::Transition_::SHIFT, 289, std::uint32_t(607) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(608) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(163) },
    { Parser::Npda_::Transition_::SHIFT, 289, std::uint32_t(610) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(611) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(612) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(164) },
    { Parser::Npda_::Transition_::SHIFT, 290, std::uint32_t(614) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(615) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(165) },
    { Parser::Npda_::Transition_::SHIFT, 290, std::uint32_t(617) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(618) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(619) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(166) },
    { Parser::Npda_::Transition_::SHIFT, 290, std::uint32_t(621) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(622) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(623) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(167) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(625) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(626) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(168) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(628) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 362, std::uint32_t(629) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 125, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::POP_STACK, 275, std::uint32_t(2) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(81) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(169) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(631) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 275, std::uint32_t(632) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(177) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(178) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 257, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(0) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(636) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 312, std::uint32_t(638) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(639) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(640) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(643) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(641) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(642) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(2) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(644) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(645) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(3) },
    { Parser::Npda_::Transition_::SHIFT, 313, std::uint32_t(647) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(648) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(649) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(651) },
    { Parser::Npda_::Transition_::SHIFT, 321, std::uint32_t(650) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(279) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(4) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(652) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(5) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::SHIFT, 340, std::uint32_t(654) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(655) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(656) },
    { Parser::Npda_::Transition_::SHIFT, 338, std::uint32_t(657) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(120) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(658) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(105) },
    { Parser::Npda_::Transition_::SHIFT, 360, std::uint32_t(660) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(661) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(662) },
    { Parser::Npda_::Transition_::SHIFT, 361, std::uint32_t(663) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(14) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(664) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(153) },
    { Parser::Npda_::Transition_::SHIFT, 365, std::uint32_t(666) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(667) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(668) },
    { Parser::Npda_::Transition_::SHIFT, 366, std::uint32_t(669) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(8) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(670) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(175) },
    { Parser::Npda_::Transition_::SHIFT, 367, std::uint32_t(672) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(673) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(674) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(675) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(703) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(677) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(679) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(681) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(688) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(693) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(697) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(680) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(180) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(682) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(683) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(684) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(685) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(686) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(687) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(181) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(689) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(690) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(691) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(692) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(182) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(694) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(695) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(696) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(183) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(698) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(699) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(700) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 258, std::uint32_t(701) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 368, std::uint32_t(702) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(678) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(184) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(179) },
    { Parser::Npda_::Transition_::SHIFT, 369, std::uint32_t(705) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(706) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(707) },
    { Parser::Npda_::Transition_::SHIFT, 370, std::uint32_t(708) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(711) },
    { Parser::Npda_::Transition_::SHIFT, 256, std::uint32_t(719) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 370, std::uint32_t(710) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(711) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(712) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(715) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(718) },
    { Parser::Npda_::Transition_::SHIFT, 370, std::uint32_t(713) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 291, std::uint32_t(714) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(186) },
    { Parser::Npda_::Transition_::SHIFT, 370, std::uint32_t(716) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 257, std::uint32_t(717) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 41, std::uint32_t(187) },
    { Parser::Npda_::Transition_::REDUCE, 256, std::uint32_t(187) },
    { Parser::Npda_::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(188) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(185) },
    { Parser::Npda_::Transition_::SHIFT, 371, std::uint32_t(721) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(722) },
    { Parser::Npda_::Transition_::RETURN, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(723) },
    { Parser::Npda_::Transition_::SHIFT, 40, std::uint32_t(724) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::SHIFT, 370, std::uint32_t(725) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::EPSILON, 0, std::uint32_t(711) },
    { Parser::Npda_::Transition_::SHIFT, 41, std::uint32_t(726) },
    { Parser::Npda_::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { Parser::Npda_::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { Parser::Npda_::Transition_::REDUCE, 0, std::uint32_t(189) }
};
std::size_t const Parser::Npda_::ms_transition_count_ = sizeof(Parser::Npda_::ms_transition_table_) / sizeof(*Parser::Npda_::ms_transition_table_);

// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 137 "../bin/barftest/text/Parser.trison"

std::string Parser::TokenIdAsString (Token::Id token_id)
{
    assert(token_id <= ms_token_name_count_);
    if (0 <= token_id && token_id < 256)
        return char_literal_of(static_cast<uint8_t>(token_id));

    switch (token_id)
    {
        // These cases are really just to provide the syntactical representation of the terminals.
        case Terminal::AND:                 return std::string("and");
        case Terminal::ASSIGN:              return std::string("=");
        case Terminal::BAD_TOKEN:           return std::string("<bad-token>");
        case Terminal::BOOLEAN:             return std::string("Boolean");
        case Terminal::BREAK:               return std::string("break");
        case Terminal::CT:                  return std::string("ct");
        case Terminal::DEFINE:              return std::string(":=");
        case Terminal::DO:                  return std::string("do");
        case Terminal::END_:                return std::string("%end");
        case Terminal::END_OF_FILE:         return std::string("<end-of-file>");
        case Terminal::EQUALS:              return std::string("==");
        case Terminal::ERROR_:              return std::string("%error");
        case Terminal::EXTERNAL:            return std::string("external");
        case Terminal::FLOAT32:             return std::string("Float32");
        case Terminal::FLOAT64:             return std::string("Float64");
        case Terminal::GLOBAL:              return std::string("global");
        case Terminal::GREATER_OR_EQUAL:    return std::string(">=");
        case Terminal::GREATER_THAN:        return std::string(">");
        case Terminal::IDENTIFIER:          return std::string("<identifier>"); // This shouldn't really be used in this manner.
        case Terminal::IF:                  return std::string("if");
        case Terminal::INTERNAL:            return std::string("internal");
        case Terminal::LESS_OR_EQUAL:       return std::string("<=");
        case Terminal::LESS_THAN:           return std::string("<");
        case Terminal::LLVM_CAST_KEYWORD:   return std::string("__llvm_cast_<instr>__"); // This shouldn't really be used in this manner.
        case Terminal::LOCAL:               return std::string("local");
        case Terminal::MAPS_TO:             return std::string("->");
        case Terminal::NOT:                 return std::string("not");
        case Terminal::NOT_EQUALS:          return std::string("!=");
        case Terminal::NULLPTR:             return std::string("__nullptr__");
        case Terminal::OR:                  return std::string("or");
        case Terminal::OTHERWISE:           return std::string("otherwise");
        case Terminal::PRIVATE:             return std::string("private");
        case Terminal::RETURN:              return std::string("return");
        case Terminal::RT:                  return std::string("rt");
        case Terminal::SINT16:              return std::string("Sint16");
        case Terminal::SINT32:              return std::string("Sint32");
        case Terminal::SINT64:              return std::string("Sint64");
        case Terminal::SINT8:               return std::string("Sint8");
        case Terminal::STATEMENT_DELIMITER: return std::string(";");
        case Terminal::THEN:                return std::string("then");
        case Terminal::TYPE_KEYWORD:        return std::string("Type");
        case Terminal::UINT16:              return std::string("Uint16");
        case Terminal::UINT32:              return std::string("Uint32");
        case Terminal::UINT64:              return std::string("Uint64");
        case Terminal::UINT8:               return std::string("Uint8");
        case Terminal::VALUE_LITERAL:       return std::string("<value-literal>"); // This shouldn't really be used in this manner.
        case Terminal::VOID_TYPE:           return std::string("Void");
        case Terminal::WHILE:               return std::string("while");
        case Terminal::XOR:                 return std::string("xor");

        // Nonterminals are handled this way (except for Nonterminal::none_, which is a sentinel value)
        default:                            return std::string(ms_token_name_table_[token_id]);
    }
}

FiLoc Parser::filoc () const
{
    assert(m_scanner != nullptr);
    return m_scanner->filoc();
}

FiPos const &Parser::fipos () const
{
    assert(m_scanner != nullptr);
    return m_scanner->fipos();
}

bool Parser::ScannerDebugSpewIsEnabled () const
{
    return m_scanner->DebugSpewIsEnabled();
}

std::ostream *Parser::ScannerDebugSpewStream () const
{
    return m_scanner->DebugSpewStream();
}

void Parser::SetScannerDebugSpewStream (std::ostream *debug_spew_stream)
{
    m_scanner->SetDebugSpewStream(debug_spew_stream);
}

bool Parser::open_file (std::string const &input_filename)
{
    assert(m_scanner != nullptr);
    ResetForNewInput();
    record_message(m_scanner->firange(), "opening file \"" + input_filename + "\" for input");
    bool scanner_open_file_succeeded = m_scanner->open_file(input_filename);
    if (scanner_open_file_succeeded)
        record_message(m_scanner->firange(), "opened file \"" + input_filename + "\" successfully");
    return scanner_open_file_succeeded;
}

void Parser::open_string (std::string const &input_string, std::string const &input_name, bool use_line_numbers)
{
    assert(m_scanner != nullptr);
    ResetForNewInput();
    return m_scanner->open_string(input_string, input_name, use_line_numbers);
}

void Parser::open_using_stream (std::istream *input_stream, std::string const &input_name, bool use_line_numbers)
{
    assert(m_scanner != nullptr);
    ResetForNewInput();
    return m_scanner->open_using_stream(input_stream, input_name, use_line_numbers);
}

void Parser::record_message (FiRange const &firange, std::string const &message)
{
    if (m_log_out != nullptr)
        *m_log_out << Log::inf() << (firange.is_valid() ? firange.as_string()+": " : std::string()) << message << '\n';
}

void Parser::record_recoverable_error (FiLoc const &filoc, std::string const &message)
{
    m_recoverable_error_encountered = true;
    if (m_log_out != nullptr)
        *m_log_out << Log::err() << (filoc.is_valid() ? filoc.as_string()+": " : std::string()) << message << '\n';
}

void Parser::record_recoverable_error (FiRange const &firange, std::string const &message)
{
    m_recoverable_error_encountered = true;
    if (m_log_out != nullptr)
        *m_log_out << Log::err() << (firange.is_valid() ? firange.as_string()+": " : std::string()) << message << '\n';
}

} // end namespace text
} // end namespace barftest

#line 8857 "../bin/barftest/text/Parser.cpp"
