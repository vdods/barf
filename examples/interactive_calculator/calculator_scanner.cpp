// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// calculator_scanner.cpp generated by reflex
// from calculator_scanner.reflex using reflex.cpp.targetspec and reflex.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "calculator_scanner.hpp"

#include <iostream>

#define REFLEX_CPP_DEBUG_CODE_(spew_code) if (DebugSpewIsEnabled()) { spew_code; }


#line 47 "../calculator_scanner.reflex"

namespace Calculator {

#line 18 "../calculator_scanner.cpp"

Scanner::Scanner (
#line 32 "../calculator_scanner.reflex"
 string const &input_string 
#line 23 "../calculator_scanner.cpp"
)
    :
    ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputApparatus_Interactive_::IsInputAtEndMethod_>(&Scanner::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputApparatus_Interactive_::ReadNextAtomMethod_>(&Scanner::ReadNextAtom_))
{
    SetDebugSpewStream(NULL);


#line 50 "../calculator_scanner.reflex"

    m_input.str(input_string);

#line 42 "../calculator_scanner.cpp"

    ResetForNewInput();
}

Scanner::~Scanner ()
{
}

Scanner::StateMachine::Name Scanner::CurrentStateMachine () const
{
    assert(InitialState_() != NULL);
    std::size_t initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return StateMachine::START_;
        case 0: return StateMachine::MAIN;
    }
}

void Scanner::SwitchToStateMachine (StateMachine::Name state_machine)
{
    assert(
        state_machine == StateMachine::MAIN ||
        (false && "invalid StateMachine::Name"));
    REFLEX_CPP_DEBUG_CODE_(
        *DebugSpewStream() << "Scanner:" << " switching to state machine "
                           << ms_state_machine_name_[state_machine];
        if (ms_state_machine_mode_flags_[state_machine] != 0)
        {
            if ((ms_state_machine_mode_flags_[state_machine] & AutomatonApparatus_FastAndBig_Interactive_::MF_CASE_INSENSITIVE_) != 0)
                *DebugSpewStream() << " %case_insensitive";
            if ((ms_state_machine_mode_flags_[state_machine] & AutomatonApparatus_FastAndBig_Interactive_::MF_UNGREEDY_) != 0)
                *DebugSpewStream() << " %ungreedy";
        }
        *DebugSpewStream() << std::endl)
    InitialState_(ms_state_table_ + ms_state_machine_start_state_index_[state_machine]);
    ModeFlags_(ms_state_machine_mode_flags_[state_machine]);
    assert(CurrentStateMachine() == state_machine);
}

void Scanner::ResetForNewInput ()
{
    REFLEX_CPP_DEBUG_CODE_(
        *DebugSpewStream() << "Scanner:" << " executing reset-for-new-input actions and switching to state machine "
                           << ms_state_machine_name_[StateMachine::START_];
        if (ms_state_machine_mode_flags_[StateMachine::START_] != 0)
        {
            if ((ms_state_machine_mode_flags_[StateMachine::START_] & AutomatonApparatus_FastAndBig_Interactive_::MF_CASE_INSENSITIVE_) != 0)
                *DebugSpewStream() << " %case_insensitive";
            if ((ms_state_machine_mode_flags_[StateMachine::START_] & AutomatonApparatus_FastAndBig_Interactive_::MF_UNGREEDY_) != 0)
                *DebugSpewStream() << " %ungreedy";
        }
        *DebugSpewStream() << std::endl)
    ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::ResetForNewInput_(ms_state_table_ + ms_state_machine_start_state_index_[StateMachine::START_], ms_state_machine_mode_flags_[StateMachine::START_]);
    assert(CurrentStateMachine() == StateMachine::START_);


#line 77 "../calculator_scanner.reflex"


#line 104 "../calculator_scanner.cpp"
}

Parser::Token Scanner::Scan () throw()
{

    std::string work_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        // clear the previous accepted/rejected string.
        work_string.clear();
        // reset the char buffer and other stuff
        PrepareToScan_();

        bool was_at_end_of_input_ = IsAtEndOfInput();

        std::uint32_t accept_handler_index_ = RunDfa_(work_string);
        // if no valid accept_handler_index_ was returned, then work_string
        // was filled with everything up to the char after the keep_string
        // cursor (i.e. the rejected atom).
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            std::string &rejected_string = work_string;
            std::uint8_t rejected_atom = rejected_string.empty() ? '\0' : *rejected_string.rbegin();

            REFLEX_CPP_DEBUG_CODE_(
                *DebugSpewStream() << "Scanner:" << " rejecting string ";
                PrintString_(*DebugSpewStream(), rejected_string);
                *DebugSpewStream() << " (rejected_atom is \'";
                PrintAtom_(*DebugSpewStream(), rejected_atom);
                *DebugSpewStream() << "\')" << std::endl)

            // execute the rejection actions.  the do/while loop is so that a
            // break statement inside the rejection actions doesn't break out
            // of the main scanner loop.
            do
            {

#line 74 "../calculator_scanner.reflex"

    assert(false && "we should have handled this in the catch-all rule");

#line 154 "../calculator_scanner.cpp"

            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
            std::string &accepted_string = work_string;

            REFLEX_CPP_DEBUG_CODE_(
                *DebugSpewStream() << "Scanner:" << " accepting string ";
                PrintString_(*DebugSpewStream(), accepted_string);
                *DebugSpewStream() << " in state machine " << ms_state_machine_name_[CurrentStateMachine()]
                                   << " using regex (" << ms_accept_handler_regex_[accept_handler_index_] << ")" << std::endl)

            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
                case 0:
                {

#line 114 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::NUMBER, strtod(accepted_string.c_str(), NULL));
    
#line 181 "../calculator_scanner.cpp"

                }
                break;

                case 1:
                {

#line 119 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::NUMBER, strtod(accepted_string.c_str(), NULL));
    
#line 193 "../calculator_scanner.cpp"

                }
                break;

                case 2:
                {

#line 124 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::NUMBER, M_PI);
    
#line 205 "../calculator_scanner.cpp"

                }
                break;

                case 3:
                {

#line 129 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::NUMBER, M_E);
    
#line 217 "../calculator_scanner.cpp"

                }
                break;

                case 4:
                {

#line 134 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::RESULT);
    
#line 229 "../calculator_scanner.cpp"

                }
                break;

                case 5:
                {

#line 139 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::LOG);
    
#line 241 "../calculator_scanner.cpp"

                }
                break;

                case 6:
                {

#line 144 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::HELP);
    
#line 253 "../calculator_scanner.cpp"

                }
                break;

                case 7:
                {

#line 149 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::MOD);
    
#line 265 "../calculator_scanner.cpp"

                }
                break;

                case 8:
                {

#line 154 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Token::Id(accepted_string[0]));
    
#line 277 "../calculator_scanner.cpp"

                }
                break;

                case 9:
                {

#line 159 "../calculator_scanner.reflex"

        // ignore all non-newline whitespace
    
#line 289 "../calculator_scanner.cpp"

                }
                break;

                case 10:
                {

#line 164 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::NEWLINE);
    
#line 301 "../calculator_scanner.cpp"

                }
                break;

                case 11:
                {

#line 169 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::END_);
    
#line 313 "../calculator_scanner.cpp"

                }
                break;

                case 12:
                {

#line 174 "../calculator_scanner.reflex"

        return Parser::Token(Parser::Terminal::BAD_TOKEN);
    
#line 325 "../calculator_scanner.cpp"

                }
                break;

                default: assert(false && "this should never happen"); break;
            }
        }
    }


#line 53 "../calculator_scanner.reflex"

    return Parser::Token(Parser::Terminal::BAD_TOKEN);

#line 340 "../calculator_scanner.cpp"
}

void Scanner::KeepString ()
{
    REFLEX_CPP_DEBUG_CODE_(*DebugSpewStream() << "Scanner:" << " keeping string" << std::endl)
    AutomatonApparatus_FastAndBig_Interactive_::KeepString();
}

void Scanner::Unaccept (std::uint32_t unaccept_char_count)
{
    REFLEX_CPP_DEBUG_CODE_(*DebugSpewStream() << "Scanner:" << " unaccepting " << unaccept_char_count << " char" << (unaccept_char_count == 1 ? '\0' : 's') << std::endl)
    AutomatonApparatus_FastAndBig_Interactive_::Unaccept(unaccept_char_count);
}

void Scanner::Unreject (std::uint32_t unreject_char_count)
{
    REFLEX_CPP_DEBUG_CODE_(*DebugSpewStream() << "Scanner:" << " unrejecting " << unreject_char_count << " char" << (unreject_char_count == 1 ? '\0' : 's') << std::endl)
    AutomatonApparatus_FastAndBig_Interactive_::Unreject(unreject_char_count);
}

// ///////////////////////////////////////////////////////////////////////
// begin internal reflex-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

bool Scanner::IsInputAtEnd_ () throw()
{

#line 68 "../calculator_scanner.reflex"

    return m_input.peek() == char_traits<char>::eof();

#line 372 "../calculator_scanner.cpp"
}

std::uint8_t Scanner::ReadNextAtom_ () throw()
{

#line 71 "../calculator_scanner.reflex"

    return m_input.get();

#line 382 "../calculator_scanner.cpp"
}

void Scanner::PrintAtom_ (std::ostream &out, std::uint8_t atom)
{
    if (atom == '\\')                    out << "\\\\";
    else if (atom == '"')                out << "\\\"";
    else if (atom >= ' ' && atom <= '~') out << atom;
    else if (atom == '\n')               out << "\\n";
    else if (atom == '\t')               out << "\\t";
    else if (atom == '\0')               out << "\\0";
    else
    {
        out.width(2);
        out << "\\x" << std::hex << std::uppercase << std::uint16_t(atom);
        out.width(1);
    }
}

void Scanner::PrintString_ (std::ostream &out, std::string const &s)
{
    // save the existing ostream properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = out.flags();
    char saved_stream_fill = out.fill();
    std::streamsize saved_stream_width = out.width();
    std::streamsize saved_stream_precision = out.precision();

    // clear all format flags to a neutral state
    out.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    out.fill('0');

    out << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        PrintAtom_(out, s[i]);
    out << '"';

    // restore the saved out properties
    out.setf(saved_stream_flags);
    out.fill(saved_stream_fill);
    out.width(saved_stream_width);
    out.precision(saved_stream_precision);
}

std::uint32_t const Scanner::ms_state_machine_start_state_index_[] =
{
    0,
};
std::uint8_t const Scanner::ms_state_machine_mode_flags_[] =
{
    0,
};
char const *const Scanner::ms_state_machine_name_[] =
{
    "MAIN",
};
std::uint32_t const Scanner::ms_state_machine_count_ = sizeof(Scanner::ms_state_machine_name_) / sizeof(*Scanner::ms_state_machine_name_);

// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaState_ const Scanner::ms_state_table_[] =
{
    { 13, 32, 0, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::CONDITIONAL, 0 },
    { 13, 255, 32, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 1 },
    { 12, 0, 287, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 9, 0, 287, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 10, 0, 287, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 8, 0, 287, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 0, 1, 287, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 46 },
    { 13, 10, 288, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 48 },
    { 1, 54, 298, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 48 },
    { 13, 15, 352, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 43 },
    { 13, 10, 367, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 48 },
    { 1, 0, 377, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 1, 10, 377, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 48 },
    { 0, 12, 387, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 46 },
    { 0, 12, 399, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 46 },
    { 3, 0, 411, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 12, 1, 411, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 101 },
    { 13, 1, 412, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 108 },
    { 13, 1, 413, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 112 },
    { 6, 0, 414, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 12, 1, 414, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 111 },
    { 13, 1, 415, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 103 },
    { 5, 0, 416, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 12, 1, 416, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 111 },
    { 13, 1, 417, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 100 },
    { 7, 0, 418, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 12, 1, 418, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 105 },
    { 2, 0, 419, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 4, 0, 419, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 0 },
    { 11, 255, 419, ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_::INPUT_ATOM, 1 }
};
std::size_t const Scanner::ms_state_count_ = sizeof(Scanner::ms_state_table_) / sizeof(*Scanner::ms_state_table_);

ReflexCpp_::AutomatonApparatus_FastAndBig_Interactive_::DfaTransition_ const Scanner::ms_transition_table_[] =
{
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 1 },
    { 1 },
    { 29 },
    { 29 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 3 },
    { 4 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 3 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 5 },
    { 5 },
    { 5 },
    { 5 },
    { 2 },
    { 5 },
    { 2 },
    { 5 },
    { 6 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 5 },
    { 2 },
    { 5 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 15 },
    { 2 },
    { 2 },
    { 16 },
    { 2 },
    { 2 },
    { 2 },
    { 20 },
    { 23 },
    { 2 },
    { 2 },
    { 26 },
    { 2 },
    { 28 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 7 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 8 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 9 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 30 },
    { 9 },
    { 10 },
    { 30 },
    { 10 },
    { 30 },
    { 30 },
    { 11 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 11 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 12 },
    { 7 },
    { 30 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 7 },
    { 30 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 14 },
    { 17 },
    { 18 },
    { 19 },
    { 21 },
    { 22 },
    { 24 },
    { 25 },
    { 27 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 3 },
    { 4 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 3 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 5 },
    { 5 },
    { 5 },
    { 5 },
    { 2 },
    { 5 },
    { 2 },
    { 5 },
    { 6 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 13 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 5 },
    { 2 },
    { 5 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 15 },
    { 2 },
    { 2 },
    { 16 },
    { 2 },
    { 2 },
    { 2 },
    { 20 },
    { 23 },
    { 2 },
    { 2 },
    { 26 },
    { 2 },
    { 28 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 },
    { 2 }
};
std::size_t const Scanner::ms_transition_count_ = sizeof(Scanner::ms_transition_table_) / sizeof(*Scanner::ms_transition_table_);

char const *const Scanner::ms_accept_handler_regex_[] =
{
    "{INTEGER}",
    "{FLOAT}",
    "pi",
    "e",
    "r",
    "log",
    "help",
    "mod",
    "{OPERATOR}",
    "{WHITESPACE}",
    "{NEWLINE}",
    "{END_OF_FILE}",
    "."
};
std::uint32_t const Scanner::ms_accept_handler_count_ = sizeof(Scanner::ms_accept_handler_regex_) / sizeof(*Scanner::ms_accept_handler_regex_);

// ///////////////////////////////////////////////////////////////////////
// end of internal reflex-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 56 "../calculator_scanner.reflex"

} // end of namespace Calculator

#line 1189 "../calculator_scanner.cpp"
