// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// CalcParser.cpp generated by trison
// from CalcParser.trison using trison.cpp.targetspec and trison.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "CalcParser.hpp"



#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpewIsEnabled()) { spew_code; }


#line 47 "CalcParser.trison"

#include "ast.hpp"
#include <cmath>
#include <sstream>
#include "Scanner.hpp"

typedef Ast::Operator<Ast::Base> BaseOperator;

template <typename... Args_>
std::shared_ptr<BaseOperator> base_operator (Args_&&... args)
{
    return std::make_shared<BaseOperator>(std::forward<Args_>(args)...);
}

#line 29 "CalcParser.cpp"

CalcParser::CalcParser ()
{
    SetDebugSpewStream(NULL);


#line 61 "CalcParser.trison"

    m_scanner = new Scanner();
    m_scanner->DebugSpew(true);

#line 41 "CalcParser.cpp"
}

CalcParser::~CalcParser ()
{


#line 65 "CalcParser.trison"

    delete m_scanner;
    m_scanner = NULL;

#line 53 "CalcParser.cpp"
}

bool CalcParser::IsAtEndOfInput ()
{
    return true; // TEMP
}

void CalcParser::ResetForNewInput ()
{
    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Executing reset-for-new-input actions\n")



#line 133 "CalcParser.trison"

    // m_recoverable_error_encountered = false;

#line 71 "CalcParser.cpp"
}

CalcParser::ParserReturnCode CalcParser::Parse (std::shared_ptr<Ast::Base> *return_token, Nonterminal::Name nonterminal_to_parse)
{
    return Parse_(return_token, nonterminal_to_parse);
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

void CalcParser::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << "CalcParser: " << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << "CalcParser: " << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, CalcParser::Token const &token)
{
    if (token.m_id < CalcParser::ms_token_name_count_)
        stream << CalcParser::ms_token_name_table_[token.m_id];
    else
        stream << "!INVALID TOKEN!";
    return stream;
}

char const *const CalcParser::ms_token_name_table_[] =
{
    "'\\0'",
    "'\\x01'",
    "'\\x02'",
    "'\\x03'",
    "'\\x04'",
    "'\\x05'",
    "'\\x06'",
    "'\\a'",
    "'\\b'",
    "'\\t'",
    "'\\n'",
    "'\\v'",
    "'\\f'",
    "'\\r'",
    "'\\x0E'",
    "'\\x0F'",
    "'\\x10'",
    "'\\x11'",
    "'\\x12'",
    "'\\x13'",
    "'\\x14'",
    "'\\x15'",
    "'\\x16'",
    "'\\x17'",
    "'\\x18'",
    "'\\x19'",
    "'\\x1A'",
    "'\\x1B'",
    "'\\x1C'",
    "'\\x1D'",
    "'\\x1E'",
    "'\\x1F'",
    "' '",
    "'!'",
    "'\"'",
    "'#'",
    "'$'",
    "'%'",
    "'&'",
    "'\\''",
    "'('",
    "')'",
    "'*'",
    "'+'",
    "','",
    "'-'",
    "'.'",
    "'/'",
    "'0'",
    "'1'",
    "'2'",
    "'3'",
    "'4'",
    "'5'",
    "'6'",
    "'7'",
    "'8'",
    "'9'",
    "':'",
    "';'",
    "'<'",
    "'='",
    "'>'",
    "'?'",
    "'@'",
    "'A'",
    "'B'",
    "'C'",
    "'D'",
    "'E'",
    "'F'",
    "'G'",
    "'H'",
    "'I'",
    "'J'",
    "'K'",
    "'L'",
    "'M'",
    "'N'",
    "'O'",
    "'P'",
    "'Q'",
    "'R'",
    "'S'",
    "'T'",
    "'U'",
    "'V'",
    "'W'",
    "'X'",
    "'Y'",
    "'Z'",
    "'['",
    "'\\\\'",
    "']'",
    "'^'",
    "'_'",
    "'`'",
    "'a'",
    "'b'",
    "'c'",
    "'d'",
    "'e'",
    "'f'",
    "'g'",
    "'h'",
    "'i'",
    "'j'",
    "'k'",
    "'l'",
    "'m'",
    "'n'",
    "'o'",
    "'p'",
    "'q'",
    "'r'",
    "'s'",
    "'t'",
    "'u'",
    "'v'",
    "'w'",
    "'x'",
    "'y'",
    "'z'",
    "'{'",
    "'|'",
    "'}'",
    "'~'",
    "'\\x7F'",
    "'\\x80'",
    "'\\x81'",
    "'\\x82'",
    "'\\x83'",
    "'\\x84'",
    "'\\x85'",
    "'\\x86'",
    "'\\x87'",
    "'\\x88'",
    "'\\x89'",
    "'\\x8A'",
    "'\\x8B'",
    "'\\x8C'",
    "'\\x8D'",
    "'\\x8E'",
    "'\\x8F'",
    "'\\x90'",
    "'\\x91'",
    "'\\x92'",
    "'\\x93'",
    "'\\x94'",
    "'\\x95'",
    "'\\x96'",
    "'\\x97'",
    "'\\x98'",
    "'\\x99'",
    "'\\x9A'",
    "'\\x9B'",
    "'\\x9C'",
    "'\\x9D'",
    "'\\x9E'",
    "'\\x9F'",
    "'\\xA0'",
    "'\\xA1'",
    "'\\xA2'",
    "'\\xA3'",
    "'\\xA4'",
    "'\\xA5'",
    "'\\xA6'",
    "'\\xA7'",
    "'\\xA8'",
    "'\\xA9'",
    "'\\xAA'",
    "'\\xAB'",
    "'\\xAC'",
    "'\\xAD'",
    "'\\xAE'",
    "'\\xAF'",
    "'\\xB0'",
    "'\\xB1'",
    "'\\xB2'",
    "'\\xB3'",
    "'\\xB4'",
    "'\\xB5'",
    "'\\xB6'",
    "'\\xB7'",
    "'\\xB8'",
    "'\\xB9'",
    "'\\xBA'",
    "'\\xBB'",
    "'\\xBC'",
    "'\\xBD'",
    "'\\xBE'",
    "'\\xBF'",
    "'\\xC0'",
    "'\\xC1'",
    "'\\xC2'",
    "'\\xC3'",
    "'\\xC4'",
    "'\\xC5'",
    "'\\xC6'",
    "'\\xC7'",
    "'\\xC8'",
    "'\\xC9'",
    "'\\xCA'",
    "'\\xCB'",
    "'\\xCC'",
    "'\\xCD'",
    "'\\xCE'",
    "'\\xCF'",
    "'\\xD0'",
    "'\\xD1'",
    "'\\xD2'",
    "'\\xD3'",
    "'\\xD4'",
    "'\\xD5'",
    "'\\xD6'",
    "'\\xD7'",
    "'\\xD8'",
    "'\\xD9'",
    "'\\xDA'",
    "'\\xDB'",
    "'\\xDC'",
    "'\\xDD'",
    "'\\xDE'",
    "'\\xDF'",
    "'\\xE0'",
    "'\\xE1'",
    "'\\xE2'",
    "'\\xE3'",
    "'\\xE4'",
    "'\\xE5'",
    "'\\xE6'",
    "'\\xE7'",
    "'\\xE8'",
    "'\\xE9'",
    "'\\xEA'",
    "'\\xEB'",
    "'\\xEC'",
    "'\\xED'",
    "'\\xEE'",
    "'\\xEF'",
    "'\\xF0'",
    "'\\xF1'",
    "'\\xF2'",
    "'\\xF3'",
    "'\\xF4'",
    "'\\xF5'",
    "'\\xF6'",
    "'\\xF7'",
    "'\\xF8'",
    "'\\xF9'",
    "'\\xFA'",
    "'\\xFB'",
    "'\\xFC'",
    "'\\xFD'",
    "'\\xFE'",
    "'\\xFF'",
    "END_",
    "ERROR_",
    "NUM",
    "BAD_TOKEN",
    "stmt_then_end",
    "stmt",
    "expr"
};
std::size_t const CalcParser::ms_token_name_count_ = sizeof(CalcParser::ms_token_name_table_) / sizeof(*CalcParser::ms_token_name_table_);


void CalcParser::ThrowAwayToken_ (Token &token_) throw()
{
    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Executing throw-away-token actions on token " << token_ << '\n')

    ThrowAwayTokenData_(token_.m_data);
}

void CalcParser::ThrowAwayTokenData_ (std::shared_ptr<Ast::Base> &token_data) throw()
{

#line 106 "CalcParser.trison"
 
#line 387 "CalcParser.cpp"
}

CalcParser::Token CalcParser::Scan_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Executing scan actions\n")


#line 107 "CalcParser.trison"

    assert(m_scanner != NULL);
    std::shared_ptr<Ast::Base> token;
    TokenId scanner_token_id = m_scanner->Scan(token);
    switch (scanner_token_id)
    {
        case BAD_TOKEN:
        case CHAR_LITERAL:
        case IDENTIFIER:
        case STRING_LITERAL:
            return Token(Terminal::BAD_TOKEN, token);

        case END_OF_FILE:
            return Token(Terminal::END_, token);

        case INTEGER_LITERAL:
            return Token(Terminal::NUM, Ast::numeric_literal(double(token->as<Ast::IntegerLiteral>().m_value)));

        case NUMERIC_LITERAL:
            return Token(Terminal::NUM, token);

        default:
            assert(std::uint32_t(scanner_token_id) < 256 && "You probably forgot a TokenId");
            return Token(Terminal::Name(scanner_token_id), nullptr);
    }

#line 422 "CalcParser.cpp"
}

#include <algorithm>
#include <limits>

std::uint32_t CalcParser::NonterminalStartStateIndex_ (CalcParser::Nonterminal::Name nonterminal)
{
    switch (nonterminal)
    {
        case Nonterminal::expr: return 10;
        case Nonterminal::stmt: return 5;
        case Nonterminal::stmt_then_end: return 0;
        default: assert(false && "invalid nonterminal"); return 0;
    }
}

CalcParser::ParserReturnCode CalcParser::Parse_ (std::shared_ptr<Ast::Base> *return_token, Nonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Starting parse\n")

    ParserReturnCode parser_return_code_ = PRC_INTERNAL_ERROR;
    *return_token = std::shared_ptr<Ast::Base>();


    m_npda_.m_root_ = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::ROOT));

    ParseStackTreeNode_ *hps = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::HPS));
    std::uint32_t initial_state = NonterminalStartStateIndex_(nonterminal_to_parse);
    hps->m_stack.push_back(HypotheticalBranchStackElement_(initial_state, Nonterminal::none_));

    m_npda_.m_root_->AddChild(hps);
    m_npda_.m_hps_queue_.push_back(hps);

    StateSet_ initial_npda_state_set;
    initial_npda_state_set.insert(initial_state);
    m_npda_.m_realized_stack_.push_back(RealizedBranchStackElement_(initial_npda_state_set, Token(Nonterminal::none_)));

    bool should_return = false;
    std::size_t iteration_index = 0;
    while (!should_return)
    {
        TRISON_CPP_DEBUG_CODE_(
            *DebugSpewStream() << "CalcParser: " << "\n";
            *DebugSpewStream() << "CalcParser: " << "---------- ITERATION " << iteration_index << " --------------\n";
            PrintParserStatus_(*DebugSpewStream());
            *DebugSpewStream() << "CalcParser: " << '\n';
        )

        if (m_npda_.m_root_->HasTrunkChild())
            ExecuteAndRemoveTrunkActions_(should_return, parser_return_code_, return_token);
        else
            ContinueNPDAParse_(should_return);

        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << '\n')
        ++iteration_index;
    }

    TRISON_CPP_DEBUG_CODE_(
        *DebugSpewStream() << "CalcParser: " << "\n";
        *DebugSpewStream() << "CalcParser: " << "---------- RETURNING --------------\n";
        PrintParserStatus_(*DebugSpewStream());
        *DebugSpewStream() << "CalcParser: " << '\n';
    )

    TRISON_CPP_DEBUG_CODE_(
        *DebugSpewStream() << "CalcParser: " << "Parse() is returning ";
        switch (parser_return_code_)
        {
            case PRC_SUCCESS:               *DebugSpewStream() << "PRC_SUCCESS\n";               break;
            case PRC_UNHANDLED_PARSE_ERROR: *DebugSpewStream() << "PRC_UNHANDLED_PARSE_ERROR\n"; break;
            default:                        assert(false && "this should never happen");
                                            parser_return_code_ = PRC_INTERNAL_ERROR; // fall through
            case PRC_INTERNAL_ERROR:        *DebugSpewStream() << "PRC_INTERNAL_ERROR\n";        break;
        }
    )

    return parser_return_code_;
}

void CalcParser::ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code_, std::shared_ptr<Ast::Base> *&return_token)
{
    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Parse stack tree has trunk; executing trunk actions.\n")
    while (m_npda_.m_root_->HasTrunkChild())
    {
        ParseStackTreeNode_ *trunk_child = m_npda_.m_root_->PopTrunkChild();
        bool destroy_and_recreate_parse_tree = false;
        switch (trunk_child->m_spec.m_type)
        {
            case ParseStackTreeNode_::RETURN: {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action RETURN.\n")
                assert(m_npda_.m_realized_stack_.size() == 2);
                parser_return_code_ = PRC_SUCCESS;
                *return_token = m_npda_.m_realized_stack_.back().m_token.m_data;
                should_return = true;
                break;
            }
            case ParseStackTreeNode_::REDUCE: {
                // Execute the appropriate rule on the top tokens in the stack
                std::uint32_t const &rule_index = trunk_child->m_spec.m_single_data;
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action REDUCE rule " << rule_index << ".\n")
                // NOTE: dont actually execute reduction rules here, that should be saved for executing the trunk
                Token::Data reduced_nonterminal_token_data = ExecuteReductionRule_(rule_index, m_npda_.m_realized_stack_);
                Rule_ const &rule = ms_rule_table_[rule_index];
                // Pop those stack tokens
                for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
                    m_npda_.m_realized_stack_.pop_back();
                // Push the reduced nonterminal token data onto the front of the lookahead queue
                m_npda_.PushFrontRealizedLookahead(Token(rule.m_reduction_nonterminal_token_id, reduced_nonterminal_token_data));
                // Because REDUCE involves popping the stack, indicate that the parse tree should be destroyed and
                // recreated.  This is draconian and non-optimal, but simple and effective.  TODO: Because HPS branches
                // are blocked right after a REDUCE or POP_STACK, maybe don't bother adding any children below REDUCE
                // or POP_STACK nodes.
                destroy_and_recreate_parse_tree = true;
                break;
            }
            case ParseStackTreeNode_::SHIFT: {
                assert(trunk_child->m_spec.m_single_data == ParseStackTreeNode_::UNUSED_DATA); // m_single_data is not used for SHIFT.
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action SHIFT.\n") // TODO: Print the lookahead that was shifted?
                // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
                m_npda_.m_realized_stack_.push_back(RealizedBranchStackElement_(trunk_child->m_npda_state_set, Lookahead_(0)));
                m_npda_.PopFrontRealizedLookahead();
                break;
            }
            case ParseStackTreeNode_::INSERT_LOOKAHEAD_ERROR: {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action INSERT_LOOKAHEAD_ERROR, and setting has-encountered-error-state flag.\n")
                m_npda_.PushFrontRealizedLookahead(Token(Terminal::ERROR_));
                m_npda_.SetHasEncounteredErrorState();
                break;
            }
            case ParseStackTreeNode_::DISCARD_LOOKAHEAD: {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action DISCARD_LOOKAHEAD.\n")
                assert(!m_npda_.m_realized_lookahead_queue_.empty());
                m_npda_.PopFrontRealizedLookahead();
                break;
            }
            case ParseStackTreeNode_::POP_STACK: {
                std::uint32_t const &pop_count = trunk_child->m_spec.m_single_data;
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Executing trunk action POP_STACK " << pop_count << ".\n")
                if (m_npda_.m_realized_stack_.size() > pop_count)
                {
                    for (std::uint32_t i = 0; i < pop_count; ++i)
                    {
                        ThrowAwayRealizedBranchStackElement_(m_npda_.m_realized_stack_.back());
                        m_npda_.m_realized_stack_.pop_back();
                    }
                }

                // Because POP_STACK involves popping the stack, indicate that the parse tree should be destroyed and
                // recreated (from the states in the top element of m_realized_stack_).  This is draconian and non-optimal,
                // but simple and effective.
                destroy_and_recreate_parse_tree = true;
                break;
            }

            default:
                assert(false && "this should not happen");
                break;
        }
        assert(trunk_child->m_parent_node == NULL);
        assert(trunk_child->m_child_nodes.empty());
        delete trunk_child;

        if (destroy_and_recreate_parse_tree)
        {
            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Destroying and recreating parse tree based on top element of realized stack.\n")
            // Destroy the whole parse tree and reconstruct HPSes based on top of m_realized_stack_,
            // but preserve m_realized_stack_ and m_realized_lookahead_queue_.  This is rather draconian and is
            // non-optimal in terms of memory allocation operations, but it is simple and effective, and should
            // only occur during error handling.
            assert(m_npda_.m_new_hps_queue_.empty());
            m_npda_.m_hps_queue_.clear();
            delete m_npda_.m_root_;
            m_npda_.m_root_ = NULL;
            // At this point, the parse tree should be destroyed.  Create a new root node
            m_npda_.m_root_ = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::ROOT));
            // Then add HPS nodes for each npda state in the top element of m_realized_stack_.
            assert(!m_npda_.m_realized_stack_.empty());
            StateVector_ const &reconstruct_state_vector = m_npda_.m_realized_stack_.back().m_npda_state_vector;
            for (StateVector_::const_iterator it = reconstruct_state_vector.begin(),
                                              it_end = reconstruct_state_vector.end();
                 it != it_end;
                 ++it)
            {
                std::uint32_t state_index = *it;
                ParseStackTreeNode_ *hps = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::HPS));
                hps->m_stack.push_back(HypotheticalBranchStackElement_(state_index, Nonterminal::none_));

                m_npda_.m_root_->AddChild(hps);
                m_npda_.m_hps_queue_.push_back(hps);
            }

            // TODO: Because HPS branches are blocked right after a REDUCE or POP_STACK, maybe don't bother
            // adding any children below REDUCE or POP_STACK nodes.  This would reduce the number of memory
            // operations.
        }
    }
}

void CalcParser::ContinueNPDAParse_ (bool &should_return)
{
    // If there are no non-blocked hps-es, then the parse should stop.  If any non-blocked hps-es
    // are processed, then this flag will be set to false.
    should_return = true;

    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Parse stack tree does not have trunk; continuing parse.\n")

    // If there's a SHIFT/REDUCE conflict, then see if it can be resolved first.
    {
        ParseStackTreeNode_ *shift  = NULL;
        ParseStackTreeNode_ *reduce = NULL;
        // TODO: Move this handling into its own function
        if (m_npda_.m_root_->HasShiftReduceConflict(shift, reduce))
        {
            assert(shift != NULL);
            assert(reduce != NULL);
            ParseStackTreeNode_::PrecedenceLevelRange shift_precedence_level_range = shift->ComputePrecedenceLevelRange(1);
            ParseStackTreeNode_::PrecedenceLevelRange reduce_precedence_level_range = reduce->ComputePrecedenceLevelRange(1);
            assert(reduce_precedence_level_range.first == reduce_precedence_level_range.second);

            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    SHIFT/REDUCE conflict encountered. REDUCE precedence level range: [" << ms_precedence_table_[reduce_precedence_level_range.first].m_name << ", " << ms_precedence_table_[reduce_precedence_level_range.second].m_name << "], SHIFT precedence level range: [" << ms_precedence_table_[shift_precedence_level_range.first].m_name << ", " << ms_precedence_table_[shift_precedence_level_range.second].m_name << "]\n")

            // 6 possibilities (the higher lines indicate higher precedence level.  same line
            // indicates equality).  there is always exactly one reduce hps, and at least
            // one shift hps.
            //
            // note that if a shift and a reduce have the same precedence level, then they also
            // have the same associativity.
            //
            // 1.     shift        2.     shift        3.
            //        shift               shift
            // reduce              reduce shift        reduce shift
            //
            // 4.                  5.                  6.
            //                                                shift
            // reduce shift        reduce              reduce shift
            //        shift               shift               shift
            //        shift               shift
            //
            // cases 1 and 5 can be trivially resolved -- by pruning the reduce
            // and by pruning the shift respectively.
            //
            // case 2 can only be resolved if the associativity of the reduction rule
            // is RIGHT, in which case the reduce is pruned.  otherwise no resolution
            // can be reached at this point.
            //
            // case 3 may be trivially resolved via rule associativity (LEFT causes the
            // shift to be pruned, RIGHT causes the reduce to be pruned, and NONASSOC
            // should cause an error).
            //
            // case 4 can only be resolved if the associativity of the reduction rule
            // is LEFT, in which case the shift is pruned.  otherwise no resolution
            // can be reached at this point.
            //
            // case 6 can not be resolved at this point.

            bool conflict_resolved = false;

            // Case 1
            if (reduce_precedence_level_range.second < shift_precedence_level_range.first)
            {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 1; REDUCE < SHIFT; pruning REDUCE and continuing.\n")
                m_npda_.RemoveBranchIfNotTrunk(reduce);
                delete reduce;
                reduce = NULL;
                conflict_resolved = true;
            }
            // Case 2
            else if (reduce_precedence_level_range.first == shift_precedence_level_range.first &&
                     shift_precedence_level_range.first < shift_precedence_level_range.second)
            {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 2; REDUCE <= SHIFT; ")
                Rule_ const &reduction_rule = ms_rule_table_[reduce->m_spec.m_single_data];
                Precedence_ const &reduction_rule_precedence = ms_precedence_table_[reduction_rule.m_precedence_index];
                if (reduction_rule_precedence.m_associativity_index == 2) // 2 is right-associative
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "pruning right-associative REDUCE and continuing.\n")
                    m_npda_.RemoveBranchIfNotTrunk(reduce);
                    delete reduce;
                    reduce = NULL;
                    conflict_resolved = true;
                }
                else
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "can't resolve conflict at this time.\n")
                }
            }
            // Case 3
            else if (reduce_precedence_level_range.second == shift_precedence_level_range.first &&
                     shift_precedence_level_range.first == shift_precedence_level_range.second)
            {
                Rule_ const &reduction_rule = ms_rule_table_[reduce->m_spec.m_single_data];
                Precedence_ const &reduction_rule_precedence = ms_precedence_table_[reduction_rule.m_precedence_index];
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 3; REDUCE == SHIFT; rule " << reduce->m_spec.m_single_data << " associativity index: " <<
 reduction_rule_precedence.m_associativity_index << '\n')
                switch (reduction_rule_precedence.m_associativity_index)
                {
                    case 0: // 0 is left-associative
                        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "pruning left-associative SHIFT and continuing.\n")
                        m_npda_.RemoveBranchIfNotTrunk(shift);
                        delete shift;
                        shift = NULL;
                        conflict_resolved = true;
                        break;

                    case 1: // 1 is non-associative
                        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "composition of non-associative rules is an error.\n")
                        assert(false && "TODO: implement nonassoc error handling");
                        break;

                    case 2: // 2 is right-associative
                        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "pruning right-associative REDUCE and continuing.\n")
                        m_npda_.RemoveBranchIfNotTrunk(reduce);
                        delete reduce;
                        reduce = NULL;
                        conflict_resolved = true;
                        break;

                    default:
                        assert(false && "this should never happen");
                        break;
                }
            }
            // Case 4
            else if (reduce_precedence_level_range.second == shift_precedence_level_range.second &&
                     shift_precedence_level_range.first < shift_precedence_level_range.second)
            {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 4; REDUCE >= SHIFT; ")
                Rule_ const &reduction_rule = ms_rule_table_[reduce->m_spec.m_single_data];
                Precedence_ const &reduction_rule_precedence = ms_precedence_table_[reduction_rule.m_precedence_index];
                if (reduction_rule_precedence.m_associativity_index == 0) // 0 is left-associative
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "pruning left-associative SHIFT and continuing.\n")
                    m_npda_.RemoveBranchIfNotTrunk(shift);
                    delete shift;
                    shift = NULL;
                    conflict_resolved = true;
                }
                else
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "can't resolve conflict at this time.\n")
                }
            }
            // Case 5
            else if (reduce_precedence_level_range.first > shift_precedence_level_range.second)
            {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 5; REDUCE > SHIFT; pruning SHIFT and continuing.\n")
                m_npda_.RemoveBranchIfNotTrunk(shift);
                delete shift;
                shift = NULL;
                conflict_resolved = true;
            }
            // Case 6
            else {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Case 6; ambiguous SHIFT/REDUCE precedence comparison; can't resolve conflict at this time.\n")
                assert(reduce_precedence_level_range.first > shift_precedence_level_range.first);
                assert(reduce_precedence_level_range.second < shift_precedence_level_range.second);
            }

            if (conflict_resolved)
            {
                should_return = false;

                assert(m_npda_.m_new_hps_queue_.empty());
                // Take new hps-es and clear old ones.
                for (HPSQueue_::iterator hps_it = m_npda_.m_hps_queue_.begin(), hps_it_end = m_npda_.m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
                {
                    ParseStackTreeNode_ *hps = *hps_it;
                    if (hps != NULL)
                        m_npda_.m_new_hps_queue_.push_back(hps);
                }
                m_npda_.m_hps_queue_.clear();
                std::swap(m_npda_.m_hps_queue_, m_npda_.m_new_hps_queue_);
                assert(m_npda_.m_new_hps_queue_.empty());
                // TODO: Break this large function up into smaller logical units
                return;
            }
        }
    }

    // Process transitions in order of their SortedTypeIndex.
    for (std::uint32_t current_sorted_type_index = 0; current_sorted_type_index <= 3; ++current_sorted_type_index)
    {
        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "    Processing transitions having SortedTypeIndex equal to " << current_sorted_type_index << ".\n")

        if (!m_npda_.m_new_hps_queue_.empty())
        {
            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "        Early-out based on sorted type index.\n")
            break;
        }

        // Process non-blocked hps-es.
        for (HPSQueue_::iterator hps_it = m_npda_.m_hps_queue_.begin(), hps_it_end = m_npda_.m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
        {
            // Skip nullified HPS nodes.
            if (*hps_it == NULL)
                continue;

            ParseStackTreeNode_ &hps = **hps_it;

            assert(hps.m_spec.m_type == ParseStackTreeNode_::HPS);
            TRISON_CPP_DEBUG_CODE_(
                *DebugSpewStream() << "CalcParser: " << "        Processing hps: ";
                hps.Print(*DebugSpewStream(), *this, "CalcParser: ", 0);
            )

            // If a hps is blocked, save it for the next parse iteration but don't do anything with it.
            if (hps.IsBlockedHPS())
            {
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "            Hypothetical Parser State is blocked; preserving for next iteration.\n")
                m_npda_.m_new_hps_queue_.push_back(&hps);
                *hps_it = NULL;
                continue;
            }

            // This hps isn't blocked, so indicate that the parse should continue.
            should_return = false;

            std::uint32_t hps_state_index = hps.m_stack.back().m_state_index;
            // Retrieve all transitions whose SortedTypeIndex is current_sorted_type_index.
            TransitionVector_ const &non_epsilon_transitions = NonEpsilonTransitionsOfState_(hps_state_index, current_sorted_type_index);
            // Exercise all valid transitions whose SortedTypeIndex is current_sorted_type_index.
            for (TransitionVector_::const_iterator transition_it = non_epsilon_transitions.begin(), transition_it_end = non_epsilon_transitions.end(); transition_it != transition_it_end; ++transition_it)
            {
                Transition_ const &transition = *transition_it;
                assert(transition.m_type >= Transition_::RETURN);
                assert(transition.m_type <= Transition_::POP_STACK);
                std::uint32_t transition_sorted_type_index = Transition_::Order::SortedTypeIndex(Transition_::Type(transition.m_type));
                assert(transition_sorted_type_index == current_sorted_type_index);

                TRISON_CPP_DEBUG_CODE_(
                    *DebugSpewStream() << "CalcParser: " << "            Processing transition " << ParseStackTreeNode_::AsString(ParseStackTreeNode_::Type(transition.m_type)) << " with transition token " << Token(transition.m_token_index) << " and data ";
                    if (transition.m_data_index == ParseStackTreeNode_::UNUSED_DATA)
                        *DebugSpewStream() << "<N/A>";
                    else
                        *DebugSpewStream() << transition.m_data_index;
                    *DebugSpewStream() << " and sorted type index " << Transition_::Order::SortedTypeIndex(Transition_::Type(transition.m_type)) << '\n';
                )

                ParseStackTreeNode_ *resulting_hps = NULL;
                // If it's a default transition, there's no need to access the lookahead.
                if (transition.m_token_index == Nonterminal::none_)
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "                Exercising transition without accessing lookahead... ")
                    resulting_hps = TakeHypotheticalActionOnHPS_(hps, ParseStackTreeNode_::Type(transition.m_type), transition.m_data_index);
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << '\n')
                }
                // Otherwise, the lookahead must be accessed.
                else
                {
                    Token::Id lookahead_token_id = hps.LookaheadTokenId(*this);
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "                Lookahead is " << Token(lookahead_token_id) << '\n')
                    if (transition.m_token_index == lookahead_token_id)
                    {
                        TRISON_CPP_DEBUG_CODE_(                        *DebugSpewStream() << "CalcParser: " << "                Exercising transition with access to lookahead... ")
                        resulting_hps = TakeHypotheticalActionOnHPS_(hps, ParseStackTreeNode_::Type(transition.m_type), transition.m_data_index);
                        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << '\n')
                    }
                }
                if (resulting_hps != NULL)
                    m_npda_.m_new_hps_queue_.push_back(resulting_hps);
            }
        }
    }

    // Take new hps-es and clear old ones.
    for (HPSQueue_::iterator hps_it = m_npda_.m_hps_queue_.begin(), hps_it_end = m_npda_.m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseStackTreeNode_ *hps = *hps_it;
        if (hps != NULL)
        {
            hps->RemoveFromParent();
            delete hps;
        }
    }
    m_npda_.m_hps_queue_.clear();
    std::swap(m_npda_.m_hps_queue_, m_npda_.m_new_hps_queue_);
    assert(m_npda_.m_new_hps_queue_.empty());
}

CalcParser::Token::Data CalcParser::ExecuteReductionRule_ (std::uint32_t const rule_index_, RealizedBranchStack_ &stack) throw()
{
    assert(rule_index_ < ms_rule_count_);
    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Executing reduction rule " << rule_index_ << '\n')
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return std::shared_ptr<Ast::Base>();

        case 0:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> st(stack[stack.size()-2].m_token.m_data);

#line 179 "CalcParser.trison"

        std::cout << "stmt_then_end <- stmt %end\n";
        return st;
    
#line 924 "CalcParser.cpp"
            break;
        }

        case 1:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());

#line 185 "CalcParser.trison"

        std::cout << "stmt_then_end <- %error[%end] %end\n";
        return Ast::error_dummy();
    
#line 937 "CalcParser.cpp"
            break;
        }

        case 2:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> ex(stack[stack.size()-2].m_token.m_data);

#line 194 "CalcParser.trison"

        std::cout << "stmt <- expr ';'\n";
        return ex;
    
#line 951 "CalcParser.cpp"
            break;
        }

        case 3:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());

#line 200 "CalcParser.trison"

        std::cout << "stmt <- %error ';'\n";
        return Ast::error_dummy();
    
#line 964 "CalcParser.cpp"
            break;
        }

        case 4:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> e(stack[stack.size()-2].m_token.m_data);

#line 209 "CalcParser.trison"

        std::cout << "expr <- '(' expr ')'\n";
        return e;
    
#line 978 "CalcParser.cpp"
            break;
        }

        case 5:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());

#line 215 "CalcParser.trison"

        std::cout << "expr <- '(' %error[')'] ')'\n";
        return Ast::error_dummy();
    
#line 991 "CalcParser.cpp"
            break;
        }

        case 6:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());

#line 225 "CalcParser.trison"

        std::cout << "expr <- '(' %error[%end | ';']\n";
        return Ast::error_dummy();
    
#line 1004 "CalcParser.cpp"
            break;
        }

        case 7:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> num(stack[stack.size()-1].m_token.m_data);

#line 231 "CalcParser.trison"

        std::cout << "expr <- NUM(" << num << ")\n";
        return num;
    
#line 1018 "CalcParser.cpp"
            break;
        }

        case 8:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-3].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 237 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '+' expr(" << rhs << ")\n";
        return base_operator("+", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1033 "CalcParser.cpp"
            break;
        }

        case 9:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-6].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 243 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '+' '+' '+' '+' expr(" << rhs << ")\n";
        return base_operator("++++", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1048 "CalcParser.cpp"
            break;
        }

        case 10:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-5].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 249 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '+' '+' '+' expr(" << rhs << ")\n";
        return base_operator("+++", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1063 "CalcParser.cpp"
            break;
        }

        case 11:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-4].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 255 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '+' '+' expr(" << rhs << ")\n";
        return base_operator("++", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1078 "CalcParser.cpp"
            break;
        }

        case 12:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-3].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 261 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '*' expr(" << rhs << ")\n";
        return base_operator("*", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1093 "CalcParser.cpp"
            break;
        }

        case 13:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-3].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 267 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '?' expr(" << rhs << ")\n";
        return base_operator("?", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1108 "CalcParser.cpp"
            break;
        }

        case 14:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> op(stack[stack.size()-1].m_token.m_data);

#line 273 "CalcParser.trison"

        std::cout << "expr <- '-' expr(" << op << ")\n";
        return base_operator("-", BaseOperator::ChildNodes{op});
    
#line 1122 "CalcParser.cpp"
            break;
        }

        case 15:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
            std::shared_ptr<Ast::Base> lhs(stack[stack.size()-3].m_token.m_data);
            std::shared_ptr<Ast::Base> rhs(stack[stack.size()-1].m_token.m_data);

#line 279 "CalcParser.trison"

        std::cout << "expr <- expr(" << lhs << ") '^' expr(" << rhs << ")\n";
        return base_operator("^", BaseOperator::ChildNodes{lhs, rhs});
    
#line 1137 "CalcParser.cpp"
            break;
        }

    }

    assert(false && "no value returned from reduction rule code block");
    return std::shared_ptr<Ast::Base>();
}

void CalcParser::ThrowAwayRealizedBranchStackElement_ (RealizedBranchStackElement_ &stack_element) throw()
{
    TRISON_CPP_DEBUG_CODE_(
        *DebugSpewStream() << "CalcParser: " << "Executing throw-away-token actions on token " << stack_element.m_token << " corresponding to stack element with npda state set ( ";
        for (StateVector_::const_iterator it = stack_element.m_npda_state_vector.begin(),
                                            it_end = stack_element.m_npda_state_vector.end();
                it != it_end;
                ++it)
        {
            std::uint32_t npda_state = *it;
            *DebugSpewStream() << npda_state << ' ';
        }
        *DebugSpewStream() << ")\n";
    )

    ThrowAwayTokenData_(stack_element.m_token.m_data);
}

void CalcParser::PrintParserStatus_ (std::ostream &out) const
{
    assert(m_npda_.m_root_ != NULL);

    out << "CalcParser: " << "Realized state stack (bottom to top) is:\n";
    for (std::size_t i = 0; i < m_npda_.m_realized_stack_.size(); ++i)
    {
        RealizedBranchStackElement_ const &stack_element = m_npda_.m_realized_stack_[i];
        out << "CalcParser: " << "    ( ";
        for (StateVector_::const_iterator it = stack_element.m_npda_state_vector.begin(),
                                          it_end = stack_element.m_npda_state_vector.end();
             it != it_end;
             ++it)
        {
            std::uint32_t npda_state = *it;
            out << npda_state << ' ';
        }
        out << ")\n";
    }
    out << "CalcParser: " << "Max realized lookahead count (so far) is:\n";
    out << "CalcParser: " << "    " << m_npda_.MaxRealizedLookaheadQueueSize() << '\n';
    out << "CalcParser: " << "Has-encountered-error-state (so far) is :\n";
    out << "CalcParser: " << "    " << (m_npda_.HasEncounteredErrorState() ? "true" : "false") << '\n';
    out << "CalcParser: " << "Realized stack tokens then realized lookahead queue is:\n";
    out << "CalcParser: " << "    ";
    for (std::size_t i = 1; i < m_npda_.m_realized_stack_.size(); ++i)
        out << m_npda_.m_realized_stack_[i].m_token << ' ';
    out << ". ";
    for (std::size_t i = 0; i < m_npda_.m_realized_lookahead_queue_.size(); ++i)
        out << m_npda_.m_realized_lookahead_queue_[i] << ' ';
    out << '\n';

    m_npda_.m_root_->Print(out, *this, "CalcParser: ");
    out << "CalcParser: " << '\n';

    out << "CalcParser: " << "HPS queue:\n";
    for (HPSQueue_::const_iterator it = m_npda_.m_hps_queue_.begin(), it_end = m_npda_.m_hps_queue_.end(); it != it_end; ++it)
    {
        ParseStackTreeNode_ *hps = *it;
        assert(hps != NULL);
        hps->Print(out, *this, "CalcParser: ", 1);
    }
}

char const *CalcParser::ParseStackTreeNode_::AsString (Type type)
{
    static char const *const LOOKUP_TABLE[COUNT_] =
    {
        "ROOT",
        "RETURN",
        "REDUCE",
        "SHIFT",
        "INSERT_LOOKAHEAD_ERROR",
        "DISCARD_LOOKAHEAD",
        "POP_STACK",
        "HPS"
    };
    assert(std::uint32_t(type) < COUNT_);
    return LOOKUP_TABLE[std::uint32_t(type)];
}


bool CalcParser::ParseStackTreeNode_::ParseStackTreeNodeOrder::operator () (CalcParser::ParseStackTreeNode_ const *lhs, CalcParser::ParseStackTreeNode_ const *rhs) const
{
    assert(lhs != NULL);
    assert(rhs != NULL);
    assert(lhs->m_spec.m_type == rhs->m_spec.m_type); // ParseStackTreeNodeSet should contain only nodes of the same type.
    // for HPS, their contents must be compared.
    if (lhs->m_spec.m_type == HPS)
    {
        assert(lhs->m_child_nodes.empty());
        assert(rhs->m_child_nodes.empty());
        // hps-es are equal if their m_realized_lookahead_cursor and m_hypothetical_lookahead_token_id_queue members are.
        if (lhs->m_realized_lookahead_cursor != rhs->m_realized_lookahead_cursor)
            return lhs->m_realized_lookahead_cursor < rhs->m_realized_lookahead_cursor;
        else if (lhs->m_stack != rhs->m_stack)
            return std::lexicographical_compare(
                lhs->m_stack.begin(), lhs->m_stack.end(),
                rhs->m_stack.begin(), rhs->m_stack.end(),
                CompareHypotheticalBranchStackElement
            );
        else
            return std::lexicographical_compare(
                lhs->m_hypothetical_lookahead_token_id_queue.begin(), lhs->m_hypothetical_lookahead_token_id_queue.end(),
                rhs->m_hypothetical_lookahead_token_id_queue.begin(), rhs->m_hypothetical_lookahead_token_id_queue.end(),
                CompareTokenId
            );
    }
    // For REDUCE, their contents must be compared.
    else if (lhs->m_spec.m_type == REDUCE)
    {
        // m_single_data contains the reduction rule index.
        Rule_ const &lhs_rule = ms_rule_table_[lhs->m_spec.m_single_data];
        Rule_ const &rhs_rule = ms_rule_table_[rhs->m_spec.m_single_data];
        // Sort first by rule precedence, then by rule index (lower has higher priority).
        if (ms_precedence_table_[lhs_rule.m_precedence_index].m_level != ms_precedence_table_[rhs_rule.m_precedence_index].m_level)
            return ms_precedence_table_[lhs_rule.m_precedence_index].m_level > ms_precedence_table_[rhs_rule.m_precedence_index].m_level;
        else // Sort based on rule index.
            return lhs->m_spec.m_single_data < rhs->m_spec.m_single_data;
    }
    // Otherwise just use pointer value.
    else
        return lhs < rhs;
}

CalcParser::ParseStackTreeNode_::~ParseStackTreeNode_ ()
{
    // TODO: figure out if stack element tokens should be thrown away
    // TODO: figure out if local lookahead queue tokens should be thrown away
    // TODO: are they actually uninitialized (default value)?
    for (ChildMap::iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet &child_node_set = it->second;
        for (ParseStackTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseStackTreeNode_ *child = *child_it;
            assert(child != NULL);
            assert(child->m_parent_node == this);
            delete child;
        }
        child_node_set.clear(); // not strictly necessary, but is cleaner.
    }
}

bool CalcParser::ParseStackTreeNode_::HasTrunkChild () const
{
    if (m_spec.m_type != ROOT || m_child_nodes.size() != 1)
        return false;
    ParseStackTreeNodeSet const &single_type_child_node_set = m_child_nodes.begin()->second;
    if (single_type_child_node_set.size() != 1)
        return false;
    ParseStackTreeNode_ *single_child = *single_type_child_node_set.begin();
    assert(single_child != NULL);
    assert(single_child->m_spec.m_type != ROOT);
    return single_child->m_spec.m_type != HPS;
}

CalcParser::ParseStackTreeNode_ *CalcParser::ParseStackTreeNode_::PopTrunkChild ()
{
    assert(HasTrunkChild());
    ParseStackTreeNode_ *trunk_child = *m_child_nodes.begin()->second.begin();
    assert(trunk_child != NULL);
    assert(trunk_child->m_parent_node == this);
    // Reassign the children of the trunk child to this node (root).
    m_child_nodes = trunk_child->m_child_nodes;
    trunk_child->m_child_nodes.clear();
    // Set the reassigned child nodes' parent to be this node (root).
    for (ChildMap::iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
    {
        ParseStackTreeNodeSet &child_node_set = child_map_it->second;
        for (ParseStackTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseStackTreeNode_ *child = *child_it;
            assert(child != NULL);
            child->m_parent_node = this;
        }
    }
    trunk_child->m_parent_node = NULL;
    return trunk_child;
}

bool CalcParser::ParseStackTreeNode_::HasExactlyOneChild () const
{
    return m_child_nodes.size() == 1 && m_child_nodes.begin()->second.size() == 1;
}

CalcParser::ParseStackTreeNode_ *CalcParser::ParseStackTreeNode_::BranchRoot ()
{
    ParseStackTreeNode_ *node = this;
    while (node->m_parent_node != NULL && node->m_parent_node->HasExactlyOneChild())
    {
        node = node->m_parent_node;
        assert(node->m_spec.m_type != HPS);
    }
    return node;
}

CalcParser::Token::Id CalcParser::ParseStackTreeNode_::LookaheadTokenId (CalcParser &parser) const
{
    if (m_hypothetical_lookahead_token_id_queue.empty())
        return parser.Lookahead_(m_realized_lookahead_cursor).m_id;
    else
        return m_hypothetical_lookahead_token_id_queue.front();
}

bool CalcParser::ParseStackTreeNode_::IsBlockedHPS () const
{
    assert(m_spec.m_type == HPS);
    if (m_parent_node == NULL)
        return false;
    switch (m_parent_node->m_spec.m_type)
    {
        case RETURN:
        case REDUCE:
        case POP_STACK: return true;

        default:        return false;
    }
}

CalcParser::ParseStackTreeNode_::PrecedenceLevelRange CalcParser::ParseStackTreeNode_::ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const
{
    if (m_spec.m_type == HPS)
    {
        // Need to look back at the rule of the (current_child_depth-1)th ancestor of this node in order
        // to get the correct rule precedence, because that's where the conflict occurred.
        assert(!m_stack.empty());
        assert(m_stack.size() >= current_child_depth);
//         std::uint32_t state_index = m_stack.back().m_state_index;
        std::uint32_t state_index = m_stack[m_stack.size()-(current_child_depth-1)].m_state_index;
        assert(state_index < ms_state_count_);
        State_ const &state = ms_state_table_[state_index];
        assert(state.m_associated_rule_index < ms_rule_count_);
        Rule_ const &associated_rule = ms_rule_table_[state.m_associated_rule_index];
        assert(associated_rule.m_precedence_index < ms_precedence_count_);
        Precedence_ const &rule_precedence = ms_precedence_table_[associated_rule.m_precedence_index];
        return PrecedenceLevelRange(rule_precedence.m_level, rule_precedence.m_level);
    }
    else if (m_spec.m_type == REDUCE)
    {
        std::uint32_t reduction_rule_index = m_spec.m_single_data;
        Rule_ const &reduction_rule = ms_rule_table_[reduction_rule_index];
        assert(reduction_rule.m_precedence_index < ms_precedence_count_);
        Precedence_ const &rule_precedence = ms_precedence_table_[reduction_rule.m_precedence_index];
        return PrecedenceLevelRange(rule_precedence.m_level, rule_precedence.m_level);
    }
    else if (m_spec.m_type == SHIFT)
    {
        PrecedenceLevelRange retval(std::numeric_limits<std::int32_t>::max(), std::numeric_limits<std::int32_t>::min());
        // The range is the smallest range encompassing the range of each child node.
        for (ChildMap::const_iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
        {
            ParseStackTreeNodeSet const &child_node_set = child_map_it->second;
            for (ParseStackTreeNodeSet::const_iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
            {
                assert(*child_it != NULL);
                ParseStackTreeNode_ const &child = **child_it;
                PrecedenceLevelRange child_precedence_level_range(child.ComputePrecedenceLevelRange(current_child_depth+1));
                retval.first = std::min(retval.first, child_precedence_level_range.first);
                retval.second = std::max(retval.second, child_precedence_level_range.second);
            }
        }
        assert(retval.first <= retval.second);
        return retval;
    }
    else
    {
        // TODO: Probably need to do something to determine if this can't happen or prevent it.
        assert(false);
        return PrecedenceLevelRange(0, 0);
    }
}

bool CalcParser::ParseStackTreeNode_::HasShiftReduceConflict (ParseStackTreeNode_ *&shift, ParseStackTreeNode_ *&reduce)
{
    ChildMap::iterator shift_children_it = m_child_nodes.find(Spec(SHIFT));
    ChildMap::iterator reduce_children_it = m_child_nodes.find(Spec(REDUCE));
    if (shift_children_it == m_child_nodes.end() || reduce_children_it == m_child_nodes.end())
        return false;

    ParseStackTreeNodeSet &shift_children = shift_children_it->second;
    ParseStackTreeNodeSet &reduce_children = reduce_children_it->second;
    assert(shift_children.size() == 1);
    assert(reduce_children.size() == 1);

    shift = *shift_children.begin();
    reduce = *reduce_children.begin();
    return true;
}

void CalcParser::ParseStackTreeNode_::AddChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == NULL);
    assert(child->m_spec.m_type != ROOT);
    m_child_nodes[child->m_spec].insert(child);
    child->m_parent_node = this;

    // If this node is SHIFT and the child is HPS, then add the child's NPDA state to this node's m_npda_state_set.
    // This is the only situation in which m_npda_state_set is added to.
    if (m_spec.m_type == SHIFT && child->m_spec.m_type == HPS)
    {
        assert(!child->m_stack.empty());
        std::uint32_t child_npda_state_index = child->m_stack.back().m_state_index;
        assert(m_npda_state_set.find(child_npda_state_index) == m_npda_state_set.end() && "NPDA state should not already be in the set");
        m_npda_state_set.insert(child_npda_state_index);
    }
}

void CalcParser::ParseStackTreeNode_::RemoveChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == this);
    assert(HasChildrenHavingSpec(child->m_spec));
    m_child_nodes[child->m_spec].erase(child);
    if (m_child_nodes[child->m_spec].empty())
        m_child_nodes.erase(child->m_spec);
    child->m_parent_node = NULL;
}

void CalcParser::ParseStackTreeNode_::RemoveFromParent ()
{
    assert(m_parent_node != NULL);
    m_parent_node->RemoveChild(this);
}

void CalcParser::ParseStackTreeNode_::NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const
{
    if (m_spec.m_type == HPS)
    {
        // NOTE: This is a linear search, which is not as efficient as a different way of handling this.
        HPSQueue_::iterator it = std::find(hps_queue.begin(), hps_queue.end(), this);
        if (it != hps_queue.end())
            *it = NULL;
    }
    for (ChildMap::const_iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
    {
        ParseStackTreeNodeSet const &child_node_set = child_map_it->second;
        for (ParseStackTreeNodeSet::const_iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            assert(*child_it != NULL);
            ParseStackTreeNode_ const &child = **child_it;
            child.NullifyHPSNodeDescendantsInHPSQueue(hps_queue);
        }
    }
}

CalcParser::ParseStackTreeNode_ *CalcParser::ParseStackTreeNode_::CloneLeafNode () const
{
    ParseStackTreeNode_ *retval = new ParseStackTreeNode_(m_spec);
    CloneLeafNodeInto(*retval);
    return retval;
}

void CalcParser::ParseStackTreeNode_::CloneLeafNodeInto (CalcParser::ParseStackTreeNode_ &orphan_target) const
{
    assert(orphan_target.m_parent_node == NULL);
    assert(m_child_nodes.empty());
    orphan_target.m_spec                                    = m_spec;
    orphan_target.m_npda_state_set                          = m_npda_state_set;
    orphan_target.m_stack                                   = m_stack;
    orphan_target.m_hypothetical_lookahead_token_id_queue   = m_hypothetical_lookahead_token_id_queue;
    orphan_target.m_realized_lookahead_cursor               = m_realized_lookahead_cursor;
}

void CalcParser::ParseStackTreeNode_::Print (std::ostream &out, CalcParser const &parser, std::string const &prefix, std::uint32_t indent_level) const
{
    out << prefix;
    for (std::uint32_t i = 0; i < indent_level; ++i)
        out << "    ";
    out << AsString(m_spec.m_type);
    if (m_spec.m_type == HPS)
        out << (IsBlockedHPS() ? " (    blocked)" : " (non-blocked)");
    switch (m_spec.m_type)
    {
        case REDUCE:    out << " rule " << m_spec.m_single_data << "; " << ms_rule_table_[m_spec.m_single_data].m_description;  break;
        case POP_STACK: out << ' ' << m_spec.m_single_data << " time(s)";                                                       break;
        default:                                                                                                                break;
    }
    // assert(!m_stack.empty());
    // out << ' ' << this << ", parent = " << m_parent_node << ' ' << ms_state_table_[m_stack.back()].m_description << ' ';
    if (!m_stack.empty())
        out << ' ' << ms_state_table_[m_stack.back().m_state_index].m_description << ' ';
    if (m_spec.m_type == HPS)
    {
        out << "    (";
        for (std::size_t i = 0; i < m_stack.size(); ++i)
        {
            out << m_stack[i].m_state_index;
            if (i+1 < m_stack.size())
                out << ' ';
        }
        out << "); ";
        for (std::size_t i = 1; i < m_stack.size(); ++i)
            out << ms_token_name_table_[m_stack[i].m_token_id] << ' ';
        out << ". ";
        for (std::size_t i = 0; i < m_hypothetical_lookahead_token_id_queue.size(); ++i)
            out << ms_token_name_table_[m_hypothetical_lookahead_token_id_queue[i]] << ' ';
        for (std::size_t i = m_realized_lookahead_cursor; i < parser.m_npda_.m_realized_lookahead_queue_.size(); ++i)
            out << ms_token_name_table_[parser.m_npda_.m_realized_lookahead_queue_[i].m_id] << ' ';
    }
    out << '\n';

    // Print children recursively with higher indent level
    for (ChildMap::const_iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet const &child_node_set = it->second;
        for (ParseStackTreeNodeSet::const_iterator set_it = child_node_set.begin(), set_it_end = child_node_set.end(); set_it != set_it_end; ++set_it)
            (*set_it)->Print(out, parser, prefix, indent_level+1);
    }
}

CalcParser::Token const &CalcParser::Lookahead_ (TokenQueue_::size_type index) throw()
{
    while (index >= m_npda_.m_realized_lookahead_queue_.size())
    {
        // This does not require updating the hps-es' m_realized_lookahead_cursor.
        m_npda_.PushBackRealizedLookahead(Scan_());

        TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "Pushed " << m_npda_.m_realized_lookahead_queue_.back() << " onto back of lookahead queue\n")
    }
    return m_npda_.m_realized_lookahead_queue_[index];
}

CalcParser::ParseStackTreeNode_ *CalcParser::TakeHypotheticalActionOnHPS_ (ParseStackTreeNode_ const &hps, ParseStackTreeNode_::Type action_type, std::uint32_t action_data)
{
    // TODO: replace individual arguments action_type, action_data with ParseStackTreeNode_::Spec and just modify that struct below where it needs it.
    assert(hps.m_spec.m_type == ParseStackTreeNode_::HPS && "Only a HPS type node can take an action");
    assert(hps.m_parent_node != NULL);

    // TODO: Once enough testing/verification is done, this comment and the commented-out early check code
    // should be removed.
    //
    // Because the parse tree will be recreated when the trunk action is POP_STACK, there's no need to
    // early out if the stack will be popped empty.

//     // Early check for if the stack would be popped empty, in which case, don't create the new hps.
//     if (action_type == ParseStackTreeNode_::POP_STACK && hps.m_stack.size() <= 1)
//     {
//         return NULL;
//     }

    ParseStackTreeNode_ *new_hps = NULL;

    switch (action_type)
    {
        case ParseStackTreeNode_::ROOT: {
            assert(false && "ParseStackTreeNode_::ROOT is an invalid action type.");
            break;
        }
        case ParseStackTreeNode_::RETURN: {
            new_hps = hps.CloneLeafNode();
            break;
        }
        case ParseStackTreeNode_::REDUCE: {
            // Execute the appropriate rule on the top tokens in the stack
            std::uint32_t const &rule_index = action_data;
            Rule_ const &rule = ms_rule_table_[rule_index];

            // Avoid creating the new hps altogether if it won't be added due to a REDUCE/REDUCE conflict.
            ParseStackTreeNode_ *existing_reduce_action_node = NULL;
            ParseStackTreeNode_ *reduce_hps = NULL;
            ParseStackTreeNode_::Spec action_spec(action_type, action_data);
            if (hps.m_parent_node->HasChildrenHavingSpec(action_spec)) // Check for an existing REDUCE action
            {
                // This is a REDUCE/REDUCE conflict
                TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "CalcParser: " << "TakeHypotheticalActionOnHPS_ - REDUCE/REDUCE conflict encountered ... ")

                ParseStackTreeNode_::ParseStackTreeNodeSet &reduce_node_set = hps.m_parent_node->ChildrenHavingSpec(action_spec);
                assert(reduce_node_set.size() == 1);
                existing_reduce_action_node = *reduce_node_set.begin();
                assert(existing_reduce_action_node != NULL);
                // If the new REDUCE action beats the existing one in a conflict, just replace the existing one
                // (replacement instead of creating a new one and deleting the old is an optimization which also
                // avoids an annoying traversal through m_npda_.m_hps_queue_).
                // NOTE: This depends on the fact that a REDUCE node has exactly one HPS child,
                // which is what these three asserts check.  TODO: maybe make abstractions for these sorts of checks.
                assert(existing_reduce_action_node->m_child_nodes.size() == 1);
                assert(existing_reduce_action_node->m_child_nodes.begin()->second.size() == 1);
                assert((*existing_reduce_action_node->m_child_nodes.begin()->second.begin())->m_spec.m_type == ParseStackTreeNode_::HPS);
                if (CompareRuleByPrecedence(action_data, existing_reduce_action_node->m_spec.m_single_data))
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "resolving in favor of new hps.\n")

                    reduce_hps = *existing_reduce_action_node->m_child_nodes.begin()->second.begin();
                    assert(reduce_hps != NULL);

                    // Remove the nodes from the ParseStackTreeNode_ tree.
                    assert(existing_reduce_action_node != NULL);
                    existing_reduce_action_node->RemoveFromParent();
                    reduce_hps->RemoveFromParent();
                    // Modify the nodes.
                    existing_reduce_action_node->m_spec = action_spec; // Replace with the winning reduction rule Spec.
                    hps.CloneLeafNodeInto(*reduce_hps); // NOTE: This modifies the existing hps, so no update of m_npda_.m_hps_queue_ is necessary.
                    // Re-add them to the ParseStackTreeNode_ tree.
                    existing_reduce_action_node->AddChild(reduce_hps);
                    hps.m_parent_node->AddChild(existing_reduce_action_node);
                }
                else
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "resolving in favor of existing hps.\n")
                }
            }
            else
            {
                new_hps = hps.CloneLeafNode();
                reduce_hps = new_hps;
            }

            if (reduce_hps != NULL)
            {
                // Pop those stack tokens.
                // Computing the number of elements to pop is necessary because we don't guarantee that
                // the number of pops is not greater than the stack size (due to destruction and recreation
                // of parse tree upon REDUCE and POP_STACK trunk actions).
                std::size_t actual_pop_count = std::min(std::size_t(rule.m_token_count), reduce_hps->m_stack.size());
                reduce_hps->m_stack.resize(reduce_hps->m_stack.size() - actual_pop_count);
                // Push the reduced nonterminal token data onto the front of the lookahead queue
                reduce_hps->m_hypothetical_lookahead_token_id_queue.push_front(rule.m_reduction_nonterminal_token_id);
            }

            break;
        }
        case ParseStackTreeNode_::SHIFT: {
            // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
            std::uint32_t const &state_index = action_data;
            // TODO: probably make "Shift" method for ParseStackTreeNode_ to do all this bookkeeping and parallel LookaheadTokenId tracking.
            new_hps = hps.CloneLeafNode();
            new_hps->m_stack.push_back(HypotheticalBranchStackElement_(state_index, new_hps->LookaheadTokenId(*this)));
            action_data = ParseStackTreeNode_::UNUSED_DATA; // SHIFT action doesn't store the state, the HPS children do.
            if (new_hps->m_hypothetical_lookahead_token_id_queue.empty())
                ++new_hps->m_realized_lookahead_cursor;
            else
                new_hps->m_hypothetical_lookahead_token_id_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::INSERT_LOOKAHEAD_ERROR: {
            new_hps = hps.CloneLeafNode();
            new_hps->m_hypothetical_lookahead_token_id_queue.push_front(Terminal::ERROR_);
            break;
        }
        case ParseStackTreeNode_::DISCARD_LOOKAHEAD: {
            new_hps = hps.CloneLeafNode();
            if (new_hps->m_hypothetical_lookahead_token_id_queue.empty())
                ++new_hps->m_realized_lookahead_cursor;
            else
                new_hps->m_hypothetical_lookahead_token_id_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::POP_STACK: {
            // TODO: make separate action nodes for each pop, instead of using action data.
            std::uint32_t const &pop_count = action_data;
            new_hps = hps.CloneLeafNode();
            assert(new_hps->m_stack.size() >= pop_count);
            for (std::uint32_t i = 0; i < pop_count; ++i)
                new_hps->m_stack.pop_back();
            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "creating HPS to be child of POP_STACK node... ")
            break;
        }
        case ParseStackTreeNode_::HPS: {
            assert(false && "ParseStackTreeNode_::HPS is an invalid action type.");
            break;
        }
        default: {
            assert(false && "invalid ParseStackTreeNode_::Type");
            break;
        }
    }

    if (new_hps != NULL)
    {
        assert(new_hps->m_parent_node == NULL);

        ParseStackTreeNode_ *action_node = NULL;

        // Ensure the action node exists, creating it if necessary.
        ParseStackTreeNode_::Spec action_spec(action_type, action_data);
        if (hps.m_parent_node->HasChildrenHavingSpec(action_spec))
        {
            ParseStackTreeNode_::ParseStackTreeNodeSet &children_of_action_type = hps.m_parent_node->ChildrenHavingSpec(action_spec);
            assert(children_of_action_type.size() == 1);
            action_node = *children_of_action_type.begin();
            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "using existing action node of type " << ParseStackTreeNode_::AsString(action_spec.m_type) << "... ")

            // If the new hps already exists (can only happen as a child of POP_STACK), then don't add it.
            if (action_type == ParseStackTreeNode_::POP_STACK && action_node->HasChildrenHavingSpec(new_hps->m_spec))
            {
                ParseStackTreeNode_::ParseStackTreeNodeSet const &child_hps_set = action_node->ChildrenHavingSpec(new_hps->m_spec);
                if (child_hps_set.find(new_hps) != child_hps_set.end())
                {
                    TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "not adding duplicate HPS as child of POP_STACK node... ")
                    delete new_hps;
                    new_hps = NULL;
                }
            }
        }
        else
        {
            TRISON_CPP_DEBUG_CODE_(*DebugSpewStream() << "creating new action node of type " << ParseStackTreeNode_::AsString(action_spec.m_type) << "... ")
            action_node = new ParseStackTreeNode_(action_spec);
            hps.m_parent_node->AddChild(action_node);
        }

        if (new_hps != NULL)
            action_node->AddChild(new_hps);
    }

    return new_hps;
}

CalcParser::Npda_::~Npda_ ()
{
    // TODO: figure out if realized stack and lookahead queue should have their tokens thrown away
    delete m_root_;
    m_root_ = NULL;
    m_hps_queue_.clear();
    m_new_hps_queue_.clear();
}

void CalcParser::Npda_::PopFrontRealizedLookahead ()
{
    assert(!m_realized_lookahead_queue_.empty());
    // Because the contents of m_npda_.m_realized_lookahead_queue_ are changing, and each hps's
    // m_realized_lookahead_cursor is an index into that queue, each must be updated.
    for (HPSQueue_::iterator hps_it = m_hps_queue_.begin(), hps_it_end = m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseStackTreeNode_ &hps = **hps_it;
        --hps.m_realized_lookahead_cursor;
    }
    m_realized_lookahead_queue_.pop_front();
}

void CalcParser::Npda_::PushFrontRealizedLookahead (CalcParser::Token const &lookahead)
{
    m_realized_lookahead_queue_.push_front(lookahead);
    // Because the contents of m_npda_.m_realized_lookahead_queue_ are changing, and each hps's
    // m_realized_lookahead_cursor is an index into that queue, each must be updated.
    for (HPSQueue_::iterator hps_it = m_hps_queue_.begin(), hps_it_end = m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
    {
        ParseStackTreeNode_ &hps = **hps_it;
        ++hps.m_realized_lookahead_cursor;
    }
    UpdateMaxRealizedLookaheadQueueSize();
}

void CalcParser::Npda_::PushBackRealizedLookahead (CalcParser::Token const &lookahead)
{
    m_realized_lookahead_queue_.push_back(lookahead);
    UpdateMaxRealizedLookaheadQueueSize();
}

void CalcParser::Npda_::RemoveBranchIfNotTrunk (ParseStackTreeNode_ *branch_node)
{
    // Find the most root-ward ancestor that is an only child.
    ParseStackTreeNode_ *branch_root = branch_node->BranchRoot();
    assert(branch_root != NULL);
    // Only do stuff if the branch isn't the trunk (i.e. only if its root isn't the tree root).
    if (branch_root->m_parent_node != NULL)
    {
        branch_root->RemoveFromParent();
        branch_node->NullifyHPSNodeDescendantsInHPSQueue(m_hps_queue_);
    }
}

void CalcParser::Npda_::UpdateMaxRealizedLookaheadQueueSize ()
{
    // m_realized_lookahead_cursor is an index into m_realized_lookahead_queue_ for each branch, so the number
    // of lookaheads depends on the cursor for each branch.
    for (HPSQueue_::iterator hps_it = m_hps_queue_.begin(), hps_it_end = m_hps_queue_.end(); hps_it != hps_it_end; ++hps_it)
    {
        // Skip nullified elements because they have been deleted.
        if (*hps_it == NULL)
            continue;

        ParseStackTreeNode_ &hps = **hps_it;
        // The actual lookaheads are offset by the realized lookahead cursor, because the tokens before
        // the realized lookahead cursor are ones we've seen already, and therefore don't contribute to
        // the actual lookahead count.
        assert(m_realized_lookahead_queue_.size() >= hps.m_realized_lookahead_cursor);
        std::size_t hps_actual_lookahead_count = m_realized_lookahead_queue_.size() - hps.m_realized_lookahead_cursor;
        m_max_realized_lookahead_queue_size_ = std::max(m_max_realized_lookahead_queue_size_, hps_actual_lookahead_count);
    }
}

bool CalcParser::CompareRuleByPrecedence (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index)
{
    if (ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level != ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level)
        return ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level > ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level;
    else
        return lhs_rule_index < rhs_rule_index;
}

CalcParser::StateVector_ const &CalcParser::EpsilonClosureOfState_ (std::uint32_t state_index)
{
    // This function implementation depends on there not being an epsilon transition cycle.

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<std::uint32_t,StateVector_> LookupTable;
    static LookupTable s_lookup_table;
    {
        LookupTable::iterator find_it = s_lookup_table.find(state_index);
        if (find_it != s_lookup_table.end())
            return find_it->second;
    }

    // This set collects the epsilon closure with no duplicates
    StateSet_ epsilon_closure_set;
    State_ const &state = ms_state_table_[state_index];
    bool state_has_non_epsilon_transitions = false;
    for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count;
         transition != transition_end;
         ++transition)
    {
        if (transition->m_type == Transition_::EPSILON)
        {
            StateVector_ const &sub_epsilon_closure = EpsilonClosureOfState_(transition->m_data_index);
            for (StateVector_::const_iterator it = sub_epsilon_closure.begin(), it_end = sub_epsilon_closure.end(); it != it_end; ++it)
                epsilon_closure_set.insert(*it);
        }
        else
            state_has_non_epsilon_transitions = true;
    }
    // The epsilon closure of a state includes itself if it has non-epsilon transitions
    if (state_has_non_epsilon_transitions)
        epsilon_closure_set.insert(state_index);

    // Add all the elements of epsilon_closure_set to the memoized entry.
    StateVector_ &epsilon_closure = s_lookup_table[state_index];
    epsilon_closure.reserve(epsilon_closure_set.size());
    for (StateSet_::const_iterator it = epsilon_closure_set.begin(), it_end = epsilon_closure_set.end(); it != it_end; ++it)
        epsilon_closure.push_back(*it);
    return epsilon_closure;
}

CalcParser::StateVector_ const &CalcParser::EpsilonClosureOfStateSet_ (StateSet_ const &state_set)
{
    // This function implementation depends on there not being an epsilon transition cycle.

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<StateSet_,StateVector_> LookupTable;
    static LookupTable s_lookup_table;
    {
        LookupTable::iterator find_it = s_lookup_table.find(state_set);
        if (find_it != s_lookup_table.end())
            return find_it->second;
    }

    // This set collects the epsilon closure with no duplicates
    StateSet_ epsilon_closure_set;

    for (StateSet_::const_iterator it = state_set.begin(), it_end = state_set.end(); it != it_end; ++it)
    {
        std::uint32_t state_index = *it;
        State_ const &state = ms_state_table_[state_index];
        bool state_has_non_epsilon_transitions = false;
        for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count;
            transition != transition_end;
            ++transition)
        {
            if (transition->m_type == Transition_::EPSILON)
            {
                StateVector_ const &sub_epsilon_closure = EpsilonClosureOfState_(transition->m_data_index);
                for (StateVector_::const_iterator it = sub_epsilon_closure.begin(), it_end = sub_epsilon_closure.end(); it != it_end; ++it)
                    epsilon_closure_set.insert(*it);
            }
            else
                state_has_non_epsilon_transitions = true;
        }
        // The epsilon closure of a state includes itself if it has non-epsilon transitions
        if (state_has_non_epsilon_transitions)
            epsilon_closure_set.insert(state_index);
    }

    // Add all the elements of epsilon_closure_set to the memoized entry.
    StateVector_ &epsilon_closure = s_lookup_table[state_set];
    epsilon_closure.reserve(epsilon_closure_set.size());
    for (StateSet_::const_iterator it = epsilon_closure_set.begin(), it_end = epsilon_closure_set.end(); it != it_end; ++it)
        epsilon_closure.push_back(*it);
    return epsilon_closure;
}

CalcParser::TransitionVector_ const &CalcParser::NonEpsilonTransitionsOfState_ (std::uint32_t state_index, std::uint32_t sorted_type_index)
{
    assert(0 <= sorted_type_index && sorted_type_index <= 3);

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::pair<std::uint32_t,std::uint32_t> KeyType;
    typedef std::map<KeyType,TransitionVector_> LookupTable;
    static LookupTable s_lookup_table;

    KeyType key(state_index, sorted_type_index);
    LookupTable::iterator it = s_lookup_table.find(key);
    if (it != s_lookup_table.end())
        return it->second;

    // TODO: probably don't need to memoize epsilon closures because non-epsilon transitions is memoized.
    TransitionSet_ non_epsilon_transition_set;
    StateVector_ const &epsilon_closure = EpsilonClosureOfState_(state_index);
    for (StateVector_::const_iterator it = epsilon_closure.begin(), it_end = epsilon_closure.end(); it != it_end; ++it)
    {
        State_ const &state = ms_state_table_[*it];
        for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count; transition != transition_end; ++transition)
        {
            std::uint32_t transition_sorted_type_index = Transition_::Order::SortedTypeIndex(Transition_::Type(transition->m_type));
            if (transition->m_type != Transition_::EPSILON && transition_sorted_type_index == sorted_type_index)
                non_epsilon_transition_set.insert(*transition);
        }
    }

    TransitionVector_ &non_epsilon_transitions = s_lookup_table[key];
    non_epsilon_transitions.reserve(non_epsilon_transition_set.size());
    for (TransitionSet_::const_iterator it = non_epsilon_transition_set.begin(), it_end = non_epsilon_transition_set.end(); it != it_end; ++it)
        non_epsilon_transitions.push_back(*it);
    return non_epsilon_transitions;
}

CalcParser::Precedence_ const CalcParser::ms_precedence_table_[] =
{
    { 0, 0, "DEFAULT_" },
    { 1, 0, "LOWEST" },
    { 2, 0, "LOW" },
    { 3, 0, "ADDITIVE" },
    { 4, 0, "MULTIPLICATIVE" },
    { 5, 1, "QUESTION" },
    { 6, 2, "UNARY" },
    { 7, 2, "EXPONENTIATION" },
    { 8, 0, "HIGHEST" }
};

std::size_t const CalcParser::ms_precedence_count_ = sizeof(CalcParser::ms_precedence_table_) / sizeof(*CalcParser::ms_precedence_table_);

CalcParser::Rule_ const CalcParser::ms_rule_table_[] =
{
    { CalcParser::Nonterminal::stmt_then_end, 2, 0, "stmt_then_end <- stmt END_" },
    { CalcParser::Nonterminal::stmt_then_end, 2, 0, "stmt_then_end <- ERROR_ END_" },
    { CalcParser::Nonterminal::stmt, 2, 0, "stmt <- expr ';'" },
    { CalcParser::Nonterminal::stmt, 2, 0, "stmt <- ERROR_ ';'" },
    { CalcParser::Nonterminal::expr, 3, 0, "expr <- '(' expr ')'" },
    { CalcParser::Nonterminal::expr, 3, 0, "expr <- '(' ERROR_ ')'" },
    { CalcParser::Nonterminal::expr, 2, 0, "expr <- '(' ERROR_" },
    { CalcParser::Nonterminal::expr, 1, 0, "expr <- NUM" },
    { CalcParser::Nonterminal::expr, 3, 3, "expr <- expr '+' expr" },
    { CalcParser::Nonterminal::expr, 6, 1, "expr <- expr '+' '+' '+' '+' expr" },
    { CalcParser::Nonterminal::expr, 5, 2, "expr <- expr '+' '+' '+' expr" },
    { CalcParser::Nonterminal::expr, 4, 8, "expr <- expr '+' '+' expr" },
    { CalcParser::Nonterminal::expr, 3, 4, "expr <- expr '*' expr" },
    { CalcParser::Nonterminal::expr, 3, 5, "expr <- expr '?' expr" },
    { CalcParser::Nonterminal::expr, 2, 6, "expr <- '-' expr" },
    { CalcParser::Nonterminal::expr, 3, 7, "expr <- expr '^' expr" }
};
std::size_t const CalcParser::ms_rule_count_ = sizeof(CalcParser::ms_rule_table_) / sizeof(*CalcParser::ms_rule_table_);

CalcParser::State_ const CalcParser::ms_state_table_[] =
{
    { 2, ms_transition_table_+0, 16, "START stmt_then_end" },
    { 1, ms_transition_table_+2, 16, "RETURN stmt_then_end" },
    { 2, ms_transition_table_+3, 16, "head of: stmt_then_end" },
    { 4, ms_transition_table_+5, 0, "rule 0: stmt_then_end <- . stmt END_" },
    { 3, ms_transition_table_+9, 0, "rule 0: stmt_then_end <- stmt . END_" },
    { 2, ms_transition_table_+12, 16, "START stmt" },
    { 1, ms_transition_table_+14, 16, "RETURN stmt" },
    { 2, ms_transition_table_+15, 16, "head of: stmt" },
    { 4, ms_transition_table_+17, 2, "rule 2: stmt <- . expr ';'" },
    { 3, ms_transition_table_+21, 2, "rule 2: stmt <- expr . ';'" },
    { 2, ms_transition_table_+24, 16, "START expr" },
    { 1, ms_transition_table_+26, 16, "RETURN expr" },
    { 12, ms_transition_table_+27, 16, "head of: expr" },
    { 3, ms_transition_table_+39, 4, "rule 4: expr <- . '(' expr ')'" },
    { 4, ms_transition_table_+42, 4, "rule 4: expr <- '(' . expr ')'" },
    { 3, ms_transition_table_+46, 4, "rule 4: expr <- '(' expr . ')'" },
    { 1, ms_transition_table_+49, 4, "rule 4: expr <- '(' expr ')' ." },
    { 3, ms_transition_table_+50, 5, "rule 5: expr <- . '(' ERROR_ ')'" },
    { 2, ms_transition_table_+53, 5, "rule 5: expr <- '(' . ERROR_ ')'" },
    { 3, ms_transition_table_+55, 5, "rule 5: expr <- '(' ERROR_ . ')'" },
    { 1, ms_transition_table_+58, 5, "rule 5: expr <- '(' ERROR_ ')' ." },
    { 3, ms_transition_table_+59, 6, "rule 6: expr <- . '(' ERROR_" },
    { 2, ms_transition_table_+62, 6, "rule 6: expr <- '(' . ERROR_" },
    { 3, ms_transition_table_+64, 6, "rule 6: expr <- '(' ERROR_ ." },
    { 3, ms_transition_table_+67, 7, "rule 7: expr <- . NUM" },
    { 1, ms_transition_table_+70, 7, "rule 7: expr <- NUM ." },
    { 3, ms_transition_table_+71, 8, "rule 8: expr <- . expr '+' expr" },
    { 3, ms_transition_table_+74, 8, "rule 8: expr <- expr . '+' expr" },
    { 4, ms_transition_table_+77, 8, "rule 8: expr <- expr '+' . expr" },
    { 1, ms_transition_table_+81, 8, "rule 8: expr <- expr '+' expr ." },
    { 3, ms_transition_table_+82, 9, "rule 9: expr <- . expr '+' '+' '+' '+' expr" },
    { 3, ms_transition_table_+85, 9, "rule 9: expr <- expr . '+' '+' '+' '+' expr" },
    { 3, ms_transition_table_+88, 9, "rule 9: expr <- expr '+' . '+' '+' '+' expr" },
    { 3, ms_transition_table_+91, 9, "rule 9: expr <- expr '+' '+' . '+' '+' expr" },
    { 3, ms_transition_table_+94, 9, "rule 9: expr <- expr '+' '+' '+' . '+' expr" },
    { 4, ms_transition_table_+97, 9, "rule 9: expr <- expr '+' '+' '+' '+' . expr" },
    { 1, ms_transition_table_+101, 9, "rule 9: expr <- expr '+' '+' '+' '+' expr ." },
    { 3, ms_transition_table_+102, 10, "rule 10: expr <- . expr '+' '+' '+' expr" },
    { 3, ms_transition_table_+105, 10, "rule 10: expr <- expr . '+' '+' '+' expr" },
    { 3, ms_transition_table_+108, 10, "rule 10: expr <- expr '+' . '+' '+' expr" },
    { 3, ms_transition_table_+111, 10, "rule 10: expr <- expr '+' '+' . '+' expr" },
    { 4, ms_transition_table_+114, 10, "rule 10: expr <- expr '+' '+' '+' . expr" },
    { 1, ms_transition_table_+118, 10, "rule 10: expr <- expr '+' '+' '+' expr ." },
    { 3, ms_transition_table_+119, 11, "rule 11: expr <- . expr '+' '+' expr" },
    { 3, ms_transition_table_+122, 11, "rule 11: expr <- expr . '+' '+' expr" },
    { 3, ms_transition_table_+125, 11, "rule 11: expr <- expr '+' . '+' expr" },
    { 4, ms_transition_table_+128, 11, "rule 11: expr <- expr '+' '+' . expr" },
    { 1, ms_transition_table_+132, 11, "rule 11: expr <- expr '+' '+' expr ." },
    { 3, ms_transition_table_+133, 12, "rule 12: expr <- . expr '*' expr" },
    { 3, ms_transition_table_+136, 12, "rule 12: expr <- expr . '*' expr" },
    { 4, ms_transition_table_+139, 12, "rule 12: expr <- expr '*' . expr" },
    { 1, ms_transition_table_+143, 12, "rule 12: expr <- expr '*' expr ." },
    { 3, ms_transition_table_+144, 13, "rule 13: expr <- . expr '?' expr" },
    { 3, ms_transition_table_+147, 13, "rule 13: expr <- expr . '?' expr" },
    { 4, ms_transition_table_+150, 13, "rule 13: expr <- expr '?' . expr" },
    { 1, ms_transition_table_+154, 13, "rule 13: expr <- expr '?' expr ." },
    { 3, ms_transition_table_+155, 14, "rule 14: expr <- . '-' expr" },
    { 4, ms_transition_table_+158, 14, "rule 14: expr <- '-' . expr" },
    { 1, ms_transition_table_+162, 14, "rule 14: expr <- '-' expr ." },
    { 3, ms_transition_table_+163, 15, "rule 15: expr <- . expr '^' expr" },
    { 3, ms_transition_table_+166, 15, "rule 15: expr <- expr . '^' expr" },
    { 4, ms_transition_table_+169, 15, "rule 15: expr <- expr '^' . expr" },
    { 1, ms_transition_table_+173, 15, "rule 15: expr <- expr '^' expr ." },
    { 1, ms_transition_table_+174, 2, "rule 2: stmt <- expr ';' ." },
    { 2, ms_transition_table_+175, 3, "rule 3: stmt <- . ERROR_ ';'" },
    { 3, ms_transition_table_+177, 3, "rule 3: stmt <- ERROR_ . ';'" },
    { 1, ms_transition_table_+180, 3, "rule 3: stmt <- ERROR_ ';' ." },
    { 1, ms_transition_table_+181, 0, "rule 0: stmt_then_end <- stmt END_ ." },
    { 2, ms_transition_table_+182, 1, "rule 1: stmt_then_end <- . ERROR_ END_" },
    { 3, ms_transition_table_+184, 1, "rule 1: stmt_then_end <- ERROR_ . END_" },
    { 1, ms_transition_table_+187, 1, "rule 1: stmt_then_end <- ERROR_ END_ ." }
};
std::size_t const CalcParser::ms_state_count_ = sizeof(CalcParser::ms_state_table_) / sizeof(*CalcParser::ms_state_table_);

CalcParser::Transition_ const CalcParser::ms_transition_table_[] =
{
    { CalcParser::Transition_::SHIFT, 260, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(2) },
    { CalcParser::Transition_::RETURN, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(3) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(68) },
    { CalcParser::Transition_::SHIFT, 261, std::uint32_t(4) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(7) },
    { CalcParser::Transition_::SHIFT, 256, std::uint32_t(67) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 261, std::uint32_t(6) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(7) },
    { CalcParser::Transition_::RETURN, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(8) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(64) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(9) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::SHIFT, 59, std::uint32_t(63) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(11) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::RETURN, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(13) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(17) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(21) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(24) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(26) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(30) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(37) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(43) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(48) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(52) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(56) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(59) },
    { CalcParser::Transition_::SHIFT, 40, std::uint32_t(14) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(15) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::SHIFT, 41, std::uint32_t(16) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(4) },
    { CalcParser::Transition_::SHIFT, 40, std::uint32_t(18) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 257, std::uint32_t(19) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::SHIFT, 41, std::uint32_t(20) },
    { CalcParser::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(5) },
    { CalcParser::Transition_::SHIFT, 40, std::uint32_t(22) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 257, std::uint32_t(23) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::REDUCE, 59, std::uint32_t(6) },
    { CalcParser::Transition_::REDUCE, 256, std::uint32_t(6) },
    { CalcParser::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::SHIFT, 258, std::uint32_t(25) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(7) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(27) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(28) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(29) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(8) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(31) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(32) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(33) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(34) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(35) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(36) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(9) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(38) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(39) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(40) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(41) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(42) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(10) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(44) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(45) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 43, std::uint32_t(46) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(47) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(11) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(49) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 42, std::uint32_t(50) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(51) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(12) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(53) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 63, std::uint32_t(54) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(55) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(13) },
    { CalcParser::Transition_::SHIFT, 45, std::uint32_t(57) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(58) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(14) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(60) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 94, std::uint32_t(61) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::SHIFT, 262, std::uint32_t(62) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 257, std::uint32_t(1) },
    { CalcParser::Transition_::EPSILON, 0, std::uint32_t(12) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(15) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(2) },
    { CalcParser::Transition_::SHIFT, 257, std::uint32_t(65) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::SHIFT, 59, std::uint32_t(66) },
    { CalcParser::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(3) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(0) },
    { CalcParser::Transition_::SHIFT, 257, std::uint32_t(69) },
    { CalcParser::Transition_::INSERT_LOOKAHEAD_ERROR, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::SHIFT, 256, std::uint32_t(70) },
    { CalcParser::Transition_::DISCARD_LOOKAHEAD, 0, std::uint32_t(-1) },
    { CalcParser::Transition_::POP_STACK, 256, std::uint32_t(2) },
    { CalcParser::Transition_::REDUCE, 0, std::uint32_t(1) }
};
std::size_t const CalcParser::ms_transition_count_ = sizeof(CalcParser::ms_transition_table_) / sizeof(*CalcParser::ms_transition_table_);

// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 76 "CalcParser.trison"

void CalcParser::AttachIstream (std::istream &in)
{
    assert(m_scanner != NULL);
    m_scanner->AttachIstream(in);
}
// FiLoc const &CalcParser::GetFiLoc () const
// {
//     assert(m_scanner != nullptr);
//     return m_scanner->GetFiLoc();
// }

bool CalcParser::ScannerDebugSpew () const
{
    return m_scanner->DebugSpew();
}

void CalcParser::ScannerDebugSpew (bool debug_spew)
{
    m_scanner->DebugSpew(debug_spew);
}

#line 2294 "CalcParser.cpp"
