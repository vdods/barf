design notes for trison error handling via state machine:

// ///////////////////////////////////////////////////////////////////////////
// design notes for trison error handling via state machine:
// ///////////////////////////////////////////////////////////////////////////

-   trison should disallow a reduction rule from having two %error terminals in a row
-   if return, reduce, or shift can't be done (including shifting a lookahead of ERROR_ pursuant
    to some parser rules), then this is a parse error.
    *   if
        ERROR_ has just been shifted (can be inferred from the current state, i.e. the top of the state stack)
        and
        the first lookahead token is not END_ (END_ can never be absorbed by ERROR_),
    *   then the first lookahead token should be thrown away; this can be thought of as the ERROR_ absorbing the lookahead.
    *   otherwise if
        the first lookahead token is ERROR_
        then pop the stack (throwing away the top stack token); this can be thought of as the pre-existing error
        panic pop sequence where the ERROR_ absorbs the stack tokens until it reaches a state which accepts ERROR_.
    *   otherwise ERROR_ should be inserted into the front of the lookahead queue.
-   this requires adding new parser actions, in addition to RETURN, REDUCE, SHIFT:
    *   DISCARD_LOOKAHEAD  - discard the first lookahead (and throw away token) (but don't alter the parser state stack).
    *   INSERT_LOOKAHEAD X - insert token X before the lookahead queue (maybe should be INSERT_ERROR_LOOKAHEAD, 
                             since that's all that it'll ever be used for)
    *   POP_STATE_STACK    - pop the top of the state stack (and throw away token)
-   the above requires that:
    *   if ERROR_ has just been shifted, then END_ should have a transition of
        ~   POP_STATE_STACK
    *   if ERROR_ has just been shifted, and there isn't a valid reduce rule, then the default action should be
        ~   DISCARD_LOOKAHEAD
        but does this screw up rules like `exp <- '(' %error`, where the %error should be able to suck up as many
        tokens as it needs?  One clear way `exp <- '(' %error` would reduce is if it encountered END_, because
        the error token couldn't absorb END_.  Having this rule read the rest of the file would make sense, because
        it could be used to mean there's no matching ')'.  %error should mostly be used to look for a stop-gap
        delimiter, such as ')', or '}', or ';', etc. in a rule like `exp <- '(' %error ')'`.  Perhaps the default
        action of DISCARD_LOOKAHEAD could supercede any reduce rules, and a rule like `exp <- '(' %error` could
        only be reduced by an explicit lookahead of END_.  Then a rule like `exp <- '(' %error` would be used
        as a last resort, and should have the lowest priority.
-   here's an idea: require that once END_ has been returned by the scanner, it's always returned by the scanner.
    e.g. the input
        "4+5"
    would return the token sequence
        INTEGER_LITERAL(4) '+' INTEGER_LITERAL(5) END_ END_ END_ END_ END_ ...
    then disallow %error from being the last token in a rule; one would have to explicitly use %end after %error.
    there would still need to be some restriction where ERROR_ can't absorb END_.
-   NOTE: In the NPDA, it's not necessary to store the [DPDA] state [set] in the global stack, since the branches
    already store this information.
-   IDEA: Memoize the DPDA while running the NPDA, and even cache the memoization to disk so that it can be
    loaded up again.  this would effectively turn the NPDA into a DPDA as it ran.  this should also be an option,
    because the cache could potentially be quite large (certain operations are exponential in the worst case, but
    those are likely for unrealistic grammars).

TODO
-   Prove theorem: it's only possible to have a REDUCE/DISCARD_LOOKAHEAD conflict in NPDA if ERROR_ was just shifted
    and END_ is the lookahead token.
    In this case, for simplicity, 

IMPORTANT NOTE
-   The conversion of NPDA to DPDA depends on the definition of a DPDA state.  In particular, a DPDA state could be
    one of the following:
    *   The set of the tops of the current branches' NPDA state stacks.  NOTE that this doesn't depend on any
        "hidden" NPDA states, only the tops of the state stacks.
    *   The set of the top portions of the current branches' NPDA state stacks, where the depth to take is specified.
        NOTE that this DOES depend on "hidden" NPDA states, and is therefore a strictly more powerful definition.
    Likely the depth-specified top portions of NPDA state stacks would allow a strictly larger class of grammars
    be parsed by a DPDA.  For example, if a SHIFT/REDUCE conflict depends on later REDUCE/POP_STACK actions to
    be resolved, as opposed to only depending on SHIFT actions.
-   If it's decided to have DPDA states be defined in the more powerful way, then the number of REDUCE/POP_STACK
    actions must be counted to determine what depth from the top of the current branch state stacks must be recorded.
    Note that the depth can be different for different DPDA state definitions (e.g. if it's not necessary to
    REDUCE multiple times to resolve a conflict).
-   EVEN BETTER: A more refined observation is that there can be REDUCE/POP_STACK actions needed to resolve a conflict
    as long as they don't depend on anything but the lookaheads and the top NPDA state(s).  For example,

        ROOT (corresponding to DPDA state {a, b})
            BRANCH with state stack (x, a)
            BRANCH with state stack (b)


        ROOT (corresponding to DPDA state {x, y})
            REDUCE (x)
                BRANCH with state stack (x) (blocked because further actions depend on states "deeper" than a)
            SHIFT (b p)
                REDUCE (b) (say consuming one token)
                    SHIFT (b q)
-   Other observation: In realistic settings, probably SHIFT/REDUCE conflicts only need to be handled at the
    root of the parse tree.  A case in which SHIFT/REDUCE conflicts would need to be handled recursively is
    if e.g. the "binary operator" in conflicting rules itself required a SHIFT/REDUCE conflict resolution.
-   Note that some of these previous considerations mostly concern NPDA -> DPDA conversion.  A grammar may have
    unbounded lookahead, in which case only NPDA can parse it, and probably I should implement "full"
    SHIFT/REDUCE conflict resolution, not just one-level resolution.


example grammar

%prec.left ADD
%prec.left MUL
%prec.right POW

%nonterminal expr
:
    INTEGER_LITERAL                   // rule 0
|   expr '+' expr %prec ADD           // rule 1
|   expr '*' expr %prec MUL           // rule 2
|   expr '^' expr %prec POW           // rule 3
|   '(' expr ')'                      // rule 4
|   '(' %error ')'                    // rule 5
|   '(' %error %end                   // rule 6
|   %error ')'                        // rule 7
|   %error %end                       // rule 8
;

state 0
    START expr
    rule 0: expr <- . INTEGER_LITERAL
    rule 1: expr <- . expr '+' expr
    rule 2: expr <- . expr '*' expr
    rule 3: expr <- . expr '^' expr
    rule 4: expr <- . '(' expr ')'
    rule 5: expr <- . '(' %error ')'
    rule 6: expr <- . '(' %error %end

   *Default action  : INSERT_LOOKAHEAD ERROR_
    INTEGER_LITERAL : SHIFT INTEGER_LITERAL then push state 1
    '('             : SHIFT '(' then push state 2
    expr            : SHIFT expr then push state 7
    ERROR_          : POP_STATE_STACK

state 1
    rule 0: expr <- INTEGER_LITERAL .

   *Default action  : REDUCE rule 0

state 2
    rule 0: expr <- . INTEGER_LITERAL
    rule 1: expr <- . expr '+' expr
    rule 2: expr <- . expr '*' expr
    rule 3: expr <- . expr '^' expr
    rule 4: expr <- . '(' expr ')'
    rule 4: expr <- '(' . expr ')'
    rule 5: expr <- . '(' %error ')'
    rule 5: expr <- '(' . %error ')'
    rule 6: expr <- . '(' %error
    rule 6: expr <- '(' . %error

   *Default action  : INSERT_LOOKAHEAD ERROR_
    INTEGER_LITERAL : shift INTEGER_LITERAL then push state 1
    ERROR_          : SHIFT ERROR_ then push state 3
    expr            : SHIFT expr then push state 5

state 3                               -- ERROR_ has just been shifted
    rule 5: expr <- '(' %error . ')'
    rule 6: expr <- '(' %error .

   *Default action  : DISCARD_LOOKAHEAD
    ')'             : SHIFT ')' then push state 4
    END_            : REDUCE rule 6

state 4
    rule 5: expr <- '(' %error ')' .

   *Default action  : REDUCE rule 5

state 5
    rule 1: expr <- expr . '+' expr
    rule 2: expr <- expr . '*' expr
    rule 3: expr <- expr . '^' expr
    rule 4: expr <- '(' expr . ')'

   *Default action  : INSERT_LOOKAHEAD ERROR_
    '+'             : SHIFT '+' then push state 8
    '*'             : SHIFT '*' then push state 9
    '^'             : SHIFT '^' then push state 10
    ')'             : SHIFT ')' then push state 6
    ERROR_          : POP_STATE_STACK


state 6
    rule 4: expr <- '(' expr ')' .

   *Default action  : REDUCE rule 4

state 7
    rule 1: expr <- expr . '+' expr
    rule 2: expr <- expr . '*' expr
    rule 3: expr <- expr . '^' expr

   *Default action  : TODO
    '+'             : SHIFT '+' then push state 8
    '*'             : SHIFT '*' then push state 9
    '^'             : SHIFT '^' then push state 10

state 8
    rule 0: expr <- . INTEGER_LITERAL
    rule 1: expr <- . expr '+' expr
    rule 1: expr <- expr '+' . expr
    rule 2: expr <- . expr '*' expr
    rule 3: expr <- . expr '^' expr
    rule 4: expr <- . '(' expr ')'
    rule 5: expr <- . '(' %error ')'
    rule 6: expr <- . '(' %error


action-generating logic; has to do with if there is %error before or after the cursor.

if (ERROR_ has just been shifted) {                 // then we want to discard unusable lookahead tokens
    if (can reduce) {                               // i.e. %error occurs last in some rule e.g. rule A <- i j k %error .
        END_            : REDUCE rule A             // because %error can't absorb END_
    } otherwise {
        END_            : POP_STATE_STACK 2         // this may result in an empty stack, but we have to pop past the state on
                                                    // the stack that accepts %error.
    }
    Default action      : DISCARD_LOOKAHEAD         // but %error can absorb anything besides END_
} otherwise {
    if (can reduce) {                               // i.e. %error does not occur last in any rule e.g. rule B <- p q %error r .
        Default action  : REDUCE rule B             // there could be several rules that are reducable; resolve based on precedence.
    } otherwise {
        Default action  : INSERT_LOOKAHEAD ERROR_   // initiate error panic
    }
}

The above nested if-statement could be refactored as

if (can reduce) {
    if (ERROR_ has just been shifted) {
        END_            : REDUCE                    // the only way to reduce a rule ending with %error is by seeing END_.
        default         : DISCARD_LOOKAHEAD         // throw away everything until END_
        NOTE: maybe it should reduce by default, in case it's possible to use enclosing nonterminal's ending terminal to end %error.
        for now, just do the END_ option, so that a nonterminal that ends with %error can only be reduced upon END_.
    } otherwise {
        default         : REDUCE                    // normal operation
    }
} otherwise {
    if (ERROR_ has just been shifted) {
        END_            : POP_STATE_STACK 2         // popping only once would cause an infinite loop because ERROR_ can't accept END_
        default         : DISCARD_LOOKAHEAD         // throw away everything until a real token is shifted
    } otherwise {
        default         : INSERT_LOOKAHEAD ERROR_   // if we can't reduce, then the default action is to initiate error panic.
    }
}

if (ERROR_ occurs as acceptable next token) {
    ERROR_ : SHIFT ERROR_ then push state X
} otherwise {
    ERROR_ : POP_STATE_STACK 1
}

finally, add all the other normal shift rules, inluding ones that may generate actions for END_ lookahead.  note that
consecutive %error tokens can't occur in a reduction rule.

another example grammar

%prec.left ADD

%nonterminal statement
:
    expr ';'            // rule 0
;

%nonterminal expr
:
    INTEGER_LITERAL     // rule 1
|   '(' expr ')'        // rule 2
|   expr '+' expr       // rule 3
|   '(' %error ')'      // rule 4
|   '(' %error          // rule 5
|   %error              // rule 6
;

state 0 (0,0 1,0 2,0 3,0 4,0 5,0 6,0)
    START statement
    rule 0,0 : statement <- . expr ';'
    rule 1,0 : expr <- . INTEGER_LITERAL
    rule 2,0 : expr <- . '(' expr ')'
    rule 3,0 : expr <- . expr '+' expr
    rule 4,0 : expr <- . '(' %error ')'
    rule 5,0 : expr <- . '(' %error
    rule 6,0 : expr <- . %error

    ERROR_ has not just been shifted
    ERROR_ could now be shifted

    Default action  : INSERT_LOOKAHEAD ERROR_
    ERROR_          : SHIFT ERROR_ then push state 1 (6,1)
    INTEGER_LITERAL : SHIFT INTEGER_LITERAL then push state 2 (1,1)
    '('             : SHIFT '(' then push state 3 (2,1 4,1 5,1)
    expr            : SHIFT expr then push state 4 (0,1 3,1)

state 1 (6,1)
    rule 6,1 : expr <- %error .

    ERROR_ has just been shifted
    ERROR_ could not now be shifted

    Default action  : DISCARD_LOOKAHEAD
    END_            : REDUCE rule 6
    // really want this to occur
    ';'

state 2 (1,1)

state 3 (2,1 4,1 5,1)

state 4 (0,1 3,1)


-----------

NPDA:

rule 0,0 : statement <- . expr ';'
rule 1,0 : expr <- . INTEGER_LITERAL
rule 2,0 : expr <- . '(' expr ')'
rule 3,0 : expr <- . expr '+' expr
rule 4,0 : expr <- . '(' %error ')'
rule 5,0 : expr <- . '(' %error
rule 6,0 : expr <- . %error

input is "-;a"

(0,0)                                                                       . '-' ';' 'a' END_
    INSERT_LOOKAHEAD ERROR_ -> (0,0)                                        . ERROR_ '-' ';' 'a' END_           *
        SHIFT ERROR_ -> (0,0 6,1)                                           ERROR_ . '-' ';' 'a' END_
            REDUCE rule 6 -> (0,0)                                          . expr '-' ';' 'a' END_
                SHIFT expr -> (0,0 0,1)                                     expr . '-' ';' 'a' END_
                    INSERT_LOOKAHEAD ERROR_ -> (0,0 0,1)                    expr . ERROR_ '-' ';' 'a' END_
                        POP_STATE_STACK -> (0,0)                            . ERROR_ '-' ';' 'a' END_           inf. loop; identical to *; kill branch
                SHIFT expr -> (0,0 3,1)                                     expr . '-' ';' 'a' END_
                    INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)                    expr . ERROR '-' ';' 'a' END_
                        POP_STATE_STACK -> (0,0)                            . ERROR '-' ';' 'a' END_            inf. loop; identical to *; kill branch
            DISCARD_LOOKAHEAD '-' -> (0,0 6,1)                              ERROR_ . ';' 'a' END_
                REDUCE rule 6 -> (0,0)                                      . expr ';' 'a' END_
                    SHIFT expr -> (0,0 0,1)                                 expr . ';' 'a' END_
                        SHIFT ';' -> (0,0 0,1 0,2)                          expr ';' . 'a' END_
                    SHIFT expr -> (0,0 3,1)                                 expr . ';' 'a' END_
                        INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)                expr . ERROR_ ';' 'a' END_
                DISCARD_LOOKAHEAD ';' -> (0,0 6,1)                          ERROR_ . 'a' END_
                    REDUCE rule 6 -> (0,0)                                  . expr 'a' END_
                        SHIFT expr -> (0,0 0,1)                             expr . 'a' END_
                            INSERT_LOOKAHEAD ERROR_ -> (0,0 0,1)            expr . ERROR_ 'a' END_
                        SHIFT expr -> (0,0 3,1)                             expr . 'a' END_
                            INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)            expr . ERROR_ 'a' END_
                    DISCARD_LOOKAHEAD 'a' -> (0,0 6,1)                      ERROR_ . END_
                        REDUCE rule 6 -> (0,0)                              . expr END_
                            SHIFT expr -> (0,0 0,1)                         expr . END_
                            SHIFT expr -> (0,0 3,1)                         expr . END_

(0,0)                                                                       . '-' ';' 'a' END_
    INSERT_LOOKAHEAD ERROR_ -> (0,0)                                        . ERROR_ '-' ';' 'a' END_
        SHIFT ERROR_ -> (0,0 6,1)                                           ERROR_ . '-' ';' 'a' END_
            DISCARD_LOOKAHEAD '-' -> (0,0 6,1)                              ERROR_ . ';' 'a' END_
                REDUCE rule 6 -> (0,0)                                      . expr ';' 'a' END_
                    SHIFT expr -> (0,0 0,1)                                 expr . ';' 'a' END_
                        SHIFT ';' -> (0,0 0,1 0,2)                          expr ';' . 'a' END_
                    SHIFT expr -> (0,0 3,1)                                 expr . ';' 'a' END_
                        INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)                expr . ERROR_ ';' 'a' END_
                DISCARD_LOOKAHEAD ';' -> (0,0 6,1)                          ERROR_ . 'a' END_
                    REDUCE rule 6 -> (0,0)                                  . expr 'a' END_
                        SHIFT expr -> (0,0 0,1)                             expr . 'a' END_
                            INSERT_LOOKAHEAD ERROR_ -> (0,0 0,1)            expr . ERROR_ 'a' END_
                        SHIFT expr -> (0,0 3,1)                             expr . 'a' END_
                            INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)            expr . ERROR_ 'a' END_
                    DISCARD_LOOKAHEAD 'a' -> (0,0 6,1)                      ERROR_ . END_
                        REDUCE rule 6 -> (0,0)                              . expr END_
                            SHIFT expr -> (0,0 0,1)                         expr . END_
                            SHIFT expr -> (0,0 3,1)                         expr . END_

execute and discard trunk
    INSERT_LOOKAHEAD ERROR_
    SHIFT ERROR_
    DISCARD_LOOKAHEAD '-'

(0,0 6,1)                                                       ERROR_ . ';' 'a' END_           *
    REDUCE rule 6 -> (0,0)                                      . expr ';' 'a' END_
        SHIFT expr -> (0,0 0,1)                                 expr . ';' 'a' END_
            SHIFT ';' -> (0,0 0,1 0,2)                          expr ';' . 'a' END_
                REDUCE rule 0 -> (0,0)                          . statement 'a' END_
                    RETURN_LOOKAHEAD statement
        SHIFT expr -> (0,0 3,1)                                 expr . ';' 'a' END_
            INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)                expr . ERROR_ ';' 'a' END_
                POP_STATE_STACK -> (0,0)                        . ERROR_ ';' 'a' END_
                    SHIFT ERROR_ -> (0,0 6,1)                   ERROR_ . ';' 'a' END_           inf. loop; identical to *; kill branch
    DISCARD_LOOKAHEAD ';' -> (0,0 6,1)                          ERROR_ . 'a' END_               **
        REDUCE rule 6 -> (0,0)                                  . expr 'a' END_
            SHIFT expr -> (0,0 0,1)                             expr . 'a' END_
                INSERT_LOOKAHEAD ERROR_ -> (0,0 0,1)            expr . ERROR_ 'a' END_          <- it looked at 'a' at this point, thereby becoming LR(2) (though if the outcome was the same for all values of the second lookahead, then it's really LR(1))
                    POP_STATE_STACK -> (0,0)                    . ERROR_ 'a' END_
                        SHIFT ERROR_ -> (0,0 6,1)               ERROR_ . 'a' END_               inf. loop; identical to **; kill branch
            SHIFT expr -> (0,0 3,1)                             expr . 'a' END_
                INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)            expr . ERROR_ 'a' END_
                    POP_STATE_STACK -> (0,0)                    . ERROR_ 'a' END_
                        SHIFT ERROR_ -> (0,0 6,1)               ERROR_ . 'a' END_               inf. loop; identical to **; kill branch
        DISCARD_LOOKAHEAD 'a' -> (0,0 6,1)                      ERROR_ . END_
            REDUCE rule 6 -> (0,0)                              . expr END_
                SHIFT expr -> (0,0 0,1)                         expr . END_
                SHIFT expr -> (0,0 3,1)                         expr . END_

(0,0 6,1)                                                       ERROR_ . ';' 'a' END_
    REDUCE rule 6 -> (0,0)                                      . expr ';' 'a' END_
        SHIFT expr -> (0,0 0,1)                                 expr . ';' 'a' END_
            SHIFT ';' -> (0,0 0,1 0,2)                          expr ';' . 'a' END_
                REDUCE rule 0 -> (0,0)                          . statement 'a' END_
                    RETURN_LOOKAHEAD statement
    DISCARD_LOOKAHEAD ';' -> (0,0 6,1)                          ERROR_ . 'a' END_
        DISCARD_LOOKAHEAD 'a' -> (0,0 6,1)                      ERROR_ . END_                   *
            REDUCE rule 6 -> (0,0)                              . expr END_
                SHIFT expr -> (0,0 0,1)                         expr . END_
                    INSERT_LOOKAHEAD ERROR_ -> (0,0 0,1)        expr . ERROR_ END_
                        POP_STATE_STACK -> (0,0)                . ERROR_ END_
                            SHIFT ERROR_ -> (0,0 6,1)           ERROR_ . END_                   inf. loop; identical to *; kill branch
                SHIFT expr -> (0,0 3,1)                         expr . END_
                    INSERT_LOOKAHEAD ERROR_ -> (0,0 3,1)        expr . ERROR_ END_
                        POP_STATE_STACK -> (0,0)                . ERROR_ END_
                            SHIFT ERROR_ -> (0,0 6,1)           ERROR_ . END_                   inf. loop; identical to *; kill branch

(0,0 6,1)                                                       ERROR_ . ';' 'a' END_
    REDUCE rule 6 -> (0,0)                                      . expr ';' 'a' END_
        SHIFT expr -> (0,0 0,1)                                 expr . ';' 'a' END_
            SHIFT ';' -> (0,0 0,1 0,2)                          expr ';' . 'a' END_
                REDUCE rule 0 -> (0,0)                          . statement 'a' END_
                    RETURN_LOOKAHEAD statement

execute and discard trunk
    REDUCE rule 6
    SHIFT expr
    SHIFT ';'
    REDUCE rule 0
    RETURN_LOOKAHEAD statement

complete log of actions:
    INSERT_LOOKAHEAD ERROR_
    SHIFT ERROR_
    DISCARD_LOOKAHEAD '-'
    REDUCE rule 6 : expr <- %error
    SHIFT expr
    SHIFT ';'
    REDUCE rule 0 : statement <- expr ';'
    RETURN_LOOKAHEAD statement


----------

%prec.left ADD
%prec.left MUL

start.e (has epsilon transitions to each e reduction rule)
rule 0 : e <- I
rule 1 : e <- e + e %prec ADD
rule 2 : e <- e * e %prec MUL
rule 3 : e <- ( e )
rule 4 : e <- ( %error )

NPDA state machine:

parse.e
    epsilon : go to state start.e
    e       : shift (e), then push state return.e

return.e
    default : return top of stack

start.e
    epsilon : go to state 0,0
    epsilon : go to state 1,0
    epsilon : go to state 2,0
    epsilon : go to state 3,0
    epsilon : go to state 4,0

0,0
    I       : shift (I), then push state 0,1
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

0,1
    ERROR_  : pop state stack               <-- not sure if this is necessary; it may be unreachable if the lookahead is ERROR_
    default : reduce rule 0

1,0
    epsilon : go to state start.e
    e       : shift (e), then push state 1,1
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

1,1
    +       : shift (+), then push state 1,2
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

1,2
    epsilon : go to state start.e
    e       : shift (e), then push state 1,3
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

1,3
    ERROR_  : pop state stack               <-- not sure if this is necessary; it may be unreachable if the lookahead is ERROR_
    default : reduce rule 1

2,0
    epsilon : go to state start.e
    e       : shift (e), then push state 2,1
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

2,1
    *       : shift (+), then push state 2,2
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

2,2
    epsilon : go to state start.e
    e       : shift (e), then push state 2,3
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

2,3
    ERROR_  : pop state stack               <-- not sure if this is necessary; it may be unreachable if the lookahead is ERROR_
    default : reduce rule 2

3,0
    (       : shift ('('), then push state 3,1
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

3,1
    epsilon : go to state start.e
    e       : shift (e), then push state 3,2
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

3,2
    )       : shift (')'), then push state 3,3
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

3,3
    ERROR_  : pop state stack               <-- not sure if this is necessary; it may be unreachable if the lookahead is ERROR_
    default : reduce rule 3

4,0
    (       : shift ('('), then push state 4,1
    ERROR_  : pop state stack
    default : insert lookahead ERROR_

4,1
    ERROR_  : shift (ERROR_), then push state 4,2
    default : insert lookahead ERROR_

4,2
    )       : shift (')'), then push state 4,3
    ERROR_  : pop state stack
    default : throw away lookahead

4,3
    ERROR_  : pop state stack               <-- not sure if this is necessary; it may be unreachable if the lookahead is ERROR_
    default : reduce rule 4


test

input is "e+e*e"

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        (start.e 1,1) (start.e 2,1)                                                 e . + e * e

At this point, the trunk is SHIFT, so assign:
    in state epsilon_closure_of(start.e), lookahead sequence "e" results in SHIFT, then PUSH epsilon_closure_of((1,1) (2,1))
prune the trunk and continue

TODO: Figure out if pruning the trunk and continuing is reasonable, in case error handling needs to happen.  Probably any time a pop
is encountered in the trunk, it should stop there; the resulting state is not explicitly known, but that's ok.

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            (start.e 1,1 1,2)                                                       e + . e * e
        INSERT_LOOKAHEAD ERROR_                                                     e . ERROR_ + e * e
            (start.e 2,1)                                                           e . ERROR_ + e * e

At this point, there is a conflict between SHIFT (+) and INSERT_LOOKAHEAD ERROR_, which should ideally resolve in favor of SHIFT.  Probably should make the action INSERT_LOOKAHEAD_ERROR_, and make it have the lowest priority, only surviving if there are no competing actions (such as SHIFT).

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            SHIFT (e)                                                               e + e . * e
                (start.e 1,1 1,2 1,1)                                               e + e . * e
                (start.e 1,1 1,2 1,3)                                               e + e . * e
                (start.e 1,1 1,2 2,1)                                               e + e . * e

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            SHIFT (e)                                                               e + e . * e
                INSERT_LOOKAHEAD_ERROR_                                             e + e . ERROR_ * e
                    (start.e 1,1 1,2 1,1)                                           e + e . ERROR_ * e
                REDUCE rule 3                                                       . e * e
                    (start.e)                                                       . e * e
                SHIFT (*)                                                           e + e * . e
                    (start.e 1,1 1,2 2,1 2,2)                                       e + e * . e

At this point, INSERT_LOOKAHEAD_ERROR_ dies because it's automatically outcompeted by any other action, leaving a shift/reduce conflict.

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            SHIFT (e)                                                               e + e . * e
                REDUCE rule 3                                                       . e * e
                    (start.e)                                                       . e * e
                SHIFT (*)                                                           e + e * . e
                    (start.e 1,1 1,2 2,1 2,2)                                       e + e * . e

At this point, the shift/reduce conflict is resolved by precedence in favor of SHIFT.

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            SHIFT (e)                                                               e + e . * e
                SHIFT (*)                                                           e + e * . e
                    (start.e 1,1 1,2 2,1 2,2)                                       e + e * . e

(start.e)                                                                           . e + e * e
    SHIFT (e)                                                                       e . + e * e
        SHIFT (+)                                                                   e + . e * e
            SHIFT (e)                                                               e + e . * e
                SHIFT (*)                                                           e + e * . e
                    SHIFT (e)                                                       e + e * e .
                        REDUCE rule 2                                               e + . e
                            SHIFT (e)                                               e + e .
                                REDUCE rule 1                                       . e
                                    (start.e)                                       . e

If the starting state was parse.e (as was added later), then the action now would be RETURN_LOOKAHEAD.



Actions:

SHIFT (then push state X)
REDUCE (rule Y)
DISCARD_LOOKAHEAD           -- maybe should have precedence lower than all shift, but equal to all reduce (though this defies a linear order).
                               on the other hand, having DISCARD_LOOKAHEAD be higher than all reduce would be simple, and implement the
                               situation where the input "-;" produces a DISCARD_LOOKAHEAD/REDUCE conflict that doesn't result in the
                               error panic in expression ending by the statement's ';' token.  this is probably simpler.  but because
                               it's possible to have a SHIFT have lower precedence than REDUCE, this would violate the DISCARD_LOOKAHEAD
                               having precedence lower than all SHIFT.
POP_STATE_STACK (Z times)   -- this only happens when ERROR_ is the lookahead and there's no rule to accept ERROR_
RETURN_TOP_OF_STACK         -- must have low precedence, but higher than INSERT_LOOKAHEAD_ERROR
INSERT_LOOKAHEAD_ERROR      -- must have low precedence, probably lowest of all

Idea: Each class doesn't need to have a uniform relative precedence (in fact, shift and reduce are a counterexample),
but rather a conflict can be described as having a graph which doesn't have a maximal element.  For example, having a cycle
    SHIFT <- DISCARD_LOOKAHEAD <-> REDUCE <- SHIFT
Conflict resolution would then be deleting arrows in the graph such that there becomes a unique maximal element.

-----------

Another try with a different formatting scheme, where ^ indicates lookahead knowledge cursor

input is "e+e*e"

ROOT -> (parse.e)                                                           . ^ e + e * e
    SHIFT (e) -> (parse.e return.e) (parse.e 1,1) (parse.e 2,1)             e . ^ + e * e

Prune the trunk -- the action is SHIFT -- start again

ROOT -> (return.e) (1,1) (2,1)                                              e . ^ + e * e
    RETURN_TOP_OF_STACK -> (return.e)                                       e . ^ + e * e
    SHIFT (+) -> (1,1 1,2)                                                  e + . ^ e * e
    INSERT_LOOKAHEAD_ERROR -> (2,1 2,2)                                     e . ^ ERROR_ + e * e

At this point, INSERT_LOOKAHEAD_ERROR should probably lose to SHIFT and RETURN_TOP_OF_STACK.
RETURN_TOP_OF_STACK should lose to SHIFT, since RETURN_TOP_OF_STACK could be considered a REDUCE action in a way, which
should have low priority.

ROOT -> (return.e) (1,1) (2,1)                                              e . ^ + e * e
    SHIFT (+) -> (1,1 1,2)                                                  e + . ^ e * e

Prune the trunk -- the action is SHIFT -- start again

ROOT -> (1,2)                                                               e + . ^ e * e
    SHIFT (e) -> (1,2 1,3) (1,2 1,1) (1,2 2,1)                              e + e . ^ * e

Prune the trunk -- the action is SHIFT -- start again

ROOT -> (1,3) (1,1) (2,1)                                                   e + e . ^ * e
    REDUCE rule 1 -> (x)                                                    . e ^ * e
    SHIFT (*) -> (2,1 2,2)                                                  e + e * . ^ e

Because rule 2 has higher precedence than rule 1, the REDUCE loses.

ROOT -> (1,3) (1,1) (2,1)                                                   e + e . ^ * e
    SHIFT (*) -> (2,1 2,2)                                                  e + e * . ^ e

Prune the trunk -- the action is SHIFT -- start again

ROOT -> (2,2)                                                               e + e * . ^ e
    SHIFT (e) -> (2,2 2,3)                                                  e + e * e . ^

Prune the trunk -- the action is SHIFT -- start again

ROOT -> (2,3)                                                               e + e * e . ^
    REDUCE rule 2 -> (x)                                                    e + . e ^

2018.07.06 --------------------------------------------------------------------

There are certain cases where considering a REDUCE branch to be "blocked" is preventing
the parser from finding the correct parse.  An example:

Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): ---------- ITERATION 39 --------------
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Realized state stack (bottom to top) is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 163 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 167 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 26 30 33 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 37 54 60 64 68 72 76 80 84 88 92 96 100 104 108 112 122 131 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Max realized lookahead count (so far) is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     1
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Has-encountered-error-state (so far) is :
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     false
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Realized stack tokens then realized lookahead queue is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     function_definition_type_expression '{' expression . '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): ROOT
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     REDUCE rule 46; statement <- expression
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         HPS (    blocked) rule 57: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     SHIFT
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         HPS (non-blocked) rule 27: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         HPS (non-blocked) rule 28: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         HPS (non-blocked) rule 29: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): HPS queue:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     HPS (    blocked) rule 57: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     HPS (non-blocked) rule 27: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     HPS (non-blocked) rule 28: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     HPS (non-blocked) rule 29: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression '(' .
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Parse stack tree does not have trunk; continuing parse.
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     SHIFT/REDUCE conflict encountered. REDUCE precedence level range: [DEFAULT_, DEFAULT_], SHIFT precedence level range: [DEFAULT_, DEFAULT_]
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         Case 3; REDUCE == SHIFT; rule 46 associativity index: 0
pruning left-associative SHIFT and continuing.
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): ---------- ITERATION 40 --------------
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Realized state stack (bottom to top) is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 163 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 167 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 26 30 33 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     ( 37 54 60 64 68 72 76 80 84 88 92 96 100 104 108 112 122 131 )
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Max realized lookahead count (so far) is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     1
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Has-encountered-error-state (so far) is :
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     false
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Realized stack tokens then realized lookahead queue is:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     function_definition_type_expression '{' expression . '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): ROOT
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     REDUCE rule 46; statement <- expression
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):         HPS (    blocked) rule 57: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): HPS queue:
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     HPS (    blocked) rule 57: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement '('
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Parse stack tree has trunk; executing trunk actions.
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     Executing trunk action REDUCE rule 46.
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">): Executing reduction rule 46
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):     Destroying and recreating parse tree based on top element of realized stack.
Parser (<string-input "(n:Integer64)->Boolean { f(x)\ng(y) }">):

In this case, it prefers to REDUCE the expression to a statement within the statement list, instead of following the REDUCE branch,
consuming the available lookaheads (and no more) and finding that there is no correct parse.  So probably the concept of "blocked"
branch should be changed into one where it's only blocked if it has run out of known lookaheads to parse.  All branches perhaps
should walk in lockstep regarding the number of lookaheads they've processed.  In this case, it would look something like

Iteration N ---------------

ROOT
    REDUCE: statement <- expression
        HPS: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement '('
    SHIFT: '('
        HPS: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression

Iteration N+1 -------------

ROOT
    REDUCE: statement <- expression
        SHIFT: statement
            HPS: statement_list <- statement .     (26); statement . '('
    SHIFT '('
        HPS: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression

Iteration N+2 -------------

ROOT
    REDUCE: statement <- expression
        SHIFT: statement
            REDUCE: statement_list <- statement
                HPS: bracketed_statement_list <- '{' . statement_list '}'     (26); . statement_list '('
    SHIFT '('
        HPS: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression

Iteration N+3 -------------

ROOT
    REDUCE: statement <- expression
        SHIFT: statement
            REDUCE: statement_list <- statement
                SHIFT: statement_list
                    HPS: bracketed_statement_list <- '{' statement_list . '}'     (26); statement_list . '('   <-- no matching lookahead; branch gets killed
    SHIFT '('
        HPS: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression

Iteration N+3 -------------

ROOT
    SHIFT '('
        HPS: parenthesized_parameter_list <- '(' . nonempty_parameter_list ')'     (26 131 137); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ')'     (26 131 155); expression '(' .
        HPS: parenthesized_parameter_list <- '(' . ERROR_ ')'     (26 131 158); expression

execute SHIFT '('

However, this violates the principle that the real parse action taken should only depend on the top of the NPDA state stack(s).
For example, in a POP_STACK or REDUCE, the NPDA state stack for that branch is popped, and then the action depends on "hidden"
states -- states below the top of the NPDA state stack(s).  The set of the NPDA states on top of each stack is what defines
a DPDA state.  Though this is not the only possible definition, it could be defined to include some substack of each stack
which includes the top element.

2018.07.12 ----------------------------

-   It probably makes sense to add a %lookahead[...] directive for use especially (or only?)
    as the last thing in a reduction rule.  This would probably make it easier to design parsers
    that avoid shift/reduce conflicts, and would allow more grammars to be viable (e.g. grammars
    that have empty reduction rules in various things).  In the above example, the problem could
    probably be resolved if there was a %lookahead['}'|STATEMENT_DELIMITER|%end] or something
    like that.
-   Perhaps other avenues to explore are the following.
    1.  Given a branched parse (say with the SHIFT/REDUCE conflict described above), all branches
        should continue at least until they exhaust all of the number of lookaheads that the
        "furthest ahead" branch (in the sense that it has looked at the most lookaheads) has looked
        at.  In the above example, the SHIFT branch(es) have looked at 1 lookahead, so the REDUCE
        branch should be allowed to continue until it has exhausted the use of 1 lookahead.

        Otherwise, the parser can't truly claim to have used the lookahead token(s) fully.  It
        should derive the maximal information out of each new token.

        NOTE: If this is done, then because REDUCE actions are no longer blocked, it follows that
        the DPDA states will actually be sets of sub-stacks of the NPDA states.  Here, "sub-stack"
        means a contiguous subsequence of stack elements which includes the top element.  While
        this is not inherently problematic, it does complicate the model for what a DPDA state is
        (it currently/used to be the set of NPDA states comprising the top of all the branches'
        NPDA state stacks).

    2.  Pre-specify the number of lookaheads allowed before a conflict is resolved or an error
        is produced.  This idea would need to be fleshed out more to be fully well-defined.

2018.07.14 ----------------------------

-   Performed an experiment to explore the feasibility of option 1 from above, and it did in fact
    solve the problem.  Now need to implement the step-in-time of all parallel HPS branches, so
    that SHIFT-going branches don't get ahead of REDUCE-going branches in terms of consumed lookaheads.

2018.07.17 ----------------------------

-   Need to figure out if it's sufficient to store only the top-of-stack elements from each HPS in
    m_npda_state_set, or if more of the stack is necessary.  Probably it is sufficient, because the
    deeper stack elements are stored in the m_npda_state_set of m_npda_.m_realized_stack_.
-   Probably should do as much processing as possible with 0 lookaheads right after adding a REDUCE
    branch.  Or maybe any branch type.  This falls under the principle of having the parser use
    each piece of information maximally before requesting more information.
-   Idea for a different implementation of NPDA:
    -   Define a general framework for nondeterministic algorithm which must eventually choose
        one of possibly many options at each step.  The algorithm should be completely recursive,
        instead of how the current NPDA implementation is with a "realized" portion and a
        "hypothetical" portion.  Each recursion is hypothetical with respect to its source.
        Thus all the conflict resolution can happen within each recursion without any additional
        or special logic.
    -   For each choice, define a precedence ordering in order to resolve branches.
    -   Also define how long branches should be allowed to proceed without resolving conflicts.
        With such a limit, each recursion would reduce that limit by one.
    -   A SortedTypeIndex-like property should be used to prevent exploring every single branch
        at every stage, but rather have a strict precedence of branches to try first until
        they're ruled out, then proceed to the next precedence, etc.  Otherwise the ubiquitous
        error handling transitions will be explored every single time and cause the algorithm
        to always run in exponential time.
    -   Should a nested hypothetical action be allowed to be an error, even though the real
        action choice is not an error?  Or should the SortedTypeIndex-like ordering apply to
        the entire recursion?  Probably it should apply to the whole recursion.
-   If REDUCE actions are to be non-blocking, then it follows that the stack data model, where
    there's a "realized" part and a branch-specific "hypothetical" part of the stack has to be
    changed, and in particular, each branch has to have a cursor for where its branch-specific
    hypothetical stack starts, because a REDUCE action can pop its whole branch-specific stack
    and further, so it has to be able to dig down into the realized stack.  NOTE: This observation
    might actually just be due to a bug in the "destroy_and_recreate_parse_tree" functionality.
    The "destroy_and_recreate_parse_tree" functionality loses some information regarding the
    earlier part of the stack.  The bug occurs when the HPS-specific stack is empty, even though
    it should contain at least part of the realized stack.
-   There is a bug in the REDUCE/REDUCE conflict resolution in NPDA target; if there are two
    HPSes (which in particular have different state stacks) that can both produce a
    "REDUCE rule N" action for the same rule N, then that shouldn't cause a REDUCE/REDUCE
    conflict, but rather the resulting HPSes should both appear under the "REDUCE rule N"
    branch action.







