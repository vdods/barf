main parsing algorithm:
{
    create tree root (rule stack level 0, no parent)
    create initial branch (using starting state of specified start nonterminal)
    add initial branch as child to tree root
    add initial branch to branch set
    is_shift_blocked = false
    reduce_transitions_were_performed = false
    shift_transitions_were_performed = false
    while (true)
    {
        perform e-closure (simple)
        if (!is_shift_blocked)
            perform reduce transitions (setting reduce_actions_were_performed and is_shift_blocked if they were)
        if (!reduce_transitions_were_performed)
        {
            if (is_shift_blocked)
                perform shift transitions (only for those branches with a private nonterminal lookahead, setting shift_transitions_were_performed if they were, recording doomed branches)
            else
                perform shift transitions (on all branches, setting shift_transitions_were_performed if they were, recording doomed branches)

            if (there were doomed branches)
            {
                if (shift_transitions_were_performed)
                    prune all doomed branches
                else if (there are any doomed branches at a return state) // this can only happen when !is_shift_blocked
                    prune only non-return-state doomed branches
                else
                    go into error-handling mode (TODO)
            }

            is_shift_blocked = false
        }

        execute and remove the trunk

        if (there is a single branch and it is at a return state)
            return the single stack token
    }
}

to perform (a single) reduce transition:
{
    if (source action tree node already has a reduce child)
    {
        if (transition reduce action has lower priority than existing reduce child)
        {
            prune source branch
            return
        }
        else if (transition reduce action has higher priority than existing reduce child)
        {
            prune existing reduce child
            create a new reduce child using the transition's specifications
        }
        else // equal priority
        {
        }
    }
    else // no existing reduce child
    {
        create a new reduce child using the transition's specifications
    }
    
    move the source branch to the reduce child
    update the priorities of the source action tree node
}

to perform (a single) shift transition:
{
    if (source action tree node already has a shift child)
    {
        integrate the source branch's precedence level, associativity and rule index into the existing shift child's
    }
    else // no existing shift child
    {
        create a new shift child using the transition's specifications, with the source branch's precedence level, associativity and rule index
    }
        
    move the source branch to the shift child    
    update the priorities of the source action tree node
}

to update the priorities of an action tree node
{
    if (this is a shift node)
    {
        integrate all child branches' precedence level, associativity and rule index
        TODO
    }
    else if (this is a reduce node)
    {
        // do nothing
    }
    else // tree root
    {
        // do nothing
    }
    TODO: figure out how to propogate the changes down the ancestor line
}

notes:

- performing the shift/reduce transitions involves resolving conflicts
- i conject that, at a given action tree node, there can be: 0 or 1 reduce
  child nodes and 0 or 1 shift child nodes.  if more than one reduce
  transition comes about at a particular action tree node, only the highest
  priority one is used.  there can only ever be one shift action from any
  given node, because it's reading from a necessarily common lookahead
  (nonterminal or terminal type).

