main parsing algorithm:
{
    create tree root (rule stack level 0, no parent)
    create initial branch (using starting state of specified start nonterminal)
    add initial branch as child to tree root
    add initial branch to branch set
    is_shift_blocked = false
    reduce_transitions_were_performed = false
    shift_transitions_were_performed = false
    while (true)
    {
        perform e-closure (simple)
        if (!is_shift_blocked)
            perform reduce transitions (setting reduce_actions_were_performed and is_shift_blocked if they were)
        if (!reduce_transitions_were_performed)
        {
            if (is_shift_blocked)
                perform shift transitions (only for those branches with a private nonterminal lookahead, setting shift_transitions_were_performed if they were, recording doomed branches)
            else
                perform shift transitions (on all branches, setting shift_transitions_were_performed if they were, recording doomed branches)

            if (there were doomed branches)
            {
                if (shift_transitions_were_performed)
                    prune all doomed branches
                else if (there are any doomed branches at a return state) // this can only happen when !is_shift_blocked
                    prune only non-return-state doomed branches
                else
                    go into error-handling mode (TODO)
            }

            is_shift_blocked = false
        }

        execute and remove the trunk

        if (there is a single branch and it is at a return state)
            return the single stack token
    }
}

to perform (a single) reduce transition (from a particular action tree node):
{
    assert(there are no shift transitions at this node)
    if (source action tree node already has a reduce child)
    {
        assert(transition reduce action has different priority than existing reduce child)
        if (transition reduce action has lower priority than existing reduce child)
        {
            prune source branch
            return
        }
        else // transition reduce action has higher priority than existing reduce child
        {
            prune existing reduce child
            create a new reduce child using the transition's specifications
        }
    }
    else // no existing reduce child
    {
        create a new reduce child using the transition's specifications
    }

    assert(reduce child has no children)
    move the source branch to the reduce child
    update the priorities of the source action tree node
}

to perform (a single) shift transition:
{
    ensure shift child exists
    assert(shift child has no children)
    move the source branch to the shift child
    if (source action tree node already has a reduce child)
        add a priority ref to shift child from source branch
}

to delete an action tree node: // towards leaves
{
    if (exists a reduce child)
    {
        set reduce child's parent pointer to NULL
        delete reduce child
    }
    if (exists a shift child)
    {
        set shift child's parent pointer to NULL
        delete shift child
    }
    for each child branch
    {
        set branch's parent pointer to NULL
        delete branch
    }
    if (this node's parent pointer != NULL)
        remove this node from its parent
    delete this
}

to delete a branch tree node: // towards root
{
    node = this;
    parent = node->parent;
    // if the parent is not NULL and the only child is node
    while (parent != NULL && parent->SingleChild() == node)
    {
        delete node;
        node = parent;
        parent = node->parent;
    }
}

diagram stuff

tree node
    node type (root, branch, shift, reduce) specifies the subclass
    parent tree node

branch tree node (inherits tree node)
    prev branch (within parser's branch list -- used for constant-time insertion/removal)
    next branch (within parser's branch list -- used for constant-time insertion/removal)
    list of weak references to shift-action ref counts
    state stack
    lookahead nonterminal token id
    is epsilon closed flag

action tree node (inherits tree node)
    child branches (probably a list, because no ordering is necessary, but arbitrary element removal is)
    shift child (single pointer)
    reduce child (single pointer)

shift action tree node (inherits action tree node)
    ref count list (list which contains pointers to ref-counted objects used in deciding the priority of this node)
    shifted token name (in debug spew mode)

reduce action tree node (inherits action tree node)
    associated rule (can't be null)








notes:

- performing the shift/reduce transitions involves resolving conflicts
- i conject that, at a given action tree node, there can be: 0 or 1 reduce
  child nodes and 0 or 1 shift child nodes.  if more than one reduce
  transition comes about at a particular action tree node, only the highest
  priority one is used.  there can only ever be one shift action from any
  given node, because it's reading from a necessarily common lookahead
  (nonterminal or terminal type).

