<|if(header_filename == implementation_filename)
<|  error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|if(parse_method_access != "public" && parse_method_access != "protected" && parse_method_access != "private")
<|  error("invalid parse_method_access \"" . parse_method_access . "\"; must be one of \"public\", \"protected\", or \"private\"")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{  define(debug_spew_prefix)}"<{class_name}: "<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#pragma once

<{define(use_npda)}true<|end_define

#include <cassert>
#include <cstdint>
#include <deque>
<|if(is_defined(generate_debug_spew_code))
#include <iostream>
<|end_if
<|if(is_defined(use_npda))
#include <functional>
#include <map>
#include <memory>
#include <set>
#include <utility>
#include <vector>
<|end_if

<|top_of_header_file?

<|if(is_defined(use_npda))
// NOTE: Because this uses std::shared_ptr, if you create a cycle in the list (which is valid and
// the algorithms will work), then you must explicitly break it later in order for that memory to
// be cleaned up (otherwise the ref count of the elements in the cycle will never go back to zero).
template <typename DataType>
struct SharedLinkedListElement_ : public std::enable_shared_from_this<SharedLinkedListElement_<DataType>>
{
    // Ideally this would be private and std::make_shared<SharedLinkedListElement_> would be a friend
    // in order to force use of std::make_shared to construct std::shared_ptr<SharedLinkedListElement_>
    // instances instead of bare SharedLinkedListElement_ instances, but I couldn't figure out how to
    // do this correctly.
    template <typename... Types>
    SharedLinkedListElement_ (std::shared_ptr<SharedLinkedListElement_> const &next, Types&&... args)
        :   m_next(next)
        ,   m_data(std::forward<Types>(args)...)
    { }

    template <typename... Types>
    static std::shared_ptr<SharedLinkedListElement_> Create (Types&&... args)
    {
        return std::make_shared<SharedLinkedListElement_>(nullptr, std::forward<Types>(args)...);
    }

    bool HasNext () const { return bool(m_next); }
    std::shared_ptr<SharedLinkedListElement_ const> Next () const { return m_next; }
    std::shared_ptr<SharedLinkedListElement_> const &Next () { return m_next; }
    DataType const &Data () const { return m_data; }
    DataType &Data () { return m_data; }
    // This is O(n), where n is the length of the linked list.
    bool HasACycle () const
    {
        if (HasNext())
            return Next()->HasACycle_Impl(*this);
        else
            return false;
    }
    // This returns the number of elements, including this one, reachable by following the linkage.
    // If there is a cycle, it will return the number of elements in the cycle.
    // This is O(n), where n is the length of the linked list.
    std::size_t ReachableElementCount () const
    {
        if (HasNext())
            return 1 + Next()->ReachableElements_Impl(*this);
        else
            return 1;
    }
    // TODO: Ideally, iterators would be created for this data structure so that C++11's for_each could be used.
    // But for now, just use a hand-implemented ForEach.
    template <typename ReturnType>
    ReturnType ForEach (std::function<ReturnType(DataType const &)> const &f) const
    {
        // TODO: Implement
    }

    // This creates a new element whose next element is this one (thereby incrementing this element's ref
    // count), but doesn't alter any other previously existing thing.
    template <typename... Types>
    std::shared_ptr<SharedLinkedListElement_> CreatePrepended (Types&&... args)
    {
        return std::make_shared<SharedLinkedListElement_>(this->shared_from_this(), std::forward<Types>(args)...);
    }
    // Will throw std::invalid_argument if p is null or if p->HasNext returns true.  Otherwise will return
    // the prepended element, which in particular is p.
    std::shared_ptr<SharedLinkedListElement_> const &Prepended (std::shared_ptr<SharedLinkedListElement_> const &p)
    {
        if (!bool(p))
            throw std::invalid_argument("p must not be null");
        if (p->HasNext())
            throw std::invalid_argument("p already has a next element");
        p->m_next = this->shared_from_this();
        return p;
    }

    // Will throw std::invalid_argument if HasNext returns true, otherwise will return the newly created element.
    template <typename... Types>
    std::shared_ptr<SharedLinkedListElement_> const &CreateAndAppend (Types&&... args) // throw(std::invalid_argument)
    {
        if (HasNext())
            throw std::invalid_argument("SharedLinkedListElement_ already has a 'next' element -- can't append another");
        m_next = std::make_shared<SharedLinkedListElement_>(nullptr, std::forward<Types>(args)...);
        return m_next;
    }
    // Will throw std::invalid_argument if HasNext returns true, otherwise will return the appended element (i.e. p).
    std::shared_ptr<SharedLinkedListElement_> const &Append (std::shared_ptr<SharedLinkedListElement_> const &p) // throw(std::invalid_argument)
    {
        if (HasNext())
            throw std::invalid_argument("SharedLinkedListElement_ already has a 'next' element -- can't append another");
        m_next = p;
        return m_next;
    }

    // Replaces the next element with the given one, and returns the previously held next element.
    std::shared_ptr<SharedLinkedListElement_> ReplaceTail (std::shared_ptr<SharedLinkedListElement_> const &p)
    {
        std::shared_ptr<SharedLinkedListElement_> old_next = m_next;
        m_next = p;
        return old_next;
    }
    // Ensures that the tail is removed (i.e. that HasNext will return false).  Returns the previously held next element.
    std::shared_ptr<SharedLinkedListElement_> RemoveTail ()
    {
        return ReplaceTail(nullptr);
    }

    // This resizes the given vector to ReachableElementCount() and then populates it with the
    // contents of this linked list.
    void PopulateVector (std::vector<DataType> &v) const
    {
        v.resize(ReachableElementCount());
        PopulateVector_Impl(v.begin(), v.end());
    }

private:

    void PopulateVector_Impl (typename std::vector<DataType>::iterator it, typename std::vector<DataType>::iterator it_end) const
    {
        if (it != it_end)
        {
            *it = Data();
            ++it;
            if (HasNext())
            {
                assert(it != it_end);
                Next()->PopulateVector_Impl(it, it_end);
            }
            else
            {
                assert(it == it_end);
            }
        }
    }

    bool HasACycle_Impl (SharedLinkedListElement_ const &initial_element) const
    {
        if (this == &initial_element)
            return true;
        else if (HasNext())
            return Next()->HasACycle_Impl(initial_element);
        else
            return false;
    }
    std::size_t ReachableElements_Impl (SharedLinkedListElement_ const &initial_element) const
    {
        if (this == &initial_element)
            return 0;
        else if (HasNext())
            return 1 + Next()->ReachableElements_Impl(initial_element);
        else
            return 1;
    }
    template <typename ReturnType>
    ReturnType ForEach_Impl (std::function<ReturnType(DataType const &)> const &f, SharedLinkedListElement_ &initial_element) const
    {
        // TODO: Implement
    }

    std::shared_ptr<SharedLinkedListElement_> m_next;
    DataType m_data;
};

template <typename DataType>
struct SharedLinkedListElementOrder_
{
    bool operator () (std::shared_ptr<SharedLinkedListElement_<DataType>> const &lhs, std::shared_ptr<SharedLinkedListElement_<DataType>> const &rhs) const
    {
        if (bool(lhs))
        {
            if (bool(rhs))
            {
                if (lhs->Data() < rhs->Data())
                    return true;
                else if (lhs->Data() > rhs->Data())
                    return false;
                else
                    // Recursive case defined on the tails of lhs and rhs respectively.
                    return this->operator()(lhs->Next(), rhs->Next());
            }
            else
                // Declare non-null to be "greater than" null.
                return false;
        }
        else
        {
            if (bool(rhs))
                // Declare null to be "less than" non-null.
                return true;
            else
                // Declare null to be "equal to" null.
                return false;
        }
    }
};

// template <typename DataType>
// bool operator < (std::shared_ptr<SharedLinkedListElement_<DataType>> const &lhs, std::shared_ptr<SharedLinkedListElement_<DataType>> const &rhs)
// {
//     if (bool(lhs))
//     {
//         if (bool(rhs))
//         {
//             if (lhs->Data() < rhs->Data())
//                 return true;
//             else if (lhs->Data() > rhs->Data())
//                 return false;
//             else
//                 // Recursive case defined on the tails of lhs and rhs respectively.
//                 return lhs->Next() < rhs->Next();
//         }
//         else
//             // Declare non-null to be "greater than" null.
//             return false;
//     }
//     else
//     {
//         if (bool(rhs))
//             // Declare null to be "less than" non-null.
//             return true;
//         else
//             // Declare null to be "equal to" null.
//             return false;
//     }
// }

template <typename DataType>
std::ostream &operator << (std::ostream &out, std::shared_ptr<SharedLinkedListElement_<DataType>> const &e)
{
    if (bool(e))
    {
        out << e->Data();
        if (e->HasNext())
            out << ' ' << e->Next();
    }
    return out;
}
<|end_if

/** A parser class generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
  * from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}.
  *
  * The term "primary source" will be used to refer to the .trison source file from which
  * this file was generated.  Specifically, the primary source is <{_source_filename}.
  *
  * The term "client" will be used to refer to the programmer who is writing the trison
  * primary source file to generate a parser (e.g. "the client shouldn't return X from Y"
  * or "the client must provide a way to X and Y").
  *
  * @brief A parser class.
  */
class <{class_name}<{if(is_defined(class_inheritance))} : <{class_inheritance}<{end_if}
{
public:

    /// Return values for Parse().
    enum ParserReturnCode : std::uint32_t
    {
        /// Indicates the Parse() method returned successfully.
        PRC_SUCCESS = 0,
        /// Indicates an unhandled parse error occurred (i.e. no %error-accepting
        /// rules were encountered).
        PRC_UNHANDLED_PARSE_ERROR,
        /// Indicates that the parse was halted because the number of realized
        /// lookaheads exceeded the max allowable lookahead count (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEADS,
        /// Indicates that the parse didn't complete because of some internal error.
        PRC_INTERNAL_ERROR
    }; // end of enum <{class_name}::ParserReturnCode

    /// "Namespace" for <{class_name}::Terminal::Name, which enumerates all valid
    /// token ids which this parser will accept as lookaheads.
    struct Terminal
    {
        /** There are two special terminals: END_ and ERROR_.
          *
          * <{class_name}::Terminal::END_ should be returned in %target.cpp.scan_actions
          * by the client when the input source has reached the end of input.  The parser
          * will not request any more input after <{class_name}::Terminal::END_ is received.
          *
          * <{class_name}::Terminal::ERROR_ should not ever be used by the client, as
          * it is used internally by the parser.
          *
          * The rest are the terminals as declared in the primary source, and should
          * be used by the client when returning from %target.cpp.scan_actions.
          *
          * @brief Acceptable values returnable to the parser in %target.cpp.scan_actions.
          */
        enum Name
        {
<|if(sizeof(_terminal_name_list) < 1)
<|error("the terminal list should always have at least one element")
<|end_if
<|if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<|error("mismatch in size of _terminal_name_list and _terminal_index_list")
<|end_if
<|loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    /// "Namespace" for <{class_name}::Nonterminal::Name, which enumerates all nonterminals.
    /// This is used internally by the parser, but is also used by the client to specify which
    /// nonterminal should be parsed by the parser.
    struct Nonterminal
    {
        /** There is one special nonterminal: none_.  This should not be used by the client,
          * as it is only used internally by the parser.
          */
        enum Name
        {
<|if(sizeof(_nonterminal_name_list) < 1)
<|error("the nonterminal list should always have at least one element")
<|end_if
<|if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<|error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<|end_if
<|loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    /** The client should package-up and return a <{class_name}::Token from
      * the code specified by %target.cpp.scan_actions, which delivers the
      * token type and token data to the parser for input.  The constructor
      * takes one or two parameters; the second can be omitted, indicating
      * that the %target.cpp.token_data_default value will be used.
      *
      * @brief Return type for %target.cpp.scan_actions.
      */
    struct Token
    {
        typedef std::uint32_t Id; // TODO -- smallest int
        typedef <{token_data_type} Data;

        Id m_id;
        Data m_data;

        /** @param id Gives the token id, e.g. Terminal::END_ or whatever
          *        other terminals were declared in the primary source.
          * @param data Gives the data associated with this token, e.g. if
          *        you were constructing an AST, data would point to an AST
          *        node constructed during scanning.
          *
          * @brief Constructor for Token struct.
          */
        Token (Id id, Data const &data = <{token_data_default}) : m_id(id), m_data(data) { }
    }; // end of struct <{class_name}::Token

<|if(is_defined(top_of_class))
<|top_of_class

<|end_if
public:

    /// Constructor.  The client can specify parameters in the primary source
    /// via the %target.cpp.constructor_parameters directive.
    <{class_name} (<{constructor_parameters?});
<|if(is_defined(force_virtual_destructor))
    /// Destructor.  The client can cause the destructor to not be declared
    /// virtual by removing the %target.cpp.force_virtual_destructor directive
    /// from the primary source.
<|else
    /// Destructor.  The client can force the destructor to be declared virtual
    /// by specifying the %target.cpp.force_virtual_destructor directive in the
    /// primary source.
<|end_if
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

    /** It is not sufficient to just check the EOF condition on the input
      * source (e.g. the scanner, cin, etc), because the parser may have read,
      * but not consumed, additional lookaheads up to EOF.  Thus checking
      * the input source for EOF condition may give false positives.  This
      * method should be the preferred means to check EOF condition.
      *
      * It should be noted that this may cause the parser to read (but never
      * consume) up to one additional lookahead token, owing to the necessity
      * of checking what the next lookahead token is.
      *
      * @brief Returns true if and only if the next unshifted lookahead
      *        token is Terminal::END_.
      */
    bool IsAtEndOfInput ();

<|if(is_defined(generate_debug_spew_code))
    /// Returns true if and only if "debug spew" is enabled (which prints, to the
    /// debug spew stream, exactly what the parser is doing at each step).  This
    /// method, along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    bool DebugSpewIsEnabled () const { return m_debug_spew_stream != NULL; }
    /// Returns the debug spew stream (see DebugSpewIsEnabled()).  This method,
    /// along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    std::ostream *DebugSpewStream () { return m_debug_spew_stream; }
    /// Sets the debug spew stream (see DebugSpewIsEnabled()).  If NULL is passed
    /// in, then debug spew printing will be disabled.  The default value is NULL.
    /// This method, along with all other debug spew code can be removed by removing
    /// the %target.cpp.generate_debug_spew_code directive from the primary source.
    void SetDebugSpewStream (std::ostream *debug_spew_stream) { m_debug_spew_stream = debug_spew_stream; }
    /// Returns the debug spew prefix string, which may depend on values like the
    /// current filename, line number, etc.
    std::string DebugSpewPrefix () const;

<|end_if
    /** This parser is capable of attempting multiple contiguous parses from the
      * same input source.  The lookahead queue is preserved between calls to
      * Parse().  Therefore, if the input source changes, the lookahead queue
      * must be cleared so that the new input source can be read.  The client
      * must call this method if the input source changes.
      *
      * @brief This method must be called if the input source changes.
      */
    void ResetForNewInput ();

<|define(parse_method_declaration)
    /** The %target.cpp.parse_method_access directive can be used to specify the
      * access level of this method.
      *
      * The %target.cpp.top_of_parse_method_actions and
      * %target.cpp.bottom_of_parse_method_actions directives can be used to specify
      * code to execute at the beginning and end, respectively, of the Parse() method.
      * This includes the ability to enclose the body of the Parse() method within a
      * try {} block, for exception handling (if exceptions are thrown in scan_actions
      * or any reduction rule code, then the %target.cpp.enable_scan_actions_exceptions
      * or %target.cpp.enable_reduction_rule_exceptions directives must be specified
      * respectively; this will cause the parser to catch and rethrow any exceptions
      * thrown by scan_actions or reduction rule code, allowing it to clean up
      * dynamically allocated memory, etc.
      *
      * @param return_token A pointer to the value which will be assigned to upon
      *        successfully parsing the requested nonterminal. If the parse fails,
      *        the value of the %target.cpp.token_data_default directive will
      *        be assigned.
      * @param nonterminal_to_parse The Parse() method can attempt to parse any
      *        nonterminal declared in the primary source.  If unspecified, the
      *        Parse() method will attempt to parse the nonterminal specified by the
      *        %default_parse_nonterminal directive.
      * @return <{class_name}::PRC_SUCCESS if the parse was successful (which includes
      *         occurrences of parse errors which were handled by client-specified
      *         %error-accepting rules), or <{class_name}::PRC_UNHANDLED_PARSE_ERROR
      *         if a parse error was not handled by any %error-accepting rules.
      *
      * @brief This is the main method of the parser; it will attempt to parse
      *        the nonterminal specified.
      */
    ParserReturnCode Parse (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse = Nonterminal::<{_default_parse_nonterminal});
<|end_define
<|if(parse_method_access == "public")
<|parse_method_declaration

<|end_if
<|if(is_defined(bottom_of_class))
<{bottom_of_class}

<|end_if
<|if(parse_method_access == "protected")
protected:

<|parse_method_declaration

<|end_if
private:

<|if(parse_method_access == "private")
<|parse_method_declaration

<|end_if
    // ///////////////////////////////////////////////////////////////////////
    // begin internal trison-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    struct Rule_;
    struct State_;
    struct Transition_;

<|if(is_defined(generate_debug_spew_code))
    // debug spew methods
    void PrintIndented_ (std::ostream &stream, char const *string) const;

    std::ostream *m_debug_spew_stream;

<|end_if
<|if(is_defined(generate_debug_spew_code))
    static char const *const ms_parser_return_code_string_table_[];
    static std::size_t const ms_parser_return_code_string_count_;

    static char const *const ms_token_name_table_[];
    static std::size_t const ms_token_name_count_;
<|end_if

    static std::uint32_t NonterminalStartStateIndex_ (Nonterminal::Name nonterminal);
    ParserReturnCode Parse_ (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse);
    void ThrowAwayToken_ (Token const &token) throw();
    void ThrowAwayTokenData_ (<{token_data_type} const &token_data) throw();
    void ResetForNewInput_ () throw();
    Token Scan_ ()<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};
<|if(is_defined(generate_debug_spew_code))
    // debug spew methods
    void PrintParserStatus_ (std::ostream &out) const;
<|end_if

<|if(is_defined(use_npda))
<|  include("trison.cpp.npda.header.codespec")
<|else
<|  include("trison.cpp.dpda.header.codespec")
<|end_if

    static Rule_ const ms_rule_table_[];
    static std::size_t const ms_rule_count_;
    static State_ const ms_state_table_[];
    static std::size_t const ms_state_count_;
    static Transition_ const ms_transition_table_[];
    static std::size_t const ms_transition_count_;

    // ///////////////////////////////////////////////////////////////////////
    // end of internal trison-generated parser guts
    // ///////////////////////////////////////////////////////////////////////

    friend std::ostream &operator << (std::ostream &stream, <{class_name}::ParserReturnCode parser_return_code);
    friend std::ostream &operator << (std::ostream &stream, <{class_name}::Token const &token);
}; // end of class <{class_name}

<|if(is_defined(generate_debug_spew_code))
std::ostream &operator << (std::ostream &stream, <{class_name}::ParserReturnCode parser_return_code);

std::ostream &operator << (std::ostream &stream, <{class_name}::Token const &token);

<|end_if
<|bottom_of_header_file?
