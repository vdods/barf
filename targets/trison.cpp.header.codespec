<|if(header_filename == implementation_filename)
<|error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|if(!is_defined(return_token_type))
<{define(return_token_type)}<{token_data_type}<{end_define}
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <cassert>
#include <deque>

#if !defined(TrisonCpp_namespace_)
#define TrisonCpp_namespace_
namespace TrisonCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// a bunch of template metaprogramming to intelligently determine
// what type to use for an integer of the given bit width
// /////////////////////////////////////////////////////////////////////////////

template <bool condition, typename Then, typename Else> struct If;
template <typename Then, typename Else> struct If<true,Then,Else> { typedef Then T; };
template <typename Then, typename Else> struct If<false,Then,Else> { typedef Else T; };

template <bool condition> struct Assert;
template <> struct Assert<true> { static bool const v = true; operator bool () { return v; } };

template <typename Sint, typename Uint> struct IntPair { typedef Sint S; typedef Uint U; };

template <int bits> struct Integer {
private:

    typedef
        typename If<bits == 8*sizeof(char),      IntPair<char,unsigned char>,
        typename If<bits == 8*sizeof(short),     IntPair<short,unsigned short>,
        typename If<bits == 8*sizeof(int),       IntPair<int,unsigned int>,
        typename If<bits == 8*sizeof(long),      IntPair<long,unsigned long>,
        typename If<bits == 8*sizeof(long long), IntPair<long long,unsigned long long>,
        Integer<0> // if no match, cause a compile error
        >::T >::T >::T >::T >::T PrivateIntPair;
    static bool const assert_size =
        Assert<bits == 8*sizeof(typename PrivateIntPair::S) &&
               bits == 8*sizeof(typename PrivateIntPair::U)>::v;

public:

    typedef typename PrivateIntPair::S Signed;
    typedef typename PrivateIntPair::U Unsigned;
};
template <> struct Integer<0> { }; // empty for intentional compile errors

typedef Integer<8> ::Signed   Sint8;
typedef Integer<8> ::Unsigned Uint8;
typedef Integer<16>::Signed   Sint16;
typedef Integer<16>::Unsigned Uint16;
typedef Integer<32>::Signed   Sint32;
typedef Integer<32>::Unsigned Uint32;
typedef Integer<8*sizeof(void*)>::Signed   Diff;
typedef Integer<8*sizeof(void*)>::Unsigned Size;

enum
{
    TYPE_SIZE_ASSERTIONS =
        Assert<sizeof(Sint8) == 1>::v &&
        Assert<sizeof(Uint8) == 1>::v &&
        Assert<sizeof(Sint16) == 2>::v &&
        Assert<sizeof(Uint16) == 2>::v &&
        Assert<sizeof(Sint32) == 4>::v &&
        Assert<sizeof(Uint32) == 4>::v &&
        Assert<sizeof(Diff) == sizeof(void*)>::v &&
        Assert<sizeof(Size) == sizeof(void*)>::v
};

} // end of namespace TrisonCpp_
#endif // !defined(TrisonCpp_namespace_)
<|if(is_defined(top_of_header_file))

<|top_of_header_file
<|end_if

class <{class_name}<{if(is_defined(class_inheritance))} : <{class_inheritance}<{end_if}
{
public:

    enum ParserReturnCode
    {
        PRC_SUCCESS = 0,
        PRC_UNHANDLED_PARSE_ERROR = 1
    }; // end of enum <{class_name}::ParserReturnCode

    struct Terminal
    {
        enum Name
        {
<|if(sizeof(_terminal_name_list) < 1)
<|error("the terminal list should always have at least one element")
<|end_if
<|if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<|error("mismatch in size of _terminal_name_list and _terminal_index_list")
<|end_if
<|loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    struct Nonterminal
    {
        enum Name
        {
<|if(sizeof(_nonterminal_name_list) < 1)
<|error("the nonterminal list should always have at least one element")
<|end_if
<|if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<|error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<|end_if
<|loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    struct ParseNonterminal
    {
        enum Name
        {
<|for_each(key, _dpda_nonterminal_start_state_index)
            <{key} = <{_dpda_nonterminal_start_state_index[key]},
<|end_for_each
            // default parse nonterminal
            default_ = <{_default_parse_nonterminal}
        }; // end of enum <{class_name}::ParseNonterminal::Name
    }; // end of struct <{class_name}::ParseNonterminal

    struct Token // TODO: rename to Token
    {
        typedef TrisonCpp_::Uint32 Id; // TODO -- smallest int
        typedef <{token_data_type} Data;

        Id m_id;
        Data m_data;

        Token () : m_id(Nonterminal::none_) { }
        Token (Id id, Data const &data = <{token_data_type_sentinel})
            :
            m_id(id),
            m_data(data)
        {
            assert(m_id != Nonterminal::none_);
        }
    }; // end of struct <{class_name}::Token

<|if(is_defined(top_of_class))
<|top_of_class

<|end_if
public:

    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<|if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<|end_if
<|if(is_defined(parse_method_access))
<|if(!(parse_method_access == "public:" || parse_method_access == "protected:" || parse_method_access == "private:"))
<|error("invalid parse_method_access \"" . parse_method_access . "\"")
<|end_if
<{parse_method_access}

<|end_if
    ParserReturnCode Parse (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_ = ParseNonterminal::<{_default_parse_nonterminal});

private:

    struct Transition_;

    struct StackElement_
    {
        TrisonCpp_::Uint32 m_state_index;
        Token::Data m_token_data;

        StackElement_ ()
            :
            m_state_index(TrisonCpp_::Uint32(-1)),
            m_token_data(<{token_data_type_sentinel})
        { }
        StackElement_ (TrisonCpp_::Uint32 state_index, Token::Data token_data)
            :
            m_state_index(state_index),
            m_token_data(token_data)
        { }
    }; // end of struct <{class_name}::StackElement_

    typedef std::deque<StackElement_> Stack_;
    typedef std::deque<Token> LookaheadQueue_;

    void ThrowAwayToken_ (Token::Data &token);
    void ResetForNewInput_ ();
    Token Scan_ ();

    ParserReturnCode Parse_ (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_);
    void ClearStack_ ();
    void ClearLookaheadQueue_ ();
    Token const &Lookahead_ (LookaheadQueue_::size_type index);
    bool ExerciseTransition_ (Transition_ const &transition);
    Token::Data ExecuteReductionRule_ (TrisonCpp_::Uint32 const rule_index_);

    struct Rule_
    {
        Token::Id m_reduction_nonterminal_token_id;
        TrisonCpp_::Uint32 m_token_count;
        char const *m_description;
    }; // end of struct <{class_name}::Rule_

    struct State_
    {
        TrisonCpp_::Size const m_transition_count; // TODO: smallest int
        Transition_ const *m_transition_table;
        char const *m_description;
    }; // end of struct <{class_name}::State_

    struct Transition_
    {
        enum Type { TT_REDUCE = 1, TT_RETURN, TT_SHIFT, TT_ERROR_PANIC };
        TrisonCpp_::Uint8 m_type;
        TrisonCpp_::Uint32 m_data; // TODO: smallest int
        TrisonCpp_::Uint32 m_lookahead_count; // TODO smallest int
        Token::Id const *m_lookahead_sequence;
    }; // end of struct <{class_name}::Transition_

    Stack_ m_stack_;
    LookaheadQueue_ m_lookahead_queue_;
    bool m_is_in_error_panic_;
<|if(is_defined(generate_debug_spew_code))
    bool m_debug_spew_;

<|end_if

    static Rule_ const ms_rule_table_[];
    static TrisonCpp_::Size const ms_rule_count_;
    static State_ const ms_state_table_[];
    static TrisonCpp_::Size const ms_state_count_;
    static Transition_ const ms_transition_table_[];
    static TrisonCpp_::Size const ms_transition_count_;
    static Token::Id const ms_lookahead_table_[];
    static TrisonCpp_::Size const ms_lookahead_count_;
<|if(is_defined(bottom_of_class))

public:
<{bottom_of_class}
<|end_if
}; // end of class <{class_name}
<|if(is_defined(bottom_of_header_file))

<|bottom_of_header_file
<|end_if
