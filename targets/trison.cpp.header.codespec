<|if(header_filename == implementation_filename)
<|  error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|if(parse_method_access != "public" && parse_method_access != "protected" && parse_method_access != "private")
<|  error("invalid parse_method_access \"" . parse_method_access . "\"; must be one of \"public\", \"protected\", or \"private\"")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{  define(debug_spew_prefix)}"<{class_name}: "<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison<{if(is_defined(generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#pragma once

<{define(use_npda)}true<|end_define

#include <cassert>
#include <cstdint>
#include <deque>
<|if(is_defined(generate_debug_spew_code))
#include <iostream>
<|end_if
<|if(is_defined(use_npda))
#include <map>
#include <memory>
#include <set>
#include <utility>
#include <vector>
<|end_if

<|top_of_header_file?

/// @brief A parser class.
///
/// A parser class generated by trison<{if(is_defined(generate_timestamps))} at <{_creation_timestamp}<{end_if}
/// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}.
///
/// The term "primary source" will be used to refer to the .trison source file from which
/// this file was generated.  Specifically, the primary source is <{_source_filename}.
///
/// The term "client" will be used to refer to the programmer who is writing the trison
/// primary source file to generate a parser (e.g. "the client shouldn't return X from Y"
/// or "the client must provide a way to X and Y").
class <{class_name}<{if(is_defined(class_inheritance))} : <{class_inheritance}<{end_if}
{
public:

    /// Return values for Parse().
    enum ParserReturnCode : std::uint32_t
    {
        /// Indicates the Parse() method returned successfully.
        PRC_SUCCESS = 0,
        /// Indicates an unhandled parse error occurred (i.e. no %error-accepting
        /// rules were encountered).
        PRC_UNHANDLED_PARSE_ERROR,
        /// Indicates that the parse was halted because the number of realized
        /// lookaheads exceeded the max allowable lookahead count (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT,
        /// Indicates that the parse was halted because the realized size of the
        /// lookahead queue exceeded the max allowable lookahead queue size (NPDA
        /// target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE,
        /// Indicates that the parse was halted because the depth of the parse tree
        /// exceeded the max allowable parse tree depth (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH,
        /// Indicates that the parse didn't complete because of some internal error.
        PRC_INTERNAL_ERROR
    }; // end of enum <{class_name}::ParserReturnCode

    /// "Namespace" for <{class_name}::Terminal::Name, which enumerates all valid
    /// token ids which this parser will accept as lookaheads.
    struct Terminal
    {
        /// @brief Acceptable values returnable to the parser in %target.cpp.scan_actions.
        /// There are two special terminals: END_ and ERROR_.
        ///
        /// <{class_name}::Terminal::END_ should be returned in %target.cpp.scan_actions
        /// by the client when the input source has reached the end of input.  The parser
        /// will not request any more input after <{class_name}::Terminal::END_ is received.
        ///
        /// <{class_name}::Terminal::ERROR_ should not ever be used by the client, as
        /// it is used internally by the parser.
        ///
        /// The rest are the terminals as declared in the primary source, and should
        /// be used by the client when returning from %target.cpp.scan_actions.
        enum Name
        {
<|          if(sizeof(_terminal_name_list) < 1)
<|              error("the terminal list should always have at least one element")
<|          end_if
<|          if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<|              error("mismatch in size of _terminal_name_list and _terminal_index_list")
<|          end_if
<|          loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<|          end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    /// "Namespace" for <{class_name}::Nonterminal::Name, which enumerates all nonterminals.
    /// This is used internally by the parser, but is also used by the client to specify which
    /// nonterminal should be parsed by the parser.
    struct Nonterminal
    {
        /// There is one special nonterminal: none_.  This should not be used by the client,
        /// as it is only used internally by the parser.
        enum Name
        {
<|          if(sizeof(_nonterminal_name_list) < 1)
<|              error("the nonterminal list should always have at least one element")
<|          end_if
<|          if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<|              error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<|          end_if
<|          loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<|          end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    /// @brief Return type for %target.cpp.scan_actions.
    ///
    /// The client should package-up and return a <{class_name}::Token from
    /// the code specified by %target.cpp.scan_actions, which delivers the
    /// token type and token data to the parser for input.  The constructor
    /// takes one or two parameters; the second can be omitted, indicating
    /// that the %target.cpp.token_data_default value will be used.
    struct Token
    {
        typedef std::uint32_t Id; // TODO -- smallest int
        typedef <{token_data_type} Data;

        Id m_id;
        Data m_data;

        /// @brief Constructor for Token struct, where m_data will take the default value.
        ///
        /// @param id Gives the token id, e.g. Terminal::END_ or whatever
        ///        other terminals were declared in the primary source.
        Token (Id id) : m_id(id), m_data(<{token_data_default}) { }
        /// @brief Constructor for Token struct, where data is an rvalue reference.
        ///
        /// @param id Gives the token id, e.g. Terminal::END_ or whatever
        ///        other terminals were declared in the primary source.
        /// @param data Gives the data associated with this token, e.g. if
        ///        you were constructing an AST, data would point to an AST
        ///        node constructed during scanning.
        Token (Id id, Data &&data) : m_id(id), m_data(std::move(data)) { }
<|      if(!is_defined(token_data_type_only_uses_move_semantics))
        /// @brief Constructor for Token struct, where data is a const reference.
        ///
        /// @param id Gives the token id, e.g. Terminal::END_ or whatever
        ///        other terminals were declared in the primary source.
        /// @param data Gives the data associated with this token, e.g. if
        ///        you were constructing an AST, data would point to an AST
        ///        node constructed during scanning.
        Token (Id id, Data const &data) : m_id(id), m_data(data) { }
<|      end_if
    }; // end of struct <{class_name}::Token

<|  if(is_defined(top_of_class))
<|  top_of_class

<|  end_if
public:

    /// Constructor.  The client can specify parameters in the primary source
    /// via the %target.cpp.constructor_parameters directive.
    <{class_name} (<{constructor_parameters?});
<|  if(is_defined(force_virtual_destructor))
    /// Destructor.  The client can cause the destructor to not be declared
    /// virtual by removing the %target.cpp.force_virtual_destructor directive
    /// from the primary source.
<|  else
    /// Destructor.  The client can force the destructor to be declared virtual
    /// by specifying the %target.cpp.force_virtual_destructor directive in the
    /// primary source.
<|  end_if
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

    /// @brief Returns true if and only if the next unshifted lookahead
    ///        token is Terminal::END_.
    ///
    /// It is not sufficient to just check the EOF condition on the input
    /// source (e.g. the scanner, cin, etc), because the parser may have read,
    /// but not consumed, additional lookaheads up to EOF.  Thus checking
    /// the input source for EOF condition may give false positives.  This
    /// method should be the preferred means to check EOF condition.
    ///
    /// It should be noted that this may cause the parser to read (but never
    /// consume) up to one additional lookahead token, owing to the necessity
    /// of checking what the next lookahead token is.
    bool IsAtEndOfInput ();
    /// Returns true iff the most recent parse encountered an error (even if it
    /// recovered using error handling rules in the grammar).
    bool HasEncounteredErrorState () const;
    /// Returns the highest value that MaxRealizedLookaheadCount may be before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT error is generated.  The default
    /// is set by the default_max_allowable_lookahead_count directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableLookaheadCount () const;
    /// Returns the maximum number of lookaheads (not including %error tokens) used in
    /// any parser decision so far (this is not the theoretical maximum for the
    /// grammar/npda, it's the maximum only for the states the parser has actually
    /// encountered).
    std::size_t MaxRealizedLookaheadCount () const;
    /// Returns the highest value that MaxRealizedLookaheadQueueSize may be before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_QUEUE_SIZE error is generated.  The default
    /// is set by the default_max_allowable_lookahead_queue_size directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableLookaheadQueueSize () const;
    /// Returns the maximum size of the lookahead queue (including %error tokens) used
    /// in any parser decision so far (this is not the theoretical maximum for the
    /// grammar/npda, it's the maximum only for the states the parser has actually
    /// encountered).
    std::size_t MaxRealizedLookaheadQueueSize () const;
    /// Returns the maximum parse tree depth that may occur before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_PARSE_TREE_DEPTH error is generated.  The default
    /// is set by the default_max_allowable_parse_tree_depth directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableParseTreeDepth () const;
    /// Returns the maximum parse tree depth achieved in any parser decision so far
    /// (this is not the theoretical maximum for the grammar/npda, it's the maximum
    /// only for the states the parser has actually encountered).
    std::uint32_t MaxRealizedParseTreeDepth () const;

    /// Sets the maximum allowable lookahead count.  The initial value is given by
    /// the default_max_allowable_lookahead_count directive defined in trison.cpp.targetspec.
    void SetMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count);
    /// Sets the maximum allowable lookahead queue size.  The initial value is given by
    /// the default_max_allowable_lookahead_queue_size directive defined in trison.cpp.targetspec.
    void SetMaxAllowableLookaheadQueueSize (std::int64_t max_allowable_lookahead_queue_size);
    /// Sets the maximum allowable parse tree depth.  The initial value is given by
    /// the default_max_allowable_parse_tree_depth directive defined in trison.cpp.targetspec.
    void SetMaxAllowableParseTreeDepth (std::int64_t max_allowable_parse_tree_depth);

<|  if(is_defined(generate_debug_spew_code))
    /// Bitflag enums for granular specification of debug spew.
    enum DebugSpewFlags
    {
        // Individual flags
        DSF_START_END_PARSE             = 1 << 0,
        DSF_ITERATION_COUNT             = 1 << 1,
        DSF_SCANNER_ACTION              = 1 << 2,
        DSF_PARSER_ACTION               = 1 << 3,
        DSF_STACK_AND_LOOKAHEADS        = 1 << 4,
        DSF_PROGRAMMER_ERROR            = 1 << 5,
        DSF_PARSE_TREE_MESSAGE          = 1 << 6,
        DSF_LIMIT_EXCEEDED              = 1 << 7,
        DSF_SHIFT_REDUCE_CONFLICT       = 1 << 8,
        DSF_REDUCE_REDUCE_CONFLICT      = 1 << 9,
        DSF_TRANSITION_PROCESSING       = 1 << 10,
        DSF_TRANSITION_EXERCISING       = 1 << 11,
        DSF_HPS_REMOVE_DEFUNCT          = 1 << 12,
        DSF_HPS_NODE_CREATION_DELETION  = 1 << 13,
        // If more are added, then make sure to update DSF_HIGHEST_.
        DSF_HIGHEST_                    = DSF_HPS_NODE_CREATION_DELETION,

        // Pre-defined common sets of bitflags, in ascending order of verbosity.
        DSF__NONE                        = 0,
        DSF__MINIMAL                     = DSF_START_END_PARSE|DSF_SCANNER_ACTION|DSF_PARSER_ACTION|DSF_LIMIT_EXCEEDED|DSF_PROGRAMMER_ERROR,
        DSF__MINIMAL_VERBOSE             = DSF__MINIMAL|DSF_STACK_AND_LOOKAHEADS,
        DSF__INTERMEDIATE                = DSF__MINIMAL_VERBOSE|DSF_ITERATION_COUNT|DSF_PARSE_TREE_MESSAGE|DSF_SHIFT_REDUCE_CONFLICT,
        DSF__ALL                         = DSF_HIGHEST_-1 // This depends on everything being contiguous bitflags
    };

    /// Returns true if and only if "debug spew" is enabled (which prints, to the
    /// debug spew stream, exactly what the parser is doing at each step).  This
    /// method, along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    bool DebugSpewIsEnabled () const { return m_debug_spew_stream_ != NULL; }
    /// Returns the debug spew stream (see DebugSpewIsEnabled()).  This method,
    /// along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    std::ostream *DebugSpewStream () { return m_debug_spew_stream_; }
    /// Sets the debug spew stream (see DebugSpewIsEnabled()).  If NULL is passed
    /// in, then debug spew printing will be disabled.  The default value is NULL.
    /// This method, along with all other debug spew code can be removed by removing
    /// the %target.cpp.generate_debug_spew_code directive from the primary source.
    void SetDebugSpewStream (std::ostream *debug_spew_stream) { m_debug_spew_stream_ = debug_spew_stream; }
    /// Gets the flags which specify which debug spew messages to allow.
    DebugSpewFlags ActiveDebugSpewFlags () const { return m_active_debug_spew_flags_; }
    /// Sets the flags which specify which debug spew messages to allow.  The values
    /// DSF_NONE, DSF_MINIMAL, DSF_INTERMEDIATE, and DSF_ALL are designed to give convenient
    /// common sets of flags.
    void SetActiveDebugSpewFlags (DebugSpewFlags active_debug_spew_flags) { m_active_debug_spew_flags_ = active_debug_spew_flags; }
    /// Returns the debug spew prefix string, which may depend on values like the
    /// current filename, line number, etc.
    std::string DebugSpewPrefix () const;

<|  end_if
    /// @brief This method must be called if the input source changes.
    ///
    /// This parser is capable of attempting multiple contiguous parses from the
    /// same input source.  The lookahead queue is preserved between calls to
    /// Parse().  Therefore, if the input source changes, the lookahead queue
    /// must be cleared so that the new input source can be read.  The client
    /// must call this method if the input source changes.
    void ResetForNewInput ();

<|  define(parse_method_declaration)
    /// @brief This is the main method of the parser; it will attempt to parse
    ///        the nonterminal specified.
    ///
    /// The %target.cpp.parse_method_access directive can be used to specify the
    /// access level of this method.
    ///
    /// The %target.cpp.top_of_parse_method_actions and
    /// %target.cpp.bottom_of_parse_method_actions directives can be used to specify
    /// code to execute at the beginning and end, respectively, of the Parse() method.
    /// This includes the ability to enclose the body of the Parse() method within a
    /// try {} block, for exception handling (if exceptions are thrown in scan_actions
    /// or any reduction rule code, then the %target.cpp.enable_scan_actions_exceptions
    /// or %target.cpp.enable_reduction_rule_exceptions directives must be specified
    /// respectively; this will cause the parser to catch and rethrow any exceptions
    /// thrown by scan_actions or reduction rule code, allowing it to clean up
    /// dynamically allocated memory, etc.
    ///
    /// @param return_token A pointer to the value which will be assigned to upon
    ///        successfully parsing the requested nonterminal. If the parse fails,
    ///        the value of the %target.cpp.token_data_default directive will
    ///        be assigned.
    /// @param nonterminal_to_parse The Parse() method can attempt to parse any
    ///        nonterminal declared in the primary source.  If unspecified, the
    ///        Parse() method will attempt to parse the nonterminal specified by the
    ///        %default_parse_nonterminal directive.
    /// @return <{class_name}::PRC_SUCCESS if the parse was successful (which includes
    ///         occurrences of parse errors which were handled by client-specified
    ///         %error-accepting rules), or <{class_name}::PRC_UNHANDLED_PARSE_ERROR
    ///         if a parse error was not handled by any %error-accepting rules.
    ParserReturnCode Parse (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse = Nonterminal::<{_default_parse_nonterminal});
<|  end_define
<|  if(parse_method_access == "public")
<|  parse_method_declaration

<|  end_if
<|  if(is_defined(bottom_of_class))
<{bottom_of_class}

<|  end_if
<|  if(parse_method_access == "protected")
protected:

<|  parse_method_declaration

<|  end_if
private:

<|  if(parse_method_access == "private")
<|  parse_method_declaration

<|  end_if
    // ///////////////////////////////////////////////////////////////////////
    // begin internal trison-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    std::int64_t m_max_allowable_lookahead_count;
    std::int64_t m_max_allowable_lookahead_queue_size;
    std::int64_t m_max_allowable_parse_tree_depth;

<|  if(is_defined(generate_debug_spew_code))
    // debug spew methods
    void PrintIndented_ (std::ostream &stream, char const *string) const;

    std::ostream *m_debug_spew_stream_;
    DebugSpewFlags m_active_debug_spew_flags_;

<|  end_if
    static char const *const ms_parser_return_code_string_table_[];
    static std::size_t const ms_parser_return_code_string_count_;

    static char const *const ms_token_name_table_[];
    static std::size_t const ms_token_name_count_;

    static std::uint32_t NonterminalStartStateIndex_ (Nonterminal::Name nonterminal);
    ParserReturnCode Parse_ (Token::Data *return_token, Nonterminal::Name nonterminal_to_parse);
    void ThrowAwayToken_ (Token &&token) throw();
    void ThrowAwayTokenData_ (Token::Data &&token_data) throw();
    Token::Data InsertLookaheadErrorActions_ (Token const &noconsume_lookahead_token);
    Token::Data DiscardLookaheadActions_ (Token &&consume_stack_top_error_token, Token &&consume_lookahead_token);
    Token::Data PopStack1Actions_ (std::vector<Token> &consume_stack_top_tokens, Token &&consume_lookahead_token);
    Token::Data PopStack2Actions_ (std::vector<Token> &consume_stack_top_tokens, Token const &noconsume_lookahead_token);
    Token::Data RunNonassocErrorActions_ (Token const &lookahead);
    void ResetForNewInput_ () throw();
    Token Scan_ ()<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};
<|  if(is_defined(generate_debug_spew_code))
    // debug spew methods
    void PrintParserStatus_ (std::ostream &out) const;
<|  end_if

<|  if(is_defined(use_npda))
<|      include("trison.cpp.npda.header.codespec")
<|  else
    DPDA TARGET IS DEPRECATED -- TODO LATER
<|  end_if

    // ///////////////////////////////////////////////////////////////////////
    // end of internal trison-generated parser guts
    // ///////////////////////////////////////////////////////////////////////

    friend std::ostream &operator << (std::ostream &stream, <{class_name}::ParserReturnCode parser_return_code);
<|if(is_defined(generate_debug_spew_code))
    friend std::ostream &operator << (std::ostream &stream, <{class_name}::Token const &token);
<|end_if
}; // end of class <{class_name}

std::ostream &operator << (std::ostream &stream, <{class_name}::ParserReturnCode parser_return_code);
<|if(is_defined(generate_debug_spew_code))

// This should really be defined for <{class_name}::Token::Id, since that's all it prints,
// but there's a difficulty because <{class_name}::Token::Id is really just std::uint32_t,
// so there would need to be some sort of strong typedef involved for this to be well-defined.
std::ostream &operator << (std::ostream &stream, <{class_name}::Token const &token);
<|if(is_defined(ostream_print_token_data))
std::ostream &operator << (std::ostream &stream, <{class_name}::Token::Data const &token_data);
<|end_if
<|if(0)

// This is for use in debugging ParseStackTreeNode_ object leaks
template <typename T>
std::ostream &operator << (std::ostream &out, std::set<T> const &s)
{
    out << "{ ";
    for (typename std::set<T>::const_iterator it = s.begin(), it_end = s.end(); it != it_end; ++it)
        out << *it << ", ";
    out << '}';
    return out;
}
<|end_if
<|end_if
<|bottom_of_header_file?
