<|if(header_filename == implementation_filename)
<|error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|if(!is_defined(return_token_type))
<{define(return_token_type)}<{token_data_type}<{end_define}
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <cassert>
#include <deque>
#include <iostream> // TEMP
#include <map>
#include <vector>

#if !defined(TrisonCpp_namespace_)
#define TrisonCpp_namespace_
namespace TrisonCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// a bunch of template metaprogramming to intelligently determine
// what type to use for an integer of the given bit width
// /////////////////////////////////////////////////////////////////////////////

template <bool condition_, typename Then_, typename Else_> struct If_;
template <typename Then_, typename Else_> struct If_<true,Then_,Else_> { typedef Then_ T_; };
template <typename Then_, typename Else_> struct If_<false,Then_,Else_> { typedef Else_ T_; };

template <bool condition_> struct Assert_;
template <> struct Assert_<true> { static bool const v_ = true; operator bool () { return v_; } };

template <typename Sint_, typename Uint_> struct IntPair_ { typedef Sint_ S_; typedef Uint_ U_; };

template <int bits_> struct Integer_ {
private:

    typedef
        typename If_<bits_ == 8*sizeof(char),      IntPair_<char,unsigned char>,
        typename If_<bits_ == 8*sizeof(short),     IntPair_<short,unsigned short>,
        typename If_<bits_ == 8*sizeof(int),       IntPair_<int,unsigned int>,
        typename If_<bits_ == 8*sizeof(long),      IntPair_<long,unsigned long>,
        typename If_<bits_ == 8*sizeof(long long), IntPair_<long long,unsigned long long>,
        Integer_<0> // if no match, cause a compile error
        >::T_ >::T_ >::T_ >::T_ >::T_ PrivateIntPair_;
    static bool const assert_size =
        Assert_<bits_ == 8*sizeof(typename PrivateIntPair_::S_) &&
                bits_ == 8*sizeof(typename PrivateIntPair_::U_)>::v_;

public:

    typedef typename PrivateIntPair_::S_ Signed_;
    typedef typename PrivateIntPair_::U_ Unsigned_;
};
template <> struct Integer_<0> { }; // empty for intentional compile errors

// /////////////////////////////////////////////////////////////////////////////
// typedefs for the integer types used in the "cpp" trison target
// /////////////////////////////////////////////////////////////////////////////

typedef Integer_<8> ::Signed_   Sint8_;
typedef Integer_<8> ::Unsigned_ Uint8_;
typedef Integer_<16>::Signed_   Sint16_;
typedef Integer_<16>::Unsigned_ Uint16_;
typedef Integer_<32>::Signed_   Sint32_;
typedef Integer_<32>::Unsigned_ Uint32_;
typedef Integer_<8*sizeof(void*)>::Signed_   Diff_;
typedef Integer_<8*sizeof(void*)>::Unsigned_ Size_;

enum
{
    TYPE_SIZE_ASSERTIONS_ =
        Assert_<sizeof(Sint8_) == 1>::v_ &&
        Assert_<sizeof(Uint8_) == 1>::v_ &&
        Assert_<sizeof(Sint16_) == 2>::v_ &&
        Assert_<sizeof(Uint16_) == 2>::v_ &&
        Assert_<sizeof(Sint32_) == 4>::v_ &&
        Assert_<sizeof(Uint32_) == 4>::v_ &&
        Assert_<sizeof(Diff_) == sizeof(void*)>::v_ &&
        Assert_<sizeof(Size_) == sizeof(void*)>::v_
};

template <typename T_>
class WeakReference_
{
public:

    WeakReference_ () : m_instance_(NULL) { }
    WeakReference_ (T_ *pointer) : m_instance_(new Instance_<T_>(pointer)) { m_instance_->IncrementReferenceCount(); }
    WeakReference_ (WeakReference_<T_> const &r) { m_instance_ = r.m_instance_; if (m_instance_ != NULL) m_instance_->IncrementReferenceCount(); }
    ~WeakReference_ () { if (m_instance_ != NULL) m_instance_->DecrementReferenceCount(); }
    WeakReference_ &operator = (WeakReference_<T_> const &r)
    {
        if (m_instance_ != NULL)
            m_instance_->DecrementReferenceCount();
        m_instance_ = r.m_instance_;
        if (m_instance_ != NULL)
            m_instance_->IncrementReferenceCount();
        return *this;
    }

    T_ &operator * () { assert(m_instance_ != NULL); return **m_instance_; }
    T_ const &operator * () const { assert(m_instance_ != NULL); return **m_instance_; }

    T_ *operator -> () { assert(m_instance_ != NULL); return &**m_instance_; }
    T_ const *operator -> () const { assert(m_instance_ != NULL); return &**m_instance_; }

    bool IsValid_ () const { return m_instance_ != NULL; }
    void Release_ () { if (m_instance_ != NULL) { m_instance_->DecrementReferenceCount(); m_instance_ = NULL; } }

    bool InstanceIsValid_ () const { assert(m_instance_ != NULL); return m_instance_->IsValid_(); }
    void InstanceRelease_ () { assert(m_instance_ != NULL); m_instance_->Release_(); }
    Uint32_ ReferenceCount_ () const { assert(m_instance_ != NULL); return m_instance_->ReferenceCount_(); }

private:

    template <typename U_>
    class Instance_
    {
    public:

        Instance_ (U_ *pointer) : m_pointer_(pointer), m_reference_count_(0) { /*std::cerr << __PRETTY_FUNCTION__ << std::endl;*/ }
        ~Instance_ () { assert(m_reference_count_ == 0); /*std::cerr << __PRETTY_FUNCTION__ << std::endl;*/ }

        U_ &operator * () { assert(m_pointer_ != NULL && "dereferenced a NULL pointer"); return *m_pointer_; }
        U_ const &operator * () const { assert(m_pointer_ != NULL && "dereferenced a NULL pointer"); return *m_pointer_; }

        bool IsValid_ () const { return m_pointer_ != NULL; }
        void Release_ () { m_pointer_ = NULL; }
        Uint32_ ReferenceCount_ () const { return m_reference_count_; }

        void IncrementReferenceCount () { assert(m_reference_count_ < Uint32_(-1)); /*std::cerr << __PRETTY_FUNCTION__ << std::endl;*/ ++m_reference_count_; }
        void DecrementReferenceCount () { assert(m_reference_count_ > 0); /*std::cerr << __PRETTY_FUNCTION__ << std::endl;*/ if (--m_reference_count_ == 0) delete this; }

    private:

        Instance_ (Instance_ const &) { assert(false && "this should never be called"); }
        void operator = (Instance_ const &) { assert(false && "this should never be called"); }

        U_ *m_pointer_;
        Uint32_ m_reference_count_;
    }; // end of class TrisonCpp_::WeakReference_<T_>::Instance_<U_>

    Instance_<T_> *m_instance_;
}; // end of class TrisonCpp_::WeakReference_<T_>

// TODO: enums should be in TrisonCpp_ namespace

enum BranchListType_ { BLT_PARSER_ = 0, BLT_ACTION_, BLT_COUNT_ };

template <typename ListNodeSubclass_>
struct ListNode_
{
public:

    ~ListNode_ ()
    {
        // remove this node from its list if it's a body
        if (NodeClass_() == CT_BODY_)
            Remove_();
        // now ensure this node is a floaty or it is a head or tail of an empty list
        assert(NodeClass_() == CT_FLOATY_ ||
               NodeClass_() == CT_HEAD_ && m_next_->NodeClass_() == CT_TAIL_ && m_next_->m_prev_ == this ||
               NodeClass_() == CT_TAIL_ && m_prev_->NodeClass_() == CT_HEAD_ && m_prev_->m_next_ == this);
    }

    bool IsAnElement_ () const { return NodeClass_() == CT_BODY_; }
    ListNodeSubclass_ *Prev_ ()
    {
        assert(NodeClass_() != CT_HEAD_ && "can't call Prev_() on a head node");
        return m_prev_->NodeClass_() != CT_HEAD_ ? m_prev_ : NULL;
    }
    ListNodeSubclass_ const *Prev_ () const
    {
        assert(NodeClass_() != CT_HEAD_ && "can't call Prev_() on a head node");
        return m_prev_->NodeClass_() != CT_HEAD_ ? m_prev_ : NULL;
    }
    ListNodeSubclass_ *Next_ ()
    {
        assert(NodeClass_() != CT_TAIL_ && "can't call Next_() on a tail node");
        return m_next_->NodeClass_() != CT_TAIL_ ? m_next_ : NULL;
    }
    ListNodeSubclass_ const *Next_ () const
    {
        assert(NodeClass_() != CT_TAIL_ && "can't call Next_() on a tail node");
        return m_next_->NodeClass_() != CT_TAIL_ ? m_next_ : NULL;
    }

    void InsertBefore_ (ListNodeSubclass_ *node)
    {
        assert(node != NULL);
        assert(node->NodeClass_() == CT_FLOATY_ && "can't insert a node that is already in a list");
        assert(NodeClass_() == CT_BODY_ || NodeClass_() == CT_TAIL_ && "can't insert a node before a head or a floaty");
        assert(node != this && "can't insert a node before itself");
        m_prev_->m_next_ = node;
        node->m_prev_ = m_prev_;
        node->m_next_ = static_cast<ListNodeSubclass_ *>(this);
        m_prev_ = node;
    }
    void InsertAfter_ (ListNodeSubclass_ *node)
    {
        assert(node != NULL);
        assert(node->NodeClass_() == CT_FLOATY_ && "can't insert a node that is already in a list");
        assert(NodeClass_() == CT_HEAD_ || NodeClass_() == CT_BODY_ && "can't insert a node after a tail or a floaty");
        assert(node != this && "can't insert a node after itself");
        m_next_->m_prev_ = node;
        node->m_next_ = m_next_;
        node->m_prev_ = static_cast<ListNodeSubclass_ *>(this);
        m_next_ = node;
    }
    ListNodeSubclass_ *Remove_ ()
    {
        assert(NodeClass_() == CT_BODY_);
        assert(m_prev_->m_next_ == this);
        assert(m_next_->m_prev_ == this);
        m_prev_->m_next_ = m_next_;
        m_next_->m_prev_ = m_prev_;
        m_next_ = NULL;
        m_prev_ = NULL;
        assert(NodeClass_() == CT_FLOATY_);
        return static_cast<ListNodeSubclass_ *>(this);
    }

protected:

    ListNode_ () : m_prev_(NULL), m_next_(NULL) { assert(NodeClass_() == CT_FLOATY_); }

private:

    enum ClassType_ { CT_FLOATY_ = 0|0, CT_HEAD_ = 0|1, CT_TAIL_ = 2|0, CT_BODY_ = 2|1 };

    ClassType_ NodeClass_ () const { return ClassType_((m_prev_ != NULL ? 2 : 0) | (m_next_ != NULL ? 1 : 0)); }

    ListNodeSubclass_ *m_prev_;
    ListNodeSubclass_ *m_next_;

    template <typename ElementType_> friend struct List_;
}; // end of struct TrisonCpp_::ListNode_<ListNodeSubclass_>

template <typename ElementType_>
struct List_
{
    List_ ()
    {
        assert(sizeof(m_head_) == 2*sizeof(void *)); // TODO: make into compile-time asserts
        assert(sizeof(m_tail_) == 2*sizeof(void *));
        // these two casts are technically unsafe, but we'll be responsible.
        m_head_.m_next_ = static_cast<ElementType_ *>(&m_tail_);
        m_tail_.m_prev_ = static_cast<ElementType_ *>(&m_head_);
        assert(m_head_.NodeClass_() == ListNode_<ElementType_>::CT_HEAD_);
        assert(m_tail_.NodeClass_() == ListNode_<ElementType_>::CT_TAIL_);
    }
    ~List_ () { assert(IsEmpty_() && "list not empty upon destruction"); }

    bool IsEmpty_ () const
    {
        assert(m_head_.NodeClass_() == ListNode_<ElementType_>::CT_HEAD_);
        assert(m_tail_.NodeClass_() == ListNode_<ElementType_>::CT_TAIL_);
        return m_head_.m_next_ == &m_tail_;
    }
    ElementType_ *Front_ () { return m_head_.Next_(); }
    ElementType_ const *Front_ () const { return m_head_.Next_(); }
    ElementType_ *Back_ () { return m_tail_.Prev_(); }
    ElementType_ const *Back_ () const { return m_tail_.Prev_(); }

    void Prepend_ (List_<ElementType_> &list)
    {
        assert(&list != this);
        if (list.IsEmpty_())
            return;
        // put the contents of the source list before the first element
        list.m_head_.m_next_->m_prev_ = static_cast<ElementType_ *>(&m_head_);
        list.m_tail_.m_prev_->m_next_ = m_head_.m_next_;
        m_head_.m_next_->m_prev_ = list.m_tail_.m_prev_;
        m_head_.m_next_ = list.m_head_.m_next_;
        // empty the source list
        list.m_head_.m_next_ = static_cast<ElementType_ *>(&list.m_tail_);
        list.m_tail_.m_prev_ = static_cast<ElementType_ *>(&list.m_head_);
    }
    void Append_ (List_<ElementType_> &list)
    {
        assert(&list != this);
        if (list.IsEmpty_())
            return;
        // put the contents of the source list after the last element
        list.m_tail_.m_prev_->m_next_ = static_cast<ElementType_ *>(&m_tail_);
        list.m_head_.m_next_->m_prev_ = m_tail_.m_prev_;
        m_tail_.m_prev_->m_next_ = list.m_head_.m_next_;
        m_tail_.m_prev_ = list.m_tail_.m_prev_;
        // empty the source list
        list.m_head_.m_next_ = static_cast<ElementType_ *>(&list.m_tail_);
        list.m_tail_.m_prev_ = static_cast<ElementType_ *>(&list.m_head_);
    }
    void Prepend_ (ElementType_ *node) { m_head_.InsertAfter_(node); }
    void Append_ (ElementType_ *node) { m_tail_.InsertBefore_(node); }
    ElementType_ *RemoveFront_ () { assert(Front_() != NULL && "can't remove from an empty list"); return Front_()->Remove_(); }
    ElementType_ *RemoveBack_ () { assert(Back_() != NULL && "can't remove from an empty list"); return Back_()->Remove_(); }

private:

    ListNode_<ElementType_> m_head_;
    ListNode_<ElementType_> m_tail_;
}; // end of struct TrisonCpp_::List_<ElementType_>

class Npda_
{
protected:

    struct Action_;
    struct ActionBranch_ : public ListNode_<ActionBranch_> { protected: ActionBranch_ () { } };
    struct ParserBranch_ : public ListNode_<ParserBranch_> { protected: ParserBranch_ () { } };
    struct Reduce_;
    struct Rule_;
    struct Shift_;
    struct State_;
    struct Transition_;

    typedef std::vector<State_ const *> StateStack_;
    typedef Uint32_ TokenId_;
    enum { none__ = 0 }; // single known value for built-in nonterminal

    enum Associativity_
    {
        ASSOCIATIVITY_LEFT_ = 0,
        ASSOCIATIVITY_NONASSOC_,
        ASSOCIATIVITY_RIGHT_
    }; // end of enum TrisonCpp_::Npda_::Associativity_
    struct Precedence_
    {
        Uint32_ m_level_;
        Associativity_ m_associativity_;
        char const *m_name_;
    }; // end of struct TrisonCpp_::Npda_::Precedence_
    struct Rule_
    {
        TokenId_ m_reduction_nonterminal_token_id_;
        Precedence_ const *m_precedence_;
        Uint32_ m_token_count_;
        char const *m_description_;

        struct ReduceReduceConflict_
        {
            static bool IsHigherPriority_ (Rule_ const &left, Rule_ const &right)
            {
                // order by higher precedence, and then lower rule index
                return left.m_precedence_->m_level_ > right.m_precedence_->m_level_
                       ||
                       left.m_precedence_->m_level_ == right.m_precedence_->m_level_ &&
                       &left < &right;
            }
        }; // end of struct TrisonCpp_::Npda_::Rule_::ReduceReduceConflict_
        struct ShiftReduceConflict_
        {
            static bool IsHigherPriority_ (Rule_ const &left, Rule_ const &right)
            {
                return left.m_precedence_->m_level_ > right.m_precedence_->m_level_;
            }
            static bool IsEqualPriority_ (Rule_ const &left, Rule_ const &right)
            {
                return left.m_precedence_->m_level_ == right.m_precedence_->m_level_;
            }

            struct Order_
            {
                bool operator () (Rule_ const *left, Rule_ const *right)
                {
                    // prefer NULL over non-NULL rules, and then go by Rule_::ShiftReduceConflict_::IsHigherPriority_
                    if (left == NULL && right == NULL)
                        return false;
                    else if (left == NULL && right != NULL)
                        return true;
                    else if (left != NULL && right == NULL)
                        return false;
                    else
                        return Rule_::ShiftReduceConflict_::IsHigherPriority_(*left, *right);
                }
            }; // end of struct TrisonCpp_::Npda_::Rule_::Order_
        }; // end of struct TrisonCpp_::Npda_::Rule_::ShiftReduceConflict_
    }; // end of struct TrisonCpp_::Npda_::Rule_
    struct State_
    {
        Rule_ const *m_associated_rule_;
        Uint32_ m_associated_rule_stage_;
        TokenId_ m_associated_nonterminal_token_id_;
        Size_ m_transition_count_;
        Transition_ const *m_transition_table_;
        char const *m_description_;
    }; // end of struct TrisonCpp_::Npda_::State_
    struct Transition_
    {
        enum Type_ { TT_EPSILON_ = 0, TT_REDUCE_, TT_RETURN_, TT_SHIFT_ };
        Uint8_ m_transition_type_;
        Uint32_ m_transition_data_;
        State_ const *m_target_state_;
    }; // end of struct TrisonCpp_::Npda_::Transition_
    struct TreeNode_
    {
        enum TreeNodeType_ { ACTION_ = 0, BRANCH_, REDUCE_, SHIFT_ };
        TreeNodeType_ const m_tree_node_type_;
        Action_ *m_parent_;

        TreeNode_ (TreeNodeType_ tree_node_type)
            :
            m_tree_node_type_(tree_node_type),
            m_parent_(NULL)
        { }
    }; // end of struct TrisonCpp_::Npda_::TreeNode_
    typedef WeakReference_<Shift_> ShiftReference_;
    typedef std::map<Rule_ const *, ShiftReference_, Rule_::ShiftReduceConflict_::Order_> ShiftReferenceMap_;
    struct Branch_ : public TreeNode_, public ActionBranch_, public ParserBranch_
    {
        typedef std::vector<ShiftReference_> ShiftReferenceList_;
        ShiftReferenceList_ m_shift_reference_list_;
        StateStack_ m_state_stack_;
        TokenId_ m_lookahead_nonterminal_token_id_;
        bool m_is_epsilon_closed_;

        Branch_ (State_ const *starting_state)
            :
            TreeNode_(BRANCH_),
            m_lookahead_nonterminal_token_id_(none__),
            m_is_epsilon_closed_(false)
        {
            assert(starting_state != NULL);
            m_state_stack_.push_back(starting_state);
        }
        ~Branch_ ()
        {
//             std::cerr << "~Branch(); this = " << this << std::endl;
            Action_ *parent = m_parent_;
            if (parent != NULL) // a NULL parent is possible with floaty branches
            {
                parent->RemoveChild_(this);
                assert(m_parent_ == NULL);
            }
            // iterate until we're out of parents, we hit the root node,
            // or there are other children which rely on the parent to live.
            while (parent != NULL && parent->m_parent_ != NULL && !parent->HasChildren_())
            {
                TreeNode_ *node = parent;
                parent = node->m_parent_;
                parent->RemoveChild_(node);
                assert(node != this);
                delete node;
            }
            // release all the rule references.  if the ref count is about to go to
            // 1, inform the Shift_ (if it exists) that it should resolve conflicts.
            for (ShiftReferenceList_::iterator it = m_shift_reference_list_.begin(), it_end = m_shift_reference_list_.end();
                 it != it_end;
                 ++it)
            {
                ShiftReference_ &shift_reference = *it;
                assert(shift_reference.IsValid_());
                if (shift_reference.ReferenceCount_() == 2 && shift_reference.InstanceIsValid_())
                {
                    Shift_ *shift = &*shift_reference;
                    assert(shift != NULL);
                    assert(shift->m_parent_ != NULL);
                    shift_reference.Release_();
                    shift->DestroyAllUnusedInRuleRange_();
                    shift->m_parent_->ResolveShiftReduceConflicts_();
                }
            }
        }

        State_ const &Top_ () const
        {
            assert(!m_state_stack_.empty());
            assert(m_state_stack_.back() != NULL);
            return *m_state_stack_.back();
        }
        Branch_ *Clone_ () const
        {
            Branch_ *cloned = new Branch_(m_state_stack_, m_lookahead_nonterminal_token_id_);
            assert(cloned->m_parent_ == NULL);
            // duplicate the shift reference list
            for (ShiftReferenceList_::const_iterator it = m_shift_reference_list_.begin(),
                                                    it_end = m_shift_reference_list_.end();
                 it != it_end;
                 ++it)
            {
                ShiftReference_ const &shift_reference = *it;
                assert(shift_reference.IsValid_());
                assert(shift_reference.ReferenceCount_() >= 1);
                // only copy the reference if it's valid
                if (shift_reference.InstanceIsValid_())
                {
                    assert(&*shift_reference != NULL);
                    cloned->m_shift_reference_list_.push_back(shift_reference);
                }
            }
            return cloned;
        }
        void RemoveFromBranchList_ (BranchListType_ branch_list_type)
        {
            assert(branch_list_type == BLT_PARSER_ || branch_list_type == BLT_ACTION_);
            if (branch_list_type == BLT_PARSER_)
                ParserBranch_::Remove_();
            else // branch_list_type == BLT_ACTION_
                ActionBranch_::Remove_();
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << (m_is_epsilon_closed_ ? 'c' : '_') << " branch " << this;
            for (StateStack_::const_iterator it = m_state_stack_.begin(), it_end = m_state_stack_.end();
                 it != it_end;
                 ++it)
            {
                State_ const *stack_state = *it;
                assert(stack_state != NULL);
                stream << ' ' << (stack_state - state_table);
            }
            if (m_lookahead_nonterminal_token_id_ != none__)
                stream << " (" << m_lookahead_nonterminal_token_id_ << ')';
            stream << " \"" << Top_().m_description_ << '\"' << std::endl;
        }

    private:

        // for use only by Clone_()
        Branch_ (StateStack_ const &state_stack, TokenId_ lookahead_nonterminal_token_id)
            :
            TreeNode_(BRANCH_),
            m_state_stack_(state_stack),
            m_lookahead_nonterminal_token_id_(lookahead_nonterminal_token_id),
            m_is_epsilon_closed_(false)
        {
            assert(!m_state_stack_.empty());
        }
    }; // end of struct TrisonCpp_::Npda_::Branch_
    struct ActionBranchList_ : public List_<ActionBranch_>
    {
        void Prepend_ (Branch_ *node) { List_<ActionBranch_>::Prepend_(static_cast<ActionBranch_ *>(node)); }
        void Append_ (Branch_ *node) { List_<ActionBranch_>::Append_(static_cast<ActionBranch_ *>(node)); }
    }; // end of struct TrisonCpp_::Npda_::ActionBranchList_
    struct ParserBranchList_ : public List_<ParserBranch_>
    {
        void Prepend_ (Branch_ *node) { List_<ParserBranch_>::Prepend_(static_cast<ParserBranch_ *>(node)); }
        void Append_ (Branch_ *node) { List_<ParserBranch_>::Append_(static_cast<ParserBranch_ *>(node)); }
    }; // end of struct TrisonCpp_::Npda_::ParserBranchList_
    struct Action_ : public TreeNode_
    {
        // TODO: make non-public
        // there can only ever be up to 2 children, one of each type.
        Reduce_ *m_reduce_child_;
        Shift_ *m_shift_child_;
        ActionBranchList_ m_action_branch_list_;

        Action_ (TreeNodeType_ tree_node_type)
            :
            TreeNode_(tree_node_type),
            m_reduce_child_(NULL),
            m_shift_child_(NULL)
        { }
        ~Action_ ()
        {
//             std::cerr << "~Action(); this = " << this << std::endl;

            // delete this and all children out to the leaves
            if (m_parent_ != NULL)
                m_parent_->RemoveChild_(this);

            delete m_reduce_child_;
            delete m_shift_child_;

            ActionBranch_ *action_branch;
            while ((action_branch = m_action_branch_list_.Front_()) != NULL)
            {
                Branch_ *branch = static_cast<Branch_ *>(static_cast<ActionBranch_ *>(action_branch));
                branch->m_parent_ = NULL; // to stop ~Branch_() from interfering
                delete branch;
                assert(m_action_branch_list_.Front_() != action_branch);
            }
        }

        bool HasChildren_ () const { return m_reduce_child_ != NULL || m_shift_child_ != NULL || !m_action_branch_list_.IsEmpty_(); }
        bool AssertActionAndParserBranchListsAreConsistent_ (ParserBranchList_ const &parser_branch_list) const
        {
            ParserBranch_ const *parser_branch = parser_branch_list.Front_();
            AssertActionAndParserBranchListsAreConsistent_(parser_branch);
            return true; // dummy value so this can be wrapped in assert()
        }
        TreeNode_ *SingleChild_ ()
        {
            if (m_reduce_child_ != NULL && m_shift_child_ == NULL && m_action_branch_list_.IsEmpty_())
                return m_reduce_child_;
            else if (m_reduce_child_ == NULL && m_shift_child_ != NULL && m_action_branch_list_.IsEmpty_())
                return m_shift_child_;
            else if (m_reduce_child_ == NULL && m_shift_child_ == NULL && !m_action_branch_list_.IsEmpty_() && m_action_branch_list_.Front_() == m_action_branch_list_.Back_())
                return static_cast<Branch_ const *>(m_action_branch_list_.Front_());
            else
                return NULL;
        }
        ActionBranch_ *LastSubordinateBranch_ ()
        {
            if (m_shift_child_ != NULL)
            {
                ActionBranch_ *last_subordinate_branch = m_shift_child_->LastSubordinateBranch_();
                if (last_subordinate_branch != NULL)
                    return last_subordinate_branch;
            }
            if (m_reduce_child_ != NULL)
            {
                ActionBranch_ *last_subordinate_branch = m_reduce_child_->LastSubordinateBranch_();
                if (last_subordinate_branch != NULL)
                    return last_subordinate_branch;
            }
            {
                ActionBranch_ *last_subordinate_branch = m_action_branch_list_.Back_();
                if (last_subordinate_branch != NULL)
                    return last_subordinate_branch;
            }
            return NULL;
        }
        bool ReduceActionWouldSucceed_ (Rule_ const *reduction_rule) const
        {
            assert(reduction_rule != NULL);
            assert(m_shift_child_ == NULL && "this should never happen");
            return m_reduce_child_ == NULL || !Rule_::ReduceReduceConflict_::IsHigherPriority_(*m_reduce_child_->m_reduction_rule_, *reduction_rule);
        }

        void AddChildBranch_ (Branch_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == NULL);
            assert(!child->ActionBranch_::IsAnElement_());
            assert(!child->ParserBranch_::IsAnElement_());
            assert(child->m_tree_node_type_ == BRANCH_);
            child->m_parent_ = this;
            // no need to call ResolveShiftReduceConflicts_() because it is
            // a no-op when the action branch list is non-empty.
        }
        void RemoveChild_ (TreeNode_ *child)
        {
            assert(child != NULL);
            assert(child->m_parent_ == this);
            switch (child->m_tree_node_type_)
            {
                default:
                case ACTION_: assert(false && "this should never happen"); break;
                case BRANCH_: static_cast<Branch_ *>(child)->RemoveFromBranchList_(BLT_ACTION_); break;
                case REDUCE_: assert(child == m_reduce_child_); m_reduce_child_ = NULL; if (m_shift_child_ != NULL) m_shift_child_->ClearRuleRange_(); break;
                case SHIFT_ : assert(child == m_shift_child_); m_shift_child_ = NULL; break;
            }
            child->m_parent_ = NULL;
            ResolveShiftReduceConflicts_();
        }
        void AddEpsilonClosure_ (Branch_ &source_branch, StateStack_ &extra_state_stack)
        {
            assert(source_branch.m_parent_ == this);
            // TODO: here is where to check for branch collisions

            // clone the source branch, push the states contained in extra_state_stack.
            Branch_ *closed_branch = source_branch.Clone_();
            assert(closed_branch->m_parent_ == NULL);
            closed_branch->m_is_epsilon_closed_ = true;
            closed_branch->m_state_stack_.insert(closed_branch->m_state_stack_.end(), extra_state_stack.begin(), extra_state_stack.end());
            // add the closed branch as a child
            AddChildBranch_(closed_branch);
            // add the closed branch to the action and parser branch lists before source_branch
            source_branch.ActionBranch_::InsertBefore_(closed_branch);
            source_branch.ParserBranch_::InsertBefore_(closed_branch);
        }
        void AddReduce_ (Branch_ &source_branch, Rule_ const *reduction_rule)
        {
            assert(source_branch.m_parent_ == this);
            assert(m_shift_child_ == NULL);
            assert(reduction_rule != NULL);
            assert(ReduceActionWouldSucceed_(reduction_rule) && "nice try, jerk");
            // three possible cases here: 1. no existing reduce child, so the
            // incoming branch gets added trivially.  2. the incoming reduction
            // rule has higher priority than that of the reduce child; so prune
            // the reduce child and use the incoming reduction rule instead.
            // 3. the incoming reduction rule is of equal priority as the existing
            // reduce child; so add the incoming branch to the reduce child.
            assert(m_reduce_child_ == NULL || !Rule_::ReduceReduceConflict_::IsHigherPriority_(*m_reduce_child_->m_reduction_rule_, *reduction_rule));
            // in case 1 or 2, we must prune a possibly existing reduce child and recreate it.
            if (m_reduce_child_ == NULL || Rule_::ReduceReduceConflict_::IsHigherPriority_(*reduction_rule, *m_reduce_child_->m_reduction_rule_))
            {
                delete m_reduce_child_;
                m_reduce_child_ = new Reduce_(reduction_rule);
                m_reduce_child_->m_parent_ = this;
            }
            // clone the source branch and operate on it
            Branch_ *reduced_branch = source_branch.Clone_();
            assert(reduced_branch != NULL);
//             reduced_branch->m_state_stack_.resize(reduced_branch->m_state_stack_.size() - (reduction_rule->m_token_count_ + 1)); // for condensed nonterminal head states
            reduced_branch->m_state_stack_.resize(reduced_branch->m_state_stack_.size() - (reduction_rule->m_token_count_ + 2)); // for uncondensed nonterminal head states
            reduced_branch->m_lookahead_nonterminal_token_id_ = reduction_rule->m_reduction_nonterminal_token_id_;
            // add the reduced branch as a child of the reduce child
            m_reduce_child_->AddChildBranch_(reduced_branch);
            // add the reduced branch to the proper place in the action and parser
            // branch lists indicated by members in various action branch lists.
            if (m_reduce_child_->m_action_branch_list_.IsEmpty_())
            {
                // if the reduce child's action branch list is empty, add the
                // reduced branch to the front of the empty reduce child's action
                // branch list, and to parser branch list corresponding to the end
                // of this node's action branch list.
                assert(!m_action_branch_list_.IsEmpty_());
                assert(m_action_branch_list_.Back_() != NULL);
                static_cast<Branch_ *>(m_action_branch_list_.Back_())->ParserBranch_::InsertAfter_(reduced_branch);
                m_reduce_child_->m_action_branch_list_.Prepend_(reduced_branch);
            }
            else
            {
                // otherwise, we can add it directly before the first branch
                // belonging to the reduce child -- in both branch lists.
                assert(m_reduce_child_->m_action_branch_list_.Front_() != NULL);
                static_cast<Branch_ *>(m_reduce_child_->m_action_branch_list_.Front_())->ParserBranch_::InsertBefore_(reduced_branch);
                m_reduce_child_->m_action_branch_list_.Front_()->InsertBefore_(reduced_branch);
            }
        }
        void AddShift_ (Branch_ &source_branch, State_ const *target_state)
        {
            assert(source_branch.m_parent_ == this);
            // associated_rule may be NULL when shifting into a return state
            if (m_shift_child_ == NULL)
            {
                m_shift_child_ = new Shift_();
                m_shift_child_->m_parent_ = this;
            }
            // clone the source branch and operate on it
            Branch_ *shifted_branch = source_branch.Clone_();
            assert(shifted_branch != NULL);
            shifted_branch->m_state_stack_.push_back(target_state);
            shifted_branch->m_lookahead_nonterminal_token_id_ = none__;
//             std::cerr << "adding parser branch " << static_cast<ParserBranch_ *>(shifted_branch)
//                       << " which is action branch " << static_cast<ActionBranch_ *>(shifted_branch)
//                       << std::endl;
            // add the shifted branch as a child of the shift child
            m_shift_child_->AddChildBranch_(shifted_branch);
            // add the shifted branch to the proper place in the parser branch list
            // indicated by members in various action branch lists.
            if (m_shift_child_->m_action_branch_list_.IsEmpty_())
            {
                // if the shift child's action branch list is empty, we'll have to
                // attempt to use elements of the reduce child to determine where to
                // add the branch into the branch lists.
                ActionBranch_ *last_reduce_subordinate_branch = m_reduce_child_ != NULL ? m_reduce_child_->LastSubordinateBranch_() : NULL;
                if (last_reduce_subordinate_branch == NULL)
                {
                    // if there are no reduce subordinate branches, we'll add it after the
                    // this node's last action branch list member.
                    assert(!m_action_branch_list_.IsEmpty_());
                    assert(m_action_branch_list_.Back_() != NULL);
                    static_cast<Branch_ *>(m_action_branch_list_.Back_())->ParserBranch_::InsertAfter_(shifted_branch);
                }
                else
                {
                    // otherwise, we can add it to the parser branch list directly after
                    // the branch corresponding to the last branch in the parser branch
                    // list subordinate to the reduce child.
                    static_cast<Branch_ *>(last_reduce_subordinate_branch)->ParserBranch_::InsertAfter_(shifted_branch);
                }
            }
            else
            {
                // otherwise, we can add it directly before the first branch
                // belonging to the shift child.  NOTE: this could be InsertAfter_
                assert(m_shift_child_->m_action_branch_list_.Front_() != NULL);
                static_cast<Branch_ *>(m_shift_child_->m_action_branch_list_.Front_())->ParserBranch_::InsertBefore_(shifted_branch);
            }
            // add the shifted branch to the shift child's action branch list.
            m_shift_child_->m_action_branch_list_.Prepend_(shifted_branch);
            // only add a shift reference if there could be a conflict
            if (m_reduce_child_ != NULL)
            {
                ShiftReference_ shift_reference = m_shift_child_->EnsureShiftReferenceExists_(target_state->m_associated_rule_);
                assert(&*shift_reference == m_shift_child_);
                shifted_branch->m_shift_reference_list_.push_back(shift_reference);
            }
        }
        void ResolveShiftReduceConflicts_ ()
        {
//             std::cerr << "~ResolveShiftReduceConflicts_(); this = " << this << ", blah = " << blah << std::endl;
            // the only time this should really be called is when adding/removing
            // a child or when the rule range on a shift child changes.

            // no conflicts can be resolved until there are no
            // pending child branches at this node.
            if (!m_action_branch_list_.IsEmpty_())
                return;

            // there is no conflict if there is zero or one child
            if (m_reduce_child_ == NULL || m_shift_child_ == NULL)
                return;

            // when we have both a reduce child and a shift child, it should be impossible
            // for the shift child to have shift references mapped to NULL rules (because
            // this can only happen while shifting into return states, which requires a
            // lookahead nonterminal.  but when this is the case, no reduces can happen.
            assert(!m_shift_child_->IsRuleRangeEmpty_());
            Rule_ const *high_shift_rule = m_shift_child_->RangeRuleHigh_();
            Rule_ const *low_shift_rule = m_shift_child_->RangeRuleLow_();
            Rule_ const *reduce_rule = m_reduce_child_->m_reduction_rule_;
            assert(high_shift_rule != NULL);
            assert(low_shift_rule != NULL);
            assert(reduce_rule != NULL);
            assert(!Rule_::ShiftReduceConflict_::IsHigherPriority_(*low_shift_rule, *high_shift_rule));

            // 6 possibilities (the higher lines indicate higher priority.  same line
            // indicates equality).  there is always exactly one reduce, and at least
            // one shift.
            //
            // 1.     shift        2.     shift        3.
            //        shift               shift
            // reduce              reduce shift        reduce shift
            //
            // 4.                  5.                  6.
            //                                                shift
            // reduce shift        reduce              reduce shift
            //        shift               shift               shift
            //        shift               shift
            //
            // cases 1 and 5 can be trivially resolved -- by pruning the reduce
            // and by pruning the shift respectively.
            //
            // case 3 may be trivially resolved via rule associativity (LEFT causes the
            // shift to be pruned, RIGHT causes the reduce to be pruned, and NONASSOC
            // should cause an error).
            //
            // case 4 can only be resolved if the associativity of the reduction rule
            // is LEFT, otherwise no resolution can be reached at this point.
            //
            // case 2 can only be resolved if the associativity of the reduction rule
            // is RIGHT, otherwise no resolution can be reached at this point.
            //
            // case 6 can not be resolved at this point.

            if (Rule_::ShiftReduceConflict_::IsHigherPriority_(*low_shift_rule, *reduce_rule))
            {   // case 1
                delete m_reduce_child_;
                m_reduce_child_ = NULL;
                m_shift_child_->ClearRuleRange_();
            }
            else if (Rule_::ShiftReduceConflict_::IsHigherPriority_(*reduce_rule, *high_shift_rule))
            {   // case 5
                delete m_shift_child_;
                m_shift_child_ = NULL;
            }
            else if (Rule_::ShiftReduceConflict_::IsEqualPriority_(*reduce_rule, *high_shift_rule) &&
                     Rule_::ShiftReduceConflict_::IsEqualPriority_(*reduce_rule, *low_shift_rule))
            {   // case 3
                assert(low_shift_rule->m_precedence_->m_level_ == high_shift_rule->m_precedence_->m_level_);
                assert(low_shift_rule->m_precedence_->m_associativity_ == high_shift_rule->m_precedence_->m_associativity_);
                assert(reduce_rule->m_precedence_->m_level_ == high_shift_rule->m_precedence_->m_level_);
                assert(reduce_rule->m_precedence_->m_associativity_ == high_shift_rule->m_precedence_->m_associativity_);
                if (reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_LEFT_)
                {
                    delete m_shift_child_;
                    m_shift_child_ = NULL;
                }
                else if (reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_RIGHT_)
                {
                    delete m_reduce_child_;
                    m_reduce_child_ = NULL;
                    m_shift_child_->ClearRuleRange_();
                }
                else // reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_NONASSOC_
                {
                    assert(reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_NONASSOC_);
                    assert(false && "nonassoc error handling not implemented yet");
                }
            }
            else if (Rule_::ShiftReduceConflict_::IsEqualPriority_(*reduce_rule, *high_shift_rule) &&
                     Rule_::ShiftReduceConflict_::IsHigherPriority_(*reduce_rule, *low_shift_rule))
            {   // case 4
                assert(reduce_rule->m_precedence_->m_level_ == high_shift_rule->m_precedence_->m_level_);
                assert(reduce_rule->m_precedence_->m_associativity_ == high_shift_rule->m_precedence_->m_associativity_);
                if (reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_LEFT_)
                {
                    delete m_shift_child_;
                    m_shift_child_ = NULL;
                }
            }
            else if (Rule_::ShiftReduceConflict_::IsEqualPriority_(*reduce_rule, *low_shift_rule) &&
                     Rule_::ShiftReduceConflict_::IsHigherPriority_(*high_shift_rule, *reduce_rule))
            {   // case 2
                assert(reduce_rule->m_precedence_->m_level_ == low_shift_rule->m_precedence_->m_level_);
                assert(reduce_rule->m_precedence_->m_associativity_ == low_shift_rule->m_precedence_->m_associativity_);
                if (reduce_rule->m_precedence_->m_associativity_ == ASSOCIATIVITY_RIGHT_)
                {
                    delete m_reduce_child_;
                    m_reduce_child_ = NULL;
                    m_shift_child_->ClearRuleRange_();
                }
            }
            else
            {   // case 6
                // nothing can be done at this point
            }
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            // fake polymorphism here, because we don't want to use virtual inheritance
            if (m_parent_ == NULL) // special treatment for the root
                PrivatePrint_(stream, rule_table, state_table, indent_level);
            else switch (m_tree_node_type_)
            {
                default:
                case BRANCH_:
                case ACTION_: assert(false && "this should never happen"); break;
                case REDUCE_: static_cast<Reduce_ const *>(this)->Print_(stream, rule_table, state_table, indent_level); break;
                case SHIFT_ : static_cast<Shift_ const *>(this)->Print_(stream, rule_table, state_table, indent_level); break;
            }
        }

    protected:

        void PrintChildNodes_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            for (ActionBranch_ const *action_branch = m_action_branch_list_.Front_(); action_branch != NULL; action_branch = action_branch->Next_())
                static_cast<Branch_ const *>(action_branch)->Print_(stream, rule_table, state_table, indent_level);
            if (m_reduce_child_ != NULL)
                m_reduce_child_->Print_(stream, rule_table, state_table, indent_level);
            if (m_shift_child_ != NULL)
                m_shift_child_->Print_(stream, rule_table, state_table, indent_level);
        }

    private:

        void AssertActionAndParserBranchListsAreConsistent_ (ParserBranch_ const *&parser_branch) const
        {
            if (parser_branch == NULL)
                assert(!HasChildren_());
            for (ActionBranch_ const *action_branch = m_action_branch_list_.Front_();
                 action_branch != NULL;
                 action_branch = action_branch->Next_(), parser_branch = parser_branch != NULL ? parser_branch->Next_() : parser_branch)
            {
//                 std::cerr << "checking parser branch " << static_cast<Branch_ const *>(parser_branch)
//                           << " against action branch " << static_cast<Branch_ const *>(action_branch)
//                           << std::endl;
                assert(parser_branch != NULL && static_cast<Branch_ const *>(parser_branch) == static_cast<Branch_ const *>(action_branch));
            }
            if (m_reduce_child_ != NULL)
                m_reduce_child_->AssertActionAndParserBranchListsAreConsistent_(parser_branch);
            if (m_shift_child_ != NULL)
                m_shift_child_->AssertActionAndParserBranchListsAreConsistent_(parser_branch);
        }
        void PrivatePrint_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            assert(m_parent_ == NULL);
            stream << std::string(2*indent_level, ' ') << "root " << this << std::endl;
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }
    }; // end of struct TrisonCpp_::Npda_::Action_
    struct Reduce_ : public Action_
    {
        Rule_ const *m_reduction_rule_;

        Reduce_ (Rule_ const *reduction_rule)
            :
            Action_(REDUCE_),
            m_reduction_rule_(reduction_rule)
        {
            assert(m_reduction_rule_ != NULL);
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << (m_parent_ != NULL ? "reduce " : "root ") << this
                   << " \"" << m_reduction_rule_->m_description_ << '\"'
                   << ", precedence = " << m_reduction_rule_->m_precedence_->m_level_
                   << ", associativity = " << m_reduction_rule_->m_precedence_->m_associativity_
                   << ", rule index = " << m_reduction_rule_-rule_table << std::endl;
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }
    }; // end of struct TrisonCpp_::Npda_::Reduce_
    struct Shift_ : public Action_
    {
        Shift_ () : Action_(SHIFT_) { }
        ~Shift_ () { ClearRuleRange_(); }

        bool IsRuleRangeEmpty_ () const { return m_rule_range_.empty(); }
        Rule_ const *RangeRuleHigh_ () const { assert(!m_rule_range_.empty()); return m_rule_range_.begin()->first; }
        Rule_ const *RangeRuleLow_ () const { assert(!m_rule_range_.empty()); return m_rule_range_.rbegin()->first; }

        ShiftReference_ EnsureShiftReferenceExists_ (Rule_ const *rule)
        {
            ShiftReferenceMap_::iterator it = m_rule_range_.find(rule);
            if (it == m_rule_range_.end())
            {
                ShiftReference_ &shift_reference = m_rule_range_[rule] = ShiftReference_(this);
                assert(shift_reference.ReferenceCount_() == 1);
                return shift_reference;
            }
            else
            {
                ShiftReference_ &shift_reference = it->second;
                assert(shift_reference.ReferenceCount_() >= 1);
                return shift_reference;
            }
        }
        void ClearRuleRange_ ()
        {
            // go through all rule references and release the instances (so any
            // branches which refer to them can know that they're no longer active)
            for (ShiftReferenceMap_::iterator it = m_rule_range_.begin(), it_end = m_rule_range_.end();
                 it != it_end;
                 ++it)
            {
                ShiftReference_ &shift_reference = it->second;
                assert(shift_reference.IsValid_());
                assert(shift_reference.ReferenceCount_() >= 1);
                assert(shift_reference.InstanceIsValid_());
                shift_reference.InstanceRelease_();
                assert(shift_reference.IsValid_());
                assert(shift_reference.ReferenceCount_() >= 1);
                assert(!shift_reference.InstanceIsValid_());
            }
            m_rule_range_.clear();
        }
        void DestroyAllUnusedInRuleRange_ ()
        {
            // go through all rule references and erase/destruct all references
            // that have a ref count of 1 (indicating we're the only ones using
            // them).  the wacky iteration is so we don't have to worry about
            // incrementing an erased iterator.
            for (ShiftReferenceMap_::iterator next_it = m_rule_range_.begin(),
                                              it_end = m_rule_range_.end(),
                                              it = (next_it != it_end) ? next_it++ : next_it;
                 it != it_end;
                 it = (next_it != it_end) ? next_it++ : next_it)
            {
                ShiftReference_ &shift_reference = it->second;
                assert(shift_reference.IsValid_());
                assert(shift_reference.ReferenceCount_() >= 1);
                if (shift_reference.ReferenceCount_() == 1)
                    m_rule_range_.erase(it); // this should call ~ShiftReference()
            }
        }

        void Print_ (std::ostream &stream, Rule_ const *rule_table, State_ const *state_table, Uint32_ indent_level) const
        {
            stream << std::string(2*indent_level, ' ') << (m_parent_ != NULL ? "shift " : "root ") << this << std::endl;
            if (!m_rule_range_.empty())
                stream << std::string(2*(indent_level+1), ' ') << "rule range" << std::endl;
            for (ShiftReferenceMap_::const_iterator it = m_rule_range_.begin(), it_end = m_rule_range_.end();
                 it != it_end;
                 ++it)
            {
                Rule_ const *rule = it->first;
                ShiftReference_ const &shift_reference = it->second;
                assert(shift_reference.IsValid_());
                assert(shift_reference.InstanceIsValid_());
                // TODO: make into assert(shift_reference.ReferenceCount_() > 1); -- changes in the ref count should cause cleanup in the rule range
                if (shift_reference.ReferenceCount_() > 1)
                {
                    stream << std::string(2*(indent_level+2), ' ') << rule;
                    if (rule != NULL)
                        stream << " \"" << rule->m_description_ << '\"'
                            << ", precedence = " << rule->m_precedence_->m_level_
                            << ", associativity = " << rule->m_precedence_->m_associativity_
                            << ", rule index = " << rule-rule_table
                            << ", ref count = " << shift_reference.ReferenceCount_();
                    stream << std::endl;
                }
            }
            // TODO: print rule range
            PrintChildNodes_(stream, rule_table, state_table, indent_level+1);
        }

    private:

        ShiftReferenceMap_ m_rule_range_;
    }; // end of struct TrisonCpp_::Npda_::Shift_
}; // end of class TrisonCpp_::Npda_

} // end of namespace TrisonCpp_
#endif // !defined(TrisonCpp_namespace_)
<|if(is_defined(top_of_header_file))

<|top_of_header_file
<|end_if

class <{class_name} : private TrisonCpp_::Npda_<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    typedef <{token_data_type} TokenData_;

    enum ParserReturnCode
    {
        PRC_SUCCESS = 0,
        PRC_UNHANDLED_PARSE_ERROR = 1
    }; // end of enum <{class_name}::ParserReturnCode

    struct Terminal
    {
        enum Name
        {
<|if(sizeof(_terminal_name_list) < 1)
<|error("the terminal list should always have at least one element")
<|end_if
<|if(sizeof(_terminal_name_list) != sizeof(_terminal_index_list))
<|error("mismatch in size of _terminal_name_list and _terminal_index_list")
<|end_if
<|loop(i, sizeof(_terminal_name_list))
            <{_terminal_name_list[i]} = <{_terminal_index_list[i]}<{if(i+1 < sizeof(_terminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Terminal::Name
    }; // end of struct <{class_name}::Terminal

    struct Nonterminal
    {
        enum Name
        {
<|if(sizeof(_nonterminal_name_list) < 1)
<|error("the nonterminal list should always have at least one element")
<|end_if
<|if(sizeof(_nonterminal_name_list) != sizeof(_nonterminal_index_list))
<|error("mismatch in size of _nonterminal_name_list and _nonterminal_index_list")
<|end_if
<|loop(i, sizeof(_nonterminal_name_list))
            <{_nonterminal_name_list[i]} = <{_nonterminal_index_list[i]}<{if(i+1 < sizeof(_nonterminal_name_list))},<{end_if}
<|end_loop
        }; // end of enum <{class_name}::Nonterminal::Name
    }; // end of struct <{class_name}::Nonterminal

    struct ParseNonterminal
    {
        enum Name
        {
<|for_each(key, _npda_nonterminal_start_state_index)
            <{key} = <{_npda_nonterminal_start_state_index[key]},
<|end_for_each
            // default parse nonterminal
            DEFAULT_ = <{_default_parse_nonterminal}
        }; // end of enum <{class_name}::ParseNonterminal::Name
    }; // end of struct <{class_name}::ParseNonterminal

    struct Token_ // TODO: rename to Token
    {
        TokenId_ m_token_id_; // TODO: rename to m_id or m_token_id
        TokenData_ m_token_data_; // TODO: rename to m_data or m_token_data

        Token_ () : m_token_id_(Nonterminal::none_) { }
        Token_ (TokenId_ token_id, TokenData_ const &token_data = <{token_data_type_sentinel})
            :
            m_token_id_(token_id),
            m_token_data_(token_data)
        {
            assert(m_token_id_ != Nonterminal::none_);
        }
    }; // end of struct <{class_name}::Token_

private:

    typedef std::deque<TokenData_> TokenDataQueue_;
    typedef std::deque<Token_> TokenQueue_;

<|if(is_defined(top_of_class))
public:

<|top_of_class

<|end_if
public:

    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<|if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<|end_if
<|if(is_defined(parse_method_access))
<|if(!(parse_method_access == "public:" || parse_method_access == "protected:" || parse_method_access == "private:"))
<|error("invalid parse_method_access \"" . parse_method_access . "\"")
<|end_if
<{parse_method_access}

<|end_if
    ParserReturnCode Parse (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_ = ParseNonterminal::<{_default_parse_nonterminal});

private:

    static bool TransitionAcceptsTokenId_ (Transition_ const *transition, TokenId_ token_id)
    {
        assert(transition >= ms_transition_table_ && transition < ms_transition_table_ + ms_transition_count_);
        return transition->m_transition_type_ == Transition_::TT_SHIFT_ &&
               transition->m_transition_data_ == token_id;
    }

/*
    void ClearBranches_ ();
    void ClearTokenStack_ ();
    void ClearLookaheadQueue_ ();
    void ClearMostRecentReturnState_ ();
    void ClearReturnToken_ ();
*/
    void ThrowAwayToken_ (TokenData_ &token);
    void ResetForNewInput_ ();


    // blah
    ParserReturnCode Parse_ (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_);
    Token_ &ShiftLookaheadToken_ ();
    void PerformEpsilonClosure_ ();
    void PerformEpsilonClosure_ (Branch_ &source_branch, StateStack_ &extra_state_stack);
    void PerformReduceTransitions_ ();
    void PerformReduceTransition_ (Branch_ &source_branch, Rule_ const *reduction_rule);
    void PerformShiftTransitions_ ();
    void PerformShiftTransition_ (Branch_ &source_branch, State_ const *target_state);
    void PruneBranchList_ (ParserBranchList_ &branch_list);
    void ExecuteAndRemoveTrunk_ ();
    TokenData_ ExecuteReductionRule_ (TrisonCpp_::Size_ rule_index);
    void PrintParserBranchList_ (); // TEMP
    // end blah



    // TODO: move as much stuff to the base class as possible
    Action_ *m_tree_root_;
    ParserBranchList_ m_parser_branch_list_;
    ParserBranchList_ m_doomed_nonreturn_branch_list_;
    ParserBranchList_ m_doomed_return_branch_list_;
    bool m_is_shift_blocked_;
    bool m_reduce_transitions_were_performed_;
    bool m_shift_transitions_were_performed_;
    bool m_nonassoc_error_encountered_;
    TokenDataQueue_ m_token_stack_;
    TokenQueue_ m_lookahead_token_queue_; // TODO: make the lookahead queue into its own class/object so it's a separate API
    TokenQueue_::size_type m_lookahead_token_queue_cursor_;
<|if(is_defined(generate_debug_spew_code))
    bool m_debug_spew_;

<|end_if
    static TrisonCpp_::Npda_::Precedence_ const ms_precedence_table_[];
    static TrisonCpp_::Size_ const ms_precedence_count_;
    static TrisonCpp_::Npda_::Rule_ const ms_rule_table_[];
    static TrisonCpp_::Size_ const ms_rule_count_;
    static TrisonCpp_::Npda_::State_ const ms_state_table_[];
    static TrisonCpp_::Size_ const ms_state_count_;
    static TrisonCpp_::Npda_::Transition_ const ms_transition_table_[];
    static TrisonCpp_::Size_ const ms_transition_count_;
<|if(is_defined(bottom_of_class))

public:
<{bottom_of_class}
<|end_if
}; // end of class <{class_name}
<|if(is_defined(bottom_of_header_file))

<|bottom_of_header_file
<|end_if
