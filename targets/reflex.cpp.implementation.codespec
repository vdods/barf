<|if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<|error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<|end_if
<|if(is_defined(scan_method_definition_parameters) && !is_defined(scan_method_parameters))
<|error("can't specify scan_method_definition_parameters without specifying scan_method_parameters")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{define(debug_spew_prefix)}"<{class_name}:"<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by reflex<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<|if(is_defined(generate_debug_spew_code))
#include <iostream>

#define REFLEX_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }

<|end_if
<|top_of_implementation_file?

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
    :
    ReflexCpp_::AutomatonApparatus(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputApparatus::IsInputAtEndMethod>(&<{class_name}::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputApparatus::ReadNextAtomMethod>(&<{class_name}::ReadNextAtom_))<{if(is_defined(superclass_and_member_constructors))},
<|superclass_and_member_constructors
<{end_if}
{
<|if(is_defined(generate_debug_spew_code))
    DebugSpew(false);
<|end_if
    ResetForNewInput();

<|constructor_actions?
}

<{class_name}::~<{class_name} ()
{
<|destructor_actions?
}

<{class_name}::Mode::Name <{class_name}::ScannerMode () const
{
    assert(InitialState_() != NULL);
    BarfCpp_::Size initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return Mode::START_;
<|for_each(key, _dfa_initial_node_index)
        case <{_dfa_initial_node_index[key]}: return Mode::<{key};
<|end_for_each
    }
}

void <{class_name}::ScannerMode (Mode::Name mode)
{
    assert(
<|for_each(key, _dfa_initial_node_index)
        mode == Mode::<{key} ||
<|end_for_each
        (false && "invalid Mode::Name"));
    InitialState_(ms_state_table_ + mode);
<|if(is_defined(generate_debug_spew_code))
    REFLEX_CPP_DEBUG_CODE_(
        std::cerr << <{debug_spew_prefix} << " transitioning to mode ";
        PrintScannerMode_(mode);
        std::cerr << std::endl)
<|end_if
    assert(ScannerMode() == mode);
}

void <{class_name}::ResetForNewInput ()
{
    ReflexCpp_::AutomatonApparatus::ResetForNewInput_(ms_state_table_ + Mode::START_);

<|reset_for_new_input_actions?
}

<{return_type} <{class_name}::Scan (<{if(is_defined(scan_method_definition_parameters))}<{scan_method_definition_parameters}<{else}<{scan_method_parameters?}<{end_if})
{
<|start_of_scan_method_actions?

    std::string accepted_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        bool was_at_end_of_input_ = IsAtEndOfInput();

        BarfCpp_::Uint32 accept_handler_index_ = RunDfa_(accepted_string);
        // if no valid accept_handler_index_ was returned, then accepted_string
        // was filled with the first unaccepted input atom (i.e. the rejected
        // atom).  we'll call the HandleUnmatchedCharacter_ method on it.
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            assert(accepted_string.length() == 1);
            BarfCpp_::Uint8 rejected_atom = accepted_string[0];
<|if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << <{debug_spew_prefix} << " rejecting atom '";
                PrintAtom_(rejected_atom);
                std::cerr << '\'' << std::endl)
<|end_if

            // execute the rejected-atom-handling actions.  the rejected atom
            // is in rejected_atom.  the loop is so a break statement inside
            // rejection_actions doesn't break out of the main scanner loop.
            do
            {
<{rejection_actions}
            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
<|if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << <{debug_spew_prefix} << " accepting string ";
                PrintString_(accepted_string);
                std::cerr << ", corresponding to mode ";
                PrintScannerMode_(ScannerMode());
                std::cerr << ", regex (" << ms_accept_handler_regex_[accept_handler_index_] << ")." << std::endl)
<|end_if
            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
<|loop (i, _accept_handler_count)
                case <{i}:
                {
<{_accept_handler_code[i]}
                }
                break;

<|end_loop
                default: assert(false && "this should never happen"); break;
            }
        }
    }

<|end_of_scan_method_actions?
}

// ///////////////////////////////////////////////////////////////////////
// begin internal reflex-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

bool <{class_name}::IsInputAtEnd_ ()
{
<|return_true_iff_input_is_at_end
}

BarfCpp_::Uint8 <{class_name}::ReadNextAtom_ ()
{
<|return_next_input_char
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintAtom_ (BarfCpp_::Uint8 atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << BarfCpp_::Uint16(atom);
        std::cerr.width(1);
    }
}

void <{class_name}::PrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        PrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

void <{class_name}::PrintScannerMode_ (Mode::Name mode)
{
    if (false) { }
<|for_each(key, _dfa_initial_node_index)
    else if (mode == Mode::<{key}) { std::cerr << "<{key}"; }
<|end_for_each
}

<|end_if
// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus::DfaState_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _dfa_state_count)
    { <{_dfa_state_accept_handler_index[i]}, <{_dfa_state_transition_count[i]}, ms_transition_table_+<{_dfa_state_transition_offset[i]} }<{if(i < _dfa_state_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Size const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

ReflexCpp_::AutomatonApparatus::DfaTransition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _dfa_transition_count)
    { ReflexCpp_::AutomatonApparatus::DfaTransition_::<{_dfa_transition_type_name[i]}, <{_dfa_transition_data_0[i]}, <{_dfa_transition_data_1[i]}, ms_state_table_+<{_dfa_transition_target_node_index[i]} }<{if(i < _dfa_transition_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Size const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);

<|if(is_defined(generate_debug_spew_code))
char const *const <{class_name}::ms_accept_handler_regex_[] =
{
<|loop(i, _accept_handler_count)
    <{to_string_literal(_accept_handler_regex[i])}<{if(i < _accept_handler_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Uint32 const <{class_name}::ms_accept_handler_count_ = sizeof(<{class_name}::ms_accept_handler_regex_) / sizeof(*<{class_name}::ms_accept_handler_regex_);
<|else
BarfCpp_::Uint32 const <{class_name}::ms_accept_handler_count_ = <{_accept_handler_count};
<|end_if

// ///////////////////////////////////////////////////////////////////////
// end of internal reflex-generated parser guts
// ///////////////////////////////////////////////////////////////////////

<|bottom_of_implementation_file?
