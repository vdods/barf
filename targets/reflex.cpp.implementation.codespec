<|if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<|error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<|end_if
<|if(is_defined(scan_method_definition_parameters) && !is_defined(scan_method_parameters))
<|error("can't specify scan_method_definition_parameters without specifying scan_method_parameters")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{define(debug_spew_prefix)}"<{class_name}:"<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by reflex<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<|if(is_defined(generate_debug_spew_code))
#include <iostream>

#define REFLEX_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }

<|end_if
<|top_of_implementation_file?

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
    :
    ReflexCpp_::AutomatonApparatus_(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputApparatus_::IsInputAtEndMethod_>(&<{class_name}::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputApparatus_::ReadNextAtomMethod_>(&<{class_name}::ReadNextAtom_))<{if(is_defined(superclass_and_member_constructors))},
<|superclass_and_member_constructors
<{end_if}
{
<|if(is_defined(generate_debug_spew_code))
    DebugSpew(false);

<|end_if
<|constructor_actions?

    ResetForNewInput();
}

<{class_name}::~<{class_name} ()
{
<|destructor_actions?
}

<{class_name}::StateMachine::Name <{class_name}::CurrentStateMachine () const
{
    assert(InitialState_() != NULL);
    BarfCpp_::Size initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return StateMachine::START_;
<|for_each(key, _dfa_initial_node_index)
        case <{_dfa_initial_node_index[key]}: return StateMachine::<{key};
<|end_for_each
    }
}

void <{class_name}::SwitchToStateMachine (StateMachine::Name state_machine)
{
    assert(
<|for_each(key, _dfa_initial_node_index)
        state_machine == StateMachine::<{key} ||
<|end_for_each
        (false && "invalid StateMachine::Name"));
    InitialState_(ms_state_table_ + ms_state_machine_start_state_index_[state_machine]);
    ModeFlags_(ms_state_machine_mode_flags_[state_machine]);
<|if(is_defined(generate_debug_spew_code))
    REFLEX_CPP_DEBUG_CODE_(
        std::cerr << <{debug_spew_prefix} << " transitioning to state machine "
                  << ms_state_machine_name_[state_machine] << std::endl)
<|end_if
    assert(CurrentStateMachine() == state_machine);
}

void <{class_name}::ResetForNewInput ()
{
<|if(is_defined(generate_debug_spew_code))
    REFLEX_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reset-for-new-input actions" << std::endl)
                
<|end_if
    ReflexCpp_::AutomatonApparatus_::ResetForNewInput_(ms_state_table_ + StateMachine::START_, ms_state_machine_mode_flags_[StateMachine::START_]);

<|reset_for_new_input_actions?
}

<{return_type} <{class_name}::Scan (<{if(is_defined(scan_method_definition_parameters))}<{scan_method_definition_parameters}<{else}<{scan_method_parameters?}<{end_if})<{if(!is_defined(enable_accept_handler_exceptions))} throw()<{end_if}
{
<|top_of_scan_method_actions?

<|if(is_defined(enable_accept_handler_exceptions))
    // this is the try {} block generated by specifying the
    // %target.cpp.enable_accept_handler_exceptions directive in the
    // primary source, to allow necessary cleanup if any of the accept
    // handler code throws an exception.
    try {

<|end_if
    std::string work_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        // clear the previous accepted/rejected string.
        work_string.clear();
        // reset the char buffer and other stuff
        PrepareToScan_();
    
        bool was_at_end_of_input_ = IsAtEndOfInput();

        BarfCpp_::Uint32 accept_handler_index_ = RunDfa_(work_string);
        // if no valid accept_handler_index_ was returned, then work_string
        // was filled with everything up to the char after the keep_string
        // cursor (i.e. the rejected atom).
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            std::string &rejected_string = work_string;
            BarfCpp_::Uint8 rejected_atom = rejected_string.empty() ? '\0' : *rejected_string.rbegin();
            
<|if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << <{debug_spew_prefix} << " rejecting string ";
                PrintString_(rejected_string);
                std::cerr << " (rejected_atom is \'";
                PrintAtom_(rejected_atom);
                std::cerr << "\')" << std::endl)

<|end_if
            // execute the rejection actions.  the do/while loop is so that a
            // break statement inside the rejection actions doesn't break out
            // of the main scanner loop.
            do
            {
<{rejection_actions}
            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
            std::string &accepted_string = work_string;
        
<|if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_CODE_(
                std::cerr << <{debug_spew_prefix} << " accepting string ";
                PrintString_(accepted_string);
                std::cerr << " in state machine " << ms_state_machine_name_[CurrentStateMachine()] 
                          << " using regex (" << ms_accept_handler_regex_[accept_handler_index_] << ")" << std::endl)
                
<|end_if
            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
<|loop (i, _accept_handler_count)
                case <{i}:
                {
<{_accept_handler_code[i]}
                }
                break;

<|end_loop
                default: assert(false && "this should never happen"); break;
            }
        }
    }

<|if(is_defined(enable_accept_handler_exceptions))
    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_accept_handler_exceptions directive in the
    // primary source, to allow necessary cleanup if any of the accept
    // handler code throws an exception.
    } catch (...) {
        // reset for new input (on InputApparatus_ and AutomatonApparatus_
        // only) because the state machine is in a bad state and the
        // behavior of scanning again from that point would be undefined.
        // pass NULL for initial_state so that the current state machine
        // is preserved.
        ReflexCpp_::AutomatonApparatus_::ResetForNewInput_(NULL);
        // rethrow the (unknown) exception.
        throw;
    }

<|end_if
<|bottom_of_scan_method_actions?
}

<|if(is_defined(generate_scanner_augmentation_methods))
<|if(is_defined(generate_debug_spew_code))
void <{class_name}::KeepString ()
{
    REFLEX_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " keeping string" << std::endl)
    AutomatonApparatus_::KeepString();
}

void <{class_name}::Unaccept (BarfCpp_::Uint32 unaccept_char_count)
{
    REFLEX_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " unaccepting " << unaccept_char_count << " char" << (unaccept_char_count == 1 ? '\0' : 's') << std::endl)
    AutomatonApparatus_::Unaccept(unaccept_char_count);
}

void <{class_name}::Unreject (BarfCpp_::Uint32 unreject_char_count)
{
    REFLEX_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " unrejecting " << unreject_char_count << " char" << (unreject_char_count == 1 ? '\0' : 's') << std::endl)
    AutomatonApparatus_::Unreject(unreject_char_count);
}

<|end_if
<|end_if
// ///////////////////////////////////////////////////////////////////////
// begin internal reflex-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

bool <{class_name}::IsInputAtEnd_ () throw()
{
<|return_true_iff_input_is_at_end
}

BarfCpp_::Uint8 <{class_name}::ReadNextAtom_ () throw()
{
<|return_next_input_char
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintAtom_ (BarfCpp_::Uint8 atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << BarfCpp_::Uint16(atom);
        std::cerr.width(1);
    }
}

void <{class_name}::PrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        PrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

<|end_if
BarfCpp_::Uint32 const <{class_name}::ms_state_machine_start_state_index_[] =
{
<|for_each(key, _dfa_initial_node_index)
    <{_dfa_initial_node_index[key]},
<|end_for_each
};
BarfCpp_::Uint8 const <{class_name}::ms_state_machine_mode_flags_[] =
{
<|for_each(key, _state_machine_mode_flags)
    <{_state_machine_mode_flags[key]},
<|end_for_each
};
<|if(is_defined(generate_debug_spew_code))
char const *const <{class_name}::ms_state_machine_name_[] =
{
<|for_each(key, _dfa_initial_node_index)
    <{to_string_literal(key)},
<|end_for_each
};
BarfCpp_::Uint32 const <{class_name}::ms_state_machine_count_ = sizeof(<{class_name}::ms_state_machine_name_) / sizeof(*<{class_name}::ms_state_machine_name_);
<|else
BarfCpp_::Uint32 const <{class_name}::ms_state_machine_count_ = <{sizeof(_dfa_initial_node_index)};
<|end_if

// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus_::DfaState_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _dfa_state_count)
    { <{_dfa_state_accept_handler_index[i]}, <{_dfa_state_transition_count[i]}, ms_transition_table_+<{_dfa_state_transition_offset[i]} }<{if(i < _dfa_state_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Size const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

ReflexCpp_::AutomatonApparatus_::DfaTransition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _dfa_transition_count)
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::<{_dfa_transition_type_name[i]}, <{_dfa_transition_data_0[i]}, <{_dfa_transition_data_1[i]}, ms_state_table_+<{_dfa_transition_target_node_index[i]} }<{if(i < _dfa_transition_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Size const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);

<|if(is_defined(generate_debug_spew_code))
char const *const <{class_name}::ms_accept_handler_regex_[] =
{
<|loop(i, _accept_handler_count)
    <{to_string_literal(_accept_handler_regex[i])}<{if(i < _accept_handler_count-1)},<{end_if}
<|end_loop
};
BarfCpp_::Uint32 const <{class_name}::ms_accept_handler_count_ = sizeof(<{class_name}::ms_accept_handler_regex_) / sizeof(*<{class_name}::ms_accept_handler_regex_);
<|else
BarfCpp_::Uint32 const <{class_name}::ms_accept_handler_count_ = <{_accept_handler_count};
<|end_if

// ///////////////////////////////////////////////////////////////////////
// end of internal reflex-generated parser guts
// ///////////////////////////////////////////////////////////////////////

<|bottom_of_implementation_file?
