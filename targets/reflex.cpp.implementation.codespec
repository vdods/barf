<*{if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<*{error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<*{end_if
<*{if(is_defined(scan_method_definition_parameters) && !is_defined(scan_method_parameters))
<*{error("can't specify scan_method_definition_parameters without specifying scan_method_parameters")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by reflex<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_langspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

#include <iostream>

<*{if(is_defined(generate_debug_spew_code))
#define REFLEX_CPP_DEBUG_SPEW_(spew_code) if (DebugSpew()) { spew_code; }

<*{end_if
<*{top_of_implementation_file?

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
    :
    ReflexCpp_::Scanner_(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputBuffer_::IsInputAtEndMethod_>(&<{class_name}::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputBuffer_::ReadNextAtomMethod_>(&<{class_name}::ReadNextAtom_))<{if(is_defined(superclass_and_member_constructors))},
<*{superclass_and_member_constructors
<{end_if}
{
<*{if(is_defined(generate_debug_spew_code))
    // one-time initializations
    DebugSpew(false);
<*{end_if
    // per-input initializations
    ResetForNewInput_();

<*{constructor_actions?
}

<{class_name}::~<{class_name} ()
{
<*{destructor_actions?
}

void <{class_name}::SetScannerState (State::Name state)
{
    assert(
<*{for_each(key, _dfa_initial_node_index)
        state == State::<{key} ||
<*{end_for_each
        (false && "invalid State::Name"));
    SetInitialState_(ms_state_table_ + state);
<*{if(is_defined(generate_debug_spew_code))
    REFLEX_CPP_DEBUG_SPEW_(std::cerr << "*** scanner: transitioning to state ")
    if (false) { }
<*{for_each(key, _dfa_initial_node_index)
    else if (state == State::<{key}) { REFLEX_CPP_DEBUG_SPEW_(std::cerr << "<{key}") }
<*{end_for_each
    REFLEX_CPP_DEBUG_SPEW_(std::cerr << std::endl)
<*{end_if
}

<{return_type} <{class_name}::Scan (<{if(is_defined(scan_method_definition_parameters))}<{scan_method_definition_parameters}<{else}<{scan_method_parameters?}<{end_if})
{
<*{start_of_scan_method_actions?

    std::string accepted_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        bool was_at_end_of_input_ = IsAtEndOfInput();

        ReflexCpp_::Uint32_ accept_handler_index_ = RunDfa_(accepted_string);
        // if no valid accept_handler_index_ was returned, then accepted_string
        // was filled with the first unaccepted input atom (i.e. the rejected
        // atom).  we'll call the HandleUnmatchedCharacter_ method on it.
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            assert(accepted_string.length() == 1);
            ReflexCpp_::Uint8_ rejected_atom = accepted_string[0];
<*{if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_SPEW_(
                std::cerr << "*** scanner: rejecting atom '";
                DebugPrintAtom_(rejected_atom);
                std::cerr << '\'' << std::endl)
<*{end_if

            // execute the rejected-atom-handling actions.  the rejected atom
            // is in rejected_atom.  the loop is so a break statement inside
            // rejection_actions doesn't break out of the main scanner loop.
            do
            {
<{rejection_actions}
            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
<*{if(is_defined(generate_debug_spew_code))
            REFLEX_CPP_DEBUG_SPEW_(
                std::cerr << "*** scanner: accepting string ";
                DebugPrintString_(accepted_string);
                std::cerr << std::endl)
<*{end_if
            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
<*{loop (i, _accept_handler_count)
                case <{i}:
                {
<{_accept_handler_code[i]}
                }
                break;

<*{end_loop
                default: assert(false && "this should never happen"); break;
            }
        }
    }

<*{end_of_scan_method_actions?
}

bool <{class_name}::IsInputAtEnd_ ()
{
<*{return_true_iff_input_is_at_end
}

ReflexCpp_::Uint8_ <{class_name}::ReadNextAtom_ ()
{
<*{return_next_input_char
}

void <{class_name}::ResetForNewInput_ ()
{
    ReflexCpp_::Scanner_::ResetForNewInput_(ms_state_table_ + State::START_);

<*{reset_for_new_input_actions?
}

<*{if(is_defined(generate_debug_spew_code))
void <{class_name}::DebugPrintAtom_ (ReflexCpp_::Uint8_ atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << ReflexCpp_::Uint16_(atom);
        std::cerr.width(1);
    }
}

void <{class_name}::DebugPrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        DebugPrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

<*{end_if
// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::Scanner_::DfaState_ const <{class_name}::ms_state_table_[] =
{
<*{loop(i, _dfa_node_count)
    { <{_dfa_node_accept_handler_index[i]}, <{_dfa_node_transition_count[i]}, ms_transition_table_+<{_dfa_node_transition_offset[i]} }<{if(i < _dfa_node_count-1)},<{end_if}
<*{end_loop
};
ReflexCpp_::Size_ const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(ReflexCpp_::Scanner_::DfaState_);

ReflexCpp_::Scanner_::DfaTransition_ const <{class_name}::ms_transition_table_[] =
{
<*{loop(i, _dfa_transition_count)
    { ReflexCpp_::Scanner_::DfaTransition_::<{_dfa_transition_type_name[i]}_, <{_dfa_transition_data_0[i]}, <{_dfa_transition_data_1[i]}, ms_state_table_+<{_dfa_transition_target_node_index[i]} }<{if(i < _dfa_transition_count-1)},<{end_if}
<*{end_loop
};
ReflexCpp_::Size_ const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(ReflexCpp_::Scanner_::DfaTransition_);

ReflexCpp_::Uint32_ const <{class_name}::ms_accept_handler_count_ = <{_accept_handler_count};

<*{bottom_of_implementation_file?
