private:

<|include("trison.cpp.npda.grammar.header.codespec")

<|include("trison.cpp.npda.npda.header.codespec")

    typedef std::uint32_t                               ActionData_;

    typedef std::deque<Token>                           TokenQueue_;
    typedef std::vector<Token>                          TokenStack_;
    typedef std::deque<Token::Id>                       TokenIdQueue_;

    // This forms one element, containing the NPDA state index, of a NPDA state stack (aka branch).
    typedef SharedLinkedListElement_<Npda__::NpdaStateIndex_>   BranchNode_;
    typedef std::shared_ptr<BranchNode_>                BranchNodePtr_;
    // This contains the tops of all the branch state stacks.  The ordering is necessary in order
    // to distinguish different branches that may have identical top states.
    typedef std::set<BranchNodePtr_,SharedLinkedListElementOrder_<Npda__::NpdaStateIndex_>> BranchNodePtrSet_;
    typedef std::vector<BranchNodePtrSet_>              BranchNodePtrSetStack_;
    typedef std::vector<BranchNodePtr_>                 BranchNodePtrVector_;
    typedef std::vector<BranchNodePtrVector_>           BranchNodePtrVectorStack_;

<|if(is_defined(generate_debug_spew_code))
    typedef SharedLinkedListElement_<Token::Id>         BranchNodeTokenId_;
    typedef std::shared_ptr<BranchNodeTokenId_>         BranchNodeTokenIdPtr_;
    typedef std::vector<BranchNodeTokenIdPtr_>          BranchNodeTokenIdPtrVector_;
    typedef std::vector<BranchNodeTokenIdPtrVector_>    BranchNodeTokenIdPtrVectorStack_;

<|end_if
    struct  ParseStackTreeNode_;

    typedef std::deque<ParseStackTreeNode_ *>           HPSQueue_;

    struct RealizedState_
    {
        RealizedState_      (Npda__::NpdaStateIndex_ initial_state);

        BranchNodePtrVectorStack_ const &BranchNodePtrVectorStack     () const { return m_branch_node_ptr_vector_stack; }
<|if(is_defined(generate_debug_spew_code))
        BranchNodeTokenIdPtrVectorStack_ const &BranchNodeTokenIdPtrVectorStack     () const { return m_branch_node_token_id_ptr_vector_stack; }
<|end_if

        TokenStack_ const & TokenStack                          () const { return m_token_stack; }
        TokenQueue_ const & LookaheadQueue                      () const { return m_lookahead_queue; }

        std::size_t         MaxRealizedLookaheadQueueSize       () const { return m_max_realized_lookahead_queue_size; }
        bool                HasEncounteredErrorState            () const { return m_has_encountered_error_state; }

        // This is used during the hypothetical branch processing for when more lookaheads are needed in the queue.
        void                PushBackLookahead                   (Token const &lookahead, HPSQueue_ const &hps_queue);

        Token               PopStack                            ();

        // void                ExecuteAction                       (Npda__::Transition_::Type action, ActionData_ action_data);

        // TODO: Need to figure out how to handle popping the token stack (since in a way it should be the
        // responsibility of ExecuteAction).  Maybe ExecuteAction should accept Token* which it will populate
        // with the popped token in the case of POP_STACK, so that the parser can call the throw-away-token actions.

        void                ExecuteActionReduce                 (Grammar_::Rule_ const &rule, Token::Data const &reduced_nonterminal_token_data, HPSQueue_ &hps_queue);
<|if(is_defined(generate_debug_spew_code))
        void                ExecuteActionShift                  (BranchNodePtrVector_ const &shifted_branch_node_ptr_vector, BranchNodeTokenIdPtrVector_ const &shifted_branch_node_token_id_ptr_vector, HPSQueue_ &hps_queue);
<|else
        void                ExecuteActionShift                  (BranchNodePtrVector_ const &shifted_branch_node_ptr_vector, HPSQueue_ &hps_queue);
<|end_if
        void                ExecuteActionInsertLookaheadError   (HPSQueue_ &hps_queue);
        void                ExecuteActionDiscardLookahead       (HPSQueue_ &hps_queue);
        // This one is tricky to implement within RealizedState_ alone.
        //void                ExecuteActionPopStack               (std::uint32_t pop_count);

        void                ClearStack                          ();
        void                Reinitialize                        (Npda__::NpdaStateIndex_ initial_state);

    private:

        void                Initialize                          (Npda__::NpdaStateIndex_ initial_state);

        void                PopFrontLookahead                   (HPSQueue_ &hps_queue);
        void                PushFrontLookahead                  (Token const &lookahead, HPSQueue_ &hps_queue);
        void                UpdateMaxRealizedLookaheadQueueSize (HPSQueue_ const &hps_queue);
        void                SetHasEncounteredErrorState         () { m_has_encountered_error_state = true; }

        // The set of the realized branches (i.e. the set of the tops of the NPDA state stacks)
        BranchNodePtrVectorStack_           m_branch_node_ptr_vector_stack;
<|if(is_defined(generate_debug_spew_code))
        BranchNodeTokenIdPtrVectorStack_    m_branch_node_token_id_ptr_vector_stack;
<|end_if
        TokenStack_                         m_token_stack;
        TokenQueue_                         m_lookahead_queue;
        // This is related to k in the LALR(k) quantity of the grammar, though it's only what's been realized
        // during the parse, not the theoretical bound (if it even exists).
        std::size_t                         m_max_realized_lookahead_queue_size;
        // TODO: Maybe make this into the number of times error recovery has been entered.
        bool                                m_has_encountered_error_state;
    }; // end of struct <{class_name}::RealizedState_

    struct ParseStackTreeNode_;

    struct HypotheticalState_
    {
        HypotheticalState_      (std::uint32_t initial_state);
        ~HypotheticalState_     ();

        // Removes the branch that the given node is a part of.  A branch of a node N is defined as the set of
        // nodes that are descendants of N, and all ancestors of N having exactly one child.
        void                    RemoveBranchIfNotTrunk (ParseStackTreeNode_ *branch_node);

    //private: // TEMP commented out until HypotheticalState_ is properly encapsulated.

        ParseStackTreeNode_ *   m_root;
        HPSQueue_               m_hps_queue;
        // This is stored so new memory isn't necessarily allocated for each parse iteration.
        HPSQueue_               m_new_hps_queue;
    }; // end of struct <{class_name}::HypotheticalState_

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, <{token_data_type} *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ const &token_stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if};

    // TODO: This should probably be inside HypotheticalState_
    struct ParseStackTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Npda__::Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, SHIFT, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // The granularity of the ordering depends on m_type.  In particular,
            // - POP_STACK is lexicographic ordering on the tuple (m_type, m_single_data).
            // - REDUCE only cares about m_type; the rule number itself doesn't matter.
            // - SHIFT only cares about m_type; the shifted token ID is only used in printing anyway
            // - other types only care about m_type.
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT:
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::Order
        }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::

<|if(is_defined(generate_debug_spew_code))
        static char const *AsString (Type type);

<|end_if

        struct ParseStackTreeNodeOrder
        {
            bool operator () (ParseStackTreeNode_ const *lhs, ParseStackTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseStackTreeNode_ *,ParseStackTreeNodeOrder> ParseStackTreeNodeSet;
        typedef std::map<Spec,ParseStackTreeNodeSet,Spec::Order> ChildMap;
        typedef std::pair<std::int32_t,std::int32_t> PrecedenceLevelRange;

        Spec m_spec;
        // This is the head node of the current branch that this ParseStackTreeNode_ is tracking.
        BranchNodePtr_ m_branch_node_ptr;
        // This is the set of m_branch_node_ptr values of all children.
        BranchNodePtrVector_ m_child_branch_node_ptr_vector;
<|if(is_defined(generate_debug_spew_code))
        // This tracks the Token::Id values in parallel with m_branch_node_ptr (which is the head
        // node of the current branch).
        BranchNodeTokenIdPtr_ m_branch_node_token_id_ptr;
        // This is the set of m_branch_node_token_id_ptr values for all children, and is indexed
        // exactly the same as m_child_branch_node_ptr_vector (i.e. one index corresponds to the
        // same child in both vectors).
        BranchNodeTokenIdPtrVector_ m_child_branch_node_token_id_ptr_vector;
<|end_if
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_ m_hypothetical_lookahead_token_id_queue;
        std::uint32_t m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        ParseStackTreeNode_ *m_parent_node;
        ChildMap m_child_nodes;

        ParseStackTreeNode_ (Spec const &spec)
            : m_spec(spec)
            , m_realized_lookahead_cursor(0)
            , m_parent_node(NULL)
        { }
        ~ParseStackTreeNode_ ();

        bool HasTrunkChild () const;
        ParseStackTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseStackTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseStackTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseStackTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (<{class_name} &parser) const;
        // Any HPS whose parent action pops the stack at all is blocked (because its future depends on the
        // values of the stack below the top).  Also, RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseStackTreeNode_ *&shift, ParseStackTreeNode_ *&reduce);

        void AddChild (ParseStackTreeNode_ *child);
        void RemoveChild (ParseStackTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseStackTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseStackTreeNode_ &orphan_target) const;
<|if(is_defined(generate_debug_spew_code))

        void Print (std::ostream &out, <{class_name} const *parser, std::string const &prefix, std::uint32_t indent_level = 0) const;
<|end_if
    }; // end of struct <{class_name}::ParseStackTreeNode_

    Token const &Lookahead_ (TokenQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};

    ParseStackTreeNode_ *   TakeHypotheticalActionOnHPS_ (ParseStackTreeNode_ const &hps, ParseStackTreeNode_::Type action_type, std::uint32_t action_data);

    static bool             CompareTokenId_             (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }

    // This doesn't reset the error state.
    void                    ClearStack_                 ();
    // This resets the error state.
    void                    CleanUpAllInternals_        ();

    RealizedState_     *    m_realized_state_;
    HypotheticalState_ *    m_hypothetical_state_;
