private:

    typedef std::set<std::uint32_t> StateSet_; // TODO: Should be NpdaStateSet_
    typedef std::vector<std::uint32_t> StateVector_; // TODO: Should be NpdaStateVector_

    // TODO: This should be RealizedBranchStateStackElement_
    struct RealizedBranchStackElement_
    {
//         std::uint32_t m_state_index;
        StateVector_ m_npda_state_vector;
        Token m_token;

        RealizedBranchStackElement_ ()
            :
//             m_state_index(std::uint32_t(-1)), // TODO: Should probably be ParseStackTreeNode_::UNUSED_DATA (or similar)
            m_token(Nonterminal::none_, <{token_data_default})
        { }
//         RealizedBranchStackElement_ (std::uint32_t state_index, Token const &token)
        RealizedBranchStackElement_ (StateVector_ const &npda_state_vector, Token const &token)
            :
//             m_state_index(state_index),
            m_npda_state_vector(npda_state_vector),
            m_token(token)
        { }
        RealizedBranchStackElement_ (StateSet_ const &npda_state_set, Token const &token)
            :
//             m_state_index(state_index),
            m_token(token)
        {
            for (StateSet_::const_iterator it = npda_state_set.begin(), it_end = npda_state_set.end(); it != it_end; ++it)
                m_npda_state_vector.push_back(*it);
        }

        bool operator == (RealizedBranchStackElement_ const &other) const
        {
            assert(false && "Is this even called?");
//             return m_state_index == other.m_state_index;
            return m_npda_state_vector == other.m_npda_state_vector;
        }
    }; // end of struct <{class_name}::RealizedBranchStackElement_

    // TODO: This should be HypotheticalBranchStateStackElement_
    struct HypotheticalBranchStackElement_
    {
        std::uint32_t m_state_index;
        Token::Id m_token_id;

        HypotheticalBranchStackElement_ ()
            :
            m_state_index(std::uint32_t(-1)), // TODO: Should probably be ParseStackTreeNode_::UNUSED_DATA (or similar)
            m_token_id(Nonterminal::none_)
        { }
        HypotheticalBranchStackElement_ (std::uint32_t state_index, Token::Id token_id)
            :
            m_state_index(state_index),
            m_token_id(token_id)
        { }

        bool operator == (HypotheticalBranchStackElement_ const &other) const { return m_state_index == other.m_state_index; }
    }; // end of struct <{class_name}::HypotheticalBranchStackElement_

    typedef std::deque<RealizedBranchStackElement_> RealizedBranchStack_;
    typedef std::deque<HypotheticalBranchStackElement_> HypotheticalBranchStack_;
    typedef std::deque<Token> TokenQueue_;
    typedef std::deque<Token::Id> TokenIdQueue_;

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, <{token_data_type} *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, RealizedBranchStack_ &stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if};
    void ThrowAwayRealizedBranchStackElement_ (RealizedBranchStackElement_ &stack_element) throw();

    struct Precedence_
    {
        std::int32_t m_level; // default precedence is 0, higher values have higher precedence.
        std::uint32_t m_associativity_index; // 0 for %left, 1 for %nonassoc, and 2 for %right.
<|if(is_defined(generate_debug_spew_code))
        char const *m_name;
<|end_if
    };

    struct Rule_
    {
        Token::Id m_reduction_nonterminal_token_id;
        std::uint32_t m_token_count;
        std::uint32_t m_precedence_index;
<|if(is_defined(generate_debug_spew_code))
        char const *m_description;
<|end_if
    }; // end of struct <{class_name}::Rule_

    struct State_
    {
        std::size_t m_transition_count; // TODO: smallest int
        Transition_ const *m_transition_table;
        std::uint32_t m_associated_rule_index;
<|if(is_defined(generate_debug_spew_code))
        char const *m_description;
<|end_if
    }; // end of struct <{class_name}::State_

    struct Transition_
    {
        enum Type { RETURN = 1, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, EPSILON };
        std::uint8_t m_type;
        // TODO: Should this be m_token_id ?
        std::uint32_t m_token_index; // TODO: smallest int
        std::uint32_t m_data_index; // TODO: smallest int

        // Lexicographic ordering on the tuple (m_type, m_token_index, m_data_index).
        struct Order
        {
            static std::uint32_t SortedTypeIndex (Type type)
            {
                switch (type)
                {
                    case REDUCE:
                    case SHIFT:
                        return 0;

                    case DISCARD_LOOKAHEAD:
                    case POP_STACK:
                        return 1;

                    case RETURN:
                        return 2;

                    case INSERT_LOOKAHEAD_ERROR:
                    case EPSILON:
                        return 3;

                    default:
                        assert(false && "this should never happen");
                        return 3; // Arbitrary
                }
            }

            bool operator () (Transition_ const &lhs, Transition_ const &rhs) const
            {
                std::uint32_t sorted_type_index_lhs = SortedTypeIndex(Type(lhs.m_type));
                std::uint32_t sorted_type_index_rhs = SortedTypeIndex(Type(rhs.m_type));
                if (sorted_type_index_lhs != sorted_type_index_rhs)
                    return sorted_type_index_lhs < sorted_type_index_rhs;
                else if (lhs.m_type != rhs.m_type)
                    return lhs.m_type < rhs.m_type;
                else if (lhs.m_token_index != rhs.m_token_index)
                    return lhs.m_token_index < rhs.m_token_index;
                else
                    return lhs.m_data_index < rhs.m_data_index;
            }
        };
    }; // end of struct <{class_name}::Transition_

    typedef std::set<Transition_,Transition_::Order> TransitionSet_;
    typedef std::vector<Transition_> TransitionVector_;

    struct Npda_;
    struct ParseStackTreeNode_;

    typedef std::deque<ParseStackTreeNode_ *> HPSQueue_;

    struct ParseStackTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                //if (m_type != REDUCE && m_type != POP_STACK)
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK) // HIPPO
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // Lexicographic ordering on the tuple (m_type, m_single_data).
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT: // HIPPO
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            };
        };

<|if(is_defined(generate_debug_spew_code))
        static char const *AsString (Type type);

<|end_if

        struct ParseStackTreeNodeOrder
        {
            bool operator () (ParseStackTreeNode_ const *lhs, ParseStackTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseStackTreeNode_ *,ParseStackTreeNodeOrder> ParseStackTreeNodeSet;
        typedef std::map<Spec,ParseStackTreeNodeSet,Spec::Order> ChildMap;
        typedef std::pair<std::int32_t,std::int32_t> PrecedenceLevelRange;

        Spec m_spec;
        StateSet_ m_npda_state_set;
        HypotheticalBranchStack_ m_stack;
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_ m_hypothetical_lookahead_token_id_queue;
        std::uint32_t m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        // StateSet_ m_top_states; // used for infinite loop detection
        ParseStackTreeNode_ *m_parent_node;
        ChildMap m_child_nodes;

        ParseStackTreeNode_ (Spec const &spec)
            : m_spec(spec)
            , m_realized_lookahead_cursor(0)
            , m_parent_node(NULL)
        { }
        ~ParseStackTreeNode_ ();

        bool HasTrunkChild () const;
        ParseStackTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseStackTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseStackTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseStackTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (<{class_name} &parser) const;
        // Any HPS whose parent action pops the stack at all is blocked (because its future depends on the
        // values of the stack below the top).  Also, RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseStackTreeNode_ *&shift, ParseStackTreeNode_ *&reduce);

        void AddChild (ParseStackTreeNode_ *child);
        void RemoveChild (ParseStackTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseStackTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseStackTreeNode_ &orphan_target) const;
<|if(is_defined(generate_debug_spew_code))

        void Print (std::ostream &out, <{class_name} const &parser, std::string const &prefix, std::uint32_t indent_level = 0) const;
<|end_if
    };

    Token const &Lookahead_ (TokenQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};

    ParseStackTreeNode_ *TakeHypotheticalActionOnHPS_ (ParseStackTreeNode_ const &hps, ParseStackTreeNode_::Type action_type, std::uint32_t action_data);

    struct Npda_
    {
        ParseStackTreeNode_ *m_root_;
        // TODO/NOTE: The hps-es should really have "npda stack" and "npda lookahead queue",
        // which don't have any token data, whereas Npda_ should have "realized stack" and "realized lookahead queue",
        // which do have (and own) the token data.
        // The "realized" states in m_realized_stack_ should actually each be a subset of the set of NPDA states.
        // These can be memoized and indexed, or not (use config flag to determine that).  The reason you may not
        // want to memoize all of them is if a grammar is somehow exponential in the number of NPDA states -> number of
        // DPDA states.
        RealizedBranchStack_ m_realized_stack_;
        TokenQueue_ m_realized_lookahead_queue_;
        HPSQueue_ m_hps_queue_;
        HPSQueue_ m_new_hps_queue_; // This is stored so new memory isn't necessarily allocated for each parse iteration.

        Npda_ () : m_root_(NULL), m_max_realized_lookahead_queue_size_(0), m_has_encountered_error_state_(false) { }
        ~Npda_ ();

        std::size_t MaxRealizedLookaheadQueueSize () const { return m_max_realized_lookahead_queue_size_; }
        bool HasEncounteredErrorState () const { return m_has_encountered_error_state_; }

        void PopFrontRealizedLookahead ();
        void PushFrontRealizedLookahead (Token const &lookahead);
        void PushBackRealizedLookahead (Token const &lookahead);
        // Removes the branch that the given node is a part of.  A branch of a node N is defined as the set of
        // nodes that are descendants of N, and all ancestors of N having exactly one child.
        void RemoveBranchIfNotTrunk (ParseStackTreeNode_ *branch_node);

        void SetHasEncounteredErrorState () { m_has_encountered_error_state_ = true; }

    private:

        void UpdateMaxRealizedLookaheadQueueSize ();

        std::size_t m_max_realized_lookahead_queue_size_;
        bool m_has_encountered_error_state_;
    };

    Npda_ m_npda_;

    // TODO: Append _ to all implementation detail methods and members
    // Returns true iff lhs_rule_index denotes a rule with a higher precedence than that denoted by rhs_rule_index.
    static bool CompareRuleByPrecedence (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index);
    static bool CompareTokenId (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }
    static bool CompareHypotheticalBranchStackElement (HypotheticalBranchStackElement_ const &lhs, HypotheticalBranchStackElement_ const &rhs) { return lhs.m_state_index < rhs.m_state_index; }

    // Returns the epsilon closure of the given NPDA state.  Return value is memoized.
    static StateVector_ const &EpsilonClosureOfState_ (std::uint32_t state_index);
    // Computes the epsilon closure of the given NPDA state.
    static void ComputeEpsilonClosureOfState_ (std::uint32_t state_index, StateSet_ &epsilon_closure);
    // Returns the epsilon closure of the given NPDA state set.  Return value is memoized.
    static StateVector_ const &EpsilonClosureOfStateSet_ (StateSet_ const &state_set);
    // Returns the transitions, matching given sorted_type_index, for the epsilon closure of the given NPDA state.  Return value is memoized.
    static TransitionVector_ const &NonEpsilonTransitionsOfState_ (std::uint32_t state_index, std::uint32_t sorted_type_index);

    friend struct ParseStackTreeNode_;

    static Precedence_ const ms_precedence_table_[];
    static std::size_t const ms_precedence_count_;
