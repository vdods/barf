private:

<|include("trison.cpp.npda.grammar.header.codespec")

<|include("trison.cpp.npda.npda.header.codespec")

    // NOTE: Because this uses std::shared_ptr, if you create a cycle in the list (which is valid and
    // the algorithms will work), then you must explicitly break it later in order for that memory to
    // be cleaned up (otherwise the ref count of the elements in the cycle will never go back to zero).
    template <typename DataType>
    struct TreeNode_ : public std::enable_shared_from_this<TreeNode_<DataType>>
    {
        // Ideally this would be private and std::make_shared<TreeNode_> would be a friend
        // in order to force use of std::make_shared to construct std::shared_ptr<TreeNode_>
        // instances instead of bare TreeNode_ instances, but I couldn't figure out how to
        // do this correctly.
        template <typename... Types>
        TreeNode_ (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
            :   m_parent(parent)
            ,   m_data(std::forward<Types>(args)...)
        { }

        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateWithParent (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
        {
            return std::make_shared<TreeNode_>(parent, std::forward<Types>(args)...);
        }
        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateOrphan (Types&&... args)
        {
            return std::make_shared<TreeNode_>(nullptr, std::forward<Types>(args)...);
        }

        bool HasParent () const { return bool(m_parent); }
        std::shared_ptr<TreeNode_ const> Parent () const { return m_parent; }
        std::shared_ptr<TreeNode_> const &Parent () { return m_parent; }
        DataType const &Data () const { return m_data; }
        DataType &Data () { return m_data; }
        std::size_t BranchLength () const
        {
            if (HasParent())
                return 1 + Parent()->BranchLength_Impl(*this);
            else
                return 1;
        }

        template <typename T>
        void PrintRootToLeaf (std::ostream &out, T (*DataTransform)(DataType const &)) const
        {
            if (this->HasParent())
            {
                Parent()->PrintRootToLeaf(out, DataTransform);
                out << ' ';
            }
            out << DataTransform(Data());
        }

    private:

        // The initial_element parameter is used to prevent infinite loop in the case of a branch containing a cycle.
        std::size_t BranchLength_Impl (TreeNode_ const &initial_element) const
        {
            if (this == &initial_element)
                return 0;
            else if (HasParent())
                return 1 + Parent()->BranchLength_Impl(initial_element);
            else
                return 1;
        }

        std::shared_ptr<TreeNode_> m_parent;
        DataType m_data;
    };

    template <typename DataType>
    struct TreeNodeOrder_
    {
        bool operator () (std::shared_ptr<TreeNode_<DataType>> const &lhs, std::shared_ptr<TreeNode_<DataType>> const &rhs) const
        {
            if (bool(lhs))
            {
                if (bool(rhs))
                {
                    if (lhs->Data() < rhs->Data())
                        return true;
                    else if (lhs->Data() > rhs->Data())
                        return false;
                    else
                        // Recursive case defined on the tails of lhs and rhs respectively.
                        return this->operator()(lhs->Parent(), rhs->Parent());
                }
                else
                    // Declare non-null to be "greater than" null.
                    return false;
            }
            else
            {
                if (bool(rhs))
                    // Declare null to be "less than" non-null.
                    return true;
                else
                    // Declare null to be "equal to" null.
                    return false;
            }
        }
    };

    typedef std::uint32_t                               ActionData_;

    typedef std::deque<Token>                           TokenQueue_;
    typedef std::vector<Token>                          TokenStack_;
    typedef std::deque<Token::Id>                       TokenIdQueue_;

    // This forms one element, containing the NPDA state index, of a NPDA state stack (aka branch).
    typedef TreeNode_<Npda_::StateIndex_>               BranchNode_;
    typedef std::shared_ptr<BranchNode_>                BranchNodePtr_;
    // This contains the tops of all the branch state stacks for a particular RealizedState_ state.
    typedef std::vector<BranchNodePtr_>                 BranchNodePtrVector_;
    // This contains the stack of RealizedState_ states.
    typedef std::vector<BranchNodePtrVector_>           BranchNodePtrVectorStack_;

<|if(is_defined(generate_debug_spew_code))
    // These are tracked in parallel with BranchNode_, etc for the purposes of debug spew only.
    typedef TreeNode_<Token::Id>                        BranchNodeTokenId_;
    typedef std::shared_ptr<BranchNodeTokenId_>         BranchNodeTokenIdPtr_;
    typedef std::vector<BranchNodeTokenIdPtr_>          BranchNodeTokenIdPtrVector_;
    typedef std::vector<BranchNodeTokenIdPtrVector_>    BranchNodeTokenIdPtrVectorStack_;

    // These are used in printing the branch state stacks and token id stacks.
    template <typename T>
    static T const &IdentityTransform_ (T const &x) { return x; }

    static char const *TokenName_ (Token::Id const &token_id) { return ms_token_name_table_[token_id]; }

<|end_if
    struct  ParseStackTreeNode_;

    typedef std::deque<ParseStackTreeNode_ *>           HPSQueue_;

    struct RealizedState_
    {
        RealizedState_      (Npda_::StateIndex_ initial_state);

        BranchNodePtrVectorStack_ const &BranchNodePtrVectorStack     () const { return m_branch_node_ptr_vector_stack; }
<|if(is_defined(generate_debug_spew_code))
        BranchNodeTokenIdPtrVectorStack_ const &BranchNodeTokenIdPtrVectorStack     () const { return m_branch_node_token_id_ptr_vector_stack; }
<|end_if

        TokenStack_ const & TokenStack                          () const { return m_token_stack; }
        TokenQueue_ const & LookaheadQueue                      () const { return m_lookahead_queue; }

        std::size_t         MaxRealizedLookaheadCount           () const { return m_max_realized_lookahead_count; }
        bool                HasExceededMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count) const { return max_allowable_lookahead_count >= 0 && m_max_realized_lookahead_count > std::size_t(max_allowable_lookahead_count); }
        bool                HasEncounteredErrorState            () const { return m_has_encountered_error_state; }

        // This is used during the hypothetical branch processing for when more lookaheads are needed in the queue.
        void                PushBackLookahead                   (Token const &lookahead, HPSQueue_ const &hps_queue);

        Token               PopStack                            ();
        Token               PopFrontLookahead                   (HPSQueue_ &hps_queue);

        // void                ExecuteAction                       (Npda_::Transition_::Type action, ActionData_ action_data);

        // TODO: Need to figure out how to handle popping the token stack (since in a way it should be the
        // responsibility of ExecuteAction).  Maybe ExecuteAction should accept Token* which it will populate
        // with the popped token in the case of POP_STACK, so that the parser can call the throw-away-token actions.

        void                ExecuteActionReduce                 (Grammar_::Rule_ const &rule, Token::Data const &reduced_nonterminal_token_data, HPSQueue_ &hps_queue);
<|if(is_defined(generate_debug_spew_code))
        void                ExecuteActionShift                  (BranchNodePtrVector_ const &shifted_branch_node_ptr_vector, BranchNodeTokenIdPtrVector_ const &shifted_branch_node_token_id_ptr_vector, HPSQueue_ &hps_queue);
<|else
        void                ExecuteActionShift                  (BranchNodePtrVector_ const &shifted_branch_node_ptr_vector, HPSQueue_ &hps_queue);
<|end_if
        void                ExecuteActionInsertLookaheadError   (HPSQueue_ &hps_queue);
        void                ExecuteActionDiscardLookahead       (HPSQueue_ &hps_queue);
        // This one is tricky to implement within RealizedState_ alone.
        //void                ExecuteActionPopStack               (std::uint32_t pop_count);

        void                ClearStack                          ();
        void                Reinitialize                        (Npda_::StateIndex_ initial_state);

    private:

        void                Initialize                          (Npda_::StateIndex_ initial_state);

        void                PushFrontLookahead                  (Token const &lookahead, HPSQueue_ &hps_queue);
        void                UpdateMaxRealizedLookaheadCount     (HPSQueue_ const &hps_queue);
        void                SetHasEncounteredErrorState         () { m_has_encountered_error_state = true; }

        // The set of the realized branches (i.e. the set of the tops of the NPDA state stacks)
        BranchNodePtrVectorStack_           m_branch_node_ptr_vector_stack;
<|if(is_defined(generate_debug_spew_code))
        BranchNodeTokenIdPtrVectorStack_    m_branch_node_token_id_ptr_vector_stack;
<|end_if
        TokenStack_                         m_token_stack;
        TokenQueue_                         m_lookahead_queue;
        // This is related to k in the LALR(k) quantity of the grammar, though it's only what's been realized
        // during the parse, not the theoretical bound (if it even exists).
        std::size_t                         m_max_realized_lookahead_count;
        // TODO: Maybe make this into the number of times error recovery has been entered.
        bool                                m_has_encountered_error_state;
    }; // end of struct <{class_name}::RealizedState_

    struct HypotheticalState_
    {
        HypotheticalState_      (std::uint32_t initial_state);
        ~HypotheticalState_     ();

        // The min and max realized lookahead cursors being equal across all HPSes indicates that
        // all HPSes have consumed the same number of lookaheads, so they're in a well-defined
        // state with respect to resolving SHIFT/REDUCE conflicts.
        bool                    MinAndMaxRealizedLookaheadCursorsAreEqual () const;

        // Removes the branch that the given node is a part of.  A branch of a node N is defined as the set of
        // nodes that are descendants of N, and all ancestors of N having exactly one child.
        ParseStackTreeNode_ *   RemoveBranchIfNotTrunk (ParseStackTreeNode_ *branch_node);

        // Destroys the parse tree and recreates a root node with no children.
        void                    DestroyParseTree ();

    //private: // TEMP commented out until HypotheticalState_ is properly encapsulated.

        // Note that if m_hps_queue is empty, then *min = std::numeric_limits<std::uint32_t>::max()
        // and *max = std::numeric_limits<std::uint32_t>::min().  If min or max is nullptr, doesn't
        // assign to that one.
        void                    ComputeMinAndMaxRealizedLookaheadCursors (std::uint32_t *min, std::uint32_t *max) const;

        ParseStackTreeNode_ *   m_root;
        HPSQueue_               m_hps_queue;
        // This is stored so new memory isn't necessarily allocated for each parse iteration.
        HPSQueue_               m_new_hps_queue;
    }; // end of struct <{class_name}::HypotheticalState_

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, <{token_data_type} *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ const &token_stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if};

    // TODO: This should probably be inside HypotheticalState_
    struct ParseStackTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Npda_::Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, SHIFT, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // The granularity of the ordering depends on m_type.  In particular,
            // - POP_STACK is lexicographic ordering on the tuple (m_type, m_single_data).
            // - REDUCE only cares about m_type; the rule number itself doesn't matter.
            // - SHIFT only cares about m_type; the shifted token ID is only used in printing anyway
            // - other types only care about m_type.
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT:
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::Order
        }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::

<|if(is_defined(generate_debug_spew_code))
        static char const *AsString (Type type);

<|end_if

        struct ParseStackTreeNodeOrder
        {
            bool operator () (ParseStackTreeNode_ const *lhs, ParseStackTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseStackTreeNode_ *,ParseStackTreeNodeOrder> ParseStackTreeNodeSet;
        typedef std::map<Spec,ParseStackTreeNodeSet,Spec::Order> ChildMap;
        typedef std::pair<std::int32_t,std::int32_t> PrecedenceLevelRange;

        Spec m_spec;
        // This is the head node of the current branch that this ParseStackTreeNode_ is tracking.
        BranchNodePtr_ m_branch_node_ptr;
        // This is the set of m_branch_node_ptr values of all children.
        BranchNodePtrVector_ m_child_branch_node_ptr_vector;
<|if(is_defined(generate_debug_spew_code))
        // This tracks the Token::Id values in parallel with m_branch_node_ptr (which is the head
        // node of the current branch).
        BranchNodeTokenIdPtr_ m_branch_node_token_id_ptr;
        // This is the set of m_branch_node_token_id_ptr values for all children, and is indexed
        // exactly the same as m_child_branch_node_ptr_vector (i.e. one index corresponds to the
        // same child in both vectors).
        BranchNodeTokenIdPtrVector_ m_child_branch_node_token_id_ptr_vector;
<|end_if
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_ m_hypothetical_lookahead_token_id_queue;
        std::uint32_t m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        ParseStackTreeNode_ *m_parent_node;
        ChildMap m_child_nodes;

<|if(0)
<|if(is_defined(generate_debug_spew_code))
        // TEMP
        static std::set<ParseStackTreeNode_*> ms_active_pointer_set;

<|end_if
<|end_if
        ParseStackTreeNode_ (Spec const &spec)
            :   m_spec(spec)
            ,   m_realized_lookahead_cursor(0)
            ,   m_parent_node(NULL)
<|if(0)
<|if(is_defined(generate_debug_spew_code))
        {
            ms_active_pointer_set.insert(this);
        }
<|end_if
<|else
        { }
<|end_if
        ~ParseStackTreeNode_ ();

        bool HasTrunkChild () const;
        ParseStackTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseStackTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseStackTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseStackTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (<{class_name} &parser) const;
        // Some actions are considered to block the HPS from continuing (because it must be realized before
        // continuing).  RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseStackTreeNode_ *&shift, ParseStackTreeNode_ *&reduce);

        void AddChild (ParseStackTreeNode_ *child);
        void RemoveChild (ParseStackTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseStackTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseStackTreeNode_ &orphan_target) const;
<|if(is_defined(generate_debug_spew_code))

        void Print (std::ostream &out, <{class_name} const *parser, std::string const &prefix, std::uint32_t indent_level = 0, bool suppress_initial_prefix = false) const;
<|end_if
    }; // end of struct <{class_name}::ParseStackTreeNode_

    Token const &Lookahead_ (TokenQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};

    ParseStackTreeNode_ *   TakeHypotheticalActionOnHPS_ (ParseStackTreeNode_ const &hps, ParseStackTreeNode_::Type action_type, std::uint32_t action_data);
    // Recreates the parse tree (i.e. the contents of m_hypothetical_state_) from the top of the
    // branch set stack of m_realized_state_, specifically, creates an HPS corresponding to each
    // branch, adding each created HPS as a child to the root node.
    void                    CreateParseTreeFromRealizedState_ ();

    static bool             CompareTokenId_             (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }

    // This doesn't reset the error state.
    void                    ClearStack_                 ();
    // This resets the error state.
    void                    CleanUpAllInternals_        ();

    RealizedState_     *    m_realized_state_;
    HypotheticalState_ *    m_hypothetical_state_;
