private:

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, <{token_data_type} *&return_token);
    void ContinueNPDAParse_ ();
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, Stack_ &stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if};

    struct Transition_
    {
        enum Type { RETURN = 1, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, EPSILON };
        std::uint8_t m_type;
        std::uint32_t m_token_index; // TODO: smallest int
        std::uint32_t m_data_index; // TODO: smallest int

        // Lexicographic ordering on the tuple (m_type, m_token_index, m_data_index).
        struct Order
        {
            static std::uint32_t SortedTypeIndex (Type type)
            {
                switch (type)
                {
                    case REDUCE:
                    case SHIFT:
                    case DISCARD_LOOKAHEAD:
                    case POP_STACK:
                        return 0;

                    case RETURN:
                        return 1;

                    case INSERT_LOOKAHEAD_ERROR:
                    case EPSILON:
                        return 2;
                }
            }

            bool operator () (Transition_ const &lhs, Transition_ const &rhs) const
            {
                std::uint32_t sorted_type_index_lhs = SortedTypeIndex(Type(lhs.m_type));
                std::uint32_t sorted_type_index_rhs = SortedTypeIndex(Type(rhs.m_type));
                if (sorted_type_index_lhs != sorted_type_index_rhs)
                    return sorted_type_index_lhs < sorted_type_index_rhs;
                else if (lhs.m_type != rhs.m_type)
                    return lhs.m_type < rhs.m_type;
                else if (lhs.m_token_index != rhs.m_token_index)
                    return lhs.m_token_index < rhs.m_token_index;
                else
                    return lhs.m_data_index < rhs.m_data_index;
            }
        };
    }; // end of struct <{class_name}::Transition_

    typedef std::set<std::uint32_t> StateSet_;
    typedef std::vector<std::uint32_t> StateVector_;
    typedef std::set<Transition_,Transition_::Order> TransitionSet_;
    typedef std::vector<Transition_> TransitionVector_;

    struct Npda_;

    struct ParseStackTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Transition_::Type.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, BRANCH, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // Lexicographic ordering on the tuple (m_type, m_single_data).
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case REDUCE:
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            };
        };

<|if(is_defined(generate_debug_spew_code))
        static char const *AsString (Type type);

<|end_if
        typedef std::set<ParseStackTreeNode_ *> ParseStackTreeNodeSet;
        typedef std::map<Spec,ParseStackTreeNodeSet,Spec::Order> ChildMap;

        Spec m_spec;
        Stack_ m_stack;
        // m_local_lookahead_queue comes before the "global" lookahead queue, and m_global_lookahead_cursor
        // is the index into the "global" lookahead queue for where the end of m_local_lookahead_queue
        // lands.  In other words, this node's "total" lookahead
        LookaheadQueue_ m_local_lookahead_queue;
        std::uint32_t m_global_lookahead_cursor; // this is an index into the "global" lookahead queue.
        // StateSet_ m_top_states; // used for infinite loop detection
        ParseStackTreeNode_ *m_parent_node;
        ChildMap m_child_nodes;

        ParseStackTreeNode_ (Spec const &spec)
            : m_spec(spec)
            , m_global_lookahead_cursor(0)
            , m_parent_node(NULL)
        { }

        bool HasTrunkChild () const;
        ParseStackTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseStackTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseStackTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        Token const &Lookahead (<{class_name} &parser) const;

        void AddChild (ParseStackTreeNode_ *child);
        void RemoveChild (ParseStackTreeNode_ *child);
        void RemoveFromParent ();

        ParseStackTreeNode_ *CloneLeafNode () const;

        void Print (std::ostream &out, <{class_name} const &parser, std::uint32_t indent_level = 0) const;
    };

    typedef std::deque<ParseStackTreeNode_ *> BranchQueue_;

    Token const &Lookahead_ (LookaheadQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};

    ParseStackTreeNode_ *TakeHypotheticalActionOnBranch_ (ParseStackTreeNode_ const &branch, ParseStackTreeNode_::Type action_type, std::uint32_t action_data);

    struct Npda_
    {
        ParseStackTreeNode_ *m_root_;
        Stack_ m_global_stack_;
        LookaheadQueue_ m_global_lookahead_queue_;
        BranchQueue_ m_branch_queue_;
        BranchQueue_ m_new_branch_queue_; // This is stored so new memory isn't allocated for each parse iteration.

        Npda_ () : m_root_(NULL) { }

        void PopFrontGlobalLookahead ();
        void PushFrontGlobalLookahead (Token const &lookahead);
    };

    Npda_ m_npda_;

    static StateVector_ const &EpsilonClosureOfState_ (std::uint32_t state_index);
    static TransitionVector_ const &NonEpsilonTransitionsOfState_ (std::uint32_t state_index);

    friend struct ParseStackTreeNode_;