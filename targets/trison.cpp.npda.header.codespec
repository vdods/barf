public:

    std::size_t MaxRealizedLookaheadQueueSize () const { return m_npda_->m_realized_state.MaxRealizedLookaheadQueueSize(); }
    //bool        HasEncounteredErrorState      () const { return m_npda_->m_realized_state.HasEncounteredErrorState(); }

private:

    struct Precedence_
    {
        std::int32_t m_level; // default precedence is 0, higher values have higher precedence.
        std::uint32_t m_associativity_index; // 0 for %left, 1 for %nonassoc, and 2 for %right.
<|if(is_defined(generate_debug_spew_code))
        char const *m_name;
<|end_if
    };

    struct Rule_
    {
        Token::Id m_reduction_nonterminal_token_id;
        std::uint32_t m_token_count;
        std::uint32_t m_precedence_index;
<|if(is_defined(generate_debug_spew_code))
        char const *m_description;
<|end_if
    }; // end of struct <{class_name}::Rule_

    struct State_
    {
        std::size_t m_transition_count; // TODO: smallest int
        Transition_ const *m_transition_table;
        std::uint32_t m_associated_rule_index;
<|if(is_defined(generate_debug_spew_code))
        char const *m_description;
<|end_if
    }; // end of struct <{class_name}::State_

    struct Transition_
    {
        enum Type { RETURN = 1, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, EPSILON };
        std::uint8_t m_type;
        // TODO: Should this be m_token_id ?
        std::uint32_t m_token_index; // TODO: smallest int
        std::uint32_t m_data_index; // TODO: smallest int

        // Lexicographic ordering on the tuple (m_type, m_token_index, m_data_index).
        struct Order
        {
            static std::uint32_t SortedTypeIndex (Type type)
            {
                switch (type)
                {
                    case REDUCE:
                    case SHIFT:
                        return 0;

                    case DISCARD_LOOKAHEAD:
                    case POP_STACK:
                        return 1;

                    case RETURN:
                        return 2;

                    case INSERT_LOOKAHEAD_ERROR:
                    case EPSILON:
                        return 3;

                    default:
                        assert(false && "this should never happen");
                        return 3; // Arbitrary
                }
            }

            bool operator () (Transition_ const &lhs, Transition_ const &rhs) const
            {
                std::uint32_t sorted_type_index_lhs = SortedTypeIndex(Type(lhs.m_type));
                std::uint32_t sorted_type_index_rhs = SortedTypeIndex(Type(rhs.m_type));
                if (sorted_type_index_lhs != sorted_type_index_rhs)
                    return sorted_type_index_lhs < sorted_type_index_rhs;
                else if (lhs.m_type != rhs.m_type)
                    return lhs.m_type < rhs.m_type;
                else if (lhs.m_token_index != rhs.m_token_index)
                    return lhs.m_token_index < rhs.m_token_index;
                else
                    return lhs.m_data_index < rhs.m_data_index;
            }
        };
    }; // end of struct <{class_name}::Transition_

    typedef std::set<Transition_,Transition_::Order>    TransitionSet_;
    typedef std::vector<Transition_>                    TransitionVector_;

    typedef std::uint32_t                               NpdaStateIndex_;
    typedef std::uint32_t                               ActionData_;

    typedef std::deque<NpdaStateIndex_>                 NpdaStateIndexStack_;
    typedef std::set<NpdaStateIndex_>                   NpdaStateIndexSet_;
    typedef std::vector<NpdaStateIndex_>                NpdaStateIndexVector_;

    typedef std::deque<Token>                           TokenQueue_;
    typedef std::vector<Token>                          TokenStack_;
    typedef std::deque<Token::Id>                       TokenIdQueue_;

    // This forms one element, containing the NPDA state index, of a NPDA state stack (aka branch).
    typedef SharedLinkedListElement_<NpdaStateIndex_>   BranchNode_;
    typedef std::shared_ptr<BranchNode_>                BranchNodePtr_;
    // This contains the tops of all the branch state stacks.  The ordering is necessary in order
    // to distinguish different branches that may have identical top states.
    typedef std::set<BranchNodePtr_,SharedLinkedListElementOrder_<NpdaStateIndex_>> BranchNodePtrSet_;
    typedef std::vector<BranchNodePtrSet_>              BranchNodePtrSetStack_;

<|if(is_defined(generate_debug_spew_code))
    typedef SharedLinkedListElement_<Token::Id>         BranchNodeTokenId_;
    typedef std::shared_ptr<BranchNodeTokenId_>         BranchNodeTokenIdPtr_;

<|end_if
    struct  ParseStackTreeNode_;

    typedef std::deque<ParseStackTreeNode_ *>           HPSQueue_;

    struct RealizedState_
    {
        RealizedState_      (std::uint32_t initial_state);

        BranchNodePtrSetStack_ const &BranchNodePtrSetStack     () const { return m_branch_node_ptr_set_stack; }

        TokenStack_ const & TokenStack                          () const { return m_token_stack; }
        TokenQueue_ const & LookaheadQueue                      () const { return m_lookahead_queue; }

        std::size_t         MaxRealizedLookaheadQueueSize       () const { return m_max_realized_lookahead_queue_size; }
        bool                HasEncounteredErrorState            () const { return m_has_encountered_error_state; }

        // This is used during the hypothetical branch processing for when more lookaheads are needed in the queue.
        void                PushBackLookahead                   (Token const &lookahead, HPSQueue_ const &hps_queue);

        Token               PopStack                            ();

        // void                ExecuteAction                       (Transition_::Type action, ActionData_ action_data);

        // TODO: Need to figure out how to handle popping the token stack (since in a way it should be the
        // responsibility of ExecuteAction).  Maybe ExecuteAction should accept Token* which it will populate
        // with the popped token in the case of POP_STACK, so that the parser can call the throw-away-token actions.

        void                ExecuteActionReduce                 (Rule_ const &rule, Token::Data const &reduced_nonterminal_token_data, HPSQueue_ &hps_queue);
        void                ExecuteActionShift                  (BranchNodePtrSet_ const &shifted_branch_node_ptr_set, HPSQueue_ &hps_queue);
        void                ExecuteActionInsertLookaheadError   (HPSQueue_ &hps_queue);
        void                ExecuteActionDiscardLookahead       (HPSQueue_ &hps_queue);
        // This one is tricky to implement within RealizedState_ alone.
        //void                ExecuteActionPopStack               (std::uint32_t pop_count);

    private:

        void                PopFrontLookahead                   (HPSQueue_ &hps_queue);
        void                PushFrontLookahead                  (Token const &lookahead, HPSQueue_ &hps_queue);
        void                UpdateMaxRealizedLookaheadQueueSize (HPSQueue_ const &hps_queue);
        void                SetHasEncounteredErrorState         () { m_has_encountered_error_state = true; }

        // The set of the realized branches (i.e. the set of the tops of the NPDA state stacks)
        BranchNodePtrSetStack_ m_branch_node_ptr_set_stack;
        TokenStack_         m_token_stack;
        TokenQueue_         m_lookahead_queue;
        // This is related to k in the LALR(k) quantity of the grammar, though it's only what's been realized
        // during the parse, not the theoretical bound (if it even exists).
        std::size_t         m_max_realized_lookahead_queue_size;
        // TODO: Maybe make this into the number of times error recovery has been entered.
        bool                m_has_encountered_error_state;
    }; // end of struct <{class_name}::RealizedState_

    struct ParseStackTreeNode_;

    struct HypotheticalState_
    {
        HypotheticalState_      (std::uint32_t initial_state);
        ~HypotheticalState_     ();

        // Removes the branch that the given node is a part of.  A branch of a node N is defined as the set of
        // nodes that are descendants of N, and all ancestors of N having exactly one child.
        void                    RemoveBranchIfNotTrunk (ParseStackTreeNode_ *branch_node);

    //private: // TEMP commented out until HypotheticalState_ is properly encapsulated.

        ParseStackTreeNode_ *   m_root;
        HPSQueue_               m_hps_queue;
        // This is stored so new memory isn't necessarily allocated for each parse iteration.
        HPSQueue_               m_new_hps_queue;
    }; // end of struct <{class_name}::HypotheticalState_

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, <{token_data_type} *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ const &token_stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if};
    // void ThrowAwayRealizedStateStackElement_ (BranchNodePtrSet_ const &branch_node_ptr_set, Token_ &token) throw();

    // TODO: This should probably be inside HypotheticalState_
    struct ParseStackTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, SHIFT, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // The granularity of the ordering depends on m_type.  In particular,
            // - POP_STACK is lexicographic ordering on the tuple (m_type, m_single_data).
            // - REDUCE only cares about m_type; the rule number itself doesn't matter.
            // - SHIFT only cares about m_type; the shifted token ID is only used in printing anyway
            // - other types only care about m_type.
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT:
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::Order
        }; // end of struct <{class_name}::ParseStackTreeNode_::Spec::

<|if(is_defined(generate_debug_spew_code))
        static char const *AsString (Type type);

<|end_if

        struct ParseStackTreeNodeOrder
        {
            bool operator () (ParseStackTreeNode_ const *lhs, ParseStackTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseStackTreeNode_ *,ParseStackTreeNodeOrder> ParseStackTreeNodeSet;
        typedef std::map<Spec,ParseStackTreeNodeSet,Spec::Order> ChildMap;
        typedef std::pair<std::int32_t,std::int32_t> PrecedenceLevelRange;

        Spec m_spec;
        BranchNodePtrSet_ m_child_branch_node_ptr_set;
        // This is the head node of the current branch that this ParseStackTreeNode_ is tracking.
        BranchNodePtr_ m_branch_node_ptr;
<|if(is_defined(generate_debug_spew_code))
        // This tracks the Token::Id values in parallel with m_branch_node_ptr (which is the head
        // node of the current branch).
        BranchNodeTokenIdPtr_ m_branch_node_token_id_ptr;
<|end_if
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_ m_hypothetical_lookahead_token_id_queue;
        std::uint32_t m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        ParseStackTreeNode_ *m_parent_node;
        ChildMap m_child_nodes;

        ParseStackTreeNode_ (Spec const &spec)
            : m_spec(spec)
            , m_realized_lookahead_cursor(0)
            , m_parent_node(NULL)
        { }
        ~ParseStackTreeNode_ ();

        bool HasTrunkChild () const;
        ParseStackTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseStackTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseStackTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseStackTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (<{class_name} &parser) const;
        // Any HPS whose parent action pops the stack at all is blocked (because its future depends on the
        // values of the stack below the top).  Also, RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseStackTreeNode_ *&shift, ParseStackTreeNode_ *&reduce);

        void AddChild (ParseStackTreeNode_ *child);
        void RemoveChild (ParseStackTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseStackTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseStackTreeNode_ &orphan_target) const;
<|if(is_defined(generate_debug_spew_code))

        void Print (std::ostream &out, <{class_name} const &parser, std::string const &prefix, std::uint32_t indent_level = 0) const;
        void PrintBasic (std::ostream &out, std::string const &prefix, std::uint32_t indent_level = 0) const;
<|end_if
    }; // end of struct <{class_name}::ParseStackTreeNode_

    Token const &Lookahead_ (TokenQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if};

    ParseStackTreeNode_ *TakeHypotheticalActionOnHPS_ (ParseStackTreeNode_ const &hps, ParseStackTreeNode_::Type action_type, std::uint32_t action_data);

    // TODO: There's probably no reason to have this class anymore, just put m_realized_state
    // and m_hypothetical_state in the parser class.
    struct Npda_
    {
        RealizedState_ m_realized_state;
        HypotheticalState_ m_hypothetical_state;

        Npda_ (Nonterminal::Name nonterminal_to_parse);
        ~Npda_ ();
    };

    Npda_ *m_npda_;

    // Returns true iff lhs_rule_index denotes a rule with a higher precedence than that denoted by rhs_rule_index.
    static bool CompareRuleByPrecedence_ (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index);
    static bool CompareTokenId_ (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }

    // Returns the epsilon closure of the given NPDA state.  Return value is memoized.
    static NpdaStateIndexVector_ const &EpsilonClosureOfState_ (std::uint32_t state_index);
    // Computes the epsilon closure of the given NPDA state.
    static void ComputeEpsilonClosureOfState_ (std::uint32_t state_index, NpdaStateIndexSet_ &epsilon_closure);
    // Returns the epsilon closure of the given NPDA state set.  Return value is memoized.
    static NpdaStateIndexVector_ const &EpsilonClosureOfStateSet_ (NpdaStateIndexSet_ const &state_set);
    // Returns the transitions, matching given sorted_type_index, for the epsilon closure of the given NPDA state.  Return value is memoized.
    static TransitionVector_ const &NonEpsilonTransitionsOfState_ (std::uint32_t state_index, std::uint32_t sorted_type_index);

    friend struct ParseStackTreeNode_;

    static Precedence_ const ms_precedence_table_[];
    static std::size_t const ms_precedence_count_;
