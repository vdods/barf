<|if(header_filename == implementation_filename)
<|error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{define(debug_spew_prefix)}"<{class_name}:"<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by reflex<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include <cassert>
#include <deque>
#include <string>

<|include("barf.cpp.include.codespec")

#if !defined(ReflexCpp_namespace_)
#define ReflexCpp_namespace_
namespace ReflexCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// implements the InputApparatus interface as described in the documentation
// /////////////////////////////////////////////////////////////////////////////

class InputApparatus_
{
protected:

    typedef bool (InputApparatus_::*IsInputAtEndMethod_)();
    typedef BarfCpp_::Uint8 (InputApparatus_::*ReadNextAtomMethod_)();

    InputApparatus_ (IsInputAtEndMethod_ IsInputAtEnd, ReadNextAtomMethod_ ReadNextAtom)
        :
        m_IsInputAtEnd(IsInputAtEnd),
        m_ReadNextAtom(ReadNextAtom)
    {
        // subclasses must call InputApparatus_::ResetForNewInput_ in their constructors.
    }

    bool IsAtEndOfInput () { return IsConditionalMet(CF_END_OF_INPUT, CF_END_OF_INPUT); }

    void Unaccept (BarfCpp_::Uint32 unaccept_char_count)
    {
        assert(m_accept_cursor == m_start_cursor && "may only Unaccept within accept handler code");
        assert(unaccept_char_count <= m_start_cursor && "can't Unaccept more characters than were accepted");
        if (unaccept_char_count == 0)
            return; // nothing to do
        // update the cursors
        m_start_cursor -= unaccept_char_count;
        m_read_cursor = m_start_cursor + 1;
        m_accept_cursor = m_start_cursor;
    }
    
    void DumpPreviouslyAcceptedChars_ ()
    {
        // dump the first m_start_cursor chars from the buffer
        while (m_start_cursor > 0)
        {
            --m_start_cursor;
            m_buffer.pop_front();
        }
        // reset the other cursors
        m_read_cursor = 1;
        m_accept_cursor = 0;
    }
    void ResetForNewInput_ ()
    {
        m_buffer.clear();
        m_buffer.push_front('\0'); // special "previous" atom for beginning of input
        assert(m_buffer.size() == 1);
        m_start_cursor = 0;
        m_read_cursor = 1;
        m_accept_cursor = 0;
        m_current_conditional_flags = 0;
    }

    // for use in AutomatonApparatus_ only
    BarfCpp_::Uint8 GetCurrentConditionalFlags_ ()
    {
        UpdateConditionalFlags();
        return m_current_conditional_flags;
    }
    BarfCpp_::Uint8 GetInputAtom_ ()
    {
        FillBuffer();
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        return m_buffer[m_read_cursor];
    }
    void AdvanceReadCursor_ ()
    {
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        if (m_buffer[m_read_cursor] != '\0')
            ++m_read_cursor;
    }
    void SetAcceptCursor_ ()
    {
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor <= m_buffer.size());
        m_accept_cursor = m_read_cursor;
    }
    void Accept_ (std::string &s)
    {
        assert(s.empty());
        assert(m_accept_cursor > 0 && "can't Accept_ if the accept cursor is not set");
        assert(m_accept_cursor <= m_buffer.size());
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor <= m_buffer.size());
        assert(m_accept_cursor <= m_read_cursor);

        // come up with iterators which specify the range of accepted chars
        Buffer::iterator accept_it = m_buffer.begin();
        ++accept_it; // don't accept the previous atom
        Buffer::iterator accept_it_end = accept_it;
        for (Buffer::size_type i = 1; i < m_accept_cursor; ++i)
        {
            assert(accept_it_end != m_buffer.end());
            ++accept_it_end;
        }
        // extract the accepted string
        s.insert(s.begin(), accept_it, accept_it_end);
        assert(s.size() == m_accept_cursor - 1);
        // advance the start cursor by the number of accepted chars
        m_start_cursor += m_accept_cursor - 1;
        // reset the other cursors
        m_read_cursor = m_start_cursor + 1;
        m_accept_cursor = m_start_cursor;
    }
    void Reject_ (std::string &s)
    {
        assert(s.empty());
        assert(m_accept_cursor == 0 && "can't Reject_ if the accept cursor was set");
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        assert(m_buffer.size() >= 2);
        // only pop the front of the buffer if we're not at EOF.
        BarfCpp_::Uint8 rejected_atom = m_buffer[1];
        if (m_buffer[1] != '\0')
            m_buffer.pop_front();
        // reset the read cursor and return the rejected atom
        m_read_cursor = 1;
        s += rejected_atom;
    }
    
private:

    enum ConditionalFlag
    {
        CF_BEGINNING_OF_INPUT = (1 << 0),
        CF_END_OF_INPUT       = (1 << 1),
        CF_BEGINNING_OF_LINE  = (1 << 2),
        CF_END_OF_LINE        = (1 << 3),
        CF_WORD_BOUNDARY      = (1 << 4)
    }; // end of enum ReflexCpp_::InputApparatus_::ConditionalFlag

    bool IsConditionalMet (BarfCpp_::Uint8 conditional_mask, BarfCpp_::Uint8 conditional_flags)
    {
        assert(m_start_cursor == 0);
        UpdateConditionalFlags();
        // return true iff no bits indicated by conditional_mask differ between
        // conditional_flags and m_current_conditional_flags.
        return ((conditional_flags ^ m_current_conditional_flags) & conditional_mask) == 0;
    }
    void FillBuffer ()
    {
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor <= m_buffer.size());
        // if we already have at least one atom ahead of the read cursor in
        // the input buffer, there is no need to suck another one out.
        if (m_read_cursor < m_buffer.size())
            return;
        // if the last atom (in front of the read cursor) in the input buffer
        // is '\0' then we have reached EOF, so there is no need to suck
        // another atom out.
        if (m_buffer.size() >= 2 && *m_buffer.rbegin() == '\0')
        {
            assert(m_read_cursor < m_buffer.size());
            return;
        }
        // if we're at the end of input, push a null char
        if ((this->*m_IsInputAtEnd)())
            m_buffer.push_back('\0');
        // otherwise retrieve and push the next input atom
        else
        {
            BarfCpp_::Uint8 atom = (this->*m_ReadNextAtom)();
            assert(atom != '\0' && "may not return '\\0' from return_next_input_char");
            m_buffer.push_back(atom);
        }
        // ensure there is at least one atom on each side of the read cursor.
        assert(m_buffer.size() >= 2);
        assert(m_read_cursor == m_buffer.size()-1);
    }
    void UpdateConditionalFlags ()
    {
        FillBuffer();
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        // given the atoms surrounding the read cursor, calculate the
        // current conditional flags.
        m_current_conditional_flags = 0;
        if (m_buffer[m_read_cursor-1] == '\0')                                            m_current_conditional_flags |= CF_BEGINNING_OF_INPUT;
        if (m_buffer[m_read_cursor] == '\0')                                              m_current_conditional_flags |= CF_END_OF_INPUT;
        if (m_buffer[m_read_cursor-1] == '\0' || m_buffer[m_read_cursor-1] == '\n')       m_current_conditional_flags |= CF_BEGINNING_OF_LINE;
        if (m_buffer[m_read_cursor] == '\0' || m_buffer[m_read_cursor] == '\n')           m_current_conditional_flags |= CF_END_OF_LINE;
        if (IsWordChar(m_buffer[m_read_cursor-1]) != IsWordChar(m_buffer[m_read_cursor])) m_current_conditional_flags |= CF_WORD_BOUNDARY;
    }
    static bool IsWordChar (BarfCpp_::Uint8 c) { return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'; }

    typedef std::deque<BarfCpp_::Uint8> Buffer;

    BarfCpp_::Uint8 m_current_conditional_flags;
    Buffer m_buffer;
    // indicates the "previous" atom (used mainly in Accept/Unaccept)
    Buffer::size_type m_start_cursor;
    // indicates how far the scanner has read
    Buffer::size_type m_read_cursor;
    // if != m_start_cursor, indicates the most recent, longest accepted string
    Buffer::size_type m_accept_cursor;
    IsInputAtEndMethod_ m_IsInputAtEnd;
    ReadNextAtomMethod_ m_ReadNextAtom;
}; // end of class ReflexCpp_::InputApparatus_

// /////////////////////////////////////////////////////////////////////////////
// implements the AutomatonApparatus interface as described in the documentation
// -- it contains all the generalized state machinery for running a reflex DFA.
// /////////////////////////////////////////////////////////////////////////////

class AutomatonApparatus_ : protected InputApparatus_
{
protected:

    struct DfaTransition_;
    struct DfaState_
    {
        BarfCpp_::Uint32 m_accept_handler_index;
        BarfCpp_::Size m_transition_count;
        DfaTransition_ const *m_transition;
    }; // end of struct ReflexCpp_::AutomatonApparatus_::DfaState_
    struct DfaTransition_
    {
        enum Type
        {
            INPUT_ATOM = 0, INPUT_ATOM_RANGE, CONDITIONAL
        }; // end of enum ReflexCpp_::AutomatonApparatus_::DfaTransition_::Type

        BarfCpp_::Uint8 m_transition_type;
        BarfCpp_::Uint8 m_data_0;
        BarfCpp_::Uint8 m_data_1;
        DfaState_ const *m_target_dfa_state;

        bool AcceptsInputAtom (BarfCpp_::Uint8 input_atom) const
        {
            assert(m_transition_type == INPUT_ATOM || m_transition_type == INPUT_ATOM_RANGE);
            // returns true iff this transition is INPUT_ATOM and input_atom
            // matches m_data_0, or this transition is INPUT_ATOM_RANGE and
            // input_atom is within the range [m_data_0, m_data_1] inclusive.
            return (m_transition_type == INPUT_ATOM &&
                    m_data_0 == input_atom)
                   ||
                   (m_transition_type == INPUT_ATOM_RANGE &&
                    m_data_0 <= input_atom && input_atom <= m_data_1);
        }
        bool AcceptsConditionalFlags (BarfCpp_::Uint8 conditional_flags) const
        {
            assert(m_transition_type == CONDITIONAL);
            // returns true iff this transition is CONDITIONAL and no relevant bits
            // in conditional_flags conflict with this transition's conditional mask
            // (m_data_0) and flags (m_data_1).
            return ((conditional_flags ^ m_data_1) & m_data_0) == 0;
        }
    }; // end of struct ReflexCpp_::AutomatonApparatus_::DfaTransition_

    AutomatonApparatus_ (
        DfaState_ const *state_table,
        BarfCpp_::Size state_count,
        DfaTransition_ const *transition_table,
        BarfCpp_::Size transition_count,
        BarfCpp_::Uint32 accept_handler_count,
        IsInputAtEndMethod_ IsInputAtEnd,
        ReadNextAtomMethod_ ReadNextAtom)
        :
        InputApparatus_(IsInputAtEnd, ReadNextAtom),
        m_accept_handler_count(accept_handler_count)
    {
        CheckDfa(state_table, state_count, transition_table, transition_count);
        // subclasses must call ReflexCpp_::InputApparatus_::ResetForNewInput_ in their constructors.
    }

    DfaState_ const *InitialState_ () const
    {
        return m_initial_state;
    }
    void InitialState_ (DfaState_ const *initial_state)
    {
        assert(initial_state != NULL);
        m_initial_state = initial_state;
    }
    void ResetForNewInput_ (DfaState_ const *initial_state)
    {
        InputApparatus_::ResetForNewInput_();
        if (initial_state != NULL)
            InitialState_(initial_state);
        m_current_state = NULL;
        m_accept_state = NULL;
    }
    BarfCpp_::Uint32 RunDfa_ (std::string &s)
    {
        assert(s.empty());
        // reset the current state to the initial state.
        assert(m_initial_state != NULL);
        m_current_state = m_initial_state;
        assert(m_accept_state == NULL);
        // loop until there are no valid transitions from the current state.
        while (m_current_state != NULL)
        {
            // if the current state is an accept state, save it
            if (IsAcceptState(m_current_state))
            {
                m_accept_state = m_current_state;
                SetAcceptCursor_();
            }
            // turn the crank on the state machine, exercising the appropriate
            // conditional (using m_current_conditional_flags) or atomic
            // transition (using the atom at the read cursor in the buffer).
            // m_current_state will be set to the transitioned-to state, or
            // NULL if no transition was possible.
            m_current_state = ProcessInputAtom();
        }
        // if we have a most recent accept state, accept the accumulated input
        // using the accept handler indicated by the most recent accept state.
        if (m_accept_state != NULL)
        {
            // extract the accepted string from the buffer
            Accept_(s);
            // save off the accept handler index
            BarfCpp_::Uint32 accept_handler_index = m_accept_state->m_accept_handler_index;
            // clear the accept state for next time
            m_accept_state = NULL;
            // return accept_handler_index to indicate which handler to call
            return accept_handler_index;
        }
        // otherwise the input atom went unhandled, so call the special
        // unmatched character handler on the rejected atom.
        else
        {
            // put the rejected atom in the return string and indicate
            // that no accept handler should be called.
            Reject_(s);
            return m_accept_handler_count;
        }
    }

private:

    // these InputApparatus_ methods should not be accessable to <{class_name}
    using InputApparatus_::GetCurrentConditionalFlags_;
    using InputApparatus_::GetInputAtom_;
    using InputApparatus_::AdvanceReadCursor_;
    using InputApparatus_::SetAcceptCursor_;
    using InputApparatus_::Accept_;
    using InputApparatus_::Reject_;

    DfaState_ const *ProcessInputAtom ()
    {
        assert(m_current_state != NULL);
        // get the current conditional flags and input atom once before looping
        BarfCpp_::Uint8 current_conditional_flags = GetCurrentConditionalFlags_();
        BarfCpp_::Uint8 input_atom = GetInputAtom_();
        // iterate through the current state's transitions, exercising the first
        // acceptable one and returning the target state
        for (DfaTransition_ const *transition = m_current_state->m_transition,
                                  *transition_end = transition + m_current_state->m_transition_count;
             transition != transition_end;
             ++transition)
        {
            assert(transition->m_transition_type == DfaTransition_::INPUT_ATOM ||
                   transition->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE ||
                   transition->m_transition_type == DfaTransition_::CONDITIONAL);
            // if it's an atomic transition, check if it accepts input_atom.
            if (transition->m_transition_type == DfaTransition_::INPUT_ATOM ||
                transition->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE)
            {
                if (transition->AcceptsInputAtom(input_atom))
                {
                    AdvanceReadCursor_();
                    return transition->m_target_dfa_state;
                }
            }
            // otherwise it must be a conditional transition, so check the flags.
            else if (transition->AcceptsConditionalFlags(current_conditional_flags))
                return transition->m_target_dfa_state;
        }
        // if we reached here, no transition was possible, so return NULL.
        return NULL;
    }
    bool IsAcceptState (DfaState_ const *state) const
    {
        assert(state != NULL);
        return state->m_accept_handler_index < m_accept_handler_count;
    }
    void CheckDfa (
        DfaState_ const *state_table,
        BarfCpp_::Size state_count,
        DfaTransition_ const *transition_table,
        BarfCpp_::Size transition_count)
    {
        // if any assertions in this method fail, the state and/or
        // transition tables were created incorrectly.
        assert(state_table != NULL && "must have a state table");
        assert(state_count > 0 && "must have at least one state");
        assert(transition_table != NULL && "must have a transition table");
        {
            DfaTransition_ const *t = transition_table;
            for (DfaState_ const *s = state_table, *s_end = state_table + state_count;
                 s != s_end;
                 ++s)
            {
                assert(s->m_transition == t &&
                       "states' transitions must be contiguous and in ascending order");
                t += s->m_transition_count;
            }
            assert(t == transition_table + transition_count &&
                   "there are too many or too few referenced "
                   "transitions in the state table");
        }
        for (DfaTransition_ const *t = transition_table,
                                  *t_end = transition_table + transition_count;
             t != t_end;
             ++t)
        {
            assert((t->m_transition_type == DfaTransition_::INPUT_ATOM ||
                    t->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE ||
                    t->m_transition_type == DfaTransition_::CONDITIONAL)
                   &&
                   "invalid DfaTransition_::Type");
            assert(t->m_target_dfa_state >= state_table &&
                   t->m_target_dfa_state < state_table + state_count &&
                   "transition target state out of range "
                   "(does not point to a valid state)");
            if (t->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE)
            {
                assert(t->m_data_0 < t->m_data_1 &&
                       "can't specify a single-element range of atoms");
            }
            else if (t->m_transition_type == DfaTransition_::CONDITIONAL)
            {
                assert(t->m_data_0 != 0 &&
                       "can't have a conditional with a mask of zero");
                assert((t->m_data_1 & ~t->m_data_0) == 0 &&
                       "there are bits set in the conditional flags "
                       "which are outside of the conditional mask");
            }
        }
    }

    BarfCpp_::Uint32 const m_accept_handler_count;
    DfaState_ const *m_initial_state;
    DfaState_ const *m_current_state;
    DfaState_ const *m_accept_state;
}; // end of class ReflexCpp_::AutomatonApparatus_

} // end of namespace ReflexCpp_
#endif // !defined(ReflexCpp_namespace_)

<|top_of_header_file?

class <{class_name} : private ReflexCpp_::AutomatonApparatus_<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    struct Mode
    {
        enum Name
        {
<|for_each(key, _dfa_initial_node_index)
            <{key} = <{_dfa_initial_node_index[key]},
<|end_for_each
            // default starting scanner mode
            START_ = <{_start_in_scanner_mode}
        }; // end of enum <{class_name}::Mode::Name
    }; // end of struct <{class_name}::Mode

<|if(is_defined(top_of_class))
<{top_of_class}
public:

<|end_if
    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<|if(is_defined(generate_debug_spew_code))
    bool DebugSpew () const { return m_debug_spew_; }
    void DebugSpew (bool debug_spew) { m_debug_spew_ = debug_spew; }

<|end_if
    Mode::Name ScannerMode () const;
    void ScannerMode (Mode::Name mode);

    using AutomatonApparatus_::IsAtEndOfInput;
    void ResetForNewInput ();

<|if(is_defined(scan_method_access))
<|if(!(scan_method_access == "public:" || scan_method_access == "protected:" || scan_method_access == "private:"))
<|error("invalid scan_method_access \"" . scan_method_access . "\"")
<|end_if
<{scan_method_access}

<|end_if
    <{return_type} Scan (<{scan_method_parameters?})<{if(!is_defined(enable_accept_handler_exceptions))} throw()<{end_if};

<|if(is_defined(bottom_of_class))
public:

<{bottom_of_class}

<|end_if
private:

    // this method is for use in accept handler code only
<|if(is_defined(generate_debug_spew_code))
    void Unaccept (BarfCpp_::Uint32 unaccept_char_count);
<|else
    using InputApparatus_::Unaccept;
<|end_if

    // ///////////////////////////////////////////////////////////////////////
    // begin internal reflex-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    using InputApparatus_::DumpPreviouslyAcceptedChars_;
    using InputApparatus_::ResetForNewInput_;

    using AutomatonApparatus_::InitialState_;
    using AutomatonApparatus_::ResetForNewInput_;
    using AutomatonApparatus_::RunDfa_;

    bool IsInputAtEnd_ () throw();
    BarfCpp_::Uint8 ReadNextAtom_ () throw();

<|if(is_defined(generate_debug_spew_code))
    // debug spew methods
    static void PrintAtom_ (BarfCpp_::Uint8 atom);
    static void PrintString_ (std::string const &s);
    static void PrintScannerMode_ (Mode::Name mode);

    bool m_debug_spew_;

<|end_if
    // state machine data
    static AutomatonApparatus_::DfaState_ const ms_state_table_[];
    static BarfCpp_::Size const ms_state_count_;
    static AutomatonApparatus_::DfaTransition_ const ms_transition_table_[];
    static BarfCpp_::Size const ms_transition_count_;
<|if(is_defined(generate_debug_spew_code))
    static char const *const ms_accept_handler_regex_[];
<|end_if
    static BarfCpp_::Uint32 const ms_accept_handler_count_;

    // ///////////////////////////////////////////////////////////////////////
    // end of internal reflex-generated parser guts
    // ///////////////////////////////////////////////////////////////////////
}; // end of class <{class_name}

<|bottom_of_header_file?
