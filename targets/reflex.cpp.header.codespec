<|if(header_filename == implementation_filename)
<|  error("collision between header_filename \"" . header_filename . "\" and implementation_filename \"" . implementation_filename . "\"")
<|end_if
<|
<|if(is_defined(generate_interactive_scanner))
<|  if(!is_defined(return_true_iff_input_is_at_end) || !is_defined(return_next_input_char))
<|      error("if directive generate_interactive_scanner is specified, then directives return_true_iff_input_is_at_end and return_next_input_char must also be specified")
<|  end_if
<|else
<|  if(is_defined(return_true_iff_input_is_at_end) || is_defined(return_next_input_char))
<|      error("if directive generate_interactive_scanner is not specified, then directive return_true_iff_input_is_at_end and return_next_input_char may not be specified")
<|  end_if
<|end_if
<|
<|if(!is_defined(debug_spew_prefix))
<{  define(debug_spew_prefix)}"<{class_name}:"<|end_define
<|end_if
<|
<|if(is_defined(generate_interactive_scanner))
<{  define(interactivity)}Interactive<|end_define
<|else
<{  define(interactivity)}Noninteractive<|end_define
<|end_if
<|
<|if(is_defined(small_and_slow))
<{  define(size_and_speed)}SmallAndSlow<|end_define
<|else
<{  define(size_and_speed)}FastAndBig<|end_define
<|end_if
<|
<{define(input_apparatus)}InputApparatus_<{interactivity}_<|end_define
<{define(automaton_apparatus)}AutomatonApparatus_<{size_and_speed}_<{interactivity}_<|end_define
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{header_filename} generated by reflex<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#pragma once

#include <cassert>
#include <cstdint>
#include <deque>
<|if(!is_defined(generate_interactive_scanner))
#include <iterator>
<|end_if
#include <string>

#if !defined(ReflexCpp_namespace_)
#define ReflexCpp_namespace_
namespace ReflexCpp_ {

// /////////////////////////////////////////////////////////////////////////////
// implements the InputApparatus interface as described in the documentation
// /////////////////////////////////////////////////////////////////////////////

class <{input_apparatus}
{
protected:

<|  if(is_defined(generate_interactive_scanner))
    typedef bool (<{input_apparatus}::*IsInputAtEndMethod_)();
    typedef std::uint8_t (<{input_apparatus}::*ReadNextAtomMethod_)();

<|  end_if
    <{input_apparatus} (<{if(is_defined(generate_interactive_scanner))}IsInputAtEndMethod_ IsInputAtEnd, ReadNextAtomMethod_ ReadNextAtom<{end_if})
        :
<|      if(is_defined(generate_interactive_scanner))
        m_IsInputAtEnd(IsInputAtEnd),
        m_ReadNextAtom(ReadNextAtom)
<|      else
        m_input_readahead(1024) // default, arbitrary reasonable lookahead
<|      end_if
    {
        // subclasses must call <{input_apparatus}::ResetForNewInput_ in their constructors.
    }

    bool IsAtEndOfInput () { return IsConditionalMet(CF_END_OF_INPUT, CF_END_OF_INPUT); }

<|  if(!is_defined(generate_interactive_scanner))
    std::istream_iterator<char> const IstreamIterator () const { return m_it; }
    void IstreamIterator (std::istream_iterator<char> it) { m_it = it; }
    std::size_t InputReadahead () const { return m_input_readahead; }
    void InputReadahead (std::size_t input_readahead) { m_input_readahead = input_readahead; }

<|  end_if
    void KeepString ()
    {
        assert(m_accept_cursor > m_start_cursor && "may only KeepString within accept or reject handler code");
        // reset the start cursor, so that the entire accepted string is
        // "put back in the already-read buffer", but we'll keep reading
        // from the same read cursor.
        m_start_cursor = 0;
        // save the accepted string's end position at the time of KeepString
        m_kept_string_cursor = m_accept_cursor;
        // leave the accept cursor to be reset in the next loop
    }
    void Unaccept (std::uint32_t unaccept_char_count)
    {
        assert(m_accept_cursor > m_start_cursor && "may only Unaccept within accept handler code");
        UnacceptUnrejectCommon(unaccept_char_count);
    }
    void Unreject (std::uint32_t unreject_char_count)
    {
        assert(m_accept_cursor == m_start_cursor+1 && "may only Unreject within accept handler code");
        UnacceptUnrejectCommon(unreject_char_count);
    }

    void PrepareToScan_ ()
    {
        assert(m_start_cursor < m_read_cursor);
        // update the read and keep_string cursors.  if KeepString was called,
        // this should do nothing, since in that case, m_start_cursor will be
        // zero;  if Unaccept was called, it should have postcondition
        // m_read_cursor == m_start_cursor + 1
        m_read_cursor -= m_start_cursor;
        m_kept_string_cursor -= m_start_cursor;
        // dump the first m_start_cursor chars from the buffer
        while (m_start_cursor > 0)
        {
            --m_start_cursor;
            m_buffer.pop_front();
        }
        // reset the accept cursor
        m_accept_cursor = m_start_cursor;
        m_keep_string_has_been_called = false;
        assert(m_kept_string_cursor > m_start_cursor);
        assert(m_accept_cursor == 0);
    }
    void ResetForNewInput_ ()
    {
        m_current_conditional_flags = 0;
        m_buffer.clear();
        m_buffer.push_front('\0'); // special "previous" atom for beginning of input
        assert(m_buffer.size() == 1);
        m_start_cursor = 0;
        m_read_cursor = 1;
        m_kept_string_cursor = 1;
        m_accept_cursor = 0;
        m_keep_string_has_been_called = false;
<|      if(!is_defined(generate_interactive_scanner))
        m_it = m_it_end;
<|      end_if
    }

    // for use in <{automaton_apparatus} only
    std::uint8_t CurrentConditionalFlags_ ()
    {
        UpdateConditionalFlags();
        return m_current_conditional_flags;
    }
    std::uint8_t InputAtom_ ()
    {
        FillBuffer();
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        return m_buffer[m_read_cursor];
    }
    void AdvanceReadCursor_ ()
    {
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        if (m_buffer[m_read_cursor] != '\0')
            ++m_read_cursor;
    }
    void SetAcceptCursor_ ()
    {
        assert(m_start_cursor == 0);
        assert(m_read_cursor > 0);
        assert(m_read_cursor <= m_buffer.size());
        m_accept_cursor = m_read_cursor;
    }
    void Accept_ (std::string &s)
    {
        assert(m_accept_cursor > 0 && "can't Accept_ if the accept cursor is not set");
        assert(m_accept_cursor <= m_read_cursor);
        AcceptRejectCommon(s);
    }
    void Reject_ (std::string &s)
    {
        assert(m_accept_cursor == 0 && "can't Reject_ if the accept cursor was set");
        // must set the accept cursor to indicate the rejected string
        // (which is the kept string plus the rejected atom)
        m_accept_cursor = m_kept_string_cursor;
        assert(m_accept_cursor < m_buffer.size());
        if (m_buffer[m_accept_cursor] != '\0')
            ++m_accept_cursor;
        AcceptRejectCommon(s);
    }

private:

    void UnacceptUnrejectCommon (std::uint32_t char_count)
    {
        assert(!m_keep_string_has_been_called && "may only Unaccept/Unreject before KeepString");
        assert(char_count <= m_start_cursor && "can't Unaccept/Unreject more characters than were rejected");
        if (char_count == 0)
            return; // nothing to do
        // update the cursors
        m_start_cursor -= char_count;
        m_read_cursor = m_start_cursor + 1;
        m_kept_string_cursor = m_start_cursor + 1;
        m_accept_cursor -= char_count;
    }
    void AcceptRejectCommon (std::string &s)
    {
        assert(s.empty());
        assert(m_buffer.size() >= 2);
        assert(m_start_cursor == 0);
        // the accept cursor indicates the end of the string to accept/reject
        assert(m_accept_cursor > 0 && m_accept_cursor <= m_buffer.size());
        // there should not be an EOF-indicating '\0' at the end of the string
        assert(m_accept_cursor == 1 || m_buffer[m_accept_cursor-1] != '\0');
        // extract the accepted/rejected string: range [1,m_accept_cursor).
        s.insert(s.begin(), m_buffer.begin()+1, m_buffer.begin()+m_accept_cursor);
        assert(s.size() == m_accept_cursor-1);
        // set the start cursor to one before the end of the string
        // (the last char in the string becomes the previous atom)
        m_start_cursor = m_accept_cursor - 1;
        // reset the other cursors
        m_read_cursor = m_accept_cursor;
        m_kept_string_cursor = m_accept_cursor;
    }

    enum ConditionalFlag
    {
        CF_BEGINNING_OF_INPUT = (1 << 0),
        CF_END_OF_INPUT       = (1 << 1),
        CF_BEGINNING_OF_LINE  = (1 << 2),
        CF_END_OF_LINE        = (1 << 3),
        CF_WORD_BOUNDARY      = (1 << 4)
    }; // end of enum ReflexCpp_::<{input_apparatus}::ConditionalFlag

    bool IsConditionalMet (std::uint8_t conditional_mask, std::uint8_t conditional_flags)
    {
        UpdateConditionalFlags();
        // return true iff no bits indicated by conditional_mask differ between
        // conditional_flags and m_current_conditional_flags.
        return ((conditional_flags ^ m_current_conditional_flags) & conditional_mask) == 0;
    }
    void FillBuffer ()
    {
        assert(m_read_cursor > 0);
        assert(m_read_cursor <= m_buffer.size());
        // if we already have at least one atom ahead of the read cursor in
        // the input buffer, there is no need to suck another one out.
        if (m_read_cursor < m_buffer.size())
            return;
        // if the last atom (in front of the read cursor) in the input buffer
        // is '\0' then we have reached EOF, so there is no need to suck
        // another atom out.
        if (m_buffer.size() >= 2 && *m_buffer.rbegin() == '\0')
        {
            assert(m_read_cursor < m_buffer.size());
            return;
        }

<|      if(is_defined(generate_interactive_scanner))
        // if we're at the end of input, push a null char
        if ((this->*m_IsInputAtEnd)())
            m_buffer.push_back('\0');
        // otherwise retrieve and push the next input atom
        else
        {
            std::uint8_t atom = (this->*m_ReadNextAtom)();
            assert(atom != '\0' && "may not return '\\0' from return_next_input_char");
            m_buffer.push_back(atom);
        }
<|      else
        // if we're at end of input, push a null char.
        if (m_it == m_it_end)
            m_buffer.push_back('\0');
        // otherwise read stuff
        else
        {
            // if our readahead is unbounded, read the whole input and
            // stick a null char at the end to signal end of input.
            if (m_input_readahead == 0)
            {
                copy(m_it, m_it_end, std::back_inserter(m_buffer));
                m_buffer.push_back('\0');
            }
            // otherwise, read the readahead number of bytes.
            else
                for (std::size_t i = 0; i < m_input_readahead && m_it != m_it_end; ++i, ++m_it)
                    m_buffer.push_back(*m_it);
        }
<|      end_if

        // ensure there is at least one atom on each side of the read cursor.
        assert(m_buffer.size() >= 2);
        assert(m_read_cursor < m_buffer.size());
    }
    void UpdateConditionalFlags ()
    {
        FillBuffer();
        assert(m_read_cursor > 0);
        assert(m_read_cursor < m_buffer.size());
        // given the atoms surrounding the read cursor, calculate the
        // current conditional flags.
        m_current_conditional_flags = 0;
        if (m_buffer[m_read_cursor-1] == '\0')                                            m_current_conditional_flags |= CF_BEGINNING_OF_INPUT;
        if (m_buffer[m_read_cursor] == '\0')                                              m_current_conditional_flags |= CF_END_OF_INPUT;
        if (m_buffer[m_read_cursor-1] == '\0' || m_buffer[m_read_cursor-1] == '\n')       m_current_conditional_flags |= CF_BEGINNING_OF_LINE;
        if (m_buffer[m_read_cursor] == '\0' || m_buffer[m_read_cursor] == '\n')           m_current_conditional_flags |= CF_END_OF_LINE;
        if (IsWordChar(m_buffer[m_read_cursor-1]) != IsWordChar(m_buffer[m_read_cursor])) m_current_conditional_flags |= CF_WORD_BOUNDARY;
    }
    static bool IsWordChar (std::uint8_t c)
    {
        // the return value should be
        // (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'
        static std::uint8_t const s_is_word_char_table[256] =
        {
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 0, 0, 0, 0, 0, 0, // '0' through '9'
            0, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, // 'A' through 'O'
            1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 0, 0, 0, 0, 1, // 'P' through 'Z', then '_'
            0, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, // 'a' through 'o'
            1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 0, 0, 0, 0, 0, // 'p' through 'z'

            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
        };
        return s_is_word_char_table[c] != 0;
    }

    typedef std::deque<std::uint8_t> Buffer;

    std::uint8_t m_current_conditional_flags;
    Buffer m_buffer;
    // indicates the "previous" atom (of the kept string)
    Buffer::size_type m_start_cursor;
    // indicates how far the scanner has read
    Buffer::size_type m_read_cursor;
    // indicates the end of the kept string
    Buffer::size_type m_kept_string_cursor;
    // if != m_start_cursor, indicates the most recent, longest accepted string
    Buffer::size_type m_accept_cursor;
    // indicates if KeepString has been called during the accept/reject handler
    bool m_keep_string_has_been_called;
<|  if(is_defined(generate_interactive_scanner))
    // corresponds to the directive return_true_iff_input_is_at_end
    IsInputAtEndMethod_ m_IsInputAtEnd;
    // corresponds to the directive return_next_input_char
    ReadNextAtomMethod_ m_ReadNextAtom;
<|  else
    // an istream_iterator to read through the input source
    std::istream_iterator<char> m_it;
    // keep a handy end-of-stream input iterator
    std::istream_iterator<char> m_it_end;
    // the max number of bytes that will be put into the buffer each time the
    // input is pulled for bytes.  a value of 0 indicates that the input will
    // be read until EOF is hit.
    std::size_t m_input_readahead;
<|  end_if
}; // end of class ReflexCpp_::<{input_apparatus}

// /////////////////////////////////////////////////////////////////////////////
// implements the AutomatonApparatus interface as described in the documentation
// -- it contains all the generalized state machinery for running a reflex DFA.
// /////////////////////////////////////////////////////////////////////////////

class <{automaton_apparatus} : protected <{input_apparatus}
{
protected:

    // state machine mode flags
    enum
    {
        MF_CASE_INSENSITIVE_ = (1 << 0),
        MF_UNGREEDY_         = (1 << 1)
    };

    struct DfaState_
    {
        std::uint32_t m_accept_handler_index;
        std::uint32_t m_transition_count;
        std::uint32_t m_transition_offset;
<|      if(!is_defined(small_and_slow))
        std::uint8_t m_transition_type;
        std::uint8_t m_transition_first_index;
<|      end_if
    }; // end of struct ReflexCpp_::<{automaton_apparatus}::DfaState_
    struct DfaTransition_
    {
        enum Type
        {
            INPUT_ATOM = 0, INPUT_ATOM_RANGE, CONDITIONAL
        }; // end of enum ReflexCpp_::<{automaton_apparatus}::DfaTransition_::Type

        std::uint32_t m_target_dfa_state_offset;
<|      if(is_defined(small_and_slow))
        std::uint8_t m_transition_type;
        std::uint8_t m_data_0;
        std::uint8_t m_data_1;

        bool AcceptsInputAtom (std::uint8_t input_atom, bool is_case_insensitive) const
        {
            assert(m_transition_type == INPUT_ATOM || m_transition_type == INPUT_ATOM_RANGE);
            // returns true iff this transition is INPUT_ATOM and input_atom
            // matches m_data_0, or this transition is INPUT_ATOM_RANGE and
            // input_atom is within the range [m_data_0, m_data_1] inclusive.
            if (is_case_insensitive)
            {
                std::uint8_t switched_case_input_atom = SwitchCase(input_atom);
                return (m_transition_type == INPUT_ATOM
                        &&
                        (m_data_0 == input_atom || m_data_0 == switched_case_input_atom))
                       ||
                       (m_transition_type == INPUT_ATOM_RANGE
                        &&
                        ((m_data_0 <= input_atom && input_atom <= m_data_1)
                         ||
                         (m_data_0 <= switched_case_input_atom && switched_case_input_atom <= m_data_1)));
            }
            else // case sensitive
                return (m_transition_type == INPUT_ATOM &&
                        m_data_0 == input_atom)
                       ||
                       (m_transition_type == INPUT_ATOM_RANGE &&
                        m_data_0 <= input_atom && input_atom <= m_data_1);
        }
        bool AcceptsConditionalFlags (std::uint8_t conditional_flags) const
        {
            assert(m_transition_type == CONDITIONAL);
            // returns true iff this transition is CONDITIONAL and no relevant bits
            // in conditional_flags conflict with this transition's conditional mask
            // (m_data_0) and flags (m_data_1).
            return ((conditional_flags ^ m_data_1) & m_data_0) == 0;
        }
<|      end_if
    }; // end of struct ReflexCpp_::<{automaton_apparatus}::DfaTransition_

    <{automaton_apparatus} (
        DfaState_ const *state_table,
        std::size_t state_count,
        DfaTransition_ const *transition_table,
        std::size_t transition_count,
        std::uint32_t accept_handler_count<{if(is_defined(generate_interactive_scanner))},
        IsInputAtEndMethod_ IsInputAtEnd,
        ReadNextAtomMethod_ ReadNextAtom<{end_if})
        :
        <{input_apparatus}(<{if(is_defined(generate_interactive_scanner))}IsInputAtEnd, ReadNextAtom<{end_if}),
        m_accept_handler_count(accept_handler_count),
        m_state_table(state_table),
        m_state_count(state_count),
        m_transition_table(transition_table)
    {
        CheckDfa(state_table, state_count, transition_table, transition_count);
        // subclasses must call ReflexCpp_::<{input_apparatus}::ResetForNewInput_ in their constructors.
    }

    DfaState_ const *InitialState_ () const
    {
        return m_initial_state;
    }
    void InitialState_ (DfaState_ const *initial_state)
    {
        assert(initial_state != NULL);
        m_initial_state = initial_state;
    }
    void ModeFlags_ (std::uint8_t mode_flags)
    {
        m_mode_flags = mode_flags;
    }
    void ResetForNewInput_ (DfaState_ const *initial_state, std::uint8_t mode_flags)
    {
        <{input_apparatus}::ResetForNewInput_();
        if (initial_state != NULL)
            InitialState_(initial_state);
        m_current_state = NULL;
        m_accept_state = NULL;
        m_mode_flags = mode_flags;
    }
    std::uint32_t RunDfa_ (std::string &s)
    {
        assert(s.empty());
        // reset the current state to the initial state.
        assert(m_initial_state != NULL);
        m_current_state = m_initial_state;
        assert(m_accept_state == NULL);
        // loop until there are no valid transitions from the current state.
        while (m_current_state != NULL)
        {
            // if the current state is an accept state, save it
            if (IsAcceptState(m_current_state))
            {
                m_accept_state = m_current_state;
                SetAcceptCursor_();
                // if we're in ungreedy mode, accept the shortest string
                // possible; don't process any more input.
                if ((m_mode_flags & MF_UNGREEDY_) != 0)
                {
                    assert(m_accept_state != NULL);
                    m_current_state = NULL;
                    break;
                }
            }
            // turn the crank on the state machine, exercising the appropriate
            // conditional (using m_current_conditional_flags) or atomic
            // transition (using the atom at the read cursor in the buffer).
            // m_current_state will be set to the transitioned-to state, or
            // NULL if no transition was possible.
            m_current_state = ProcessInputAtom();
        }
        // if we have a most recent accept state, accept the accumulated input
        // using the accept handler indicated by the most recent accept state.
        if (m_accept_state != NULL)
        {
            // extract the accepted string from the buffer
            Accept_(s);
            // save off the accept handler index
            std::uint32_t accept_handler_index = m_accept_state->m_accept_handler_index;
            // clear the accept state for next time
            m_accept_state = NULL;
            // return accept_handler_index to indicate which handler to call
            return accept_handler_index;
        }
        // otherwise the input atom went unhandled; extract the rejected string.
        else
        {
            // put the rejected string in the return string and indicate
            // that no accept handler should be called.
            Reject_(s);
            return m_accept_handler_count;
        }
    }

private:

    // these <{input_apparatus} methods should not be accessable to <{class_name}
    using <{input_apparatus}::CurrentConditionalFlags_;
    using <{input_apparatus}::InputAtom_;
    using <{input_apparatus}::AdvanceReadCursor_;
    using <{input_apparatus}::SetAcceptCursor_;
    using <{input_apparatus}::Accept_;
    using <{input_apparatus}::Reject_;

    DfaState_ const *ProcessInputAtom ()
    {
<|      if(is_defined(small_and_slow))
        assert(m_current_state != NULL);
        // get the current conditional flags and input atom once before looping
        std::uint8_t current_conditional_flags;
        std::uint8_t input_atom = InputAtom_();
        // only calculate the current conditional flags if this is a state whose
        // transitions are conditional transitions (the transition type is the
        // same for all transitions in this state).
        if (m_current_state->m_transition_count > 0 &&
            m_transition_table[m_current_state->m_transition_offset].m_transition_type == DfaTransition_::CONDITIONAL)
        {
            current_conditional_flags = CurrentConditionalFlags_();
        }
        // calculate the case sensitivity
        bool is_case_insensitive = (m_mode_flags & MF_CASE_INSENSITIVE_) != 0;
        // iterate through the current state's transitions, exercising the first
        // acceptable one and returning the target state
        for (DfaTransition_ const *transition = m_transition_table + m_current_state->m_transition_offset,
                                  *transition_end = transition + m_current_state->m_transition_count;
             transition != transition_end;
             ++transition)
        {
            assert(transition->m_transition_type == DfaTransition_::INPUT_ATOM ||
                   transition->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE ||
                   transition->m_transition_type == DfaTransition_::CONDITIONAL);
            // if it's an atomic transition, check if it accepts input_atom.
            if (transition->m_transition_type == DfaTransition_::INPUT_ATOM ||
                transition->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE)
            {
                if (transition->AcceptsInputAtom(input_atom, is_case_insensitive))
                {
                    AdvanceReadCursor_();
                    return m_state_table + transition->m_target_dfa_state_offset;
                }
            }
            // otherwise it must be a conditional transition, so check the flags.
            else if (transition->AcceptsConditionalFlags(current_conditional_flags))
                return m_state_table + transition->m_target_dfa_state_offset;
        }
        // if we reached here, no transition was possible, so return NULL.
        return NULL;
<|      else
        assert(m_current_state != NULL);
        std::uint32_t target_dfa_state_offset = m_state_count;
        if (m_current_state->m_transition_type == DfaTransition_::CONDITIONAL)
        {
            target_dfa_state_offset = m_transition_table[m_current_state->m_transition_offset + CurrentConditionalFlags_()].m_target_dfa_state_offset;
            // don't advance the read cursor, because no input was actualy eaten
        }
        else // m_current_state->m_transition_type == DfaTransition_::INPUT_ATOM
        {
            std::uint8_t input_atom = InputAtom_();

            // only do the lookup if the input atom is in range of the table
            if (input_atom >= m_current_state->m_transition_first_index &&
                input_atom < m_current_state->m_transition_first_index + m_current_state->m_transition_count)
            {
                target_dfa_state_offset = m_transition_table[m_current_state->m_transition_offset + input_atom - m_current_state->m_transition_first_index].m_target_dfa_state_offset;
            }

            // if we're case-insensitive and the above check didn't match, try
            // the switched case input atom
            if ((m_mode_flags & MF_CASE_INSENSITIVE_) != 0 && target_dfa_state_offset == m_state_count)
            {
                input_atom = SwitchCase(input_atom);
                // only do the lookup if the input atom is in range of the table
                if (input_atom >= m_current_state->m_transition_first_index &&
                    input_atom < m_current_state->m_transition_first_index + m_current_state->m_transition_count)
                {
                    target_dfa_state_offset = m_transition_table[m_current_state->m_transition_offset + input_atom - m_current_state->m_transition_first_index].m_target_dfa_state_offset;
                }
            }

            // only advance the read cursor if the transition was valid
            if (target_dfa_state_offset < m_state_count)
                AdvanceReadCursor_();
        }
        return target_dfa_state_offset < m_state_count ? m_state_table + target_dfa_state_offset : NULL;
<|      end_if
    }
    bool IsAcceptState (DfaState_ const *state) const
    {
        assert(state != NULL);
        return state->m_accept_handler_index < m_accept_handler_count;
    }
    static std::uint8_t SwitchCase (std::uint8_t c)
    {
        if (c >= 'a' && c <= 'z')
            return c - 'a' + 'A';
        if (c >= 'A' && c <= 'Z')
            return c - 'A' + 'a';
        return c;
    }
    static void CheckDfa (
        DfaState_ const *state_table,
        std::size_t state_count,
        DfaTransition_ const *transition_table,
        std::size_t transition_count)
    {
        // if any assertions in this method fail, the state and/or
        // transition tables were created incorrectly.
        assert(state_table != NULL && "must have a state table");
        assert(state_count > 0 && "must have at least one state");
        assert(transition_table != NULL && "must have a transition table");
        {
            DfaTransition_ const *t = transition_table;
            for (DfaState_ const *s = state_table, *s_end = state_table + state_count;
                 s != s_end;
                 ++s)
            {
<|              if(!is_defined(small_and_slow))
                assert(s->m_transition_type == DfaTransition_::INPUT_ATOM ||
                       s->m_transition_type == DfaTransition_::CONDITIONAL);
<|              end_if
                assert(transition_table + s->m_transition_offset == t &&
                       "states' transitions must be contiguous and in ascending order");
                t += s->m_transition_count;
            }
            assert(t == transition_table + transition_count &&
                   "there are too many or too few referenced "
                   "transitions in the state table");
        }
        for (DfaTransition_ const *t = transition_table,
                                  *t_end = transition_table + transition_count;
             t != t_end;
             ++t)
        {
<|          if(is_defined(small_and_slow))
            assert(t->m_target_dfa_state_offset < state_count &&
                   "transition target state out of range (does not point to a valid state)");
            assert((t->m_transition_type == DfaTransition_::INPUT_ATOM ||
                    t->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE ||
                    t->m_transition_type == DfaTransition_::CONDITIONAL)
                   &&
                   "invalid DfaTransition_::Type");
            if (t->m_transition_type == DfaTransition_::INPUT_ATOM_RANGE)
            {
                assert(t->m_data_0 < t->m_data_1 &&
                       "can't specify a single-element range of atoms");
            }
            else if (t->m_transition_type == DfaTransition_::CONDITIONAL)
            {
                assert(t->m_data_0 != 0 &&
                       "can't have a conditional with a mask of zero");
                assert((t->m_data_1 & ~t->m_data_0) == 0 &&
                       "there are bits set in the conditional flags "
                       "which are outside of the conditional mask");
            }
<|          else
            assert(t->m_target_dfa_state_offset <= state_count &&
                   "transition target state out of range (highest acceptable value is state count)");
<|          end_if
        }
    }

    std::uint32_t const m_accept_handler_count;
    DfaState_ const *const m_state_table;
    std::size_t const m_state_count;
    DfaTransition_ const *const m_transition_table;
    DfaState_ const *m_initial_state;
    DfaState_ const *m_current_state;
    DfaState_ const *m_accept_state;
    std::uint8_t m_mode_flags;
}; // end of class ReflexCpp_::<{automaton_apparatus}

} // end of namespace ReflexCpp_
#endif // !defined(ReflexCpp_namespace_)

<|top_of_header_file?

class <{class_name} : private ReflexCpp_::<{automaton_apparatus}<{if(is_defined(class_inheritance))}, <{class_inheritance}<{end_if}
{
public:

    struct StateMachine
    {
        enum Name
        {
<|          for_each(key, _dfa_initial_node_index)
            <{key},
<|          end_for_each
            // default starting state machine
            START_ = <{_start_with_state_machine}
        }; // end of enum <{class_name}::StateMachine::Name
    }; // end of struct <{class_name}::StateMachine

<|  if(is_defined(top_of_class))
<{top_of_class}
public:

<|  end_if
    <{class_name} (<{constructor_parameters?});
    <{if(is_defined(force_virtual_destructor))}virtual <{end_if}~<{class_name} ();

<|  if(is_defined(generate_debug_spew_code))
    /// Returns true if and only if "debug spew" is enabled (which prints, to the
    /// debug spew stream, what actions the scanner is taking).  This method, along
    /// with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    bool DebugSpewIsEnabled () const { return m_debug_spew_stream_ != NULL; }
    /// Returns the debug spew stream (see DebugSpewIsEnabled()).  This method,
    /// along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    std::ostream *DebugSpewStream () { return m_debug_spew_stream_; }
    /// Sets the debug spew stream (see DebugSpewIsEnabled()).  If NULL is passed
    /// in, then debug spew printing will be disabled.  The default value is NULL.
    /// This method, along with all other debug spew code can be removed by removing
    /// the %target.cpp.generate_debug_spew_code directive from the primary source.
    void SetDebugSpewStream (std::ostream *debug_spew_stream) { m_debug_spew_stream_ = debug_spew_stream; }

<|  end_if
    /// Returns the currently active state machine.
    StateMachine::Name CurrentStateMachine () const;
    /// Switches the current state machine to the specified one.
    void SwitchToStateMachine (StateMachine::Name state_machine);

    using <{automaton_apparatus}::IsAtEndOfInput;
<|  if(!is_defined(generate_interactive_scanner))
    using <{automaton_apparatus}::IstreamIterator;
    using <{automaton_apparatus}::InputReadahead;

<|  end_if
    void ResetForNewInput ();

<|  if(is_defined(scan_method_access))
<|  if(!(scan_method_access == "public:" || scan_method_access == "protected:" || scan_method_access == "private:"))
<|      error("invalid scan_method_access \"" . scan_method_access . "\"")
<|  end_if
<{scan_method_access}

<|  end_if
    <{return_type} Scan (<{scan_method_parameters?})<{if(!is_defined(enable_accept_handler_exceptions))} throw()<{end_if};

<|  if(is_defined(bottom_of_class))
public:

<{bottom_of_class}

<|  end_if
private:

<|  if(is_defined(generate_debug_spew_code))
    void KeepString ();
    void Unaccept (std::uint32_t unaccept_char_count);
    void Unreject (std::uint32_t unreject_char_count);
<|  else
    using <{input_apparatus}::KeepString;
    using <{input_apparatus}::Unaccept;
    using <{input_apparatus}::Unreject;

<|  end_if
    // ///////////////////////////////////////////////////////////////////////
    // begin internal reflex-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    using <{input_apparatus}::PrepareToScan_;
    using <{input_apparatus}::ResetForNewInput_;

    using <{automaton_apparatus}::InitialState_;
    using <{automaton_apparatus}::ResetForNewInput_;
    using <{automaton_apparatus}::RunDfa_;

<|  if(is_defined(generate_interactive_scanner))
    bool IsInputAtEnd_ () throw();
    std::uint8_t ReadNextAtom_ () throw();

<|  end_if
<|  if(is_defined(generate_debug_spew_code))
    // debug spew methods
    static void PrintAtom_ (std::ostream &out, std::uint8_t atom);
    static void PrintString_ (std::ostream &out, std::string const &s);

    std::ostream *m_debug_spew_stream_;

<|  end_if
    // state machine and automaton data
    static std::uint32_t const ms_state_machine_start_state_index_[];
    static std::uint8_t const ms_state_machine_mode_flags_[];
<|  if(is_defined(generate_debug_spew_code))
    static char const *const ms_state_machine_name_[];
<|  end_if
    static std::uint32_t const ms_state_machine_count_;
    static <{automaton_apparatus}::DfaState_ const ms_state_table_[];
    static std::size_t const ms_state_count_;
    static <{automaton_apparatus}::DfaTransition_ const ms_transition_table_[];
    static std::size_t const ms_transition_count_;
<|  if(is_defined(generate_debug_spew_code))
    static char const *const ms_accept_handler_regex_[];
<|  end_if
    static std::uint32_t const ms_accept_handler_count_;

    // ///////////////////////////////////////////////////////////////////////
    // end of internal reflex-generated parser guts
    // ///////////////////////////////////////////////////////////////////////
}; // end of class <{class_name}

<|bottom_of_header_file?
