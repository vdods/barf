<*{if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<*{error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<*{end_if
<*{if(is_defined(parse_method_definition_parameters) && !is_defined(parse_method_parameters))
<*{error("can't specify parse_method_definition_parameters without specifying parse_method_parameters")
<*{end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<*{if(is_defined(generate_debug_spew_code))

#define TRISON_CPP_DEBUG_SPEW_(spew_code) if (DebugSpew()) { spew_code; }
<*{end_if
<*{if(is_defined(top_of_implementation_file))

<*{top_of_implementation_file
<*{end_if

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
<*{if(is_defined(superclass_and_member_constructors))
    :
<*{superclass_and_member_constructors
<*{end_if
{
    // one-time initializations
    m_tree_root_ = NULL;
<*{if(is_defined(generate_debug_spew_code))
    DebugSpew(false);
<*{end_if
    // per-input initializations
    ResetForNewInput_();

<*{if(is_defined(constructor_actions))

<*{constructor_actions
<*{end_if
}

<{class_name}::~<{class_name} ()
{
/*
    ClearBranches_();
    ClearTokenStack_();
    ClearLookaheadQueue_();
    ClearMostRecentReturnState_();
    ClearReturnToken_();
*/
<*{if(is_defined(destructor_actions))

<*{destructor_actions
<*{end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse (ParseNonterminal::Name nonterminal_to_parse_)
{
<*{if(is_defined(start_of_parse_method_actions))
<*{start_of_parse_method_actions

<*{end_if
<*{if(is_defined(end_of_parse_method_actions))
    ParserReturnCode parser_return_code_ = Parse_(nonterminal_to_parse_);

<*{end_of_parse_method_actions

    return parser_return_code_;
<*{else
    return Parse_(nonterminal_to_parse_);
<*{end_if
}
/*
void <{class_name}::ClearBranches_ ()
{
    // delete branches if any exist, and clear the set.
    for (BranchSet_::iterator it_ = m_branch_set_.begin(), it_end_ = m_branch_set_.end(); it_ != it_end_; ++it_)
        delete *it_;
    m_branch_set_.clear();
}

void <{class_name}::ClearTokenStack_ ()
{
    // throw away all tokens remaining in the token stack and clear it.
    for (TokenBuffer_::iterator it_ = m_token_stack_.begin(), it_end_ = m_token_stack_.end(); it_ != it_end_; ++it_)
        ThrowAwayToken_(it_->m_token_data_);
    m_token_stack_.clear();
}

void <{class_name}::ClearLookaheadQueue_ ()
{
    // throw away all tokens remaining in the lookahead queue and clear it
    for (TokenBuffer_::iterator it_ = m_lookahead_queue_.begin(), it_end_ = m_lookahead_queue_.end(); it_ != it_end_; ++it_)
        ThrowAwayToken_(it_->m_token_data_);
    m_lookahead_queue_.clear();
    // also reset the cursor
    m_lookahead_queue_cursor_ = 0;
}

void <{class_name}::ClearMostRecentReturnState_ ()
{
    m_most_recent_return_state_ = NULL;
}

void <{class_name}::ClearReturnToken_ ()
{
    // clear the return token's members to neutral values
    m_return_token_.m_token_id_ = 0; // TODO: make an ERROR_ token (nonterminal? terminal?)
    m_return_token_.m_token_data_ = <{token_data_type_sentinel};
}
*/
void <{class_name}::ThrowAwayToken_ (TokenData_ &token)
{
<*{token_throw_away_actions?
}

void <{class_name}::ResetForNewInput_ ()
{
//     TrisonCpp_::Npda_::ResetForNewInput_();
    m_lookahead_queue_.clear();
    m_lookahead_queue_cursor_ = 0;
/*
    ClearBranches_();
    ClearTokenStack_();
    ClearLookaheadQueue_();
    ClearMostRecentReturnState_();
    ClearReturnToken_();
*/
<*{if(is_defined(reset_for_new_input_actions))

<*{reset_for_new_input_actions
<*{end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse_ (ParseNonterminal::Name nonterminal_to_parse_)
{
    ParserReturnCode parser_return_code_ = PRC_SUCCESS;

    // TODO: clear any existing tree/branches

    assert(m_tree_root_ == NULL);
    assert(m_parser_branch_list_.IsEmpty_());

    // create the tree root - TODO move the below initialization into Action_() for case TreeNode_::ACTION_
    m_tree_root_ = new Action_(TreeNode_::ACTION_);
    {
        // create the initial branch with a rule stack level of 0
        Branch_ *initial_branch = new Branch_(ms_state_table_ + nonterminal_to_parse_);
        // add the initial nonterminal state as a child to the tree
        m_tree_root_->AddChildBranch_(initial_branch);
        // add the initial branch to the action and parser branch lists
        m_tree_root_->m_action_branch_list_.Prepend_(initial_branch);
        m_parser_branch_list_.Prepend_(initial_branch);
    }
    // initialize other members
    m_is_shift_blocked_ = false;
    m_reduce_transitions_were_performed_ = false;
    m_shift_transitions_were_performed_ = false;
    m_nonassoc_error_encountered_ = false;

    std::cerr << "!!! start !!!" << std::endl;
    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
    assert(m_tree_root_->AssertActionAndParserBranchListsAreConsistent_(m_parser_branch_list_));

    while (true)
    {
        std::cerr << std::endl << std::endl << "!!! iteration !!!" << std::endl;

        assert(!m_parser_branch_list_.IsEmpty_());
        assert(m_doomed_nonreturn_branch_list_.IsEmpty_());
        assert(m_doomed_return_branch_list_.IsEmpty_());

        // e-closure nodes should not be added for self-recursive rules.  e-closures
        // should only be done on non-closed branches.  the rule stack level should
        // be incremented on the transition after an e-closure.
        std::cerr << "*** e-close ***" << std::endl;
        PerformEpsilonClosure_();
        m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
        // only schedule reduce transitions if no branches have nonterminal lookaheads
        // (equivalent to not being shift-blocked)
        m_reduce_transitions_were_performed_ = false;
        m_shift_transitions_were_performed_ = false;
        // we can only perform reduce transitions if we're not blocked with
        // lookahead nonterminals.  we must wait to shift the lookahead nonterminals
        // so all branches can stay in lock-step with the scanner input.
        if (!m_is_shift_blocked_)
            PerformReduceTransitions_();
        if (m_reduce_transitions_were_performed_)
        {
            std::cerr << "*** reduce transitions ***" << std::endl;
            m_is_shift_blocked_ = true;
            m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
        }
        // we can only ever perform shift transitions if no reduce transitions were
        // scheduled, because we want to keep all branches' lookahead reading in sync.
        else
        {
            // if we are currently shift-blocked, only schedule shift transitions for
            // branches which have a nonterminal lookahead.  during shift-transition
            // scheduling, if a branch has no transitions, it is scheduled to be pruned.
            PerformShiftTransitions_();
            if (m_shift_transitions_were_performed_)
            {
                if (m_is_shift_blocked_)
                    std::cerr << "*** shift transitions (for lookahead nonterminal branches only) ***" << std::endl;
                else
                    std::cerr << "*** shift transitions (for all branches) ***" << std::endl;
                m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
            }

            m_is_shift_blocked_ = false;

            // if there were doomed branches
            if (!m_doomed_nonreturn_branch_list_.IsEmpty_() || !m_doomed_return_branch_list_.IsEmpty_())
            {
                // if any shift transitions were performed, we can prune all
                // doomed branches (because there was a valid transition)
                if (m_shift_transitions_were_performed_)
                {
                    std::cerr << "*** pruning all doomed branches ***" << std::endl;
                    assert(!m_parser_branch_list_.IsEmpty_());
                    // TODO: figure out if deleting these branch lists in this order guarantees
                    // no shift/reduce conflicts will be resolved incorrectly
                    PruneBranchList_(m_doomed_return_branch_list_);
                    PruneBranchList_(m_doomed_nonreturn_branch_list_);
                    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
                    assert(m_tree_root_->AssertActionAndParserBranchListsAreConsistent_(m_parser_branch_list_));
                }
                // if no shift transitions were performed but the doomed return branch
                // list isn't empty, prune only the doomed non-return branches, keeping
                // the return branches.  then return the single stack token.
                else if (!m_doomed_return_branch_list_.IsEmpty_())
                {
                    std::cerr << "*** pruning doomed non-return branches only ***" << std::endl;
                    assert(m_parser_branch_list_.IsEmpty_());
                    PruneBranchList_(m_doomed_nonreturn_branch_list_);
                    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
                    assert(m_doomed_nonreturn_branch_list_.IsEmpty_());

                    std::cerr << "*** executing and removing trunk (actions:";
                    ExecuteAndRemoveTrunk_();
                    std::cerr << ") ***" << std::endl;
                    m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);

                    // TODO technically there should only be one return branch at this
                    // point, but currently there's no way of guaranteeing branch uniqueness,
                    // so mutually recursive rules will produce redundant branches.
                    //assert(!m_doomed_return_branch_list_.IsEmpty_() && // TODO: enable this assert when appropriate
                    //       m_doomed_return_branch_list_.Front_() == m_doomed_return_branch_list_.Back_());

                    // return the single stack token TODO
                    parser_return_code_ = PRC_SUCCESS;
                    std::cerr << "*** returning successfully ***" << std::endl;
                    break;
                }
                // if none of the above, go into error handling mode
                else
                {
                    assert(m_parser_branch_list_.IsEmpty_());
                    assert(m_doomed_return_branch_list_.IsEmpty_());
                    m_parser_branch_list_.TrisonCpp_::List_<ParserBranch_>::Prepend_(m_doomed_nonreturn_branch_list_);
                    assert(false && "error handling mode not implemented yet");
                }
            }

            assert(!m_parser_branch_list_.IsEmpty_());
            assert(m_doomed_nonreturn_branch_list_.IsEmpty_());
            assert(m_doomed_return_branch_list_.IsEmpty_());
        }
        // TODO: handle nonassoc errors -- should this be
        // detected before PerformScheduledTransitions_ ?
        assert(!m_nonassoc_error_encountered_ && "nonassoc error handling not implemented yet");
        m_nonassoc_error_encountered_ = false;
        // Because the action tree represents all possible valid parses of the input
        // read so far, the "trunk" of the tree represents the actions which all of
        // the branches agree upon.  therefore, there is no reason not to execute said
        // actions now.  execute said actions, removing them as you go.
        std::cerr << "*** executing and removing trunk (actions:";
        ExecuteAndRemoveTrunk_();
        std::cerr << ") ***" << std::endl;
        m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
        assert(m_tree_root_->AssertActionAndParserBranchListsAreConsistent_(m_parser_branch_list_));

        assert(!m_parser_branch_list_.IsEmpty_() || !m_doomed_nonreturn_branch_list_.IsEmpty_() || !m_doomed_return_branch_list_.IsEmpty_());
    }

    delete m_tree_root_;
    m_tree_root_ = NULL;
    assert(m_parser_branch_list_.IsEmpty_());

    return parser_return_code_;
}

<{class_name}::Token_ &<{class_name}::ShiftLookaheadToken_ ()
{
    assert(m_lookahead_queue_cursor_ <= m_lookahead_queue_.size());
    if (m_lookahead_queue_cursor_ == m_lookahead_queue_.size())
        m_lookahead_queue_.push_back(Scan());
    return m_lookahead_queue_[m_lookahead_queue_cursor_++];
}

void <{class_name}::PerformEpsilonClosure_ ()
{
    // perform epsilon closure on the top stack states
    // of all non-epsilon-closed branches.
    StateStack_ extra_state_stack;
    for (ParserBranch_ *parser_branch = m_parser_branch_list_.Front_(); parser_branch != NULL; parser_branch = parser_branch->Next_())
    {
        Branch_ *branch = static_cast<Branch_ *>(parser_branch);
        if (!branch->m_is_epsilon_closed_)
        {
            branch->m_is_epsilon_closed_ = true;
            assert(extra_state_stack.empty());
            // this will add branches to the beginning of m_parser_branch_list_,
            // so we don't need to worry about it interfering with iteration.
            PerformEpsilonClosure_(*branch, extra_state_stack);
            assert(extra_state_stack.empty());
        }
    }
}

void <{class_name}::PerformEpsilonClosure_ (Branch_ &source_branch, StateStack_ &extra_state_stack)
{
    // iterate through the transitions from the top state of the branch,
    // recursively epsilon-closing epsilon transitions.  also, remember
    // if we have encountered a non-epsilon transition; this indicates
    // that a branch should be cloned and added here.
    bool non_epsilon_transition_encountered = false;
    for (Transition_ const *transition = (extra_state_stack.empty() ? source_branch.Top_().m_transition_table_ : extra_state_stack.back()->m_transition_table_),
                           *transition_end = transition + (extra_state_stack.empty() ? source_branch.Top_().m_transition_count_ : extra_state_stack.back()->m_transition_count_);
         transition != transition_end;
         ++transition)
    {
        if (transition->m_transition_type_ == Transition_::TT_EPSILON_)
        {
            // don't perform epsilon closure on this transition if the target
            // state has already been visited during this epsilon closure overall.
            bool transition_target_has_been_visited = &source_branch.Top_() == transition->m_target_state_;
            for (StateStack_::iterator it = extra_state_stack.begin(), it_end = extra_state_stack.end();
                 !transition_target_has_been_visited && it != it_end;
                 ++it)
            {
                if (transition->m_target_state_ == *it)
                    transition_target_has_been_visited = true;
            }
            if (!transition_target_has_been_visited)
            {
                extra_state_stack.push_back(transition->m_target_state_);
                PerformEpsilonClosure_(source_branch, extra_state_stack);
                extra_state_stack.pop_back();
            }
        }
        else
            non_epsilon_transition_encountered = true;
    }

    // we don't clone the source branch if the extra state stack is empty
    // because it would be identical to the source branch which is already
    // contained in m_parser_branch_list_.
    if (!extra_state_stack.empty() && non_epsilon_transition_encountered)
    {
        source_branch.m_parent_->AddEpsilonClosure_(source_branch, extra_state_stack);
        assert(m_tree_root_->AssertActionAndParserBranchListsAreConsistent_(m_parser_branch_list_));
    }
}

void <{class_name}::PerformReduceTransitions_ ()
{
    assert(!m_is_shift_blocked_);
    assert(!m_reduce_transitions_were_performed_);
    ParserBranch_ *parser_branch = m_parser_branch_list_.Front_();
    while (parser_branch != NULL)
    {
        Branch_ *branch = static_cast<Branch_ *>(parser_branch);
        parser_branch = parser_branch->Next_();

        // only attempt to transition from non-transition-fromed branches
        if (branch->m_is_epsilon_closed_)
        {
            bool reduce_transitions_were_performed_on_this_branch = false;
            State_ const &state = branch->Top_();
            for (Transition_ const *transition = state.m_transition_table_,
                                   *transition_end = transition + state.m_transition_count_;
                 transition != transition_end;
                 ++transition)
            {
                if (transition->m_transition_type_ == Transition_::TT_REDUCE_)
                {
                    PerformReduceTransition_(*branch, ms_rule_table_ + transition->m_transition_data_);
                    reduce_transitions_were_performed_on_this_branch = true;
                }
            }

            if (reduce_transitions_were_performed_on_this_branch)
                delete branch;
        }
    }
}

void <{class_name}::PerformReduceTransition_ (Branch_ &source_branch, Rule_ const *reduction_rule)
{
    assert(reduction_rule != NULL);
    assert(reduction_rule >= ms_rule_table_ && reduction_rule < ms_rule_table_ + ms_rule_count_);
    assert(source_branch.m_lookahead_nonterminal_token_id_ == none__);
    assert(source_branch.m_state_stack_.size() > reduction_rule->m_token_count_ + 1);
    assert(source_branch.m_parent_ != NULL);

    // only bother with a reduce action if it would actually succeed
    // (and not immediately be superceded by an existing reduce action.
    if (source_branch.m_parent_->ReduceActionWouldSucceed_(reduction_rule))
    {
        m_reduce_transitions_were_performed_ = true;
        source_branch.m_parent_->AddReduce_(source_branch, reduction_rule);
//         m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
//         PrintParserBranchList_();
        assert(m_tree_root_->AssertActionAndParserBranchListsAreConsistent_(m_parser_branch_list_));
    }
}

void <{class_name}::PerformShiftTransitions_ ()
{
    assert(!m_reduce_transitions_were_performed_);
    assert(m_doomed_nonreturn_branch_list_.IsEmpty_());

    Token_ dummy_lookahead_token;
    // only shift a lookahead token if we're not blocked waiting to
    // sync up the branch-wise token reading.
    Token_ &lookahead_token = m_is_shift_blocked_ ? dummy_lookahead_token : ShiftLookaheadToken_();

    ParserBranch_ *parser_branch = m_parser_branch_list_.Front_();
    while (parser_branch != NULL)
    {
        Branch_ *branch = static_cast<Branch_ *>(parser_branch);
        parser_branch = parser_branch->Next_();
//         std::cerr << "branch: " << branch << std::endl;
        assert(m_is_shift_blocked_ || branch->m_lookahead_nonterminal_token_id_ == 0);
        // if we're shift-blocked, then we only want to transition those
        // branches that have a lookahead nonterminal token.
        if (m_is_shift_blocked_ && branch->m_lookahead_nonterminal_token_id_ == 0)
            continue;
        // if this branch is not epsilon closed, then it's already transitioned.
        if (!branch->m_is_epsilon_closed_)
            continue;
        // otherwise iterate through the transitions at this state and transition
        // all that match the current lookahead.
        State_ const &state = branch->Top_();
        bool return_state_encountered = false;
        for (Transition_ const *transition = state.m_transition_table_,
                               *transition_end = transition + state.m_transition_count_;
             transition != transition_end;
             ++transition)
        {
            // if we're shift-blocked, only schedule shift-transitions for branches with
            // nonterminal lookaheads, otherwise schedule any valid shift-transition.
            if (m_is_shift_blocked_ &&
                branch->m_lookahead_nonterminal_token_id_ != 0 &&
                TransitionAcceptsTokenId_(transition, branch->m_lookahead_nonterminal_token_id_)
                ||
                !m_is_shift_blocked_ &&
                TransitionAcceptsTokenId_(transition, lookahead_token.m_token_id_))
            {
                PerformShiftTransition_(*branch, transition->m_target_state_);
            }
            else if (transition->m_transition_type_ == Transition_::TT_RETURN_)
            {
                return_state_encountered = true;
            }
        }

        branch->RemoveFromBranchList_(TrisonCpp_::BLT_PARSER_);
        if (return_state_encountered)
            m_doomed_return_branch_list_.Append_(branch);
        else
            m_doomed_nonreturn_branch_list_.Append_(branch);
    }
}

void <{class_name}::PerformShiftTransition_ (Branch_ &source_branch, State_ const *target_state)
{
    assert(target_state >= ms_state_table_ && target_state < ms_state_table_ + ms_state_count_);

    m_shift_transitions_were_performed_ = true;
    source_branch.m_parent_->AddShift_(source_branch, target_state);
//     m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
//     PrintParserBranchList_();
}

void <{class_name}::PruneBranchList_ (ParserBranchList_ &branch_list)
{
    // there can't be any pruning when un-shift-blocking because there's
    // no way for a branch with a lookahead nonterminal to fail to shift it.
    assert(!m_is_shift_blocked_);
    // prune from the end of the list towards the front -- necessary to
    // prevent certain shift/reduce conflicts from being incorrectly resolved.
    // this is due to the order which branches are added to the Action_
    // branch lists.
    ParserBranch_ *parser_branch;
    while ((parser_branch = branch_list.Back_()) != NULL)
    {
//         std::cerr << "pruning branch " << static_cast<Branch_ *>(parser_branch) << std::endl;
        delete static_cast<Branch_ *>(parser_branch);
//         m_tree_root_->Print_(std::cerr, ms_rule_table_, ms_state_table_, 0);
    }
}

void <{class_name}::ExecuteAndRemoveTrunk_ ()
{
    Action_ *action = m_tree_root_;
    bool first_action = true;

    while (true)
    {
        assert(action != NULL);

        // TODO: merge trunk deletion with this loop

        if (action->m_parent_ == NULL)
        {
            // this is the root, so don't do any action
        }
        else switch (action->m_tree_node_type_)
        {
            default:
            case TreeNode_::ACTION_:
                assert(false && "this should never happen");
            case TreeNode_::BRANCH_:
                // this is ok though
                break;

            case TreeNode_::REDUCE_:
            {
                Reduce_ *reduce = static_cast<Reduce_ *>(action);
                assert(reduce->m_reduction_rule_ != NULL);
                if (!first_action)
                    std::cerr << ',';
                std::cerr << " reduce \"" << reduce->m_reduction_rule_->m_description_ << '\"';
                first_action = false;
                break;
            }

            case TreeNode_::SHIFT_:
            {
                Shift_ *shift = static_cast<Shift_ *>(action);
                shift->ClearRuleRange_();
                if (!first_action)
                    std::cerr << ',';
                std::cerr << " shift";
                first_action = false;
                break;
            }
        }

        // if we're at a branch or a fork, stop iterating
        TreeNode_ *single_child = action->SingleChild_();
        if (single_child == NULL || single_child->m_tree_node_type_ == TreeNode_::BRANCH_)
            break;

        action = static_cast<Action_ *>(single_child);
    }

    // the trunk has been executed.  now delete it.
    while (m_tree_root_ != action)
    {
        TreeNode_ *single_child = m_tree_root_->SingleChild_();
        assert(single_child->m_tree_node_type_ == TreeNode_::REDUCE_ ||
               single_child->m_tree_node_type_ == TreeNode_::SHIFT_);
        m_tree_root_->RemoveChild_(single_child);
        switch (m_tree_root_->m_tree_node_type_)
        {
            default:
            case TreeNode_::BRANCH_: assert(false && "this should never happen"); break;
            case TreeNode_::ACTION_: delete m_tree_root_; break;
            case TreeNode_::REDUCE_: delete static_cast<Reduce_ *>(m_tree_root_); break;
            case TreeNode_::SHIFT_ : delete static_cast<Shift_ *>(m_tree_root_); break;
        }
        m_tree_root_ = static_cast<Action_ *>(single_child);
    }
}

void <{class_name}::PrintParserBranchList_ ()
{
    std::cerr << "&&& parser branch list &&&" << std::endl;
    for (ParserBranch_ *parser_branch = m_parser_branch_list_.Front_(); parser_branch != NULL; parser_branch = parser_branch->Next_())
        static_cast<Branch_ *>(parser_branch)->Print_(std::cerr, ms_rule_table_, ms_state_table_, 1);
    std::cerr << "&&& end of parser branch list &&&" << std::endl;
}

<*{loop(i, _rule_count)
<{class_name}::TokenData_ <{class_name}::RuleCode<{i}_ ()
{
<*{_rule_code[i]
}

<*{end_loop
TrisonCpp_::Npda_::Precedence_ const <{class_name}::ms_precedence_table_[] =
{
<*{loop(i, sizeof(_npda_precedence_level))
    { <*{
<{_npda_precedence_level[i]}<*{", "
TrisonCpp_::Npda_::ASSOCIATIVITY_<{_npda_precedence_associativity_name[i]}_<*{", "
"<{_npda_precedence_name[i]}"<*{
 }<{if(i+1 < sizeof(_npda_precedence_level))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_precedence_count_ = sizeof(<{class_name}::ms_precedence_table_) / sizeof(TrisonCpp_::Npda_::Precedence_);

TrisonCpp_::Npda_::Rule_ const <{class_name}::ms_rule_table_[] =
{
<*{loop(i, sizeof(_npda_rule_reduction_nonterminal_index))
    { <*{
<{class_name}::Nonterminal::<{_npda_rule_reduction_nonterminal_name[i]}<*{", "
<{if(_npda_rule_precedence_index[i] < _npda_precedence_count)}ms_precedence_table_+<{_npda_rule_precedence_index[i]}<{else}NULL<{end_if}<*{", "
<{_npda_rule_token_count[i]}<*{", "
<*{_npda_rule_description[i]
 }<{if(i+1 < sizeof(_npda_rule_reduction_nonterminal_index))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_rule_count_ = sizeof(<{class_name}::ms_rule_table_) / sizeof(TrisonCpp_::Npda_::Rule_);

TrisonCpp_::Npda_::State_ const <{class_name}::ms_state_table_[] =
{
<*{loop(i, sizeof(_npda_state_rule_index))
    { <*{
<{if(_npda_state_rule_index[i] < _rule_count)}ms_rule_table_+<{_npda_state_rule_index[i]}<{else}NULL<{end_if}<*{", "
<{_npda_state_rule_stage[i]}<*{", "
<{class_name}::Nonterminal::<{_npda_state_nonterminal_name[i]}<*{", "
<{_npda_state_transition_count[i]}<*{", "
ms_transition_table_+<{_npda_state_transition_offset[i]}<*{", "
<*{_npda_state_description[i]
 }<{if(i+1 < sizeof(_npda_state_rule_index))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(TrisonCpp_::Npda_::State_);

TrisonCpp_::Npda_::Transition_ const <{class_name}::ms_transition_table_[] =
{
<*{loop(i, sizeof(_npda_transition_type_name))
    { <*{
TrisonCpp_::Npda_::Transition_::<{_npda_transition_type_name[i]}_<*{", "
<*{if(_npda_transition_type_name[i] == "TT_SHIFT")
<*{if(sizeof(_terminal_index_list) > 0 && _npda_transition_data_index[i] >= _terminal_index_list[0] && _npda_transition_data_index[i] <= _terminal_index_list[sizeof(_terminal_index_list)-1])
<{class_name}::Terminal::<*{
<*{else_if(sizeof(_nonterminal_index_list) > 0 && (_npda_transition_data_index[i] == 0 || _npda_transition_data_index[i] >= 256 && _npda_transition_data_index[i] <= _nonterminal_index_list[sizeof(_nonterminal_index_list)-1]))
<{class_name}::Nonterminal::<*{
<*{end_if
<*{_npda_transition_data_name[i]
<*{else
<*{_npda_transition_data_index[i]
<*{end_if
<*{", "
<{if(_npda_transition_target_node_index[i] < 0)}NULL<{else}ms_state_table_+<{_npda_transition_target_node_index[i]}<*{end_if
 }<{if(i+1 < sizeof(_npda_transition_type_name))},<{end_if}
<*{end_loop
};
TrisonCpp_::Size_ const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(TrisonCpp_::Npda_::Transition_);

enum
{
    TABLE_SIZE_ASSERTIONS_ =
        TrisonCpp_::Assert_<<{class_name}::ms_precedence_count_ == <{_npda_precedence_count}>::v_ &&
        TrisonCpp_::Assert_<<{class_name}::ms_rule_count_ == <{_rule_count}>::v_ &&
        TrisonCpp_::Assert_<<{class_name}::ms_state_count_ == <{_npda_state_count}>::v_ &&
        TrisonCpp_::Assert_<<{class_name}::ms_transition_count_ == <{_npda_transition_count}>::v_
};
<*{if(is_defined(bottom_of_implementation_file))

<*{bottom_of_implementation_file
<*{end_if
