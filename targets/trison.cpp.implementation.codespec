<|if(is_defined(parse_method_access))
<|  if(parse_method_access != "public:" && parse_method_access != "protected:" && parse_method_access != "private:")
<|      error("invalid parse_method_access \"" . parse_method_access . "\"")
<|  end_if
<|else
<{  define(parse_method_access)}public:<|end_define
<|end_if
<|if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<|  error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<|end_if
<|if(is_defined(parse_method_definition_parameters) && !is_defined(parse_method_parameters))
<|  error("can't specify parse_method_definition_parameters without specifying parse_method_parameters")
<|end_if
<|if(!is_defined(debug_spew_prefix))
<{  define(debug_spew_prefix)}"<{class_name}:"<|end_define
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<|if(is_defined(generate_debug_spew_code))

#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }
<|end_if

<|top_of_implementation_file?

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
<|if(is_defined(superclass_and_member_constructors))
    :
<|superclass_and_member_constructors
<|end_if
{
<|if(is_defined(generate_debug_spew_code))
    DebugSpew(false);
<|end_if
<|if(is_defined(constructor_actions))

<|constructor_actions
<|end_if
}

<{class_name}::~<{class_name} ()
{
    // clean up dynamically allocated memory.
    ClearStack_();
    ClearLookaheadQueue_();

<|if(is_defined(destructor_actions))

<|destructor_actions
<|end_if
}

bool <{class_name}::IsAtEndOfInput ()
{
    return Lookahead_(0).m_id == Terminal::END_;
}

void <{class_name}::ResetForNewInput ()
{
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reset-for-new-input actions" << std::endl)

<|end_if
    // clean up stuff that might be hanging around from the last parse's input.
    ClearStack_();
    ClearLookaheadQueue_();
<|if(is_defined(reset_for_new_input_actions))

<|reset_for_new_input_actions
<|end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse (<{token_data_type} *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
<|if(is_defined(top_of_parse_method_actions))
<|top_of_parse_method_actions

<|end_if
<|if(is_defined(bottom_of_parse_method_actions))
    ParserReturnCode const parse_return_code = Parse_(return_token, nonterminal_to_parse);

<|bottom_of_parse_method_actions

    return parse_return_code;
<|else
    return Parse_(return_token, nonterminal_to_parse);
<|end_if
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

<{class_name}::ParserReturnCode <{class_name}::Parse_ (<{token_data_type} *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " starting parse" << std::endl)
<|end_if

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = <{token_data_default};

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the try {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    try {

<|end_if
    // make sure all our structures are empty and variables initialized.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();
    m_is_in_error_panic_ = false;

    // push the initial state of the DPDA.
    assert((false
<|for_each(key, _dpda_nonterminal_start_state_index)
<|if(key != "none_")
           || nonterminal_to_parse == ParseNonterminal::<{key}
<|end_if
<|end_for_each
           ) && "invalid nonterminal_to_parse");
    m_stack_.push_back(StackElement_(nonterminal_to_parse, Token(Nonterminal_::none_, <{token_data_default})));
    // main parser loop
    while (true)
    {
        if (m_is_in_error_panic_)
        {
<|if(is_defined(generate_debug_spew_code))
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " begin error panic" << std::endl)

<|end_if
            while (true)
            {
                // get the current state (top of the stack)
                assert(!m_stack_.empty());
                std::uint32_t current_state_index = m_stack_.back().m_state_index;
                assert(current_state_index < ms_state_count_);
                State_ const &current_state = ms_state_table_[current_state_index];
<|if(is_defined(generate_debug_spew_code))
                TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))
<|end_if

                // check if the current state accepts ERROR_ (only need to check the
                // non-default transitions, since the default transition can't be a shift).
                bool accepts_error = false;
                for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                       *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                     transition != transition_end;
                     ++transition)
                {
                    if (transition->m_type == Transition_::SHIFT && transition->m_lookahead_count == 1 && *transition->m_lookahead_sequence == Terminal::ERROR_)
                    {
                        accepts_error = true;
                        break;
                    }
                }

                if (accepts_error)
                {
<|if(is_defined(generate_debug_spew_code))
                    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " end error panic; success (current state accepts ERROR_ token)" << std::endl)
<|end_if
                    // if the current state accepts error, then we check if the lookahead token
                    // is Terminal::END_.  if it is, then we add a dummy Terminal::ERROR_ token
                    // in before it (since %error can't accept END_).  otherwise, we throw away
                    // the lookahead token, then clear the thrown-away token data, and set the
                    // token id to ERROR_.
                    assert(!m_lookahead_queue_.empty());
                    if (m_lookahead_queue_[0].m_id == Terminal::END_)
                    {
<|if(is_defined(generate_debug_spew_code))
                        TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " deferring Terminal::END_ (padding with Terminal::ERROR_ token)" << std::endl)
<|end_if
                        m_lookahead_queue_.push_front(Token(Terminal::END_)); // dummy value
                    }
                    else
                        ThrowAwayToken_(m_lookahead_queue_[0]);
                    m_lookahead_queue_[0].m_id = Terminal::ERROR_;
                    m_lookahead_queue_[0].m_data = <{token_data_default};
                    m_is_in_error_panic_ = false;
                    break;
                }
                else
                {
<|if(is_defined(generate_debug_spew_code))
                    if (m_stack_.size() > 1)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " continue error panic; pop stack (current state doesn't accept ERROR_ token)" << std::endl)
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " end error panic; abort (stack is empty)" << std::endl)
                    }
<|end_if
                    // otherwise throw away the data at the top of the stack, and pop the stack.
                    // then if the stack is empty, an unhandled parse error occurred.
                    ThrowAwayStackElement_(m_stack_.back());
                    m_stack_.resize(m_stack_.size()-1);
                    if (m_stack_.empty())
                    {
                        // parser_return_code_ and return_token are already appropriately
                        // set, so just break out of the inner loop.
                        break;
                    }
                }
            }

            // if we're still in error panic, then this indicates that we bottomed-
            // out the stack and it's an unhandled parse error, so break from the
            // main loop.
            if (m_is_in_error_panic_)
                break;
        }
        else // !m_is_in_error_panic_
        {
            // get the current state (top of the stack)
            assert(!m_stack_.empty());
            std::uint32_t current_state_index = m_stack_.back().m_state_index;
            assert(current_state_index < ms_state_count_);
            State_ const &current_state = ms_state_table_[current_state_index];
<|if(is_defined(generate_debug_spew_code))
            TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))
<|end_if

            // TODO -- binary search for faster transition matching?

            // loop through the current state's transitions and see if any match
            bool transition_exercised = false;
<|if(is_defined(generate_debug_spew_code))
            std::uint32_t tested_lookahead_count = 0;
<|end_if
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " current transitions:" << std::endl)
            for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                   *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                transition != transition_end;
                ++transition)
            {
                // the non-default transitions can only be REDUCE or SHIFT
                assert(transition->m_type == Transition_::REDUCE || transition->m_type == Transition_::SHIFT);

                // make sure enough lookaheads are in the queue (this must be done before
                // checking if the lookaheads match because otherwise the debug-spew printing will
                // be interrupted by the debug-spew printing that happens in the call to Looahead_).
                if (transition->m_lookahead_count > 0)
                    Lookahead_(transition->m_lookahead_count - 1);

                // check if the lookaheads match those of this transition.
                bool lookahead_sequence_matched = true;
                TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << "    transition with " << transition->m_lookahead_count << " lookahead(s):")
                for (std::uint32_t i = 0; i < transition->m_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << ms_token_name_table_[transition->m_lookahead_sequence[i]])
                    if (Lookahead_(i).m_id != transition->m_lookahead_sequence[i])
                    {
                        lookahead_sequence_matched = false;
                        break;
                    }
<|if(is_defined(generate_debug_spew_code))
                    else
                    {
                        if (i+1 > tested_lookahead_count)
                            tested_lookahead_count = i+1;
                    }
<|end_if
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                // if all the lookaheads matched, then exercise this transition,
                // and break out of this inner (transition) loop.
                if (lookahead_sequence_matched)
                {
<|if(is_defined(generate_debug_spew_code))
                    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " currently usable lookahead(s):")
                    for (std::uint32_t i = 0; i < tested_lookahead_count; ++i)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                    }
                    TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

<|end_if
                    ExerciseTransition_(*transition);
                    transition_exercised = true;
                    break;
                }
            }

            // if no transition was exercised, then exercise the default transition
            if (!transition_exercised)
            {
<|if(is_defined(generate_debug_spew_code))
                TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " currently usable lookahead(s):")
                for (std::uint32_t i = 0; i < tested_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " exercising default transition" << std::endl)
<|end_if
                // exercise the default transition.  a return value of true indicates
                // that the parser should return.
                if (ExerciseTransition_(*current_state.m_transition_table))
                {
                    // the token (data) on the top of the stack is the return token.
                    // set parser_return_code_ and assign the top stack token data to
                    // *return_token and then break out of the main parser loop.
                    assert(m_stack_[0].m_state_index == std::uint32_t(nonterminal_to_parse));
                    assert(m_stack_.size() == 2);
                    parser_return_code_ = PRC_SUCCESS;
                    *return_token = m_stack_.back().m_token.m_data;
                    // take the return token out of the stack, so it's not thrown away
                    // when we clear the stack later.
                    m_stack_.back().m_token.m_data = <{token_data_default};
                    break;
                }
            }
        }
    }

    // clear the stack, because we won't need it for the next parse.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    } catch (...) {
        // clear the stack, because we won't need it for the next parse.
        // we don't clear the lookahead queue here because we might want to
        // parse multiple times from the same input, and the lookahead queue
        // could have the next few tokens in it.
        ClearStack_();
        // rethrow the (unknown) exception.
        throw;
    }

<|end_if
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

<|end_if
    return parser_return_code_;
}

void <{class_name}::ThrowAwayToken_ (Token &token_) throw()
{
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing throw-away-token actions on token " << token_ << std::endl)

<|end_if
    ThrowAwayTokenData_(token_.m_data);
}

void <{class_name}::ThrowAwayStackElement_ (StackElement_ &stack_element_) throw()
{
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing throw-away-token actions on token " << stack_element_.m_token << " corresponding to stack element with index " << stack_element_.m_state_index << std::endl)

<|end_if
    ThrowAwayTokenData_(stack_element_.m_token.m_data);
}

void <{class_name}::ThrowAwayTokenData_ (<{token_data_type} &token_data) throw()
{
<|throw_away_token_actions?
}

<{class_name}::Token <{class_name}::Scan_ ()<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if}
{
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing scan actions" << std::endl)

<|end_if
<|scan_actions
}

void <{class_name}::ClearStack_ () throw()
{
    if (m_stack_.empty())
        return; // nothing to do

<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " clearing the stack" << std::endl)

<|end_if
    Stack_::iterator it = m_stack_.begin();
    Stack_::iterator it_end = m_stack_.end();
    // skip the bottom of the stack, since it
    // contains the start state and no token data.
    ++it;
    for ( ; it != it_end; ++it)
        ThrowAwayStackElement_(*it);
    m_stack_.clear();
}

void <{class_name}::ClearLookaheadQueue_ () throw()
{
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " clearing the lookahead queue" << std::endl)

<|end_if
    for (LookaheadQueue_::iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
        ThrowAwayToken_(*it);
    m_lookahead_queue_.clear();
}

<{class_name}::Token const &<{class_name}::Lookahead_ (LookaheadQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if}
{
    while (index >= m_lookahead_queue_.size())
    {
        m_lookahead_queue_.push_back(Scan_());
<|if(is_defined(generate_debug_spew_code))

        TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " pushed " << m_lookahead_queue_.back() << " onto back of lookahead queue" << std::endl)
<|end_if
    }
    return m_lookahead_queue_[index];
}

bool <{class_name}::ExerciseTransition_ (Transition_ const &transition)
{
    switch (transition.m_type)
    {
        case Transition_::REDUCE:
        {
            // execute the indicated reduction rule, push the returned Token
            // onto the front of the lookahead queue, then pop the corresponding
            // number of stack elements.
            assert(transition.m_data < ms_rule_count_);
            Rule_ const &rule = ms_rule_table_[transition.m_data];
<|if(is_defined(generate_debug_spew_code))
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " REDUCE " << rule.m_description << std::endl)
<|end_if
            assert(m_stack_.size() > rule.m_token_count);
            m_lookahead_queue_.push_front(
                Token(
                    rule.m_reduction_nonterminal_token_id,
                    ExecuteReductionRule_(transition.m_data)));
            m_stack_.resize(m_stack_.size() - rule.m_token_count);
<|if(is_defined(generate_debug_spew_code))
            assert(rule.m_reduction_nonterminal_token_id < ms_token_name_count_);
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " pushed " << Token(rule.m_reduction_nonterminal_token_id) << " onto front of lookahead queue" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << std::endl)
<|end_if
            return false; // indicating the parser isn't returning
        }

        case Transition_::RETURN:
<|if(is_defined(generate_debug_spew_code))
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " RETURN" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << std::endl)
<|end_if
            return true; // indicating the parser is returning

        case Transition_::SHIFT:
            // push the state (indicated by the shift transition) and token data
            // onto the stack, then pop the corresponding lookahead.
            assert(transition.m_data < ms_state_count_);
<|if(is_defined(generate_debug_spew_code))
            assert(Lookahead_(0).m_id < ms_token_name_count_); // at this point, we're past a possible
                                                               // client error, so asserting here is ok.
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " SHIFT " << Lookahead_(0) << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << std::endl)
<|end_if
            m_stack_.push_back(StackElement_(transition.m_data, Lookahead_(0)));
            m_lookahead_queue_.pop_front();
            return false; // indicating the parser isn't returning

        case Transition_::ERROR_PANIC:
<|if(is_defined(generate_debug_spew_code))
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " ERROR_PANIC" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << std::endl)
<|end_if
            m_is_in_error_panic_ = true;
            return false; // indicating the parser isn't returning

        default:
            assert(false && "invalid transition type (bad state machine, or memory corruption)");
            return false; // indicating the parser isn't returning
    }
}

<{class_name}::Token::Data <{class_name}::ExecuteReductionRule_ (std::uint32_t const rule_index_)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if}
{
    assert(rule_index_ < ms_rule_count_);
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reduction rule " << rule_index_ << std::endl)
<|end_if
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return <{token_data_default};

<|loop(i, _rule_count)
        case <{i}:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
<|loop(j, _rule_token_table_count[i])
<|if(_rule_token_assigned_id[_rule_token_table_offset[i]+j] != "")
            <{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}<{else}<{token_data_type}<{end_if} <{_rule_token_assigned_id[_rule_token_table_offset[i]+j]}(<{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{custom_token_data_type_cast}<<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}>(m_stack_[m_stack_.size()-<{_rule_token_count[i]-j}].m_token.m_data)<{else}m_stack_[m_stack_.size()-<{_rule_token_count[i]-j}].m_token.m_data<{end_if});
<|end_if
<|end_loop
<|_rule_code[i]
            break;
        }

<|end_loop
    }

<|if(!is_defined(dont_assert_if_reduction_rule_code_doesnt_return))
    assert(false && "no value returned from reduction rule code block");
<|end_if
    return <{token_data_default};
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintParserStatus_ (std::ostream &stream) const
{
    assert(!m_stack_.empty());

    stream << <{debug_spew_prefix} << " parser state stack: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        stream << it->m_state_index;
        Stack_::const_iterator next_it = it;
        if (++next_it != it_end)
            stream << ' ';
    }
    stream << std::endl;

    assert(m_stack_.size() >= 1);
    assert(m_stack_.front().m_token.m_id == std::uint32_t(Nonterminal_::none_));
    stream << <{debug_spew_prefix} << " parser stack tokens . lookahead queue: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        // the first token is always Nonterminal_::none_, which doesn't correspond to a real token, so skip it.
        if (it == m_stack_.begin())
            continue;
        stream << it->m_token << ' ';
    }
    stream << '.';
    for (LookaheadQueue_::const_iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
    {
        Token const &lookahead_token = *it;
        assert(lookahead_token.m_id < ms_token_name_count_ && "Token id out of range");
        stream << ' ' << lookahead_token;
    }
    stream << std::endl;

    PrintIndented_(stream, ms_state_table_[m_stack_.back().m_state_index].m_description);
    stream << std::endl;
}

void <{class_name}::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << <{debug_spew_prefix} << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << <{debug_spew_prefix} << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, <{class_name}::Token const &token)
{
    if (token.m_id < <{class_name}::ms_token_name_count_)
        stream << <{class_name}::ms_token_name_table_[token.m_id];
    else
        stream << "!INVALID TOKEN!";
    return stream;
}

<|end_if
<{class_name}::Rule_ const <{class_name}::ms_rule_table_[] =
{
<|loop(i, _rule_count)
    { <{class_name}::Nonterminal_::<{_rule_reduction_nonterminal_name[i]}, <{_rule_token_count[i]}<{if(is_defined(generate_debug_spew_code))}, <{_rule_description[i]}<{end_if} }<{if(i < _rule_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_rule_count_ = sizeof(<{class_name}::ms_rule_table_) / sizeof(*<{class_name}::ms_rule_table_);

<{class_name}::State_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _dpda_state_count)
    { <{_dpda_state_transition_count[i]}, ms_transition_table_+<{_dpda_state_transition_offset[i]}<{if(is_defined(generate_debug_spew_code))}, <{_dpda_state_description[i]}<{end_if} }<{if(i < _dpda_state_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

<{class_name}::Transition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _dpda_transition_count)
    { <{class_name}::Transition_::<{_dpda_transition_type_name[i]}, <{_dpda_transition_data[i]}, <{_dpda_transition_lookahead_count[i]}, ms_lookahead_table_+<{_dpda_transition_lookahead_offset[i]} }<{if(i < _dpda_transition_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);

<{class_name}::Token::Id const <{class_name}::ms_lookahead_table_[] =
{
<|loop(i, _dpda_lookahead_count)
    <|if(_dpda_lookahead_index[i] >= _terminal_index_list[0] && _dpda_lookahead_index[i] <= _terminal_index_list[sizeof(_terminal_index_list)-1])
<{class_name}::Terminal::<|
<|else_if(_dpda_lookahead_index[i] == 0 || _dpda_lookahead_index[i] >= 256 && _dpda_lookahead_index[i] <= _nonterminal_index_list[sizeof(_nonterminal_index_list)-1])
<{class_name}::Nonterminal_::<|
<|end_if
<|_dpda_lookahead_name[i]
<{if(i < _dpda_lookahead_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_lookahead_count_ = sizeof(<{class_name}::ms_lookahead_table_) / sizeof(*<{class_name}::ms_lookahead_table_);

<|if(is_defined(generate_debug_spew_code))
char const *const <{class_name}::ms_token_name_table_[] =
{
<|loop(i, 256+sizeof(_terminal_name_list)+sizeof(_nonterminal_name_list)-1)
<|if(i < 256)
    <|to_string_literal(to_character_literal(i))
<|else_if(i < 256+sizeof(_terminal_name_list))
    <|to_string_literal(_terminal_name_list[i-256])
<|else
    <|to_string_literal(_nonterminal_name_list[i-(256+sizeof(_terminal_name_list))+1])
<|end_if
<{if(i < 256+sizeof(_terminal_name_list)+sizeof(_nonterminal_name_list)-1-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_token_name_count_ = sizeof(<{class_name}::ms_token_name_table_) / sizeof(*<{class_name}::ms_token_name_table_);

<|end_if
// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////

<|bottom_of_implementation_file?
