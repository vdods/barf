<|if(is_defined(constructor_definition_parameters) && !is_defined(constructor_parameters))
<|error("can't specify constructor_definition_parameters without specifying constructor_parameters")
<|end_if
<|if(is_defined(parse_method_definition_parameters) && !is_defined(parse_method_parameters))
<|error("can't specify parse_method_definition_parameters without specifying parse_method_parameters")
<|end_if
<|if(!is_defined(return_token_type))
<{define(return_token_type)}<{token_data_type}<{end_define}
<|end_if
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// <{implementation_filename} generated by trison<{if(!is_defined(dont_generate_timestamps))} at <{_creation_timestamp}<{end_if}
// from <{_source_filename} using <{_targetspec_filename} and <{_codespec_filename}
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "<{header_filename}"

<|if(is_defined(generate_debug_spew_code))

#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }
<|end_if
<|if(is_defined(top_of_implementation_file))

<|top_of_implementation_file
<|end_if

<{class_name}::<{class_name} (<{if(is_defined(constructor_definition_parameters))}<{constructor_definition_parameters}<{else}<{constructor_parameters?}<{end_if})
<|if(is_defined(superclass_and_member_constructors))
    :
<|superclass_and_member_constructors
<|end_if
{
    // one-time initializations
<|if(is_defined(generate_debug_spew_code))
    DebugSpew(false);
<|end_if
    // per-input initializations
    ResetForNewInput_();
    m_is_in_error_panic_ = false;

<|if(is_defined(constructor_actions))

<|constructor_actions
<|end_if
}

<{class_name}::~<{class_name} ()
{
<|if(is_defined(destructor_actions))

<|destructor_actions
<|end_if
}

<{class_name}::ParserReturnCode <{class_name}::Parse (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_)
{
<|if(is_defined(start_of_parse_method_actions))
<|start_of_parse_method_actions

<|end_if
<|if(is_defined(end_of_parse_method_actions))
    ParserReturnCode parser_return_code_ = Parse_(return_token_, nonterminal_to_parse_);

<|end_of_parse_method_actions

    return parser_return_code_;
<|else
    return Parse_(return_token_, nonterminal_to_parse_);
<|end_if
}

void <{class_name}::ThrowAwayToken_ (Token::Data &token)
{
    TRISON_CPP_DEBUG_CODE_(cerr << "** executing throw-away-token actions" << endl;)
<|token_throw_away_actions?
}

void <{class_name}::ResetForNewInput_ ()
{
    TRISON_CPP_DEBUG_CODE_(cerr << "** executing reset-for-new-input actions" << endl;)
<|reset_for_new_input_actions?
}

<{class_name}::Token <{class_name}::Scan_ ()
{
<|scan_actions
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintParserStatus_ (ostream &stream) const
{
    assert(!m_stack_.empty());

    stream << "** parser stack: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        stream << it->m_state_index;
        Stack_::const_iterator next_it = it;
        if (++next_it != it_end)
            stream << ' ';
    }
    stream << endl;

    PrintIndented_(stream, ms_state_table_[m_stack_.rbegin()->m_state_index].m_description);
    stream << endl;
}

void <{class_name}::PrintIndented_ (ostream &stream, char const *string)
{
    assert(string != NULL);
    stream << "**    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << "\n**    ";
        else
            stream << *string;
        ++string;
    }
}

<|end_if
<{class_name}::ParserReturnCode <{class_name}::Parse_ (<{return_token_type} *return_token_, ParseNonterminal::Name nonterminal_to_parse_)
{
    assert(return_token_ != NULL && "the return-token pointer must be non-NULL");

    ParserReturnCode parser_return_code_ = PRC_SUCCESS;

    // make sure all our structures are empty
    ClearStack_();
    ClearLookaheadQueue_();
    m_is_in_error_panic_ = false;

    // push the initial state of the DPDA.
    assert((false
<|for_each(key, _dpda_nonterminal_start_state_index)
<|if(key != "none_")
           || nonterminal_to_parse_ == ParseNonterminal::<{key}
<|end_if
<|end_for_each
           ) && "invalid nonterminal_to_parse_");
    m_stack_.push_back(StackElement_(nonterminal_to_parse_, <{token_data_type_sentinel}));
    TRISON_CPP_DEBUG_CODE_(cerr << "** starting parse" << endl;)

    // main parser loop
    while (true)
    {
        if (m_is_in_error_panic_)
        {
            TRISON_CPP_DEBUG_CODE_(cerr << "** begin error panic" << endl;)

            // the special Terminal::END_ can not be eaten by error panic.
            if (Lookahead_(0).m_id == Terminal::END_)
            {
                TRISON_CPP_DEBUG_CODE_(cerr << "** end error panic; abort (error panic can't eat Terminal::END_)" << endl;)
                // set parser_return_code_ and return_token_ and break out of the main loop.
                parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
                *return_token_ = <{token_data_type_sentinel};
                break;
            }

            while (true)
            {
                // get the current state (top of the stack)
                assert(!m_stack_.empty());
                TrisonCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
                assert(current_state_index < ms_state_count_);
                State_ const &current_state = ms_state_table_[current_state_index];
                TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(cerr);)

                // check if the current state accepts ERROR_
                bool accepts_error = false;
                for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                       *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                     transition != transition_end;
                     ++transition)
                {
                    if (transition->m_type == Transition_::TT_SHIFT && transition->m_lookahead_count == 1 && *transition->m_lookahead_sequence == Terminal::ERROR_)
                    {
                        accepts_error = true;
                        break;
                    }
                }

                if (accepts_error)
                {
                    TRISON_CPP_DEBUG_CODE_(cerr << "** end error panic; success (current state accepts ERROR_ token)" << endl;)
                    // if the current state accepts error, throw away the first lookahead data
                    // (but don't pop the front of the lookahead queue).  then clear the thrown-
                    // away token data, and set the token id to ERROR_.
                    assert(!m_lookahead_queue_.empty());
                    ThrowAwayToken_(m_lookahead_queue_[0].m_data);
                    m_lookahead_queue_[0].m_id = Terminal::ERROR_;
                    m_lookahead_queue_[0].m_data = <{token_data_type_sentinel};
                    m_is_in_error_panic_ = false;
                    break;
                }
                else
                {
                    if (m_stack_.size() > 1)
                    {
                        TRISON_CPP_DEBUG_CODE_(cerr << "** continue error panic; pop stack (current state doesn't accept ERROR_ token)" << endl;)
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(cerr << "** end error panic; abort (stack is empty)" << endl;)
                    }
                    // otherwise throw away the data at the top of the stack, and pop the stack.
                    // then if the stack is empty, an unhandled parse error occurred, so set
                    // parser_return_code_ and return_token_ and break.
                    ThrowAwayToken_(m_stack_.rbegin()->m_token_data);
                    m_stack_.resize(m_stack_.size()-1);
                    if (m_stack_.empty())
                    {
                        parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
                        *return_token_ = <{token_data_type_sentinel};
                        break;
                    }
                }
            }

            // if we're still in error panic, then this indicates that we bottomed-
            // out the stack and it's an unhandled parse error, so break from the
            // main loop.
            if (m_is_in_error_panic_)
                break;
        }
        else // !m_is_in_error_panic_
        {
            // get the current state (top of the stack)
            assert(!m_stack_.empty());
            TrisonCpp_::Uint32 current_state_index = m_stack_.rbegin()->m_state_index;
            assert(current_state_index < ms_state_count_);
            State_ const &current_state = ms_state_table_[current_state_index];
            TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(cerr);)

            // TODO -- binary search for faster transition matching?

            // loop through the current state's transitions and see if any match
            bool transition_exercised = false;
            for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                   *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                transition != transition_end;
                ++transition)
            {
                // the non-default transitions can only be TT_REDUCE or TT_SHIFT
                assert(transition->m_type == Transition_::TT_REDUCE || transition->m_type == Transition_::TT_SHIFT);

                // TODO -- ensure the lookahead sequence lengths are sorted from
                // shortest to longest to ensure that we need the fewest lookaheads
                // to parse.

                // check if the lookaheads match those of this transition.
                bool lookahead_sequence_matched = true;
                for (TrisonCpp_::Uint32 i = 0; i < transition->m_lookahead_count; ++i)
                    if (Lookahead_(i).m_id != transition->m_lookahead_sequence[i])
                    {
                        lookahead_sequence_matched = false;
                        break;
                    }

                // if all the lookaheads matched, then exercise this transition,
                // and break out of this inner (transition) loop.
                if (lookahead_sequence_matched)
                {
                    ExerciseTransition_(*transition);
                    transition_exercised = true;
                    break;
                }
            }

            // if no transition was exercised, then exercise the default transition
            if (!transition_exercised)
            {
                TRISON_CPP_DEBUG_CODE_(cerr << "** exercising default transition..." << endl;)
                // exercise the default transition.  a return value of true indicates
                // that the parser should return.
                if (ExerciseTransition_(*current_state.m_transition_table))
                {
                    // the token (data) on the top of the stack is the return token.
                    // assign it to *return_token_ and then break out of the main
                    // parser loop.
                    assert(m_stack_[0].m_state_index == TrisonCpp_::Uint32(nonterminal_to_parse_));
                    assert(m_stack_.size() == 2);
                    *return_token_ = m_stack_[1].m_token_data;
                    break;
                }
            }
        }
    }

    // clean up -- TODO -- make exception catch/rethrow so we can cleanup even with exceptions
    ClearStack_();
    ClearLookaheadQueue_();

    return parser_return_code_;
}

void <{class_name}::ClearStack_ ()
{
    if (m_stack_.empty())
        return; // nothing to do

    TRISON_CPP_DEBUG_CODE_(cerr << "** clearing the stack" << endl;)

    Stack_::iterator it = m_stack_.begin();
    Stack_::iterator it_end = m_stack_.end();
    // skip the bottom of the stack, since it
    // contains the start state and no token data.
    ++it;
    for ( ; it != it_end; ++it)
        ThrowAwayToken_(it->m_token_data);
    m_stack_.clear();
}

void <{class_name}::ClearLookaheadQueue_ ()
{
    TRISON_CPP_DEBUG_CODE_(cerr << "** clearing the lookahead queue" << endl;)

    for (LookaheadQueue_::iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
        ThrowAwayToken_(it->m_data);
    m_lookahead_queue_.clear();
}

<{class_name}::Token const &<{class_name}::Lookahead_ (LookaheadQueue_::size_type index)
{
    while (index >= m_lookahead_queue_.size())
    {
        m_lookahead_queue_.push_back(Scan_());
        TRISON_CPP_DEBUG_CODE_(cerr << "** pushed " << m_lookahead_queue_.rbegin()->m_id << " onto back of lookahead queue" << endl;)
    }
    return m_lookahead_queue_[index];
}

bool <{class_name}::ExerciseTransition_ (Transition_ const &transition)
{
    switch (transition.m_type)
    {
        case Transition_::TT_REDUCE:
        {
            // execute the indicated reduction rule, push the returned Token
            // onto the front of the lookahead queue, then pop the corresponding
            // number of stack elements.
            assert(transition.m_data < ms_rule_count_);
            Rule_ const &rule = ms_rule_table_[transition.m_data];
            TRISON_CPP_DEBUG_CODE_(cerr << "** REDUCE " << rule.m_description << endl;)
            assert(m_stack_.size() > rule.m_token_count);
            m_lookahead_queue_.push_front(
                Token(
                    rule.m_reduction_nonterminal_token_id,
                    ExecuteReductionRule_(transition.m_data)));
            m_stack_.resize(m_stack_.size() - rule.m_token_count);
            TRISON_CPP_DEBUG_CODE_(cerr << "** pushed " << rule.m_reduction_nonterminal_token_id << " onto front of lookahead queue" << endl;)
            return false; // indicating the parser isn't returning
        }

        case Transition_::TT_RETURN:
            TRISON_CPP_DEBUG_CODE_(cerr << "** RETURN" << endl;)
            return true; // indicating the parser is returning

        case Transition_::TT_SHIFT:
            // push the state (indicated by the shift transition) and token data
            // onto the stack, then pop the corresponding lookahead.
            assert(transition.m_data < ms_state_count_);
            TRISON_CPP_DEBUG_CODE_(cerr << "** SHIFT (" << Lookahead_(0).m_id << ')' << endl;)
            m_stack_.push_back(StackElement_(transition.m_data, Lookahead_(0).m_data));
            m_lookahead_queue_.pop_front();
            return false; // indicating the parser isn't returning

        case Transition_::TT_ERROR_PANIC:
            TRISON_CPP_DEBUG_CODE_(cerr << "** ERROR_PANIC" << endl;)
            m_is_in_error_panic_ = true;
            return false; // indicating the parser isn't returning

        default:
            assert(false && "invalid transition type (bad state machine, or memory corruption)");
            return false; // indicating the parser isn't returning
    }
}

<{class_name}::Token::Data <{class_name}::ExecuteReductionRule_ (TrisonCpp_::Uint32 const rule_index_)
{
    assert(rule_index_ < ms_rule_count_);
    TRISON_CPP_DEBUG_CODE_(cerr << "** executing reduction rule " << rule_index_ << endl;)
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return <{token_data_type_sentinel};

<|loop(i, _rule_count)
        case <{i}:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
<|loop(j, _rule_token_table_count[i])
<|if(_rule_token_assigned_id[_rule_token_table_offset[i]+j] != "")
            <{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}<{else}<{token_data_type}<{end_if} <{_rule_token_assigned_id[_rule_token_table_offset[i]+j]}(<{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{custom_token_data_cast}<<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}>(m_stack_[m_stack_.size()-<{_rule_token_count[i]-j}])<{else}m_stack_[m_stack_.size()-<{_rule_token_count[i]-j}]<{end_if});
<|end_if
<|end_loop
<|_rule_code[i]
            break;
        }

<|end_loop
    }

<|if(!is_defined(dont_assert_if_reduction_rule_code_doesnt_return))
    assert(false && "no value returned from reduction rule code block");
<|end_if
    return <{token_data_type_sentinel};
}

<{class_name}::Rule_ const <{class_name}::ms_rule_table_[] =
{
<|loop(i, _rule_count)
    { <{class_name}::Nonterminal::<{_rule_reduction_nonterminal_name[i]}, <{_rule_token_count[i]}, <{_rule_description[i]} }<{if(i < _rule_count-1)},<{end_if}
<|end_loop
};
TrisonCpp_::Size const <{class_name}::ms_rule_count_ = sizeof(<{class_name}::ms_rule_table_) / sizeof(*<{class_name}::ms_rule_table_);

<{class_name}::State_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _dpda_state_count)
    { <{_dpda_state_transition_count[i]}, ms_transition_table_+<{_dpda_state_transition_offset[i]}, <{_dpda_state_description[i]} }<{if(i < _dpda_state_count-1)},<{end_if}
<|end_loop
};
TrisonCpp_::Size const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

<{class_name}::Transition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _dpda_transition_count)
    { <{class_name}::Transition_::<{_dpda_transition_type_name[i]}, <{_dpda_transition_data[i]}, <{_dpda_transition_lookahead_count[i]}, ms_lookahead_table_+<{_dpda_transition_lookahead_offset[i]} }<{if(i < _dpda_transition_count-1)},<{end_if}
<|end_loop
};
TrisonCpp_::Size const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);

<{class_name}::Token::Id const <{class_name}::ms_lookahead_table_[] =
{
<|loop(i, _dpda_lookahead_count)
    <|if(_dpda_lookahead_index[i] >= _terminal_index_list[0] && _dpda_lookahead_index[i] <= _terminal_index_list[sizeof(_terminal_index_list)-1])
<{class_name}::Terminal::<|
<|else_if(_dpda_lookahead_index[i] == 0 || _dpda_lookahead_index[i] >= 256 && _dpda_lookahead_index[i] <= _nonterminal_index_list[sizeof(_nonterminal_index_list)-1])
<{class_name}::Nonterminal::<|
<|end_if
<|_dpda_lookahead_name[i]
<{if(i < _dpda_lookahead_count-1)},<{end_if}
<|end_loop
};
TrisonCpp_::Size const <{class_name}::ms_lookahead_count_ = sizeof(<{class_name}::ms_lookahead_table_) / sizeof(*<{class_name}::ms_lookahead_table_);

enum
{
    TABLE_SIZE_ASSERTIONS_ =
        TrisonCpp_::Assert<<{class_name}::ms_rule_count_ == <{_rule_count}>::v &&
        TrisonCpp_::Assert<<{class_name}::ms_state_count_ == <{_dpda_state_count}>::v &&
        TrisonCpp_::Assert<<{class_name}::ms_transition_count_ == <{_dpda_transition_count}>::v &&
        TrisonCpp_::Assert<<{class_name}::ms_lookahead_count_ == <{_dpda_lookahead_count}>::v
};
<|if(is_defined(bottom_of_implementation_file))

<|bottom_of_implementation_file
<|end_if
