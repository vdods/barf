std::uint32_t <{class_name}::NonterminalStartStateIndex_ (<{class_name}::Nonterminal::Name nonterminal)
{
    switch (nonterminal)
    {
<|for_each(key, _npda_nonterminal_start_state_index)
        case Nonterminal::<{key}: return <{_npda_nonterminal_start_state_index[key]};
<|end_for_each
        default: assert(false && "invalid nonterminal"); return 0;
    }
}

<{class_name}::ParserReturnCode <{class_name}::Parse_ (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " starting parse" << std::endl)
<|end_if

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = <{token_data_default};

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the try {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    try {

<|end_if

    m_root = new ParseStackTreeNode_(ParseStackTreeNode_::ROOT, 0);

    ParseStackTreeNode_ *branch = new ParseStackTreeNode_(ParseStackTreeNode_::BRANCH, 0);
    branch->m_stack.push_back(StackElement_(NonterminalStartStateIndex_(nonterminal_to_parse), 0.0));

    m_root->AddChild(branch);

    PrintParserStatus_(std::cerr);

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    } catch (...) {
        // // clear the stack, because we won't need it for the next parse.
        // // we don't clear the lookahead queue here because we might want to
        // // parse multiple times from the same input, and the lookahead queue
        // // could have the next few tokens in it.
        // ClearStack_();
        // rethrow the (unknown) exception.
        throw;
    }

<|end_if
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

<|end_if
    return parser_return_code_;
}

<{class_name}::Token::Data <{class_name}::ExecuteReductionRule_ (std::uint32_t const rule_index_, Stack_ &stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if}
{
    assert(rule_index_ < ms_rule_count_);
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reduction rule " << rule_index_ << std::endl)
<|end_if
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return <{token_data_default};

<|loop(i, _rule_count)
        case <{i}:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
<|loop(j, _rule_token_table_count[i])
<|if(_rule_token_assigned_id[_rule_token_table_offset[i]+j] != "")
            <{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}<{else}<{token_data_type}<{end_if} <{_rule_token_assigned_id[_rule_token_table_offset[i]+j]}(<{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{custom_token_data_type_cast}<<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}>(stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data)<{else}stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data<{end_if});
<|end_if
<|end_loop
<|_rule_code[i]
            break;
        }

<|end_loop
    }

<|if(!is_defined(dont_assert_if_reduction_rule_code_doesnt_return))
    assert(false && "no value returned from reduction rule code block");
<|end_if
    return <{token_data_default};
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintParserStatus_ (std::ostream &stream) const
{
    assert(m_root != NULL);
    m_root->Print(stream);
}

char const *<{class_name}::ParseStackTreeNode_::AsString (Type type)
{
    static char const *const LOOKUP_TABLE[COUNT_] =
    {
        "ROOT",
        "RETURN",
        "REDUCE",
        "SHIFT",
        "INSERT_LOOKAHEAD_ERROR",
        "DISCARD_LOOKAHEAD",
        "POP_STACK",
        "BRANCH"
    };
    assert(std::uint32_t(type) < COUNT_);
    return LOOKUP_TABLE[std::uint32_t(type)];
}

void <{class_name}::ParseStackTreeNode_::AddChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == NULL);
    m_child_nodes[child->m_type].insert(child);
    child->m_parent_node = this;
}

void <{class_name}::ParseStackTreeNode_::RemoveChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == this);
    assert(HasChildrenOfType(child->m_type));
    m_child_nodes[child->m_type].erase(child);
    if (m_child_nodes[child->m_type].empty())
        m_child_nodes.erase(child->m_type);
    child->m_parent_node = NULL;
}

void <{class_name}::ParseStackTreeNode_::RemoveFromParent ()
{
    assert(m_parent_node != NULL);
    m_parent_node->RemoveChild(this);
}

void <{class_name}::ParseStackTreeNode_::Print (std::ostream &out, std::uint32_t indent_level) const
{
    for (std::uint32_t i = 0; i < indent_level; ++i)
        out << "    ";
    out << AsString(m_type) << " (";
    for (std::size_t i = 0; i < m_stack.size(); ++i)
    {
        out << m_stack[i].m_state_index;
        if (i+1 < m_stack.size())
            out << ' ';
    }
    out << ") ";
    for (std::size_t i = 0; i < m_lookahead_queue.size(); ++i)
    {
        out << ms_token_name_table_[m_lookahead_queue[i].m_id];
        if (i == m_lookahead_cursor)
            out << " . ";
        else
            out << ' ';
    }
    out << '\n';
    for (ChildMap::const_iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet const &child_node_set = it->second;
        for (ParseStackTreeNodeSet::const_iterator set_it = child_node_set.begin(), set_it_end = child_node_set.end(); set_it != set_it_end; ++set_it)
            (*set_it)->Print(out, indent_level+1);
    }
}

<|end_if
<{class_name}::State_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _npda_state_count)
    { <{_npda_state_transition_count[i]}, ms_transition_table_+<{_npda_state_transition_offset[i]}<{if(is_defined(generate_debug_spew_code))}, <{_npda_state_description[i]}<{end_if} }<{if(i < _npda_state_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

<{class_name}::Transition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _npda_transition_count)
    { <{class_name}::Transition_::<{_npda_transition_type_name[i]}, <{_npda_transition_data_index[i]}, <{_npda_transition_target_node_index[i]} }<{if(i < _npda_transition_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);
