std::uint32_t <{class_name}::NonterminalStartStateIndex_ (<{class_name}::Nonterminal::Name nonterminal)
{
    switch (nonterminal)
    {
<|for_each(key, _npda_nonterminal_start_state_index)
        case Nonterminal::<{key}: return <{_npda_nonterminal_start_state_index[key]};
<|end_for_each
        default: assert(false && "invalid nonterminal"); return 0;
    }
}

<{class_name}::ParserReturnCode <{class_name}::Parse_ (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " starting parse" << std::endl)
<|end_if

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = <{token_data_default};

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the try {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    try {

<|end_if

    m_root_ = new ParseStackTreeNode_(ParseStackTreeNode_::ROOT, 0);

    ParseStackTreeNode_ *branch = new ParseStackTreeNode_(ParseStackTreeNode_::BRANCH, 0);
    std::uint32_t initial_state = NonterminalStartStateIndex_(nonterminal_to_parse);
    branch->m_stack.push_back(StackElement_(initial_state, 0.0));

    StateVector_ const &epsilon_closure = EpsilonClosureOfState_(branch->m_stack.back().m_state_index);
    std::cerr << "epsilon closure of state " << initial_state << ";\n";
    for (StateVector_::const_iterator it = epsilon_closure.begin(), it_end = epsilon_closure.end(); it != it_end; ++it)
        std::cerr << *it << ' ';
    std::cerr << '\n';

    m_root_->AddChild(branch);
    PrintParserStatus_(std::cerr);

    // while (true)
    // {
    //     if (parse state stack tree has trunk)
    //     {
    //         do trunk actions
    //         prune trunk
    //     }
    //     else
    //     {

    //     }
    // }

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    } catch (...) {
        // // clear the stack, because we won't need it for the next parse.
        // // we don't clear the lookahead queue here because we might want to
        // // parse multiple times from the same input, and the lookahead queue
        // // could have the next few tokens in it.
        // ClearStack_();
        // rethrow the (unknown) exception.
        throw;
    }

<|end_if
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

<|end_if
    return parser_return_code_;
}

<{class_name}::Token::Data <{class_name}::ExecuteReductionRule_ (std::uint32_t const rule_index_, Stack_ &stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if}
{
    assert(rule_index_ < ms_rule_count_);
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reduction rule " << rule_index_ << std::endl)
<|end_if
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return <{token_data_default};

<|loop(i, _rule_count)
        case <{i}:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
<|loop(j, _rule_token_table_count[i])
<|if(_rule_token_assigned_id[_rule_token_table_offset[i]+j] != "")
            <{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}<{else}<{token_data_type}<{end_if} <{_rule_token_assigned_id[_rule_token_table_offset[i]+j]}(<{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{custom_token_data_type_cast}<<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}>(stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data)<{else}stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data<{end_if});
<|end_if
<|end_loop
<|_rule_code[i]
            break;
        }

<|end_loop
    }

<|if(!is_defined(dont_assert_if_reduction_rule_code_doesnt_return))
    assert(false && "no value returned from reduction rule code block");
<|end_if
    return <{token_data_default};
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintParserStatus_ (std::ostream &stream) const
{
    assert(m_root_ != NULL);
    m_root_->Print(stream);
}

char const *<{class_name}::ParseStackTreeNode_::AsString (Type type)
{
    static char const *const LOOKUP_TABLE[COUNT_] =
    {
        "ROOT",
        "RETURN",
        "REDUCE",
        "SHIFT",
        "INSERT_LOOKAHEAD_ERROR",
        "DISCARD_LOOKAHEAD",
        "POP_STACK",
        "BRANCH"
    };
    assert(std::uint32_t(type) < COUNT_);
    return LOOKUP_TABLE[std::uint32_t(type)];
}

<|end_if
void <{class_name}::ParseStackTreeNode_::AddChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == NULL);
    m_child_nodes[child->m_type].insert(child);
    child->m_parent_node = this;
}

void <{class_name}::ParseStackTreeNode_::RemoveChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == this);
    assert(HasChildrenOfType(child->m_type));
    m_child_nodes[child->m_type].erase(child);
    if (m_child_nodes[child->m_type].empty())
        m_child_nodes.erase(child->m_type);
    child->m_parent_node = NULL;
}

void <{class_name}::ParseStackTreeNode_::RemoveFromParent ()
{
    assert(m_parent_node != NULL);
    m_parent_node->RemoveChild(this);
}

<{class_name}::ParseStackTreeNode_ *<{class_name}::ParseStackTreeNode_::CloneLeafNode () const
{
    assert(m_child_nodes.empty());
    ParseStackTreeNode_ *retval = new ParseStackTreeNode_(m_type, m_data);
    retval->m_stack = m_stack;
    retval->m_lookahead_queue = m_lookahead_queue;
    retval->m_lookahead_cursor = m_lookahead_cursor;
    return retval;
}

void <{class_name}::ParseStackTreeNode_::Print (std::ostream &out, std::uint32_t indent_level) const
{
    for (std::uint32_t i = 0; i < indent_level; ++i)
        out << "    ";
    out << AsString(m_type) << " (";
    for (std::size_t i = 0; i < m_stack.size(); ++i)
    {
        out << m_stack[i].m_state_index;
        if (i+1 < m_stack.size())
            out << ' ';
    }
    out << ") ";
    for (std::size_t i = 0; i < m_lookahead_queue.size(); ++i)
    {
        out << ms_token_name_table_[m_lookahead_queue[i].m_id];
        if (i == m_lookahead_cursor)
            out << " . ";
        else
            out << ' ';
    }
    out << '\n';
    for (ChildMap::const_iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet const &child_node_set = it->second;
        for (ParseStackTreeNodeSet::const_iterator set_it = child_node_set.begin(), set_it_end = child_node_set.end(); set_it != set_it_end; ++set_it)
            (*set_it)->Print(out, indent_level+1);
    }
}

<{class_name}::ParseStackTreeNode_ *<{class_name}::TakeActionOnBranch_ (ParseStackTreeNode_ const &branch, ParseStackTreeNode_::Type action_type, std::uint32_t action_data)
{
    assert(branch.m_type == ParseStackTreeNode_::BRANCH && "Only a BRANCH type node can take an action");
    assert(branch.m_parent_node != NULL);
    ParseStackTreeNode_ *new_branch = branch.CloneLeafNode();
    switch (action_type)
    {
        case ParseStackTreeNode_::ROOT: {
            assert(false && "ParseStackTreeNode_::ROOT is an invalid action type.");
            break;
        }
        case ParseStackTreeNode_::RETURN: {
            // Nothing to do.
            break;
        }
        case ParseStackTreeNode_::REDUCE: {
            // Execute the appropriate rule on the top tokens in the stack
            std::uint32_t const &rule_index = branch.m_data;
            // NOTE: dont actually execute reduction rules here, that should be saved for executing the trunk
            // Token::Data reduced_nonterminal_token_data = ExecuteReductionRule_(rule_index, new_branch->m_stack);
            Rule_ const &rule = ms_rule_table_[rule_index];
            // Pop those stack tokens
            for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
                new_branch->m_stack.pop_back();
            // Push the reduced nonterminal token data onto the front of the lookahead queue
            // new_branch->m_lookahead_queue.push_front(Token(rule.m_reduction_nonterminal_token_id, reduced_nonterminal_token_data));
            new_branch->m_lookahead_queue.push_front(Token(rule.m_reduction_nonterminal_token_id));
            break;
        }
        case ParseStackTreeNode_::SHIFT: {
            // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
            std::uint32_t const &state_index = action_data;
            new_branch->m_stack.push_back(StackElement_(state_index, new_branch->m_lookahead_queue.front()));
            new_branch->m_lookahead_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::INSERT_LOOKAHEAD_ERROR: {
            new_branch->m_lookahead_queue.push_front(Token(Terminal::ERROR_));
            break;
        }
        case ParseStackTreeNode_::DISCARD_LOOKAHEAD: {
            assert(!new_branch->m_lookahead_queue.empty());
            new_branch->m_lookahead_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::POP_STACK: {
            // TODO: make separate action nodes for each pop, instead of using action data.
            std::uint32_t const &pop_count = action_data;
            for (std::uint32_t i = 0; i < pop_count; ++i)
                new_branch->m_stack.pop_back();
            break;
        }
        case ParseStackTreeNode_::BRANCH: {
            assert(false && "ParseStackTreeNode_::BRANCH is an invalid action type.");
            break;
        }
        default: {
            assert(false && "invalid ParseStackTreeNode_::Type");
            break;
        }
    }

    // Ensure the action node exists, creating it if necessary.
    ParseStackTreeNode_ *action_node = NULL;
    if (!branch.m_parent_node->HasChildrenOfType(action_type))
    {
        action_node = new ParseStackTreeNode_(action_type, action_data);
        branch.m_parent_node->AddChild(action_node);
    }
    else
    {
        ParseStackTreeNode_::ParseStackTreeNodeSet &children_of_action_type = branch.m_parent_node->ChildrenOfType(action_type);
        assert(children_of_action_type.size() == 1);
        action_node = *children_of_action_type.begin();
    }
    assert(action_node != NULL);
    action_node->AddChild(new_branch);

    return new_branch;
}

<{class_name}::StateVector_ const &<{class_name}::EpsilonClosureOfState_ (std::uint32_t state_index)
{
    // This function implementation depends on there not being an epsilon transition cycle.

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<std::uint32_t,StateVector_> LookupTable;
    static LookupTable s_lookup_table;
    LookupTable::iterator it = s_lookup_table.find(state_index);
    if (it != s_lookup_table.end())
        return it->second;

    // This set collects the epsilon closure with no duplicates    
    StateSet_ epsilon_closure_set;
    State_ const &state = ms_state_table_[state_index];
    bool state_has_non_epsilon_transitions = false;
    for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count;
         transition != transition_end;
         ++transition)
    {
        if (transition->m_type == Transition_::EPSILON)
        {
            StateVector_ const &sub_epsilon_closure = EpsilonClosureOfState_(transition->m_target_state_index);
            for (StateVector_::const_iterator it = sub_epsilon_closure.begin(), it_end = sub_epsilon_closure.end(); it != it_end; ++it)
                epsilon_closure_set.insert(*it);
        }
        else
            state_has_non_epsilon_transitions = true;
    }
    // The epsilon closure of a state includes itself if it has non-epsilon transitions
    if (state_has_non_epsilon_transitions)
        epsilon_closure_set.insert(state_index);

    // Add all the elements of epsilon_closure_set to the memoized entry.
    StateVector_ &epsilon_closure = s_lookup_table[state_index];
    epsilon_closure.reserve(epsilon_closure_set.size());
    for (StateSet_::const_iterator it = epsilon_closure_set.begin(), it_end = epsilon_closure_set.end(); it != it_end; ++it)
        epsilon_closure.push_back(*it);
    return epsilon_closure;
}

<{class_name}::State_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _npda_state_count)
    { <{_npda_state_transition_count[i]}, ms_transition_table_+<{_npda_state_transition_offset[i]}<{if(is_defined(generate_debug_spew_code))}, <{_npda_state_description[i]}<{end_if} }<{if(i < _npda_state_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

<{class_name}::Transition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _npda_transition_count)
    { <{class_name}::Transition_::<{_npda_transition_type_name[i]}, <{_npda_transition_data_index[i]}, <{_npda_transition_target_node_index[i]} }<{if(i < _npda_transition_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);
