#include <algorithm>

std::uint32_t <{class_name}::NonterminalStartStateIndex_ (<{class_name}::Nonterminal::Name nonterminal)
{
    switch (nonterminal)
    {
<|for_each(key, _npda_nonterminal_start_state_index)
        case Nonterminal::<{key}: return <{_npda_nonterminal_start_state_index[key]};
<|end_for_each
        default: assert(false && "invalid nonterminal"); return 0;
    }
}

<{class_name}::ParserReturnCode <{class_name}::Parse_ (<{token_data_type} *return_token, Nonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " starting parse" << std::endl)
<|end_if

    ParserReturnCode parser_return_code_ = PRC_INTERNAL_ERROR;
    *return_token = <{token_data_default};

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the try {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    try {

<|end_if

    m_npda_.m_root_ = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::ROOT));

    ParseStackTreeNode_ *branch = new ParseStackTreeNode_(ParseStackTreeNode_::Spec(ParseStackTreeNode_::BRANCH));
    std::uint32_t initial_state = NonterminalStartStateIndex_(nonterminal_to_parse);
    branch->m_stack.push_back(StackElement_(initial_state, <{token_data_default}));

    m_npda_.m_branch_queue_.push_back(branch);

    m_npda_.m_global_stack_.push_back(StackElement_(initial_state, <{token_data_default}));

    StateVector_ const &epsilon_closure = EpsilonClosureOfState_(branch->m_stack.back().m_state_index);
    std::cerr << "epsilon closure of state " << initial_state << ";\n";
    for (StateVector_::const_iterator it = epsilon_closure.begin(), it_end = epsilon_closure.end(); it != it_end; ++it)
        std::cerr << *it << ' ';
    std::cerr << '\n';

    m_npda_.m_root_->AddChild(branch);

    bool should_return = false;
    // while (true)
    for (int i = 0; i < 200 && !should_return; ++i)
    {
        std::cerr << "\n---------- ITERATION " << i << " --------------\n";
        PrintParserStatus_(std::cerr);
        std::cerr << '\n';

        if (m_npda_.m_root_->HasTrunkChild())
            ExecuteAndRemoveTrunkActions_(should_return, parser_return_code_, return_token);
        else
            ContinueNPDAParse_();
        std::cerr << '\n';
    }

    std::cerr << "\n---------- RETURNING --------------\n";
    PrintParserStatus_(std::cerr);
    std::cerr << '\n';

<|if(is_defined(enable_scan_actions_exceptions) || is_defined(enable_reduction_rule_exceptions))
    // this is the catch {} block generated by specifying the
    // %target.cpp.enable_scan_actions_exceptions or
    // %target.cpp.enable_reduction_rule_exceptions directives in the
    // primary source, to allow necessary cleanup if the scan actions
    // or a reduction rule code block throws an exception.
    } catch (...) {
        // // clear the stack, because we won't need it for the next parse.
        // // we don't clear the lookahead queue here because we might want to
        // // parse multiple times from the same input, and the lookahead queue
        // // could have the next few tokens in it.
        // ClearStack_();
        // rethrow the (unknown) exception.
        throw;
    }

<|end_if
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << <{debug_spew_prefix} << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

<|end_if
    return parser_return_code_;
}

void <{class_name}::ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code_, <{token_data_type} *&return_token)
{
    std::cerr << "Parse stack tree has trunk; executing trunk actions.\n";
    while (m_npda_.m_root_->HasTrunkChild())
    {
        ParseStackTreeNode_ *trunk_child = m_npda_.m_root_->PopTrunkChild();
        switch (trunk_child->m_spec.m_type)
        {
            case ParseStackTreeNode_::RETURN: {
                std::cerr << "    executing trunk action RETURN.\n";
                assert(m_npda_.m_global_stack_.size() == 2);
                parser_return_code_ = PRC_SUCCESS;
                *return_token = m_npda_.m_global_stack_.back().m_token.m_data;
                should_return = true;
                break;
            }
            case ParseStackTreeNode_::REDUCE: {
                // Execute the appropriate rule on the top tokens in the stack
                std::uint32_t const &rule_index = trunk_child->m_spec.m_single_data;
                std::cerr << "    executing trunk action REDUCE rule " << rule_index << ".\n";
                // NOTE: dont actually execute reduction rules here, that should be saved for executing the trunk
                Token::Data reduced_nonterminal_token_data = ExecuteReductionRule_(rule_index, m_npda_.m_global_stack_);
                Rule_ const &rule = ms_rule_table_[rule_index];
                // Pop those stack tokens
                // std::cerr << "TakeActionOnBranch_ -- reducing rule " << rule_index << " \"" << rule.m_description << "\" which has " << rule.m_token_count << " tokens\n";
                for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
                    m_npda_.m_global_stack_.pop_back();
                // Push the reduced nonterminal token data onto the front of the lookahead queue
                m_npda_.PushFrontGlobalLookahead(Token(rule.m_reduction_nonterminal_token_id, reduced_nonterminal_token_data));
                break;
            }
            case ParseStackTreeNode_::SHIFT: {
                // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
                std::uint32_t const &state_index = trunk_child->m_spec.m_single_data;
                std::cerr << "    executing trunk action SHIFT.\n";// then push state " << state_index << ".\n";
                m_npda_.m_global_stack_.push_back(StackElement_(state_index, Lookahead_(0)));
                m_npda_.PopFrontGlobalLookahead();
                break;
            }
            case ParseStackTreeNode_::INSERT_LOOKAHEAD_ERROR: {
                std::cerr << "    executing trunk action INSERT_LOOKAHEAD_ERROR.\n";
                m_npda_.PushFrontGlobalLookahead(Token(Terminal::ERROR_));
                break;
            }
            case ParseStackTreeNode_::DISCARD_LOOKAHEAD: {
                std::cerr << "    executing trunk action DISCARD_LOOKAHEAD.\n";
                assert(!m_npda_.m_global_lookahead_queue_.empty());
                m_npda_.PopFrontGlobalLookahead();
                break;
            }
            case ParseStackTreeNode_::POP_STACK: {
                std::uint32_t const &pop_count = trunk_child->m_spec.m_single_data;
                std::cerr << "    executing trunk action POP_STACK " << pop_count << ".\n";
                if (m_npda_.m_global_stack_.size() > pop_count)
                {
                    for (std::uint32_t i = 0; i < pop_count; ++i)
                    {
                        ThrowAwayStackElement_(m_npda_.m_global_stack_.back());
                        m_npda_.m_global_stack_.pop_back();
                    }
                }
                // TODO: figure out if branches' lookahead queues or cursors need to be updated.
                break;
            }

            default:
                assert(false && "this should not happen");
                break;
        }
        assert(trunk_child->m_parent_node == NULL);
        assert(trunk_child->m_child_nodes.empty());
        delete trunk_child;
    }
}

void <{class_name}::ContinueNPDAParse_ ()
{
    std::cerr << "Parse stack tree does not have trunk; continuing parse.\n";
    // This is a clunky and inefficient way to process actions (from all branches) first by their SortedTypeIndex.
    for (std::uint32_t current_sorted_type_index = 0; current_sorted_type_index <= 3; ++current_sorted_type_index)
    {
        std::cerr << "    Processing transitions having SortedTypeIndex equal to " << current_sorted_type_index << ".\n";

        if (!m_npda_.m_new_branch_queue_.empty())
        {
            std::cerr << "        Early-out based on sorted type index.\n";
            break;
        }

        // Process non-blocked branches.
        for (BranchQueue_::iterator branch_it = m_npda_.m_branch_queue_.begin(), branch_it_end = m_npda_.m_branch_queue_.end(); branch_it != branch_it_end; ++branch_it)
        {
            assert(*branch_it != NULL);
            ParseStackTreeNode_ &branch = **branch_it;

            if (branch.IsBlockedBranch())
                continue;

            assert(branch.m_spec.m_type == ParseStackTreeNode_::BRANCH);
            std::cerr << "        Processing branch: ";
            branch.Print(std::cerr, *this, 0);
            std::uint32_t branch_state_index = branch.m_stack.back().m_state_index;
            TransitionVector_ const &non_epsilon_transitions = NonEpsilonTransitionsOfState_(branch_state_index);

            // Exercise all valid transitions whose SortedTypeIndex is current_sorted_type_index
            for (TransitionVector_::const_iterator transition_it = non_epsilon_transitions.begin(), transition_it_end = non_epsilon_transitions.end(); transition_it != transition_it_end; ++transition_it)
            {                    
                Transition_ const &transition = *transition_it;
                assert(transition.m_type >= Transition_::RETURN);
                assert(transition.m_type <= Transition_::POP_STACK);
                std::uint32_t transition_sorted_type_index = Transition_::Order::SortedTypeIndex(Transition_::Type(transition.m_type));

                if (transition_sorted_type_index != current_sorted_type_index)
                    continue;

                std::cerr << "            Processing transition " << ParseStackTreeNode_::AsString(ParseStackTreeNode_::Type(transition.m_type)) << " with transition token " << transition.m_token_index << " and data " << transition.m_data_index << " and sorted type index " << Transition_::Order::SortedTypeIndex(Transition_::Type(transition.m_type)) << '\n';

                ParseStackTreeNode_ *resulting_branch = NULL;
                // If it's a default transition, there's no need to access the lookahead.
                if (transition.m_token_index == Nonterminal::none_)
                {
                    std::cerr << "                Exercising transition.\n";
                    resulting_branch = TakeHypotheticalActionOnBranch_(branch, ParseStackTreeNode_::Type(transition.m_type), transition.m_data_index);
                    // std::cerr << "                    resulting branch: ";
                    // if (resulting_branch != NULL)
                    //     resulting_branch->Print(std::cerr, *this, 0);
                    // else
                    //     std::cerr << "NULL\n";
                }
                // Otherwise, the lookahead must be accessed.
                else
                {
                    Token const &lookahead = branch.Lookahead(*this);
                    std::cerr << "                Lookahead is " << lookahead.m_id << '\n';
                    if (transition.m_token_index == lookahead.m_id)
                    {
                        std::cerr << "                Exercising transition.\n";
                        resulting_branch = TakeHypotheticalActionOnBranch_(branch, ParseStackTreeNode_::Type(transition.m_type), transition.m_data_index);
                        // std::cerr << "                    resulting branch: ";
                        // if (resulting_branch != NULL)
                        //     resulting_branch->Print(std::cerr, *this, 0);
                        // else
                        //     std::cerr << "NULL\n";
                    }
                }
                if (resulting_branch != NULL)
                    m_npda_.m_new_branch_queue_.push_back(resulting_branch);
            }
        }
    }

    // std::cerr << "m_npda_.m_new_branch_queue_.size() = " << m_npda_.m_new_branch_queue_.size() << '\n';
    // Take new branches and clear old ones.
    for (BranchQueue_::iterator branch_it = m_npda_.m_branch_queue_.begin(), branch_it_end = m_npda_.m_branch_queue_.end(); branch_it != branch_it_end; ++branch_it)
    {
        ParseStackTreeNode_ *branch = *branch_it;
        // std::cerr << "deleting branch " << branch << " ";
        // branch->Print(std::cerr, *this, 0);
        // std::cerr << " having parent " << branch->m_parent_node << '\n';
        branch->RemoveFromParent();
        delete branch;
    }
    m_npda_.m_branch_queue_.clear();
    std::swap(m_npda_.m_branch_queue_, m_npda_.m_new_branch_queue_);
    assert(m_npda_.m_new_branch_queue_.empty());
}

<{class_name}::Token::Data <{class_name}::ExecuteReductionRule_ (std::uint32_t const rule_index_, Stack_ &stack)<{if(!is_defined(enable_reduction_rule_exceptions))} throw()<{end_if}
{
    assert(rule_index_ < ms_rule_count_);
<|if(is_defined(generate_debug_spew_code))
    TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " executing reduction rule " << rule_index_ << std::endl)
<|end_if
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return <{token_data_default};

<|loop(i, _rule_count)
        case <{i}:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < stack.size());
<|loop(j, _rule_token_table_count[i])
<|if(_rule_token_assigned_id[_rule_token_table_offset[i]+j] != "")
            <{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}<{else}<{token_data_type}<{end_if} <{_rule_token_assigned_id[_rule_token_table_offset[i]+j]}(<{if(_rule_token_assigned_type[_rule_token_table_offset[i]+j] != "")}<{custom_token_data_type_cast}<<{_rule_token_assigned_type[_rule_token_table_offset[i]+j]}>(stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data)<{else}stack[stack.size()-<{_rule_token_count[i]-j}].m_token.m_data<{end_if});
<|end_if
<|end_loop
<|_rule_code[i]
            break;
        }

<|end_loop
    }

<|if(!is_defined(dont_assert_if_reduction_rule_code_doesnt_return))
    assert(false && "no value returned from reduction rule code block");
<|end_if
    return <{token_data_default};
}

<|if(is_defined(generate_debug_spew_code))
void <{class_name}::PrintParserStatus_ (std::ostream &out) const
{
    assert(m_npda_.m_root_ != NULL);

    out << "global state stack is (";
    for (std::size_t i = 0; i < m_npda_.m_global_stack_.size(); ++i)
    {
        out << m_npda_.m_global_stack_[i].m_state_index;
        if (i+1 < m_npda_.m_global_stack_.size())
            out << ' ';
    }
    out << "), stack tokens then lookahead queue is ";
    for (std::size_t i = 1; i < m_npda_.m_global_stack_.size(); ++i)
        out << ms_token_name_table_[m_npda_.m_global_stack_[i].m_token.m_id] << ' ';
    out << ". ";
    for (std::size_t i = 0; i < m_npda_.m_global_lookahead_queue_.size(); ++i)
        out << ms_token_name_table_[m_npda_.m_global_lookahead_queue_[i].m_id] << ' ';
    out << '\n';

    m_npda_.m_root_->Print(out, *this);
    out << '\n';

    out << "branch queue:\n";
    for (BranchQueue_::const_iterator it = m_npda_.m_branch_queue_.begin(), it_end = m_npda_.m_branch_queue_.end(); it != it_end; ++it)
    {
        ParseStackTreeNode_ *branch = *it;
        assert(branch != NULL);
        branch->Print(std::cerr, *this, 1);
    }
}

char const *<{class_name}::ParseStackTreeNode_::AsString (Type type)
{
    static char const *const LOOKUP_TABLE[COUNT_] =
    {
        "ROOT",
        "RETURN",
        "REDUCE",
        "SHIFT",
        "INSERT_LOOKAHEAD_ERROR",
        "DISCARD_LOOKAHEAD",
        "POP_STACK",
        "BRANCH"
    };
    assert(std::uint32_t(type) < COUNT_);
    return LOOKUP_TABLE[std::uint32_t(type)];
}

<|end_if

bool <{class_name}::ParseStackTreeNode_::ParseStackTreeNodeOrder::operator () (<{class_name}::ParseStackTreeNode_ const *lhs, <{class_name}::ParseStackTreeNode_ const *rhs) const
{
    assert(lhs != NULL);
    assert(rhs != NULL);
    assert(lhs->m_spec.m_type == rhs->m_spec.m_type); // ParseStackTreeNodeSet should contain only nodes of the same type.
    // for BRANCH, their contents must be compared.
    if (lhs->m_spec.m_type == BRANCH)
    {
        assert(lhs->m_child_nodes.empty());
        assert(rhs->m_child_nodes.empty());
        // Branches are equal if their m_global_lookahead_cursor and m_local_lookahead_queue members are.
        if (lhs->m_global_lookahead_cursor != rhs->m_global_lookahead_cursor)
            return lhs->m_global_lookahead_cursor < rhs->m_global_lookahead_cursor;
        else if (lhs->m_stack != rhs->m_stack)
            return std::lexicographical_compare(
                lhs->m_stack.begin(), lhs->m_stack.end(),
                rhs->m_stack.begin(), rhs->m_stack.end(),
                CompareStackElement
            );
        else
            return std::lexicographical_compare(
                lhs->m_local_lookahead_queue.begin(), lhs->m_local_lookahead_queue.end(),
                rhs->m_local_lookahead_queue.begin(), rhs->m_local_lookahead_queue.end(),
                CompareToken
            );
    }
    // For REDUCE, their contents must be compared.
    else if (lhs->m_spec.m_type == REDUCE)
    {
        // m_single_data contains the reduction rule index.
        Rule_ const &lhs_rule = ms_rule_table_[lhs->m_spec.m_single_data];
        Rule_ const &rhs_rule = ms_rule_table_[rhs->m_spec.m_single_data];
        // Sort first by rule precedence, then by rule index (lower has higher priority).
        if (ms_precedence_table_[lhs_rule.m_precedence_index].m_level != ms_precedence_table_[rhs_rule.m_precedence_index].m_level)
            return ms_precedence_table_[lhs_rule.m_precedence_index].m_level > ms_precedence_table_[rhs_rule.m_precedence_index].m_level;
        else // Sort based on rule index.
            return lhs->m_spec.m_single_data < rhs->m_spec.m_single_data;
    }
    // Otherwise just use pointer value.
    else
        return lhs < rhs;
}

<{class_name}::ParseStackTreeNode_::~ParseStackTreeNode_ ()
{
    // TODO: figure out if stack element tokens should be thrown away
    // TODO: figure out if local lookahead queue tokens should be thrown away
    // TODO: are they actually uninitialized (default value)?
    for (ChildMap::iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet &child_node_set = it->second;
        for (ParseStackTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseStackTreeNode_ *child = *child_it;
            assert(child != NULL);
            assert(child->m_parent_node == this);
            delete child;
        }
        child_node_set.clear(); // not strictly necessary, but is cleaner.
    }
}

bool <{class_name}::ParseStackTreeNode_::HasTrunkChild () const
{
    if (m_spec.m_type != ROOT || m_child_nodes.size() != 1)
        return false;
    ParseStackTreeNodeSet const &single_type_child_node_set = m_child_nodes.begin()->second;
    if (single_type_child_node_set.size() != 1)
        return false;
    ParseStackTreeNode_ *single_child = *single_type_child_node_set.begin();
    assert(single_child != NULL);
    assert(single_child->m_spec.m_type != ROOT);
    return single_child->m_spec.m_type != BRANCH;
}

<{class_name}::ParseStackTreeNode_ *<{class_name}::ParseStackTreeNode_::PopTrunkChild ()
{
    assert(HasTrunkChild());
    ParseStackTreeNode_ *trunk_child = *m_child_nodes.begin()->second.begin();
    assert(trunk_child != NULL);
    assert(trunk_child->m_parent_node == this);
    // Reassign the children of the trunk child to this node (root).
    m_child_nodes = trunk_child->m_child_nodes;
    trunk_child->m_child_nodes.clear();
    // Set the reassigned child nodes' parent to be this node (root).
    for (ChildMap::iterator child_map_it = m_child_nodes.begin(), child_map_it_end = m_child_nodes.end(); child_map_it != child_map_it_end; ++child_map_it)
    {
        ParseStackTreeNodeSet &child_node_set = child_map_it->second;
        for (ParseStackTreeNodeSet::iterator child_it = child_node_set.begin(), child_it_end = child_node_set.end(); child_it != child_it_end; ++child_it)
        {
            ParseStackTreeNode_ *child = *child_it;
            // std::cerr << "reassigning node " << child << "'s parent (formerly " << child->m_parent_node << ") to " << this << '\n';
            assert(child != NULL);
            child->m_parent_node = this;
        }
    }
    trunk_child->m_parent_node = NULL;
    return trunk_child;
}

<{class_name}::Token const &<{class_name}::ParseStackTreeNode_::Lookahead (<{class_name} &parser) const
{
    if (m_local_lookahead_queue.empty())
        return parser.Lookahead_(m_global_lookahead_cursor);
    else
        return m_local_lookahead_queue.front();
}

bool <{class_name}::ParseStackTreeNode_::IsBlockedBranch () const
{
    assert(m_spec.m_type == BRANCH);
    if (m_parent_node == NULL)
        return false;
    switch (m_parent_node->m_spec.m_type)
    {
        case RETURN:
        case REDUCE:
        case POP_STACK: return true;

        default:        return false;
    }
}

void <{class_name}::ParseStackTreeNode_::AddChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == NULL);
    assert(child->m_spec.m_type != ROOT);
    m_child_nodes[child->m_spec].insert(child);
    child->m_parent_node = this;
}

void <{class_name}::ParseStackTreeNode_::RemoveChild (ParseStackTreeNode_ *child)
{
    assert(child != NULL);
    assert(child->m_parent_node == this);
    assert(HasChildrenHavingSpec(child->m_spec));
    m_child_nodes[child->m_spec].erase(child);
    if (m_child_nodes[child->m_spec].empty())
        m_child_nodes.erase(child->m_spec);
    child->m_parent_node = NULL;
}

void <{class_name}::ParseStackTreeNode_::RemoveFromParent ()
{
    assert(m_parent_node != NULL);
    m_parent_node->RemoveChild(this);
}

<{class_name}::ParseStackTreeNode_ *<{class_name}::ParseStackTreeNode_::CloneLeafNode () const
{
    ParseStackTreeNode_ *retval = new ParseStackTreeNode_(m_spec);
    CloneLeafNodeInto(*retval);
    return retval;
}

void <{class_name}::ParseStackTreeNode_::CloneLeafNodeInto (<{class_name}::ParseStackTreeNode_ &orphan_target) const
{
    assert(orphan_target.m_parent_node == NULL);
    assert(m_child_nodes.empty());
    orphan_target.m_spec = m_spec;
    orphan_target.m_stack = m_stack;
    orphan_target.m_local_lookahead_queue = m_local_lookahead_queue;
    orphan_target.m_global_lookahead_cursor = m_global_lookahead_cursor;
}

void <{class_name}::ParseStackTreeNode_::Print (std::ostream &out, <{class_name} const &parser, std::uint32_t indent_level) const
{
    for (std::uint32_t i = 0; i < indent_level; ++i)
        out << "    ";
    out << AsString(m_spec.m_type);
    switch (m_spec.m_type)
    {
        case REDUCE:    out << " rule " << m_spec.m_single_data << "; " << ms_rule_table_[m_spec.m_single_data].m_description;  break;
        case POP_STACK: out << ' ' << m_spec.m_single_data << " times";                                                         break;
        default:                                                                                                                break;
    }
    out << " " << this << ", parent = " << m_parent_node << " ";
    if (m_spec.m_type == BRANCH)
    {
        out << "; state stack is (";
        for (std::size_t i = 0; i < m_stack.size(); ++i)
        {
            out << m_stack[i].m_state_index;
            if (i+1 < m_stack.size())
                out << ' ';
        }
        out << "), stack tokens then lookahead queue is ";
        for (std::size_t i = 1; i < m_stack.size(); ++i)
            out << ms_token_name_table_[m_stack[i].m_token.m_id] << ' ';
        out << ". ";
        for (std::size_t i = 0; i < m_local_lookahead_queue.size(); ++i)
            out << ms_token_name_table_[m_local_lookahead_queue[i].m_id] << ' ';
        for (std::size_t i = m_global_lookahead_cursor; i < parser.m_npda_.m_global_lookahead_queue_.size(); ++i)
            out << ms_token_name_table_[parser.m_npda_.m_global_lookahead_queue_[i].m_id] << ' ';
    }
    out << '\n';

    // Print children recursively with higher indent level
    for (ChildMap::const_iterator it = m_child_nodes.begin(), it_end = m_child_nodes.end(); it != it_end; ++it)
    {
        ParseStackTreeNodeSet const &child_node_set = it->second;
        for (ParseStackTreeNodeSet::const_iterator set_it = child_node_set.begin(), set_it_end = child_node_set.end(); set_it != set_it_end; ++set_it)
            (*set_it)->Print(out, parser, indent_level+1);
    }
}

<{class_name}::Token const &<{class_name}::Lookahead_ (LookaheadQueue_::size_type index)<{if(!is_defined(enable_scan_actions_exceptions))} throw()<{end_if}
{
    while (index >= m_npda_.m_global_lookahead_queue_.size())
    {
        // This does not require updating the branches' m_global_lookahead_cursor.
        m_npda_.m_global_lookahead_queue_.push_back(Scan_());
<|if(is_defined(generate_debug_spew_code))

        TRISON_CPP_DEBUG_CODE_(std::cerr << <{debug_spew_prefix} << " pushed " << m_npda_.m_global_lookahead_queue_.back() << " onto back of lookahead queue" << std::endl)
<|end_if
    }
    return m_npda_.m_global_lookahead_queue_[index];
}

<{class_name}::ParseStackTreeNode_ *<{class_name}::TakeHypotheticalActionOnBranch_ (ParseStackTreeNode_ const &branch, ParseStackTreeNode_::Type action_type, std::uint32_t action_data)
{
    // TODO: replace individual arguments action_type, action_data with ParseStackTreeNode_::Spec and just modify that struct below where it needs it.
    assert(branch.m_spec.m_type == ParseStackTreeNode_::BRANCH && "Only a BRANCH type node can take an action");
    assert(branch.m_parent_node != NULL);

    // Early check for if the stack would be popped empty, in which case, don't create the new branch.
    if (action_type == ParseStackTreeNode_::POP_STACK && branch.m_stack.size() <= 1)
        return NULL;

    ParseStackTreeNode_ *new_branch = NULL;

    switch (action_type)
    {
        case ParseStackTreeNode_::ROOT: {
            assert(false && "ParseStackTreeNode_::ROOT is an invalid action type.");
            break;
        }
        case ParseStackTreeNode_::RETURN: {
            new_branch = branch.CloneLeafNode();
            break;
        }
        case ParseStackTreeNode_::REDUCE: {
            // Execute the appropriate rule on the top tokens in the stack
            std::uint32_t const &rule_index = action_data;
            Rule_ const &rule = ms_rule_table_[rule_index];

            // Avoid creating the new branch altogether if it won't be added due to a REDUCE/REDUCE conflict.
            ParseStackTreeNode_ *existing_reduce_action_node = NULL;
            ParseStackTreeNode_ *reduce_branch = NULL;
            ParseStackTreeNode_::Spec action_spec(action_type, action_data);
            if (branch.m_parent_node->HasChildrenHavingSpec(action_spec)) // Check for an existing REDUCE action
            {
                // This is a REDUCE/REDUCE conflict
                std::cerr << "TakeHypotheticalActionOnBranch_ - REDUCE/REDUCE conflict encountered ... ";

                ParseStackTreeNode_::ParseStackTreeNodeSet &reduce_node_set = branch.m_parent_node->ChildrenHavingSpec(action_spec);
                assert(reduce_node_set.size() == 1);
                existing_reduce_action_node = *reduce_node_set.begin();
                assert(existing_reduce_action_node != NULL);
                // If the new REDUCE action beats the existing one in a conflict, just replace the existing one
                // (replacement instead of creating a new one and deleting the old is an optimization which also
                // avoids an annoying traversal through m_npda_.m_branch_queue_).
                // NOTE: This depends on the fact that a [hypothetical] REDUCE node has exactly one BRANCH child,
                // which is what these three asserts check.  TODO: maybe make abstractions for these sorts of checks.
                assert(existing_reduce_action_node->m_child_nodes.size() == 1);
                assert(existing_reduce_action_node->m_child_nodes.begin()->second.size() == 1);
                assert((*existing_reduce_action_node->m_child_nodes.begin()->second.begin())->m_spec.m_type == ParseStackTreeNode_::BRANCH);
                if (CompareRuleByPrecedence(action_data, existing_reduce_action_node->m_spec.m_single_data))
                {
                    std::cerr << "resolving in favor of new branch.\n";

                    reduce_branch = *existing_reduce_action_node->m_child_nodes.begin()->second.begin();
                    assert(reduce_branch != NULL);

                    // Remove the nodes from the ParseStackTreeNode_ tree.
                    assert(existing_reduce_action_node != NULL);
                    existing_reduce_action_node->RemoveFromParent();
                    reduce_branch->RemoveFromParent();
                    // Modify the nodes.
                    existing_reduce_action_node->m_spec = action_spec; // Replace with the winning reduction rule Spec.
                    branch.CloneLeafNodeInto(*reduce_branch); // NOTE: This modifies the existing branch, so no update of m_npda_.m_branch_queue_ is necessary.
                    // Re-add them to the ParseStackTreeNode_ tree.
                    existing_reduce_action_node->AddChild(reduce_branch);
                    branch.m_parent_node->AddChild(existing_reduce_action_node);
                }
                else
                {
                    std::cerr << "resolving in favor of existing branch.\n";
                }
            }
            else
            {
                new_branch = branch.CloneLeafNode();
                reduce_branch = new_branch;
            }

            if (reduce_branch != NULL)
            {
                // Pop those stack tokens
                // std::cerr << "TakeHypotheticalActionOnBranch_ -- reducing rule " << rule_index << " \"" << rule.m_description << "\" which has " << rule.m_token_count << " tokens\n";
                for (std::uint32_t i = 0; i < rule.m_token_count; ++i)
                    reduce_branch->m_stack.pop_back();
                // Push the reduced nonterminal token data onto the front of the lookahead queue
                reduce_branch->m_local_lookahead_queue.push_front(Token(rule.m_reduction_nonterminal_token_id));
            }

            break;
        }
        case ParseStackTreeNode_::SHIFT: {
            // Move the front of the lookahead queue to the top of the stack, assigning the appropriate state index.
            std::uint32_t const &state_index = action_data;
            // TODO: probably make "Shift" method for ParseStackTreeNode_ to do all this bookkeeping and parallel Lookahead.
            new_branch = branch.CloneLeafNode();
            new_branch->m_stack.push_back(StackElement_(state_index, new_branch->Lookahead(*this)));
            action_data = ParseStackTreeNode_::UNUSED_DATA; // SHIFT action doesn't store the state, the BRANCH children do.
            if (new_branch->m_local_lookahead_queue.empty())
                ++new_branch->m_global_lookahead_cursor;
            else
                new_branch->m_local_lookahead_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::INSERT_LOOKAHEAD_ERROR: {
            new_branch = branch.CloneLeafNode();
            new_branch->m_local_lookahead_queue.push_front(Token(Terminal::ERROR_));
            break;
        }
        case ParseStackTreeNode_::DISCARD_LOOKAHEAD: {
            new_branch = branch.CloneLeafNode();
            if (new_branch->m_local_lookahead_queue.empty())
                ++new_branch->m_global_lookahead_cursor;
            else
                new_branch->m_local_lookahead_queue.pop_front();
            break;
        }
        case ParseStackTreeNode_::POP_STACK: {
            // TODO: make separate action nodes for each pop, instead of using action data.
            std::uint32_t const &pop_count = action_data;
            new_branch = branch.CloneLeafNode();
            assert(new_branch->m_stack.size() > pop_count);
            for (std::uint32_t i = 0; i < pop_count; ++i)
                new_branch->m_stack.pop_back();
            break;
        }
        case ParseStackTreeNode_::BRANCH: {
            assert(false && "ParseStackTreeNode_::BRANCH is an invalid action type.");
            break;
        }
        default: {
            assert(false && "invalid ParseStackTreeNode_::Type");
            break;
        }
    }

    if (new_branch != NULL)
    {
        assert(new_branch->m_parent_node == NULL);

        ParseStackTreeNode_ *action_node = NULL;

        // Ensure the action node exists, creating it if necessary.
        ParseStackTreeNode_::Spec action_spec(action_type, action_data);
        // std::cerr << "branch.m_parent_node = " << branch.m_parent_node << '\n';
        if (branch.m_parent_node->HasChildrenHavingSpec(action_spec))
        {
            ParseStackTreeNode_::ParseStackTreeNodeSet &children_of_action_type = branch.m_parent_node->ChildrenHavingSpec(action_spec);
            assert(children_of_action_type.size() == 1);
            action_node = *children_of_action_type.begin();

            // If the new branch already exists (can only happen as a child of POP_STACK), then don't add it.
            if (action_type == ParseStackTreeNode_::POP_STACK && action_node->HasChildrenHavingSpec(new_branch->m_spec))
            {
                ParseStackTreeNode_::ParseStackTreeNodeSet const &child_branch_set = action_node->ChildrenHavingSpec(new_branch->m_spec);
                if (child_branch_set.find(new_branch) != child_branch_set.end())
                {
                    delete new_branch;
                    new_branch = NULL;
                }
            }
        }
        else
        {
            action_node = new ParseStackTreeNode_(action_spec);
            branch.m_parent_node->AddChild(action_node);
        }

        if (new_branch != NULL)
        {
            // std::cerr << "    adding new branch: ";
            // new_branch->Print(std::cerr, *this, 2);
            // std::cerr << "    to action node: ";
            // action_node->Print(std::cerr, *this, 2);
            action_node->AddChild(new_branch);
        }
    }

    return new_branch;
}

<{class_name}::Npda_::~Npda_ ()
{
    // TODO: figure out if global stack and lookahead queue should have their tokens thrown away
    delete m_root_;
    m_root_ = NULL;
    m_branch_queue_.clear();
    m_new_branch_queue_.clear();
}

void <{class_name}::Npda_::PopFrontGlobalLookahead ()
{
    assert(!m_global_lookahead_queue_.empty());
    // Because the contents of m_npda_.m_global_lookahead_queue_ are changing, and each branch's
    // m_global_lookahead_cursor is an index into that queue, each must be updated.
    for (BranchQueue_::iterator branch_it = m_branch_queue_.begin(), branch_it_end = m_branch_queue_.end(); branch_it != branch_it_end; ++branch_it)
    {
        ParseStackTreeNode_ &branch = **branch_it;
        --branch.m_global_lookahead_cursor;
    }
    m_global_lookahead_queue_.pop_front();
}

void <{class_name}::Npda_::PushFrontGlobalLookahead (<{class_name}::Token const &lookahead)
{
    // Because the contents of m_npda_.m_global_lookahead_queue_ are changing, and each branch's
    // m_global_lookahead_cursor is an index into that queue, each must be updated.
    for (BranchQueue_::iterator branch_it = m_branch_queue_.begin(), branch_it_end = m_branch_queue_.end(); branch_it != branch_it_end; ++branch_it)
    {
        ParseStackTreeNode_ &branch = **branch_it;
        ++branch.m_global_lookahead_cursor;
    }
    m_global_lookahead_queue_.push_front(lookahead);
}

bool <{class_name}::CompareRuleByPrecedence (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index)
{
    if (ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level != ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level)
        return ms_precedence_table_[ms_rule_table_[lhs_rule_index].m_precedence_index].m_level > ms_precedence_table_[ms_rule_table_[rhs_rule_index].m_precedence_index].m_level;
    else
        return lhs_rule_index < rhs_rule_index;
}

<{class_name}::StateVector_ const &<{class_name}::EpsilonClosureOfState_ (std::uint32_t state_index)
{
    // This function implementation depends on there not being an epsilon transition cycle.

    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<std::uint32_t,StateVector_> LookupTable;
    static LookupTable s_lookup_table;
    LookupTable::iterator it = s_lookup_table.find(state_index);
    if (it != s_lookup_table.end())
        return it->second;

    // This set collects the epsilon closure with no duplicates    
    StateSet_ epsilon_closure_set;
    State_ const &state = ms_state_table_[state_index];
    bool state_has_non_epsilon_transitions = false;
    for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count;
         transition != transition_end;
         ++transition)
    {
        if (transition->m_type == Transition_::EPSILON)
        {
            StateVector_ const &sub_epsilon_closure = EpsilonClosureOfState_(transition->m_data_index);
            for (StateVector_::const_iterator it = sub_epsilon_closure.begin(), it_end = sub_epsilon_closure.end(); it != it_end; ++it)
                epsilon_closure_set.insert(*it);
        }
        else
            state_has_non_epsilon_transitions = true;
    }
    // The epsilon closure of a state includes itself if it has non-epsilon transitions
    if (state_has_non_epsilon_transitions)
        epsilon_closure_set.insert(state_index);

    // Add all the elements of epsilon_closure_set to the memoized entry.
    StateVector_ &epsilon_closure = s_lookup_table[state_index];
    epsilon_closure.reserve(epsilon_closure_set.size());
    for (StateSet_::const_iterator it = epsilon_closure_set.begin(), it_end = epsilon_closure_set.end(); it != it_end; ++it)
        epsilon_closure.push_back(*it);
    return epsilon_closure;
}

<{class_name}::TransitionVector_ const &<{class_name}::NonEpsilonTransitionsOfState_ (std::uint32_t state_index)
{
    // Memoize this function, because it will be called so many times and is somewhat intensive.
    typedef std::map<std::uint32_t,TransitionVector_> LookupTable;
    static LookupTable s_lookup_table;
    LookupTable::iterator it = s_lookup_table.find(state_index);
    if (it != s_lookup_table.end())
        return it->second;

    // TODO: probably don't need to memoize epsilon closures because non-epsilon transitions is memoized.
    TransitionSet_ non_epsilon_transition_set;
    StateVector_ const &epsilon_closure = EpsilonClosureOfState_(state_index);
    for (StateVector_::const_iterator it = epsilon_closure.begin(), it_end = epsilon_closure.end(); it != it_end; ++it)
    {
        State_ const &state = ms_state_table_[*it];
        for (Transition_ const *transition = state.m_transition_table, *transition_end = state.m_transition_table+state.m_transition_count; transition != transition_end; ++transition)
            if (transition->m_type != Transition_::EPSILON)
                non_epsilon_transition_set.insert(*transition);
    }

    TransitionVector_ &non_epsilon_transitions = s_lookup_table[state_index];
    non_epsilon_transitions.reserve(non_epsilon_transition_set.size());
    for (TransitionSet_::const_iterator it = non_epsilon_transition_set.begin(), it_end = non_epsilon_transition_set.end(); it != it_end; ++it)
        non_epsilon_transitions.push_back(*it);
    return non_epsilon_transitions;
}

<{class_name}::Precedence_ const <{class_name}::ms_precedence_table_[] =
{
<|loop(i, _precedence_count)
    { <{_precedence_level[i]}, <{_precedence_associativity_index[i]}<{if(is_defined(generate_debug_spew_code))}, "<{_precedence_name[i]}"<{end_if} }<{if(i < _precedence_count-1)},<{end_if}
<|end_loop
};

std::size_t const <{class_name}::ms_precedence_count_ = sizeof(<{class_name}::ms_precedence_table_) / sizeof(*<{class_name}::ms_precedence_table_);

<{class_name}::Rule_ const <{class_name}::ms_rule_table_[] =
{
<|loop(i, _rule_count)
    { <{class_name}::Nonterminal::<{_rule_reduction_nonterminal_name[i]}, <{_rule_token_count[i]}, <{_rule_precedence_index[i]}<{if(is_defined(generate_debug_spew_code))}, <{_rule_description[i]}<{end_if} }<{if(i < _rule_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_rule_count_ = sizeof(<{class_name}::ms_rule_table_) / sizeof(*<{class_name}::ms_rule_table_);

<{class_name}::State_ const <{class_name}::ms_state_table_[] =
{
<|loop(i, _npda_state_count)
    { <{_npda_state_transition_count[i]}, ms_transition_table_+<{_npda_state_transition_offset[i]}, <{_npda_state_rule_index[i]}<{if(is_defined(generate_debug_spew_code))}, <{_npda_state_description[i]}<{end_if} }<{if(i < _npda_state_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_state_count_ = sizeof(<{class_name}::ms_state_table_) / sizeof(*<{class_name}::ms_state_table_);

<{class_name}::Transition_ const <{class_name}::ms_transition_table_[] =
{
<|loop(i, _npda_transition_count)
    { <{class_name}::Transition_::<{_npda_transition_type_name[i]}, <{_npda_transition_token_index[i]}, <{_npda_transition_data_index[i]} }<{if(i < _npda_transition_count-1)},<{end_if}
<|end_loop
};
std::size_t const <{class_name}::ms_transition_count_ = sizeof(<{class_name}::ms_transition_table_) / sizeof(*<{class_name}::ms_transition_table_);
