// ///////////////////////////////////////////////////////////////////////////
// BARF bugs
// ///////////////////////////////////////////////////////////////////////////

-   disallow empty reflex states
-   reflex: an unterminated regex causes a hang;
    %state_machine BLAH
    :
        (
    ;
-   bug (in trison) -- lack of a parse error handler for:

        %terminal XXX %type "Blah"

    which should be

        %terminal XXX %type.cpp "Blah"

-   looks like trison doesn't catch EOF before ; in a nonterminal declaration

// ///////////////////////////////////////////////////////////////////////////
// BARF general
// ///////////////////////////////////////////////////////////////////////////

-   write man pages for reflex, trison, bpp (hopefully somehow get doxygen to
    do this)
-   figure out how to generate/install docs
-   guarantee that errors will be reported such that the line numbers never
    decrease.
-   bug: getting "file not found" error when a file exists but the permissions
    are such that the user can't read it.
*   add lots of error rules to all parser grammars
-   descriptions should use terms "finite-automaton-based scanners" and
    "pushdown-automaton-based parsers"
-   error when any output file is the same as an input file, or when any two
    output files are the same.
-   change comments to %/ and %* *% in primary sources?
-   move trison/reflex stuff into lib/trison and lib/reflex? and only keep
    main, options and main header file in app dir (so test apps can link the
    libs and run tests)?  put stuff in Barf::Xxx namespace
$   do comprehensive deleting of stuff (this might be hard with all the throwing)
    THEN
    do memory leak checking (valgrind)
-   get rid of AST hierarchy overviews once doxygen docs are to some decent state
-   use Ast::Directive::DirectiveString in error messages instead of
    creating the error messages by hand -- make all directives derive from
    Ast::Directive
-   file locations should be "2d range" -- a starting line/column and an ending
    line/column (or starting line/column and a number of bytes following).
    nonterminal expressions can then be the union of the file locations of their
    component parts.  this technique will be useful later in compiler design for
    debugging info.
-   add filename-sanitizing function -- i.e. to check for newlines and other stuff
-   save off FiLoc where each error panic starts, so that if it's a general parse
    error, at least some info can be printed.

// ///////////////////////////////////////////////////////////////////////////
// documentation
// ///////////////////////////////////////////////////////////////////////////

-   table of contents inside each doxygen_pages page
-   pyramidal documentation
-   simplify documentation (maybe leave out basic regex stuff, keep to essentials)

// ///////////////////////////////////////////////////////////////////////////
// commonlang
// ///////////////////////////////////////////////////////////////////////////

-   target directives (including rule handlers) should accept multiple targets ? like

        %target.cpp_nostl,cpp_withstl,cpp_noexceptions %{ blah %}

// ///////////////////////////////////////////////////////////////////////////
// core
// ///////////////////////////////////////////////////////////////////////////

-   make a Graph::Node::Index type (a struct or an enum with a value
    UINT32_UPPER_BOUND (to force it to be unsigned)) and Graph::Node::IndexArray
    vector type in barf_graph.h (replacing the ad-hoc vector<Uint32> used all
    over the place)
-   check standard on octal escape chars (up to 3 octal digits only?)
-   make EscapeChar (which does full char escaping) and use it in EscapeString?
    this would make the char scanning much easier
-   make repeated identical (or perhaps just very similar) warnings/errors
    suppressed (e.g. in preprocessor, having an error in a loop will cause that
    error to be emitted that many times)

// ///////////////////////////////////////////////////////////////////////////
// targetspec
// ///////////////////////////////////////////////////////////////////////////

-   allow using the value of previously declared directives as default values
    (this would be had for free if targetspec-declared, primary-source-defined
    codespec symbols are allowed to use codespec symbols -- see codespec section)
-   add targetspec versions (target-specific) -- so you can compile/link
    multiple coexisting versions of the same target but at different versions.
    do this by sticking a version number in the namespace of the generated
    baseclasses

// ///////////////////////////////////////////////////////////////////////////
// codespec
// ///////////////////////////////////////////////////////////////////////////

-   add comment/description element to each codespec symbol, so that you can
    print out a list of all available codespec symbols and their descriptions
    from the commandline for easier development (i.e. to the state machine ones
    so that you don't have to look through xxx_codespecsymbols.cpp for these)
-   make better error message (i.e. anything informative at all) when there's
    an error in an included codespec file.

// ///////////////////////////////////////////////////////////////////////////
// preprocessor
// ///////////////////////////////////////////////////////////////////////////

-   add parser error handler for when argument to is_defined is not an identifier
-   just make the preprocessor language better in general -- it's sort of crappy
-   add a printf function
-   add some way to use a different file location for errors/warnings
-   add comments (C++ and C style)
-   make _blah ids not be able to be defined in-file, they're reserved
-   add assignment operator; e.g. <{x=x+3}
-   add eval directive so you can parse and execute a block of text as a
    preprocessor body.
-   add 64 bit ints (better) and add whatever the negative-most 64-bit int is
    to the scanner (because the way negative ints are constructed in the parser
    screws this up)
-   maybe make the Textifier detect if a newline was just printed, so that
    it doesn't print unnecessary newlines when generating line directives
-   add boolean property for wether or not a particular symbol was referenced
    during preprocessing, so that warnings can be emitted if a symbol isn't used

// ///////////////////////////////////////////////////////////////////////////
// regex
// ///////////////////////////////////////////////////////////////////////////

*   document all of this regex stuff in detail, since it's pretty complicated,
    and not completely standard
*   in graph printing, TT_INPUT_ATOM_RANGEs which include [ or ] as the ending
    char need to escape them
*   generally fix up the escaping of characters in display strings and graphs
    to escape in the context of the regex.
-   make a parse-string method which returns a Regex::RegularExpression and
    possibly throws to indicate errors.
-   move NodeData into separate file
-   improve the DFA generation so that when throwing an exception when there is
    a conditional conflict, it includes the file location that caused it.
-   add a pass to NFA generation where it optimizes unnecessary epsilon
    transitions out.
-   bracket expression transitions should use single-atom transitions when possible

// ///////////////////////////////////////////////////////////////////////////
// bpp
// ///////////////////////////////////////////////////////////////////////////

-   add predefine (-D) option

// ///////////////////////////////////////////////////////////////////////////
// grope/grop/grap (grep-like tool)
// ///////////////////////////////////////////////////////////////////////////

-   write it (or not. probably not.  but it might be nice to have a
    grep-like tool which can match across newlines, and also to directly
    test the regex system)

// ///////////////////////////////////////////////////////////////////////////
// reflex
// ///////////////////////////////////////////////////////////////////////////

-   instead of always extracting the accepted string and passing it in,
    make it available through an accessor, so it can be constructed lazily.
    OR
    somehow just return pointers into the buffer for the accepted string, so
    that there is as little overhead as possible when running the scanner.
    Could do this with std::span (newer C++ standard)
-   maybe consistencize the codespec symbol names

// ///////////////////////////////////////////////////////////////////////////
// reflex/trison common
// ///////////////////////////////////////////////////////////////////////////

-   use smallest integer type to store state and transition indices, etc.
    (in C++, this can be done easily with templates)
-   move the --with-line-directives option to be an optional targetspec directive
$   add targetspec directive for line directives referencing codespecs (the
    default should be to not refer to codespecs), making development easier
$   add option which prints the reflex/trison targets available in the current
    search path and which directory each resides in.
*   the rule handler code block type should be specifiable by the targetspec
*   specifying any %target.xxx directive seems to add the target; stop this
*   allow "%targets xxxx" in pre/postdefine
$   also add post-undefine option
*   warn about targetspec directive values that weren't referenced in the
    code generation (preprocessor) stage -- ones that don't appear at all in
    any codespec, not necessarily to indicate they weren't used in one particular
    case.
-   Ensure that commandline-specified values for parser directives override in-source values,
    so that parser generation can be controlled from the build system if needed, e.g. for unit testing.
-   Run preprocessor on code blocks in reflex and trison, so that e.g. stuff like this can work
    in a reflex/trison code block.

        Parser::ParserReturnCode parse (std::string const &s, double &parsed_value)
        {
            std::istringstream in(s);
            Parser parser;
            parser.attach_istream(in);
        <|if(is_defined(generate_debug_spew_code))
            parser.DebugSpew(true);
        <|end_if
            Parser::ParserReturnCode return_code = parser.Parse(&parsed_value);
            return return_code;
        }

// ///////////////////////////////////////////////////////////////////////////
// trison
// ///////////////////////////////////////////////////////////////////////////

-   pass reference instead of double pointer to Parse
!   refactor the DPDA generation to be simpler and faster (difficult)
-   figure out why minimal graphing isn't working (the right lookaheads
    aren't being generated).
-   if possible, make the dpda.states file put the states' rules in order.
$   add a max token stack depth in each parser implementation
-   you shouldn't have to specify %terminal 'X' for ascii chars.  you should
    just be able to use them (or maybe add as a directive)
-   check for reduction rule variable name collisions
-   decouple npda states from trison ASTs -- they should only exist in the
    graph itself.
-   add an unbounded grammar app/dev test case, and deal with unbounded grammars
    (since DPDAs can't be generated for them)
-   compactify lookaheads in dpda
-   make sure lookahead sequences are alphabetized, allowing for a binary search
    instead of a linear search (in the dpda target)

template <Sint32 low, Sint32 high> struct SmallestSint {
    typedef
        typename If<(low >= -128   && high <= 127),   Sint8,
        typename If<(low >= -32768 && high <= 32767), Sint16,
        Sint32
        >::T >::T Type;
};

template <Uint32 high> struct SmallestUint {
    typedef
        typename If<(high <= 255),   Uint8,
        typename If<(high <= 65535), Uint16,
        Uint32
        >::T >::T Type;
};

-   unit tests for NPDA
-   add some nice metrics to the NPDA parser -- make this part of the parser API
    x   max lookahead count
    -   max memory used
    -   some measurement of the "leanness" of the grammar, like how much branching
        was encountered, etc
-   in the NPDA dot graph, maybe move the self-transitions to just text lines in the
    state box itself, to avoid the mess that dot creates with self transitions.
-   maybe add some online DPDA generation in NPDA during runtime, optionally saving
    the tables to a file.  The file should be able to be specified as "read-only".
    This would allow a balance between DPDA-generation for commonly used grammar pathways
    and the flexibility of NPDA parsers.
-   port NPDA code to offline DPDA generation (after NPDA has been fully unit tested)
-   NPDA parser test design notes
    -   need to test a bunch of different grammars
        -   grammars with bounded lookahead (1, 2, 3, and 0 if that's possible)
        -   grammars with unbounded lookahead
        -   try to come up with a worst case grammar
        -   look on wikipedia and other websites for grammars
        -   use actual grammars like from barf, steel, etc.
    -   for each grammar, make sure each rule is exercised
    -   for each grammar, make sure each combination of rules (i.e. binary operators) is exercised
    Unit test should be compiled into a single binary.  Each Parser should have a distinct
    name, and the various inputs to the parsers should be stored in files.  The outputs should
    be ASTs, and compared against "expected" ASTs which can be defined in code.
-   Add an error handling rule for trison:

        %nonterminal maybe_assigned_id %type "Ast::Id *"

    caused the generic error `syntax error in %nonterminal directive` because of missing `.cpp`
-   Ensure that commandline-specified values for parser directives override in-source values,
    so that parser generation can be controlled from the build system if needed, e.g. for unit testing.
-   Run preprocessor on code blocks in reflex and trison, so that e.g. stuff like this can work
    in a reflex/trison code block.

        Parser::ParserReturnCode parse (std::string const &s, double &parsed_value)
        {
            std::istringstream in(s);
            Parser parser;
            parser.attach_istream(in);
        <|if(is_defined(generate_debug_spew_code))
            parser.DebugSpew(true);
        <|end_if
            Parser::ParserReturnCode return_code = parser.Parse(&parsed_value);
            return return_code;
        }

-   Change doxygen comments to all /// style
-   Ensure all the different types of cleanup are performed, verify with valgrind.
-   Probably compute epsilon closure of states during trison execution, so that the NPDA implementation
    doesn't have to implement it.  This could also be used for the NPDA states file, so that it requires
    the reader to do less work.
-   Perhaps in NPDA states file, show epsilon closure and transitions from all states in that epsilon
    closure, so that the human reader doesn't have to do as much mental work.
-   Collapse some options together using arguments (e.g. the pairs of "do" and "don't" options).
-   Add [ ] brackets to "symbol" class in kate syntax highlighting file.
-   Add symbols and strings/chars to the body section of codespec kate syntax highlighting file, so that
    at least some syntax highlighting is done in the body.
-   Could add "indent" and "unindent" directives to BPP in order to better format code as well as
    allow implementation of Python targets (since they're indentation-sensitive).  Would need this
    to work inside "if" blocks.
-   Make the npda states file grammar section print out the precedence levels and print the precedence
    for each rule (including default)
-   There appears to be a crash bug in trison where an undeclared terminal is used in the bracketed
    %error[...] syntax.
-   Should re-add the specification of which stage of each rule it is in the npda state file,
    probably as a tuple, like if there is

        rule 123 : blah <- A B C

    then there would be

        rule 123,0 : blah <- . A B C
        rule 123,1 : blah <- A . B C
        rule 123,2 : blah <- A B . C
        rule 123,3 : blah <- A B C .

-   Probably restructure the `targets` directory to be hierarchical, like

        targets
            reflex
                cpp
                    <associated files>
            trison
                cpp
                    <general use trison cpp files>
                    dpda
                        <associated files
                    npda
                        <associated files>

    and then make the include directive use that directory hierarchy.  Probably require full
    paths in include directive, and disallow relative paths.
-   Allow an id to be associated with an %error directive, where the token associated with the
    %error directive is produced by the error handling actions.  This is so the parser can store
    a file location (or range) for the error.  This would support the idea of making ERROR_ into
    a nonterminal, which would then be called error_.
-   Probably just get rid of ResetForNewInput, favoring destroying and recreating the parser/scanner.
    At least examine if there's any reason to keep that feature.
-   Make an option in reflex and trison for printing a list of dependent targetspec and codespec files
    for a given source or target.  I.e. the input file is parser.trison and it specifies targets
    target.cpp and target.fakelang, and then it prints target.cpp.targetspec, target.cpp.header.codespec,
    target.cpp.implementation.codespec, target.cpp.npda.header.codespec, target.cpp.npda.implementation.codespec,
    ..., target.fakelang.targetspec target.fakelang.codespec.  This way, build processes can be more
    automated and require less hand-specification.

    Similarly, make an option where it prints the files that would be generated by a command (i.e.
    thing_parser.trison -> thing_parser.hpp thing_parser.cpp

-   Should probably make NPDA DAG generation forbid an INSERT_ERROR_TOKEN action when the lookahead
    is ERROR_.  This would prevent one class of infinite loop.

