%targets cpp_npda

%target.cpp_npda.header_filename "dumblang_parser.hpp"
%target.cpp_npda.implementation_filename "dumblang_parser.cpp"


%target.cpp_npda.top_of_header_file %{
#if !defined(DUMBLANG_PARSER_HPP_)
#define DUMBLANG_PARSER_HPP_

#include <iostream>
#include <list>
#include <string>

using namespace std;

typedef unsigned int uint;

extern string const g_empty_string;

class Ast;
class Scanner;

class Ast : public list<Ast *>
{
public:

    enum AstType
    {
        DECLARATION_LIST = 0,
        VAR_DECLARATION,
        FUNC_DECLARATION,
        PARAMETER_LIST,
        CODE_BLOCK,
        IF_STATEMENT,
        IF_ELSE_STATEMENT,
        RETURN_STATEMENT,
        EMPTY_STATEMENT,
        ASSIGNMENT,
        LESS_THAN,
        LESS_THAN_OR_EQUAL,
        GREATER_THAN,
        GREATER_THAN_OR_EQUAL,
        EQUAL,
        NOT_EQUAL,
        ADD,
        SUBTRACT,
        MULTIPLY,
        DIVIDE,
        NEGATIVE,
        NOT,
        EXPONENTIATE,
        ID,
        INTEGER_LITERAL,

        TYPE_COUNT
    };

    Ast (AstType type, int int_data = 0, string const &string_data = g_empty_string)
        :
        m_type(type),
        m_int_data(int_data),
        m_string_data(string_data)
    { }
    ~Ast ()
    {
        for (iterator it = begin(), it_end = end(); it != it_end; ++it)
            delete *it;
        clear();
    }

    AstType Type () const { return m_type; }
    int IntData () const { return m_int_data; }
    string const &StringData () const { return m_string_data; }

    void IntData (int int_data) { m_int_data = int_data; }
    void StringData (string const &string_data) { m_string_data = string_data; }

    void Print (uint indent_level = 0) const;

private:

    AstType const m_type;
    int m_int_data;
    string m_string_data;
};
%}
%target.cpp_npda.class_name Parser
%target.cpp_npda.bottom_of_class {
    Token_ Scan ();

private:

    Scanner *m_scanner;
}
%target.cpp_npda.bottom_of_header_file %{
#endif // !defined(DUMBLANG_PARSER_HPP_)
%}


%target.cpp_npda.top_of_implementation_file %{
#include "dumblang_scanner.hpp"

string const g_empty_string;

struct Tabs
{
    Tabs (uint count) : m_count(count) { }

    uint const m_count;
};

ostream &operator << (ostream &stream, Tabs const &tabs)
{
    for (uint i = 0; i < tabs.m_count; ++i)
        stream << "    ";
    return stream;
}

ostream &operator << (ostream &stream, Ast::AstType type)
{
    static char const *const s_type_string[Ast::TYPE_COUNT] =
    {
        "DECLARATION_LIST",
        "VAR_DECLARATION",
        "FUNC_DECLARATION",
        "PARAMETER_LIST",
        "CODE_BLOCK",
        "IF_STATEMENT",
        "IF_ELSE_STATEMENT",
        "RETURN_STATEMENT",
        "EMPTY_STATEMENT",
        "ASSIGNMENT",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "EQUAL",
        "NOT_EQUAL",
        "ADD",
        "SUBTRACT",
        "MULTIPLY",
        "DIVIDE",
        "NEGATIVE",
        "NOT",
        "EXPONENTIATE",
        "ID",
        "INTEGER_LITERAL"
    };

    assert(type >= 0 && type < Ast::TYPE_COUNT);
    return stream << s_type_string[(uint)type];
}

void Ast::Print (uint indent_level) const
{
    cerr << Tabs(indent_level) << m_type << ", int data = " << IntData() << ", string data = \"" << StringData() << "\"" << endl;
    for (const_iterator it = begin(), it_end = end(); it != it_end; ++it)
        (*it)->Print(indent_level+1);
}
%}
%target.cpp_npda.constructor_actions {
    m_scanner = new Scanner();
}
%target.cpp_npda.destructor_actions {
    delete m_scanner;
    m_scanner = NULL;
}
%target.cpp_npda.bottom_of_implementation_file %{
Parser::Token_ Parser::Scan ()
{
    assert(m_scanner != NULL);
    return m_scanner->Scan();
}

int main (int argc, char **argv)
{
    Parser parser;
    Ast *return_token;
    if (Parser::PRC_SUCCESS == parser.Parse(&return_token))
    {
//         cerr << endl << endl;
//         return_token->Print();
    }
    else
        cerr << "\n\nunhandled parse error" << endl;
    return 0;
}
%}


%target.cpp_npda.token_data_type "Ast *"
%target.cpp_npda.token_data_type_sentinel "NULL"
%target.cpp_npda.return_token_type "Ast *"

%terminal '+' '-' '*' '/' '^' '(' ')'
%terminal '>' '<' '=' '!'
%terminal '{' '}' ';' ','
%terminal ID
%terminal INTEGER_LITERAL
%terminal KEYWORD_IF KEYWORD_ELSE KEYWORD_VAR KEYWORD_FUNC KEYWORD_RETURN

%prec.right ASSIGNMENT
%prec.left COMPARISON
%prec.left ADDITION
%prec.left MULTIPLICATION
%prec.right UNARY
%prec.right EXPONENTIATION
%prec.right IF
%prec.right IF_ELSE

// %default_parse_nonterminal declaration_list
%default_parse_nonterminal st

%%

// ///////////////////////////////////////////////////////////////////////////
// shift/reduce conflicts requiring 3 lookaheads, resolved by precedence
// ///////////////////////////////////////////////////////////////////////////

%nonterminal st
:
    exp ';' %target.cpp_npda { return NULL; }
;

%nonterminal exp
:
    exp '+' '+' exp %prec COMPARISON %target.cpp_npda { return NULL; }
|
    exp '+' exp %prec ADDITION %target.cpp_npda { return NULL; }
|
    exp '+' '+' '+' exp %prec MULTIPLICATION %target.cpp_npda { return NULL; }
|
    ID %target.cpp_npda { return NULL; }
;

// ///////////////////////////////////////////////////////////////////////////
// parsing either of these will immediately incur a reduce (empty)
// ///////////////////////////////////////////////////////////////////////////

%nonterminal outer_empty
:
    empty %target.cpp_npda { return NULL; }
;

%nonterminal empty
:
    // empty reduction rule
    %target.cpp_npda { return NULL; }
;

// ///////////////////////////////////////////////////////////////////////////
// mutually recursive rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal odd
:
    even ID %target.cpp_npda { return NULL; }
;

%nonterminal even
:
    odd ID %target.cpp_npda { return NULL; }
|
    // empty reduction rule
    %target.cpp_npda { return NULL; }
;

/*
%nonterminal declaration_list
:
    declaration_list:list declaration:decl
    %target.cpp_npda
    {
        list->push_back(decl);
        return list;
    }
|
    // empty reduction rule
    %target.cpp_npda
    {
        return new Ast(Ast::DECLARATION_LIST);
    }
;

%nonterminal declaration
:
    KEYWORD_VAR ID:id ';'
    %target.cpp_npda
    {
        Ast *decl = new Ast(Ast::VAR_DECLARATION);
        decl->push_back(id);
        return decl;
    }
|
    KEYWORD_FUNC ID:id '(' function_parameters:params ')' '{' code_block:code '}'
    %target.cpp_npda
    {
        Ast *decl = new Ast(Ast::FUNC_DECLARATION);
        decl->push_back(id);
        decl->push_back(params);
        decl->push_back(code);
        return decl;
    }
;

%nonterminal function_parameters
:
    parameter_list:list
    %target.cpp_npda { return list; }
|
    // empty reduction rule
    %target.cpp_npda { return new Ast(Ast::PARAMETER_LIST); }
;

%nonterminal parameter_list
:
    parameter_list:list ',' KEYWORD_VAR ID:id
    %target.cpp_npda
    {
        list->push_back(id);
        return list;
    }
|
    KEYWORD_VAR ID:id
    %target.cpp_npda
    {
        Ast *list = new Ast(Ast::PARAMETER_LIST);
        list->push_back(id);
        return list;
    }
;

%nonterminal code_block
:
    code_block:code KEYWORD_VAR ID:id ';'
    %target.cpp_npda
    {
        Ast *decl = new Ast(Ast::VAR_DECLARATION);
        decl->push_back(id);
        code->push_back(decl);
        return code;
    }
|
    code_block:code statement:st
    %target.cpp_npda
    {
        code->push_back(st);
        return code;
    }
|
    // empty reduction rule
    %target.cpp_npda
    {
        return new Ast(Ast::CODE_BLOCK);
    }
;

%nonterminal statement
:
    '{' code_block:code '}'
    %target.cpp_npda { return code; }
|
    expression:exp ';'
    %target.cpp_npda { return exp; }
|
    KEYWORD_RETURN expression:exp ';'
    %target.cpp_npda
    {
        Ast *ret = new Ast(Ast::RETURN_STATEMENT);
        ret->push_back(exp);
        return ret;
    }
|
    ';'
    %target.cpp_npda { return new Ast(Ast::EMPTY_STATEMENT); }
|
    KEYWORD_IF '(' expression:cond ')' statement:then %prec IF
    %target.cpp_npda
    {
        Ast *if_statement = new Ast(Ast::IF_STATEMENT);
        if_statement->push_back(cond);
        if_statement->push_back(then);
        return if_statement;
    }
|
    KEYWORD_IF '(' expression:cond ')' statement:then KEYWORD_ELSE statement:otherwise %prec IF_ELSE
    %target.cpp_npda
    {
        Ast *if_else_statement = new Ast(Ast::IF_ELSE_STATEMENT);
        if_else_statement->push_back(cond);
        if_else_statement->push_back(then);
        if_else_statement->push_back(otherwise);
        return if_else_statement;
    }
;

%nonterminal expression
:
    ID:id '=' expression:val %prec ASSIGNMENT
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::ASSIGNMENT);
        exp->push_back(id);
        exp->push_back(val);
        return exp;
    }
|
    expression:l '<' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::LESS_THAN);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '<' '=' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::LESS_THAN_OR_EQUAL);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '>' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::GREATER_THAN);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '>' '=' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::GREATER_THAN_OR_EQUAL);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '=' '=' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::EQUAL);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '!' '=' expression:r %prec COMPARISON
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::NOT_EQUAL);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '+' expression:r %prec ADDITION
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::ADD);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '-' expression:r %prec ADDITION
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::SUBTRACT);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '*' expression:r %prec MULTIPLICATION
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::MULTIPLY);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '/' expression:r %prec MULTIPLICATION
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::DIVIDE);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    '-' expression:r %prec UNARY
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::NEGATIVE);
        exp->push_back(r);
        return exp;
    }
|
    '!' expression:r %prec UNARY
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::NOT);
        exp->push_back(r);
        return exp;
    }
|
    expression:l '^' expression:r %prec EXPONENTIATION
    %target.cpp_npda
    {
        Ast *exp = new Ast(Ast::EXPONENTIATE);
        exp->push_back(l);
        exp->push_back(r);
        return exp;
    }
|
    '(' expression:exp ')'
    %target.cpp_npda { return exp; }
|
    ID:id
    %target.cpp_npda { return id; }
|
    INTEGER_LITERAL:value
    %target.cpp_npda { return value; }
;
*/
