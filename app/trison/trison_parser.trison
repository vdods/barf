// ///////////////////////////////////////////////////////////////////////////
// trison_parser.trison by Victor Dods, created 2006/02/19
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_class_name "Parser"

%parser_header_file_top%{
#if !defined(_TRISON_PARSER_HPP_)
#define _TRISON_PARSER_HPP_

#include "trison.hpp"

#include "trison_message.hpp"

namespace Barf {
namespace Ast {

class Base;

} // end of namespace Ast
} // end of namespace Barf

namespace Trison {

class Scanner;
%}

%parser_class_methods_and_members{
    bool SetInputFilename (string const &input_filename);

private:

    FiLoc GetFiLoc () const;

    Token::Type Scan ();

    Scanner *m_scanner;
}

%parser_header_file_bottom%{
} // end of namespace Trison

#endif // !defined(_TRISON_PARSER_HPP_)
%}

%parser_implementation_file_top%{
#include <sstream>

#include "trison_ast.hpp"
#include "trison_scanner.hpp"

namespace Trison {
%}

%parser_constructor_actions{
    m_scanner = new Scanner();
}

%parser_destructor_actions{
    delete m_scanner;
}

%parser_throw_away_token_actions{
    delete token;
}

%parser_implementation_file_bottom%{
bool Parser::SetInputFilename (string const &input_filename)
{
    assert(m_scanner != NULL);
    m_scanner->Close();
    return m_scanner->Open(input_filename);
}

FiLoc Parser::GetFiLoc () const
{
    assert(m_scanner != NULL);
    return FiLoc(m_scanner->GetInputFilename(), m_scanner->GetLineNumber());
}

Parser::Token::Type Parser::Scan ()
{
    assert(m_scanner != NULL);
    return m_scanner->Scan(&m_lookahead_token);
}

} // end of namespace Trison
%}

%parser_base_assigned_type "Ast::Base *"
%parser_base_assigned_type_sentinel "NULL"
%parser_custom_cast "Dsc"

%token ':' ';' '|'
%token STRICT_CODE_BLOCK %type "Ast::StrictCodeBlock *"
%token DUMB_CODE_BLOCK %type "Ast::DumbCodeBlock *"
%token ID %type "Ast::Id *"
%token DIRECTIVE_PARSER_WITH_PARAMETER %type "ParserDirective *"
%token DIRECTIVE_PARSER_WITHOUT_PARAMETER %type "ParserDirective *"
%token STRING %type "Ast::String *"
%token DIRECTIVE_ERROR %type "Ast::ThrowAway *"
%token DIRECTIVE_TOKEN %type "Ast::ThrowAway *"
%token END_PREAMBLE %type "Ast::ThrowAway *"
%token LEFT %type "Ast::ThrowAway *"
%token NONASSOC %type "Ast::ThrowAway *"
%token PREC %type "Ast::ThrowAway *"
%token RIGHT %type "Ast::ThrowAway *"
%token START %type "Ast::ThrowAway *"
%token TYPE %type "Ast::ThrowAway *"
%token TOKEN_ID_CHAR %type "TokenIdChar *"
%token BAD_TOKEN
%token NEWLINE

%start root

%%

root %type "Grammar *"
:
    directive_list:directive_list END_PREAMBLE:end_preamble nonterminal_list:nonterminal_list
    {
        Grammar *grammar =
            new Grammar(
                directive_list,
                end_preamble->GetFiLoc(),
                nonterminal_list);
        delete end_preamble;
        return grammar;
    }
|
    directive_list:directive_list END_PREAMBLE:end_preamble nonterminal_list:nonterminal_list %error
    {
        EmitError("extraneous tokens at end of file");

        Grammar *grammar =
            new Grammar(
                directive_list,
                end_preamble->GetFiLoc(),
                nonterminal_list);
        delete end_preamble;
        return grammar;
    }
;

directive_list %type "Ast::DirectiveList *"
:
    directive_list:directive_list directive:directive
    {
        if (directive != NULL)
            directive_list->Append(directive);
        return directive_list;
    }
|
    at_least_zero_newlines
    {
        return new Ast::DirectiveList();
    }
;

directive %type "Ast::Directive *"
:
    DIRECTIVE_PARSER_WITH_PARAMETER:parser_directive STRICT_CODE_BLOCK:value at_least_one_newline
    {
        parser_directive->SetValue(value);
        return parser_directive;
    }
|
    DIRECTIVE_PARSER_WITH_PARAMETER:parser_directive DUMB_CODE_BLOCK:value at_least_one_newline
    {
        if (!ParserDirective::GetDoesParserDirectiveAcceptDumbCodeBlock(
                parser_directive->GetParserDirectiveType()))
        {
            ostringstream out;
            out << ParserDirective::GetString(parser_directive->GetParserDirectiveType())
                << " does not accept %{ %} code blocks -- use { }";
            EmitError(out.str(), parser_directive->GetFiLoc());
            return NULL;
        }

        parser_directive->SetValue(value);
        return parser_directive;
    }
|
    DIRECTIVE_PARSER_WITH_PARAMETER:parser_directive STRING:value at_least_one_newline
    {
        parser_directive->SetValue(value);
        return parser_directive;
    }
|
    DIRECTIVE_PARSER_WITHOUT_PARAMETER:parser_directive at_least_one_newline
    {
        return parser_directive;
    }
|
    DIRECTIVE_TOKEN:throwaway token_id_list:token_id_list at_least_one_newline
    {
        delete throwaway;
        return new TokenDirective(token_id_list, NULL);
    }
|
    DIRECTIVE_TOKEN:throwaway1 token_id_list:token_id_list TYPE:throwaway2 STRING:assigned_type at_least_one_newline
    {
        delete throwaway1;
        delete throwaway2;
        return new TokenDirective(token_id_list, assigned_type);
    }
|
    DIRECTIVE_TOKEN:throwaway %error at_least_one_newline
    {
        EmitError("syntax error in %token directive", throwaway->GetFiLoc());

        delete throwaway;
        return new TokenDirective(new TokenIdList(), NULL);
    }
|
    DIRECTIVE_TOKEN:throwaway1 token_id_list:token_id_list TYPE:throwaway2 %error at_least_one_newline
    {
        EmitError("syntax error in %type directive", throwaway2->GetFiLoc());

        Ast::String *dummy_string = new Ast::String(throwaway2->GetFiLoc());
        delete throwaway1;
        delete throwaway2;
        return new TokenDirective(token_id_list, dummy_string);
    }
|
    PREC:throwaway ID:id at_least_one_newline
    {
        delete throwaway;
        return new PrecedenceDirective(id);
    }
|
    PREC:throwaway %error at_least_one_newline
    {
        EmitError("syntax error in %prec directive", throwaway->GetFiLoc());

        Ast::Id *dummy_id = new Ast::Id("!ERROR!", throwaway->GetFiLoc());
        delete throwaway;
        return new PrecedenceDirective(dummy_id);
    }
|
    START:throwaway ID:id at_least_one_newline
    {
        delete throwaway;
        return new StartDirective(id);
    }
|
    START:throwaway %error at_least_one_newline
    {
        EmitError("syntax error in %start directive", throwaway->GetFiLoc());

        Ast::Id *dummy_id = new Ast::Id("!ERROR!", throwaway->GetFiLoc());
        delete throwaway;
        return new StartDirective(dummy_id);
    }
|
    %error STRICT_CODE_BLOCK:value at_least_one_newline
    {
        EmitError("syntax error in directive", value->GetFiLoc());

        return NULL;
    }
|
    %error DUMB_CODE_BLOCK:value at_least_one_newline
    {
        EmitError("syntax error in directive", value->GetFiLoc());

        return NULL;
    }
|
    %error STRING:value at_least_one_newline
    {
        EmitError("syntax error in directive", value->GetFiLoc());

        return NULL;
    }
|
    %error at_least_one_newline
    {
        EmitError("syntax error in directive", GetFiLoc());

        return NULL;
    }
;

token_id_list %type "TokenIdList *"
:
    token_id_list:token_id_list token_id:token_id
    {
        token_id_list->Append(token_id);
        return token_id_list;
    }
|
    token_id:token_id
    {
        TokenIdList *token_id_list = new TokenIdList();
        token_id_list->Append(token_id);
        return token_id_list;
    }
;

token_id %type "TokenId *"
:
    ID:id
    {
        TokenIdId *token_id_id =
            new TokenIdId(id->GetText(), id->GetFiLoc());
        delete id;
        return token_id_id;
    }
|
    TOKEN_ID_CHAR:token_id_char
    {
        return token_id_char;
    }
;

at_least_zero_newlines
:
    at_least_zero_newlines NEWLINE { return NULL; }
|
    /* empty reduction rule */ { return NULL; }
;

at_least_one_newline
:
    at_least_one_newline NEWLINE { return NULL; }
|
    NEWLINE { return NULL; }
;

nonterminal_list %type "NonterminalList *"
:
    nonterminal_list:nonterminal_list nonterminal:nonterminal
    {
        // the nonterminal could be null if an error was recovered from
        if (nonterminal != NULL)
            nonterminal_list->Append(nonterminal);
        return nonterminal_list;
    }
|
    // empty reduction rule
    {
        return new NonterminalList();
    }
;

nonterminal %type "Nonterminal *"
:
    nonterminal_specification:nonterminal_specification ':' rule_list:rule_list ';'
    {
        assert(nonterminal_specification != NULL);
        nonterminal_specification->SetRuleList(rule_list);
        return nonterminal_specification;
    }
|
    %error ';'
    {
        EmitError("syntax error in nonterminal definition", GetFiLoc());

        return NULL;
    }
;

nonterminal_specification %type "Nonterminal *"
:
    ID:id TYPE:throwaway STRING:assigned_type
    {
        delete throwaway;
        return new Nonterminal(id, assigned_type);
    }
|
    ID:id
    {
        return new Nonterminal(id, NULL);
    }
|
    %error
    {
        EmitError("syntax error while parsing nonterminal specification", GetFiLoc());

        return new Nonterminal(new Ast::Id("!ERROR!", FiLoc::ms_invalid), NULL);
    }
|
    ID:id %error
    {
        EmitError("syntax error in nonterminal directive", id->GetFiLoc());

        return new Nonterminal(id, NULL);
    }
|
    ID:id TYPE:throwaway %error
    {
        EmitError("syntax error in nonterminal %type directive; was expecting a string", id->GetFiLoc());

        delete throwaway;
        return new Nonterminal(id, NULL);
    }
;

rule_list %type "RuleList *"
:
    rule_list:rule_list '|' rule:rule
    {
        rule_list->Append(rule);
        return rule_list;
    }
|
    rule:rule
    {
        RuleList *rule_list = new RuleList();
        rule_list->Append(rule);
        return rule_list;
    }
;

rule %type "Rule *"
:
    rule_specification:rule_specification STRICT_CODE_BLOCK:code_block
    {
        rule_specification->SetCodeBlock(code_block);
        return rule_specification;
    }
|
    rule_specification:rule_specification
    {
        return rule_specification;
    }
|
    rule_specification:rule_specification DUMB_CODE_BLOCK:code_block
    {
        EmitError(
            "rules do not accept %{ %} code blocks -- use { } instead",
            code_block->GetFiLoc());

        rule_specification->SetCodeBlock(code_block);
        return rule_specification;
    }
;

rule_specification %type "Rule *"
:
    rule_token_list:rule_token_list LEFT:throwaway rule_precedence_directive:rule_precedence_directive
    {
        delete throwaway;
        return new Rule(rule_token_list, A_LEFT, rule_precedence_directive);
    }
|
    rule_token_list:rule_token_list RIGHT:throwaway rule_precedence_directive:rule_precedence_directive
    {
        delete throwaway;
        return new Rule(rule_token_list, A_RIGHT, rule_precedence_directive);
    }
|
    rule_token_list:rule_token_list NONASSOC:throwaway rule_precedence_directive:rule_precedence_directive
    {
        delete throwaway;
        return new Rule(rule_token_list, A_NONASSOC, rule_precedence_directive);
    }
|
    rule_token_list:rule_token_list rule_precedence_directive:rule_precedence_directive
    {
        // the default associativity when none is specified is LEFT
        return new Rule(rule_token_list, A_LEFT, rule_precedence_directive);
    }
;

rule_token_list %type "RuleTokenList *"
:
    rule_token_list:rule_token_list rule_token:rule_token
    {
        rule_token_list->Append(rule_token);
        return rule_token_list;
    }
|
    // empty reduction rule
    {
        // it is necessary to explicitly assign the file location here because
        // the rule token list may be empty (and thus wouldn't take its file
        // location from the first appended list element).
        return new RuleTokenList(GetFiLoc());
    }
;

rule_token %type "RuleToken *"
:
    token_id:token_id ':' ID:assigned_id
    {
        return new RuleToken(token_id, assigned_id);
    }
|
    token_id:token_id
    {
        return new RuleToken(token_id, NULL);
    }
|
    DIRECTIVE_ERROR:throwaway
    {
        delete throwaway;
        return new RuleToken(new TokenIdId("%error", GetFiLoc()), NULL);
    }
;

rule_precedence_directive %type "Ast::Id *"
:
    PREC:throwaway ID:id
    {
        delete throwaway;
        return id;
    }
|
    // empty reduction rule
    {
        return NULL;
    }
;
