// ///////////////////////////////////////////////////////////////////////////
// trison_parser.trison by Victor Dods, created 2006/02/19
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%targets cpp


%target.cpp.header_filename "trison_parser.hpp"
%target.cpp.implementation_filename "trison_parser.cpp"


%target.cpp.top_of_header_file %{
#if !defined(TRISON_PARSER_HPP_)
#define TRISON_PARSER_HPP_

#include "trison.hpp"

#include "barf_commonlang_scanner.hpp"

namespace Barf {
namespace Ast {

class Base;
struct Id;
struct IdMap;
class IntegerMap;

} // end of namespace Ast

namespace CommonLang {

struct TargetMap;

} // end of namespace CommonLang
} // end of namespace Barf

namespace Trison {

struct NonterminalList;
struct NonterminalMap;
struct PrecedenceList;
struct PrecedenceMap;
struct TerminalList;
struct TerminalMap;
%}
%target.cpp.class_name Parser
%target.cpp.bottom_of_class {
    inline FiLoc const &GetFiLoc () const { return m_scanner.GetFiLoc(); }
    CommonLang::TargetMap &GetTargetMap () { assert(m_target_map != NULL); return *m_target_map; }
    CommonLang::TargetMap *StealTargetMap ();

    bool ScannerDebugSpewIsEnabled () const { return m_scanner.DebugSpewIsEnabled(); }
    std::ostream *ScannerDebugSpewStream () { return m_scanner.DebugSpewStream(); }
    void SetScannerDebugSpewStream (std::ostream *debug_spew_stream) { m_scanner.SetDebugSpewStream(debug_spew_stream); }

    bool OpenFile (string const &input_filename);
    void OpenString (string const &input_string, string const &input_name, bool use_line_numbers = false);
    void OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers);

private:

    CommonLang::Scanner m_scanner;
    CommonLang::TargetMap *m_target_map;
    TerminalList *m_terminal_list;
    TerminalMap *m_terminal_map;
    Uint32 m_token_index;
    PrecedenceList *m_precedence_list;
    PrecedenceMap *m_precedence_map;
    Ast::Id *m_default_parse_nonterminal_id;
    NonterminalList *m_nonterminal_list;
    NonterminalMap *m_nonterminal_map;
    Uint32 m_rule_count;
}
%target.cpp.bottom_of_header_file %{
} // end of namespace Trison

#endif // !defined(TRISON_PARSER_HPP_)
%}


%target.cpp.top_of_implementation_file %{
#include <sstream>

#include "trison_ast.hpp"

namespace Trison {
%}
%target.cpp.constructor_actions {
    m_target_map = new CommonLang::TargetMap();
}
%target.cpp.destructor_actions {
    // if the target map wasn't stolen by the user of this parser,
    // then make sure to delete it.
    delete m_target_map;
    m_target_map = NULL;
}
%target.cpp.top_of_parse_method_actions %{
    m_default_parse_nonterminal_id = NULL;
    m_rule_count = 0;

    // initialize m_terminal_map and m_terminal_list and populate the special,
    // pre-defined terminals.
    {
        m_terminal_list = new TerminalList();
        m_terminal_map = new TerminalMap();

        Ast::Id *id;
        Trison::Terminal *terminal;

        // create and add the special END_ and ERROR_ terminals (with
        // token_index 0x100 and 0x101 respectively.
        m_token_index = 0x100;

        id = new Ast::Id("END_", FiLoc::ms_invalid);
        terminal = new Trison::Terminal(id, m_token_index++);
        terminal->SetAssignedTypeMap(new TypeMap()); // default type
        m_terminal_list->Append(terminal);
        m_terminal_map->Add(terminal->GetText(), terminal);

        id = new Ast::Id("ERROR_", FiLoc::ms_invalid);
        terminal = new Trison::Terminal(id, m_token_index++);
        terminal->SetAssignedTypeMap(new TypeMap()); // default type
        m_terminal_list->Append(terminal);
        m_terminal_map->Add(terminal->GetText(), terminal);
    }

    // initialize m_nonterminal_map and m_nonterminal_list and populate the special,
    // pre-defined nonterminal(s).
    {
        m_nonterminal_list = new NonterminalList();
        m_nonterminal_map = new NonterminalMap();

        // add the special "none_" nonterminal with token_index 0 and empty rule list
        Trison::Nonterminal *nonterminal = new Trison::Nonterminal("none_", 0, FiLoc::ms_invalid);
        nonterminal->SetRuleList(new RuleList());
        m_nonterminal_list->Append(nonterminal);
        m_nonterminal_map->Add(nonterminal->GetText(), nonterminal);
    }

    m_precedence_list = new PrecedenceList();
    m_precedence_map = new PrecedenceMap();

    EmitExecutionMessage("starting trison parser");
%}
%target.cpp.bottom_of_parse_method_actions %{
    if (parse_return_code == PRC_SUCCESS)
        EmitExecutionMessage("trison parse was successful");
%}
%target.cpp.bottom_of_implementation_file %{
CommonLang::TargetMap *Parser::StealTargetMap ()
{
    assert(m_target_map != NULL);
    CommonLang::TargetMap *retval = m_target_map;
    m_target_map = NULL;
    return retval;
}

bool Parser::OpenFile (string const &input_filename)
{
    ResetForNewInput();
    EmitExecutionMessage("opening file \"" + input_filename + "\" for input");
    bool scanner_open_file_succeeded = m_scanner.OpenFile(input_filename);
    if (scanner_open_file_succeeded)
        EmitExecutionMessage("opened file \"" + input_filename + "\" successfully");
    return scanner_open_file_succeeded;
}

void Parser::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    EmitExecutionMessage("using string " + input_name + " (" + StringLiteral(input_string) + ") for input");
    m_scanner.OpenString(input_string, input_name, use_line_numbers);
}

void Parser::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    EmitExecutionMessage("using stream " + input_name + " for input");
    m_scanner.OpenUsingStream(input_stream, input_name, use_line_numbers);
}

} // end of namespace Trison
%}


%target.cpp.token_data_type "Ast::Base *"
%target.cpp.token_data_default "NULL"
%target.cpp.custom_token_data_type_cast "Dsc"
%target.cpp.throw_away_token_actions {
    delete token_data;
}
%target.cpp.scan_actions {
    Ast::Base *lookahead_token_data = NULL;
    CommonLang::Scanner::Token::Type scanner_token_type = m_scanner.Scan(lookahead_token_data);
    assert(scanner_token_type >= 0);
    if (scanner_token_type < 0x100)
        return Token(Parser::Token::Id(scanner_token_type), lookahead_token_data);
    switch (scanner_token_type)
    {
        case CommonLang::Scanner::Token::BAD_END_OF_FILE:                     return Token(Terminal::END_, lookahead_token_data);
        case CommonLang::Scanner::Token::BAD_TOKEN:                           return Token(Terminal::BAD_TOKEN, lookahead_token_data);
        case CommonLang::Scanner::Token::CHAR_LITERAL:                        return Token(Terminal::CHAR_LITERAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT:                   return Token(Terminal::DIRECTIVE_DEFAULT, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL: return Token(Terminal::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_EMPTY:                     return Token(Terminal::DIRECTIVE_EMPTY, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_END:                       return Token(Terminal::DIRECTIVE_END, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_ERROR:                     return Token(Terminal::DIRECTIVE_ERROR, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_LOOKAHEAD:                 return Token(Terminal::DIRECTIVE_LOOKAHEAD, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_NONTERMINAL:               return Token(Terminal::DIRECTIVE_NONTERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_PREC:                      return Token(Terminal::DIRECTIVE_PREC, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TARGET:                    return Token(Terminal::DIRECTIVE_TARGET, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TARGETS:                   return Token(Terminal::DIRECTIVE_TARGETS, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TERMINAL:                  return Token(Terminal::DIRECTIVE_TERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TYPE:                      return Token(Terminal::DIRECTIVE_TYPE, lookahead_token_data);
        case CommonLang::Scanner::Token::DUMB_CODE_BLOCK:                     return Token(Terminal::DUMB_CODE_BLOCK, lookahead_token_data);
        case CommonLang::Scanner::Token::END_OF_FILE:                         return Token(Terminal::END_, lookahead_token_data);
        case CommonLang::Scanner::Token::END_PREAMBLE:                        return Token(Terminal::END_PREAMBLE, lookahead_token_data);
        case CommonLang::Scanner::Token::ID:                                  return Token(Terminal::ID, lookahead_token_data);
        case CommonLang::Scanner::Token::NEWLINE:                             return Token(Terminal::NEWLINE, lookahead_token_data);
        case CommonLang::Scanner::Token::STRICT_CODE_BLOCK:                   return Token(Terminal::STRICT_CODE_BLOCK, lookahead_token_data);
        case CommonLang::Scanner::Token::STRING_LITERAL:                      return Token(Terminal::STRING_LITERAL, lookahead_token_data);

        case CommonLang::Scanner::Token::DIRECTIVE_ADD_CODESPEC:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_OPTIONAL_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_REQUIRED_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_CASE_INSENSITIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_DUMB_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_ID:
        case CommonLang::Scanner::Token::DIRECTIVE_MACRO:
        case CommonLang::Scanner::Token::DIRECTIVE_START_IN_STATE_MACHINE:
        case CommonLang::Scanner::Token::DIRECTIVE_STRICT_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_STRING:
        case CommonLang::Scanner::Token::DIRECTIVE_UNGREEDY:
        case CommonLang::Scanner::Token::REGEX:
            assert(lookahead_token_data != NULL);
            EmitError(FORMAT("unrecognized token " << scanner_token_type), lookahead_token_data->GetFiLoc());
            delete lookahead_token_data;
            return Token(Terminal::BAD_TOKEN);

        default:
            assert(false && "this should never happen");
            if (lookahead_token_data != NULL)
                delete lookahead_token_data;
            return Token(Terminal::BAD_TOKEN);
    }
}
%target.cpp.reset_for_new_input_actions {
    m_scanner.ResetForNewInput();
}


%target.cpp.generate_debug_spew_code
%target.cpp.debug_spew_prefix {"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"}


%terminal BAD_TOKEN
%terminal CHAR_LITERAL %type.cpp "Ast::Char *"
%terminal DIRECTIVE_DEFAULT %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_DEFAULT_PARSE_NONTERMINAL %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_EMPTY %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_END %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_ERROR %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_LOOKAHEAD %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_NONTERMINAL %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_PREC %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_TARGET %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_TARGETS %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_TERMINAL %type.cpp "Ast::ThrowAway *"
%terminal DIRECTIVE_TYPE %type.cpp "Ast::ThrowAway *"
%terminal DUMB_CODE_BLOCK %type.cpp "Ast::DumbCodeBlock *"
%terminal END_PREAMBLE %type.cpp "Ast::ThrowAway *"
%terminal ID %type.cpp "Ast::Id *"
%terminal NEWLINE
%terminal STRICT_CODE_BLOCK %type.cpp "Ast::StrictCodeBlock *"
%terminal STRING_LITERAL %type.cpp "Ast::String *"
%terminal '.' ':' ';' '|' '[' ']' '!'


%prec.left %default


%default_parse_nonterminal root

%%

// ///////////////////////////////////////////////////////////////////////////
// root rule
// ///////////////////////////////////////////////////////////////////////////

%nonterminal root %type.cpp "PrimarySource *"
:
    preamble:throwaway nonterminals %end
    %target.cpp {
        assert(m_nonterminal_map != NULL);
        assert(m_nonterminal_list != NULL);
        assert(m_default_parse_nonterminal_id != NULL);

        if (m_default_parse_nonterminal_id == NULL)
        {
            // just use a dummy value -- this error condition has already been EmitError-handled
            // in the reduction rule handler for preamble.
            m_default_parse_nonterminal_id = new Ast::Id(m_nonterminal_list->Element(0)->GetText(), throwaway->GetFiLoc());
            assert(m_nonterminal_map->Element(m_default_parse_nonterminal_id->GetText()) != NULL);
        }

        // make sure the %default_parse_nonterminal directive value specifies a real nonterminal
        if (m_nonterminal_map->Element(m_default_parse_nonterminal_id->GetText()) == NULL)
        {
            EmitError(
                "undeclared nonterminal \"" + m_default_parse_nonterminal_id->GetText() + "\"",
                m_default_parse_nonterminal_id->GetFiLoc());
        }

        // Go through all nonterminals and make sure all the token_ids everywhere are valid.
        assert(m_nonterminal_list->size() == m_nonterminal_map->size());
        for (NonterminalList::const_iterator nonterminal_it = m_nonterminal_list->begin(), nonterminal_it_end = m_nonterminal_list->end();
             nonterminal_it != nonterminal_it_end;
             ++nonterminal_it)
        {
            assert(*nonterminal_it != NULL);
            Trison::Nonterminal const &nonterminal = **nonterminal_it;
            assert(m_nonterminal_map->find(nonterminal.GetText()) != m_nonterminal_map->end());
            for (RuleList::const_iterator rule_it = nonterminal.m_rule_list->begin(), rule_it_end = nonterminal.m_rule_list->end();
                 rule_it != rule_it_end;
                 ++rule_it)
            {
                assert(*rule_it != NULL);
                Rule const &rule = **rule_it;
                for (RuleTokenList::const_iterator rule_token_it = rule.m_rule_token_list->begin(), rule_token_it_end = rule.m_rule_token_list->end();
                    rule_token_it != rule_token_it_end;
                    ++rule_token_it)
                {
                    assert(*rule_token_it != NULL);
                    RuleToken const &rule_token = **rule_token_it;
                    if (m_nonterminal_map->find(rule_token.m_token_id) == m_nonterminal_map->end() && m_terminal_map->find(rule_token.m_token_id) == m_terminal_map->end())
                        EmitError(FORMAT("undeclared token \"" << rule_token.m_token_id << "\""), rule_token.GetFiLoc());

                    // If the rule token is %error, then check its m_lookaheads.  NOTE
                    // that these each have to be a terminal (not nonterminal).
                    ErrorDirective const *error_token = dynamic_cast<ErrorDirective const *>(&rule_token);
                    if (error_token != NULL)
                    {
                        for (TokenSpecifierList::const_iterator error_rule_token_lookahead_it = error_token->m_lookaheads->begin(), error_rule_token_lookahead_it_end = error_token->m_lookaheads->end();
                             error_rule_token_lookahead_it != error_rule_token_lookahead_it_end;
                             ++error_rule_token_lookahead_it)
                        {
                            assert(*error_rule_token_lookahead_it != NULL);
                            Ast::Id const &error_rule_token_lookahead = **error_rule_token_lookahead_it;
                            // Currently, the choice to limit to terminals only has been made to avoid
                            // potentially unknown complicating functionality.
                            bool const allow_error_to_use_nonterminals = false;
                            if (allow_error_to_use_nonterminals)
                            {
                                if (m_nonterminal_map->find(error_rule_token_lookahead.GetText()) == m_nonterminal_map->end() && m_terminal_map->find(error_rule_token_lookahead.GetText()) == m_terminal_map->end())
                                    EmitError(FORMAT("undeclared token \"" << error_rule_token_lookahead.GetText() << "\""), error_rule_token_lookahead.GetFiLoc());
                            }
                            else
                            {
                                if (m_terminal_map->find(error_rule_token_lookahead.GetText()) == m_terminal_map->end())
                                    EmitError(FORMAT("undeclared terminal \"" << error_rule_token_lookahead.GetText() << "\""), error_rule_token_lookahead.GetFiLoc());
                            }
                        }
                    }
                }

                // If there is a %lookahead directive, then check its lookaheads.
                if (rule.m_lookahead_directive != NULL)
                {
                    for (TokenSpecifierList::const_iterator lookahead_it = rule.m_lookahead_directive->m_lookaheads->begin(), lookahead_it_end = rule.m_lookahead_directive->m_lookaheads->end();
                         lookahead_it != lookahead_it_end;
                         ++lookahead_it)
                    {
                        assert(*lookahead_it != NULL);
                        Ast::Id const &lookahead = **lookahead_it;
                        bool const allow_lookahead_to_use_nonterminals = false;
                        // Currently, the choice to limit to terminals only has been made to avoid
                        // potentially unknown complicating functionality.
                        if (allow_lookahead_to_use_nonterminals)
                        {
                            if (m_nonterminal_map->find(lookahead.GetText()) == m_nonterminal_map->end() && m_terminal_map->find(lookahead.GetText()) == m_terminal_map->end())
                                EmitError(FORMAT("undeclared token \"" << lookahead.GetText() << "\""), lookahead.GetFiLoc());
                        }
                        else
                        {
                            if (m_terminal_map->find(lookahead.GetText()) == m_terminal_map->end())
                                EmitError(FORMAT("undeclared terminal \"" << lookahead.GetText() << "\""), lookahead.GetFiLoc());
                        }
                    }
                }
            }
        }

        PrimarySource *primary_source =
            new PrimarySource(
                m_terminal_list,
                m_terminal_map,
                m_precedence_map,
                m_precedence_list,
                m_default_parse_nonterminal_id->GetText(),
                throwaway->GetFiLoc(),
                m_nonterminal_list,
                m_nonterminal_map);
        delete throwaway;
        return primary_source;
    }
;

%nonterminal preamble %type.cpp "Ast::ThrowAway *"
:
    preamble_directives END_PREAMBLE:throwaway
    %target.cpp {
        assert(m_target_map != NULL);
        assert(m_terminal_list != NULL);
        assert(m_terminal_map != NULL);
        assert(m_precedence_list != NULL);
        assert(m_precedence_map != NULL);

        // set the TargetMap's primary source path
        m_target_map->SetSourcePath(m_scanner.InputName());

        // validate the %default_parse_nonterminal directive value.
        if (m_default_parse_nonterminal_id == NULL)
            EmitError("missing %default_parse_nonterminal directive; must specify a valid nonterminal", throwaway->GetFiLoc());

        // validate that m_precedence_map has an entry for "DEFAULT_".  this has to be done
        // here so that the precedences are ready to be used in the nonterminal reduction rules.
        Precedence *default_precedence = m_precedence_map->Element("DEFAULT_");
        if (default_precedence == NULL)
            EmitError("preamble is missing %default precedence directive; suggested reasonable default: %prec.left %default", throwaway->GetFiLoc());
        else
        {
            // Shift all the m_precedence_level values such that default_precedence has level 0.
            for (PrecedenceList::iterator it = m_precedence_list->begin(), it_end = m_precedence_list->end(); it != it_end; ++it)
            {
                Precedence *precedence = *it;
                assert(precedence != NULL);
                precedence->m_precedence_level -= default_precedence->m_precedence_level;
            }
            // Because default_precedence was in the list, its level should now be at zero.
            assert(default_precedence->m_precedence_level == 0);
        }

        return throwaway;
    }
;

%nonterminal preamble_directives
:
    preamble_directives preamble_directive
    %target.cpp {
        return NULL;
    }
|
    %empty
    %target.cpp {
        return NULL;
    }
;

%nonterminal preamble_directive
:
    targets_directive at_least_one_newline
    %target.cpp {
        // The logic is already handled by targets_directive
        assert(m_target_map != NULL);
        return NULL;
    }
|
    target_directive:target_directive at_least_one_newline
    %target.cpp {
        assert(target_directive != NULL);
        assert(m_target_map != NULL);
        if (target_directive != NULL)
            m_target_map->SetTargetDirective(target_directive);
        return NULL;
    }
|
    DIRECTIVE_TERMINAL:throwaway terminals:terminal_list type_spec:assigned_type_map at_least_one_newline
    %target.cpp {
        assert(m_terminal_list != NULL);
        assert(m_terminal_map != NULL);
        assert(terminal_list != NULL);
        assert(assigned_type_map != NULL);
        for (TerminalList::iterator it = terminal_list->begin(),
                                    it_end = terminal_list->end();
             it != it_end;
             ++it)
        {
            Trison::Terminal *terminal = *it;
            assert(terminal != NULL);
            terminal->SetAssignedTypeMap(assigned_type_map);
            m_terminal_list->Append(terminal);
            m_terminal_map->Add(terminal->GetText(), terminal);
        }
        terminal_list->clear();
        delete throwaway;
        delete terminal_list;
        return NULL;
    }
|
    precedence_directive at_least_one_newline
    %target.cpp {
        // Already handled by precedence_directive reduction rule.
        return NULL;
    }
|
    DIRECTIVE_DEFAULT_PARSE_NONTERMINAL:throwaway ID:id at_least_one_newline
    %target.cpp {
        if (m_default_parse_nonterminal_id != NULL)
        {
            EmitError(FORMAT("duplicate %default_parse_nonterminal directive; previously specified at " << m_default_parse_nonterminal_id->GetFiLoc()), throwaway->GetFiLoc());
            delete id;
        }
        else
            m_default_parse_nonterminal_id = id;

        assert(m_default_parse_nonterminal_id != NULL);
        delete throwaway;
        return NULL;
    }
|
    DIRECTIVE_DEFAULT_PARSE_NONTERMINAL:throwaway %error[![%end|NEWLINE]] at_least_one_newline
    %target.cpp {
        if (m_default_parse_nonterminal_id != NULL)
            EmitError(FORMAT("duplicate %default_parse_nonterminal directive; previously specified at " << m_default_parse_nonterminal_id->GetFiLoc()), throwaway->GetFiLoc());

        EmitError("parse error in %default_parse_nonterminal directive", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    }
|
    at_least_one_newline
    %target.cpp {
        return NULL;
    }
|
    %error[![%end|NEWLINE]] at_least_one_newline
    %target.cpp {
        EmitError("parse error in preamble directives", m_scanner.GetFiLoc());
        return NULL;
    }
|
    %error[![%end|END_PREAMBLE]]
    %target.cpp {
        EmitError("parse error in preamble directives", m_scanner.GetFiLoc());
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// targets directive rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal targets_directive
:
    DIRECTIVE_TARGETS:throwaway target_ids
    %target.cpp {
        delete throwaway;
        return NULL;
    }
|
    DIRECTIVE_TARGETS:throwaway %error[![%end|NEWLINE]]
    %target.cpp {
        EmitError("parse error in directive %targets", throwaway->GetFiLoc());
        return NULL;
    }
;

%nonterminal target_ids
:
    target_ids ID:target_id
    %target.cpp {
        assert(m_target_map != NULL);
        // if the given target doesn't exist in the target map, add it.
        if (m_target_map->Element(target_id->GetText()) == NULL)
        {
            CommonLang::Target *target = new CommonLang::Target(target_id->GetText());
            m_target_map->Add(target_id->GetText(), target);
        }
        // otherwise delete the target_id since we don't need it
        else
        {
            delete target_id;
        }
        return NULL;
    }
|
    %empty
    %target.cpp {
        assert(m_target_map != NULL);
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// target directive rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal target_directive %type.cpp "CommonLang::TargetDirective *"
:
    DIRECTIVE_TARGET:throwaway '.' ID:target_id '.' ID:target_directive target_directive_param:param
    %target.cpp {
        delete throwaway;
        return new CommonLang::TargetDirective(target_id, target_directive, param);
    }
|
    DIRECTIVE_TARGET:throwaway '.' ID:target_id '.' ID:target_directive %error[![%end|NEWLINE]]
    %target.cpp {
        EmitError("parse error in parameter for directive %target." + target_id->GetText() + "." + target_directive->GetText(), throwaway->GetFiLoc());
        delete throwaway;
        delete target_id;
        delete target_directive;
        return NULL;
    }
|
    DIRECTIVE_TARGET:throwaway '.' ID:target_id %error[![%end|NEWLINE]]
    %target.cpp {
        EmitError("parse error in directive name for directive %target." + target_id->GetText(), throwaway->GetFiLoc());
        delete throwaway;
        delete target_id;
        return NULL;
    }
|
    DIRECTIVE_TARGET:throwaway %error[![%end|NEWLINE]]
    %target.cpp {
        EmitError("parse error in target name for directive %target", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    }
;

%nonterminal target_directive_param %type.cpp "Ast::TextBase *"
:
    ID:value                    %target.cpp { return value; }
|   STRING_LITERAL:value        %target.cpp { return value; }
|   STRICT_CODE_BLOCK:value     %target.cpp { return value; }
|   DUMB_CODE_BLOCK:value       %target.cpp { return value; }
|   %empty                      %target.cpp { return NULL; }
;

// ///////////////////////////////////////////////////////////////////////////
// terminal directive rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal terminals %type.cpp "TerminalList *"
:
    terminals:terminal_list terminal:terminal
    %target.cpp {
        if (terminal != NULL)
            terminal_list->Append(terminal);
        return terminal_list;
    }
|
    terminal:terminal
    %target.cpp {
        TerminalList *terminal_list = new TerminalList();
        if (terminal != NULL)
            terminal_list->Append(terminal);
        return terminal_list;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// precedence directive rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal precedence_directive
:
    DIRECTIVE_PREC:throwaway '.' ID:associativity_id ID:id
    %target.cpp {
        assert(m_precedence_list != NULL);
        assert(m_precedence_map != NULL);
        assert(associativity_id != NULL);

        Associativity associativity = A_LEFT;
        if (associativity_id->GetText() == "left")
            associativity = A_LEFT;
        else if (associativity_id->GetText() == "nonassoc")
            associativity = A_NONASSOC;
        else if (associativity_id->GetText() == "right")
            associativity = A_RIGHT;
        else
            EmitError("invalid associativity specifier \"" + associativity_id->GetText() + "\"", throwaway->GetFiLoc());

        Precedence *precedence =
            new Precedence(
                id->GetText(),
                associativity,
                id->GetFiLoc(),
                m_precedence_map->size(), // precedence_index
                m_precedence_map->size()); // precedence_level (to be offset by level of default precedence later)
        m_precedence_list->Append(precedence);
        m_precedence_map->Add(precedence->m_precedence_id, precedence);
        delete throwaway;
        delete id;
        return NULL;
    }
|
    DIRECTIVE_PREC:throwaway0 '.' ID:associativity_id DIRECTIVE_DEFAULT:throwaway1
    %target.cpp {
        assert(m_precedence_list != NULL);
        assert(m_precedence_map != NULL);
        assert(associativity_id != NULL);

        Associativity associativity = A_LEFT;
        if (associativity_id->GetText() == "left")
            associativity = A_LEFT;
        else if (associativity_id->GetText() == "nonassoc")
            associativity = A_NONASSOC;
        else if (associativity_id->GetText() == "right")
            associativity = A_RIGHT;
        else
            EmitError("invalid associativity specifier \"" + associativity_id->GetText() + "\"", associativity_id->GetFiLoc());

        Precedence *precedence =
            new Precedence(
                "DEFAULT_",
                associativity,
                throwaway1->GetFiLoc(),
                m_precedence_map->size(), // precedence_index
                m_precedence_map->size()); // precedence_level (to be offset by level of default precedence later)
        m_precedence_list->Append(precedence);
        m_precedence_map->Add(precedence->m_precedence_id, precedence);
        delete throwaway0;
        delete throwaway1;
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// nonterminal rules
// ///////////////////////////////////////////////////////////////////////////

// TODO: If `%type.cpp` isn't followed by a quoted string, there's a general parse error.
%nonterminal nonterminals // %type.cpp
:
    nonterminals nonterminal:nonterminal
    %target.cpp {
        assert(m_nonterminal_list != NULL);
        assert(m_nonterminal_map != NULL);
        if (nonterminal != NULL)
        {
            m_nonterminal_map->Add(nonterminal->GetText(), nonterminal);
            m_nonterminal_list->Append(nonterminal);
        }
        return NULL;
    }
|
    %empty
    %target.cpp {
        assert(m_nonterminal_list != NULL);
        assert(m_nonterminal_map != NULL);
        return NULL;
    }
;

%nonterminal nonterminal %type.cpp "Trison::Nonterminal *"
:
    nonterminal_specification:nonterminal ':' rules:rule_list ';'
    %target.cpp {
        if (nonterminal != NULL)
            nonterminal->SetRuleList(rule_list);
        else
            delete rule_list;
        return nonterminal;
    }
|
    // TODO: This should be %error[![%end|';']]
    %error[![%end]] ';'
    %target.cpp {
        EmitError("parse error in nonterminal definition", GetFiLoc());
        return NULL;
    }
;

%nonterminal nonterminal_specification %type.cpp "Trison::Nonterminal *"
:
    DIRECTIVE_NONTERMINAL:throwaway ID:id type_spec:assigned_type_map
    %target.cpp {
        assert(m_terminal_map != NULL);
        assert(m_token_index >= 0x100);
        assert(id != NULL);
        assert(assigned_type_map != NULL);
        if (m_terminal_map->Element(id->GetText()) != NULL)
            EmitError("id collision with terminal " + id->GetText(), id->GetFiLoc());
        Trison::Nonterminal *nonterminal =
            new Trison::Nonterminal(
                id->GetText(),
                m_token_index++,
                id->GetFiLoc(),
                assigned_type_map);
        delete throwaway;
        delete id;
        return nonterminal;
    }
|
    // TODO: add a %lookahead directive
    DIRECTIVE_NONTERMINAL:throwaway %error[![%end]]
    %target.cpp {
        assert(throwaway != NULL);
        EmitError("parse error while parsing nonterminal specification", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    }
|
    // TODO: add a %lookahead directive
    DIRECTIVE_NONTERMINAL:throwaway ID:id %error[![%end]]
    %target.cpp {
        assert(id != NULL);
        EmitError("parse error in %nonterminal directive", id->GetFiLoc());
        delete throwaway;
        delete id;
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// rule rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal rules %type.cpp "RuleList *"
:
    rules:rule_list '|' rule:rule
    %target.cpp {
        rule_list->Append(rule);
        return rule_list;
    }
|
    rule:rule
    %target.cpp {
        RuleList *rule_list = new RuleList();
        rule_list->Append(rule);
        return rule_list;
    }
|
    // TODO: add a %lookahead directive
    %error[![%end|'|'|';']]
    %target.cpp {
        EmitError("parse error in rule (note that an empty reduction rule must be specified by the %empty directive)", GetFiLoc());
        return new RuleList();
    }
;

%nonterminal rule %type.cpp "Rule *"
:
    rule_specification:rule rule_handlers:rule_handler_map
    %target.cpp {
        rule->m_rule_handler_map = rule_handler_map;
        return rule;
    }
;

%nonterminal rule_specification %type.cpp "Rule *"
:
    rule_token_list:rule_token_list lookahead_directive:lookahead_directive rule_precedence_directive:rule_precedence_directive
    %target.cpp {
        Precedence *rule_precedence;
        if (rule_precedence_directive == NULL)
            rule_precedence = m_precedence_map->Element("DEFAULT_");
        else if ((rule_precedence = m_precedence_map->Element(rule_precedence_directive->GetText())) == NULL)
        {
            EmitError("undefined %prec value \"" + rule_precedence_directive->GetText() + "\"");
            rule_precedence = m_precedence_map->Element("DEFAULT_");
        }

        Rule *rule = new Rule(rule_token_list, lookahead_directive, rule_precedence, m_rule_count++);
        delete rule_precedence_directive;
        return rule;
    }
;

%nonterminal rule_handlers %type.cpp "CommonLang::RuleHandlerMap *"
:
    rule_handlers:rule_handler_map rule_handler:rule_handler
    %target.cpp {
        if (rule_handler != NULL)
            rule_handler_map->Add(rule_handler->m_target_id->GetText(), rule_handler);
        return rule_handler_map;
    }
|
    %empty
    %target.cpp {
        return new CommonLang::RuleHandlerMap();
    }
;

%nonterminal rule_handler %type.cpp "CommonLang::RuleHandler *"
:
    DIRECTIVE_TARGET:throwaway '.' ID:target_id any_type_of_code_block:code_block
    %target.cpp {
        delete throwaway;
        assert(m_target_map != NULL);
        if (m_target_map->Element(target_id->GetText()) == NULL)
            EmitWarning(
                "undeclared target \"" + target_id->GetText() + "\"",
                target_id->GetFiLoc());
        return new CommonLang::RuleHandler(target_id, code_block);
    }
|
    DIRECTIVE_TARGET:throwaway %error[![%end]] any_type_of_code_block:code_block
    %target.cpp {
        assert(m_target_map != NULL);
        EmitError("parse error in target id after directive %target", throwaway->GetFiLoc());
        delete throwaway;
        delete code_block;
        return NULL;
    }
|
    // TODO: add a %lookahead directive
    DIRECTIVE_TARGET:throwaway %error[![%end]]
    %target.cpp {
        assert(m_target_map != NULL);
        EmitError("parse error in directive %target", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    }
|
    %error[![%end]] any_type_of_code_block:code_block
    %target.cpp {
        assert(m_target_map != NULL);
        EmitError("missing directive %target before rule handler code block", code_block->GetFiLoc());
        delete code_block;
        return NULL;
    }
;

%nonterminal rule_token_list %type.cpp "RuleTokenList *"
:
    nonempty_rule_token_list:rule_token_list
    %target.cpp {
        return rule_token_list;
    }
|
    // An empty reduction rule must be specified using the %empty directive.
    DIRECTIVE_EMPTY:throwaway
    %target.cpp {
        delete throwaway;
        return new RuleTokenList();
    }
;

%nonterminal nonempty_rule_token_list %type.cpp "RuleTokenList *"
:
    nonempty_rule_token_list:rule_token_list rule_token:rule_token
    %target.cpp {
        rule_token_list->Append(rule_token);
        return rule_token_list;
    }
|
    rule_token:rule_token
    %target.cpp {
        RuleTokenList *rule_token_list = new RuleTokenList();
        rule_token_list->Append(rule_token);
        return rule_token_list;
    }
;

%nonterminal rule_token %type.cpp "RuleToken *"
:
    token_id:token_id ':' ID:assigned_id
    %target.cpp {
        RuleToken *rule_token = NULL;
        assert(m_terminal_map != NULL);
        assert(m_nonterminal_map != NULL);
        if (token_id != NULL)
            rule_token = new RuleToken(token_id->GetText(), token_id->GetFiLoc(), assigned_id->GetText());
        delete token_id;
        delete assigned_id;
        return rule_token;
    }
|
    token_id:token_id
    %target.cpp {
        RuleToken *rule_token = NULL;
        assert(m_terminal_map != NULL);
        assert(m_nonterminal_map != NULL);
        if (token_id != NULL)
            rule_token = new RuleToken(token_id->GetText(), token_id->GetFiLoc());
        delete token_id;
        return rule_token;
    }
|
    DIRECTIVE_END:throwaway ':' ID:assigned_id
    %target.cpp {
        RuleToken *rule_token = new RuleToken("END_", throwaway->GetFiLoc(), assigned_id->GetText());
        delete throwaway;
        delete assigned_id;
        return rule_token;
    }
|
    DIRECTIVE_END:throwaway
    %target.cpp {
        RuleToken *rule_token = new RuleToken("END_", throwaway->GetFiLoc());
        delete throwaway;
        return rule_token;
    }
|
    DIRECTIVE_ERROR:throwaway ID:assigned_id
    %target.cpp {
        EmitError("%error directive must be followed by lookahead-specifier [a|b|...], where a, b, ... are the terminals which this error token won't accept, which must include %end and may not include %error", throwaway->GetFiLoc());
        // This is the minimal necessary token, although the EmitError call should prevent trison
        // from proceeding to parser generation.
        TokenSpecifierList *lookaheads = new TokenSpecifierList(throwaway->GetFiLoc());
        lookaheads->Append(new Ast::Id("END_", throwaway->GetFiLoc()));
        lookaheads->m_is_inverted = true;

        ErrorDirective *rule_token_error_until_lookahead = new ErrorDirective(throwaway->GetFiLoc(), lookaheads, assigned_id->GetText());
        delete throwaway;
        delete assigned_id;
        return rule_token_error_until_lookahead;
    }
|
    DIRECTIVE_ERROR:throwaway
    %target.cpp {
        // This is the minimal necessary token, although the EmitError call should prevent trison
        // from proceeding to parser generation.
        TokenSpecifierList *lookaheads = new TokenSpecifierList(throwaway->GetFiLoc());
        lookaheads->Append(new Ast::Id("END_", throwaway->GetFiLoc()));
        lookaheads->m_is_inverted = true;

        EmitError("%error directive must be followed by lookahead-specifier [a|b|...], where a, b, ... are the terminals which this error token won't accept, which must include %end and may not include %error", throwaway->GetFiLoc());

        ErrorDirective *rule_token_error_until_lookahead = new ErrorDirective(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    }
|
    DIRECTIVE_ERROR:throwaway bracketed_lookaheads:lookaheads ':' ID:assigned_id
    %target.cpp {
        assert(lookaheads != NULL);

        // TEMP HACK until done transitioning to inverted %error lookaheads
        lookaheads->m_is_inverted = true;

        // TODO: Maybe move this to ErrorDirective
        // Verify that the lookaheads include %end.  Also verify that it's a negated TokenSpecifierList
        // since the way the NPDA is generated depends on it.
        if (!lookaheads->m_is_inverted || lookaheads->Contains("END_"))
            EmitError("%error directive specifier (which defines the terminals which this error token won't accept) must include %end and may not include %error; e.g. %error[!%end] or %error[![%end|a|b]] etc.", throwaway->GetFiLoc());
        if (!lookaheads->Contains("ERROR_"))
            EmitError("%error directive may not exclude %error itself (meaning that %error may not appear in the terminals this error token won't accept); e.g. %error[![%end|%error]] is invalid.", throwaway->GetFiLoc());

        ErrorDirective *rule_token_error_until_lookahead = new ErrorDirective(throwaway->GetFiLoc(), lookaheads, assigned_id->GetText());
        delete throwaway;
        delete assigned_id;
        return rule_token_error_until_lookahead;
    }
|
    DIRECTIVE_ERROR:throwaway bracketed_lookaheads:lookaheads
    %target.cpp {
        assert(lookaheads != NULL);

        // TEMP HACK until done transitioning to inverted %error lookaheads
        lookaheads->m_is_inverted = true;

        // TODO: Maybe move this to ErrorDirective
        // Verify that the lookaheads include %end.  Also verify that it's a negated TokenSpecifierList
        // since the way the NPDA is generated depends on it.
        if (!lookaheads->m_is_inverted || lookaheads->Contains("END_"))
            EmitError("%error directive specifier (which defines the terminals which this error token won't accept) must include %end and may not include %error; e.g. %error[!%end] or %error[![%end|a|b]] etc.", throwaway->GetFiLoc());
        if (!lookaheads->Contains("ERROR_"))
            EmitError("%error directive may not exclude %error itself (meaning that %error may not appear in the terminals this error token won't accept); e.g. %error[![%end|%error]] is invalid.", throwaway->GetFiLoc());

        ErrorDirective *rule_token_error_until_lookahead = new ErrorDirective(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    }
;

%nonterminal lookahead_directive %type.cpp "LookaheadDirective *"
:
    DIRECTIVE_LOOKAHEAD:throwaway bracketed_lookaheads:lookaheads ':' ID:assigned_id
    %target.cpp {
        assert(lookaheads != NULL);
        assert(assigned_id != NULL);

        if (lookaheads->empty())
            EmitError("%lookahead directive terminal list may not be empty", throwaway->GetFiLoc());
        LookaheadDirective *lookahead_directive = new LookaheadDirective(throwaway->GetFiLoc(), lookaheads, assigned_id->GetText());

        delete throwaway;
        delete assigned_id;
        return lookahead_directive;
    }
|
    DIRECTIVE_LOOKAHEAD:throwaway bracketed_lookaheads:lookaheads
    %target.cpp {
        assert(lookaheads != NULL);

        if (lookaheads->empty())
            EmitError("%lookahead directive terminal list may not be empty", throwaway->GetFiLoc());
        LookaheadDirective *lookahead_directive = new LookaheadDirective(throwaway->GetFiLoc(), lookaheads);

        delete throwaway;
        return lookahead_directive;
    }
|
    %empty
    %target.cpp {
        return NULL;
    }
;

%nonterminal bracketed_lookaheads %type.cpp "TokenSpecifierList *"
:
    '[' lookahead_terminal_list:lookaheads ']'
    %target.cpp {
        assert(lookaheads != NULL);
        return lookaheads;
    }
|
    '[' '!' '[' lookahead_terminal_list:lookaheads ']' ']'
    %target.cpp {
        assert(lookaheads != NULL);
        lookaheads->m_is_inverted = !lookaheads->m_is_inverted;
        return lookaheads;
    }
|
    // This is a negated single lookahead
    '[' '!' lookahead_terminal:lookahead_terminal ']'
    %target.cpp {
        assert(lookahead_terminal != NULL);
        TokenSpecifierList *lookaheads = new TokenSpecifierList(lookahead_terminal->GetFiLoc());
        lookaheads->Append(lookahead_terminal);
        lookaheads->m_is_inverted = !lookaheads->m_is_inverted;
        return lookaheads;
    }
;

// An "or"ed sequence of lookaheads; e.g. a|b|c
%nonterminal lookahead_terminal_list %type.cpp "TokenSpecifierList *"
:
    lookahead_terminal_list:lookaheads '|' lookahead_terminal:lookahead_terminal
    %target.cpp {
        assert(lookahead_terminal != NULL);
        lookaheads->Append(lookahead_terminal);
        return lookaheads;
    }
|
    lookahead_terminal:lookahead_terminal
    %target.cpp {
        assert(lookahead_terminal != NULL);
        TokenSpecifierList *lookaheads = new TokenSpecifierList(lookahead_terminal->GetFiLoc());
        lookaheads->Append(lookahead_terminal);
        return lookaheads;
    }
;

%nonterminal lookahead_terminal %type.cpp "Ast::Id *"
:
    DIRECTIVE_END:throwaway
    %target.cpp {
        Ast::Id *t = new Ast::Id("END_", throwaway->GetFiLoc());
        delete throwaway;
        return t;
    }
|
    DIRECTIVE_ERROR:throwaway
    %target.cpp {
        Ast::Id *t = new Ast::Id("ERROR_", throwaway->GetFiLoc());
        delete throwaway;
        return t;
    }
|
    token_id:token_id
    %target.cpp {
        assert(token_id != NULL && "If this fails, it's ok, I just wasn't sure that the condition was necessary");
        Ast::Id *t = NULL;
        assert(m_terminal_map != NULL);
        if (token_id != NULL)
        {
            if (m_terminal_map->find(token_id->GetText()) == m_terminal_map->end())
                // TODO: This probably isn't going to print %end or %error correctly.
                EmitError(FORMAT("undeclared terminal \"" << token_id->GetText() << "\""), token_id->GetFiLoc());
            else
                t = new Ast::Id(token_id->GetText(), token_id->GetFiLoc());
        }
        delete token_id;
        return t;
    }
;

%nonterminal rule_precedence_directive %type.cpp "Ast::Id *"
:
    DIRECTIVE_PREC:throwaway ID:id
    %target.cpp {
        delete throwaway;
        return id;
    }
|
    %empty
    %target.cpp {
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// misc rules
// ///////////////////////////////////////////////////////////////////////////

%nonterminal at_least_zero_newlines
:
    at_least_zero_newlines NEWLINE %target.cpp { return NULL; }
|
    %empty %target.cpp { return NULL; }
;

%nonterminal at_least_one_newline
:
    at_least_one_newline NEWLINE %target.cpp { return NULL; }
|
    NEWLINE %target.cpp { return NULL; }
;

%nonterminal token_id %type.cpp "Ast::Id *"
:
    ID:id
    %target.cpp {
        return id;
    }
|
    CHAR_LITERAL:ch
    %target.cpp {
        Ast::Id *token_id = new Ast::Id(CharLiteral(ch->GetChar()), ch->GetFiLoc());
        delete ch;
        return token_id;
    }
;

%nonterminal terminal %type.cpp "Trison::Terminal *"
:
    ID:id           %target.cpp { return new Trison::Terminal(id, m_token_index++); }
|
    CHAR_LITERAL:ch %target.cpp { return new Trison::Terminal(ch); }
;

%nonterminal any_type_of_code_block %type.cpp "Ast::CodeBlock *"
:
    DUMB_CODE_BLOCK:dumb_code_block %target.cpp { return dumb_code_block; }
|
    STRICT_CODE_BLOCK:strict_code_block %target.cpp { return strict_code_block; }
;

%nonterminal type_spec %type.cpp "TypeMap *"
:
    type_spec:type_map DIRECTIVE_TYPE:throwaway '.' ID:target_id STRING_LITERAL:assigned_type
    %target.cpp {
        assert(type_map != NULL);
        assert(target_id != NULL);
        assert(assigned_type != NULL);
        type_map->Add(target_id->GetText(), assigned_type);
        delete throwaway;
        delete target_id;
        return type_map;
    }
|
    %empty
    %target.cpp {
        return new TypeMap();
    }
;

