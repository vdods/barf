// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// trison_parser.cpp generated by trison
// from trison_parser.trison using trison.cpp.targetspec and trison.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "trison_parser.hpp"


#define TRISON_CPP_DEBUG_CODE_(spew_code) if (DebugSpew()) { spew_code; }


#line 82 "trison_parser.trison"

#include <sstream>

#include "trison_ast.hpp"

namespace Trison {

#line 21 "trison_parser.cpp"

Parser::Parser ()
{
    DebugSpew(false);


#line 89 "trison_parser.trison"

    m_target_map = new CommonLang::TargetMap();

#line 32 "trison_parser.cpp"
}

Parser::~Parser ()
{
    // clean up dynamically allocated memory.
    ClearStack_();
    ClearLookaheadQueue_();



#line 92 "trison_parser.trison"

    // if the target map wasn't stolen by the user of this parser,
    // then make sure to delete it.
    delete m_target_map;
    m_target_map = NULL;

#line 50 "trison_parser.cpp"
}

bool Parser::IsAtEndOfInput ()
{
    return Lookahead_(0).m_id == Terminal::END_;
}

void Parser::ResetForNewInput ()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 63 "trison_parser.cpp"
 << " executing reset-for-new-input actions" << std::endl)

    // clean up stuff that might be hanging around from the last parse's input.
    ClearStack_();
    ClearLookaheadQueue_();


#line 208 "trison_parser.trison"

    m_scanner.ResetForNewInput();

#line 75 "trison_parser.cpp"
}

Parser::ParserReturnCode Parser::Parse (Ast::Base * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{

#line 98 "trison_parser.trison"

    m_terminal_list = NULL;
    m_terminal_map = NULL;
    m_token_index = 0;
    m_precedence_list = NULL;
    m_precedence_map = NULL;
    m_nonterminal_list = NULL;
    m_rule_count = 0;
    EmitExecutionMessage("starting trison parser");

#line 92 "trison_parser.cpp"

    ParserReturnCode const parse_return_code = Parse_(return_token, nonterminal_to_parse);


#line 108 "trison_parser.trison"

    if (parse_return_code == PRC_SUCCESS)
        EmitExecutionMessage("trison parse was successful");

#line 102 "trison_parser.cpp"

    return parse_return_code;
}

// ///////////////////////////////////////////////////////////////////////
// begin internal trison-generated parser guts -- don't use
// ///////////////////////////////////////////////////////////////////////

Parser::ParserReturnCode Parser::Parse_ (Ast::Base * *return_token, ParseNonterminal::Name nonterminal_to_parse)
{
    assert(return_token != NULL && "the return-token pointer must be non-NULL");

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 118 "trison_parser.cpp"
 << " starting parse" << std::endl)

    ParserReturnCode parser_return_code_ = PRC_UNHANDLED_PARSE_ERROR;
    *return_token = NULL;

    // make sure all our structures are empty and variables initialized.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();
    m_is_in_error_panic_ = false;

    // push the initial state of the DPDA.
    assert((false
           || nonterminal_to_parse == ParseNonterminal::any_type_of_code_block
           || nonterminal_to_parse == ParseNonterminal::at_least_one_newline
           || nonterminal_to_parse == ParseNonterminal::at_least_zero_newlines
           || nonterminal_to_parse == ParseNonterminal::lookahead_terminal
           || nonterminal_to_parse == ParseNonterminal::lookahead_terminal_list
           || nonterminal_to_parse == ParseNonterminal::maybe_assigned_id
           || nonterminal_to_parse == ParseNonterminal::nonterminal
           || nonterminal_to_parse == ParseNonterminal::nonterminal_specification
           || nonterminal_to_parse == ParseNonterminal::nonterminals
           || nonterminal_to_parse == ParseNonterminal::precedence_directive
           || nonterminal_to_parse == ParseNonterminal::precedence_directives
           || nonterminal_to_parse == ParseNonterminal::root
           || nonterminal_to_parse == ParseNonterminal::rule
           || nonterminal_to_parse == ParseNonterminal::rule_handler
           || nonterminal_to_parse == ParseNonterminal::rule_handlers
           || nonterminal_to_parse == ParseNonterminal::rule_precedence_directive
           || nonterminal_to_parse == ParseNonterminal::rule_specification
           || nonterminal_to_parse == ParseNonterminal::rule_token
           || nonterminal_to_parse == ParseNonterminal::rule_token_list
           || nonterminal_to_parse == ParseNonterminal::rules
           || nonterminal_to_parse == ParseNonterminal::start_directive
           || nonterminal_to_parse == ParseNonterminal::target_directive
           || nonterminal_to_parse == ParseNonterminal::target_directive_param
           || nonterminal_to_parse == ParseNonterminal::target_directives
           || nonterminal_to_parse == ParseNonterminal::target_ids
           || nonterminal_to_parse == ParseNonterminal::targets_directive
           || nonterminal_to_parse == ParseNonterminal::terminal
           || nonterminal_to_parse == ParseNonterminal::terminal_directive
           || nonterminal_to_parse == ParseNonterminal::terminal_directives
           || nonterminal_to_parse == ParseNonterminal::terminals
           || nonterminal_to_parse == ParseNonterminal::token_id
           || nonterminal_to_parse == ParseNonterminal::type_spec
           ) && "invalid nonterminal_to_parse");
    m_stack_.push_back(StackElement_(nonterminal_to_parse, Token(Nonterminal_::none_, NULL)));
    // main parser loop
    while (true)
    {
        if (m_is_in_error_panic_)
        {
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 175 "trison_parser.cpp"
 << " begin error panic" << std::endl)

            while (true)
            {
                // get the current state (top of the stack)
                assert(!m_stack_.empty());
                std::uint32_t current_state_index = m_stack_.back().m_state_index;
                assert(current_state_index < ms_state_count_);
                State_ const &current_state = ms_state_table_[current_state_index];
                TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

                // check if the current state accepts ERROR_ (only need to check the
                // non-default transitions, since the default transition can't be a shift).
                bool accepts_error = false;
                for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                       *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                     transition != transition_end;
                     ++transition)
                {
                    if (transition->m_type == Transition_::SHIFT && transition->m_lookahead_count == 1 && *transition->m_lookahead_sequence == Terminal::ERROR_)
                    {
                        accepts_error = true;
                        break;
                    }
                }

                if (accepts_error)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 207 "trison_parser.cpp"
 << " end error panic; success (current state accepts ERROR_ token)" << std::endl)
                    // if the current state accepts error, then we check if the lookahead token
                    // is Terminal::END_.  if it is, then we add a dummy Terminal::ERROR_ token
                    // in before it (since %error can't accept END_).  otherwise, we throw away
                    // the lookahead token, then clear the thrown-away token data, and set the
                    // token id to ERROR_.
                    assert(!m_lookahead_queue_.empty());
                    if (m_lookahead_queue_[0].m_id == Terminal::END_)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 220 "trison_parser.cpp"
 << " deferring Terminal::END_ (padding with Terminal::ERROR_ token)" << std::endl)
                        m_lookahead_queue_.push_front(Token(Terminal::END_)); // dummy value
                    }
                    else
                        ThrowAwayToken_(m_lookahead_queue_[0]);
                    m_lookahead_queue_[0].m_id = Terminal::ERROR_;
                    m_lookahead_queue_[0].m_data = NULL;
                    m_is_in_error_panic_ = false;
                    break;
                }
                else
                {
                    if (m_stack_.size() > 1)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 238 "trison_parser.cpp"
 << " continue error panic; pop stack (current state doesn't accept ERROR_ token)" << std::endl)
                    }
                    else
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 246 "trison_parser.cpp"
 << " end error panic; abort (stack is empty)" << std::endl)
                    }
                    // otherwise throw away the data at the top of the stack, and pop the stack.
                    // then if the stack is empty, an unhandled parse error occurred.
                    ThrowAwayStackElement_(m_stack_.back());
                    m_stack_.resize(m_stack_.size()-1);
                    if (m_stack_.empty())
                    {
                        // parser_return_code_ and return_token are already appropriately
                        // set, so just break out of the inner loop.
                        break;
                    }
                }
            }

            // if we're still in error panic, then this indicates that we bottomed-
            // out the stack and it's an unhandled parse error, so break from the
            // main loop.
            if (m_is_in_error_panic_)
                break;
        }
        else // !m_is_in_error_panic_
        {
            // get the current state (top of the stack)
            assert(!m_stack_.empty());
            std::uint32_t current_state_index = m_stack_.back().m_state_index;
            assert(current_state_index < ms_state_count_);
            State_ const &current_state = ms_state_table_[current_state_index];
            TRISON_CPP_DEBUG_CODE_(PrintParserStatus_(std::cerr))

            // TODO -- binary search for faster transition matching?

            // loop through the current state's transitions and see if any match
            bool transition_exercised = false;
            std::uint32_t tested_lookahead_count = 0;
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 285 "trison_parser.cpp"
 << " current transitions:" << std::endl)
            for (Transition_ const *transition = current_state.m_transition_table+1, // +1 because the first is the default
                                   *transition_end = current_state.m_transition_table+current_state.m_transition_count;
                transition != transition_end;
                ++transition)
            {
                // the non-default transitions can only be REDUCE or SHIFT
                assert(transition->m_type == Transition_::REDUCE || transition->m_type == Transition_::SHIFT);

                // make sure enough lookaheads are in the queue (this must be done before
                // checking if the lookaheads match because otherwise the debug-spew printing will
                // be interrupted by the debug-spew printing that happens in the call to Looahead_).
                if (transition->m_lookahead_count > 0)
                    Lookahead_(transition->m_lookahead_count - 1);

                // check if the lookaheads match those of this transition.
                bool lookahead_sequence_matched = true;
                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 306 "trison_parser.cpp"
 << "    transition with " << transition->m_lookahead_count << " lookahead(s):")
                for (std::uint32_t i = 0; i < transition->m_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << ms_token_name_table_[transition->m_lookahead_sequence[i]])
                    if (Lookahead_(i).m_id != transition->m_lookahead_sequence[i])
                    {
                        lookahead_sequence_matched = false;
                        break;
                    }
                    else
                    {
                        if (i+1 > tested_lookahead_count)
                            tested_lookahead_count = i+1;
                    }
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                // if all the lookaheads matched, then exercise this transition,
                // and break out of this inner (transition) loop.
                if (lookahead_sequence_matched)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 331 "trison_parser.cpp"
 << " currently usable lookahead(s):")
                    for (std::uint32_t i = 0; i < tested_lookahead_count; ++i)
                    {
                        TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                    }
                    TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                    ExerciseTransition_(*transition);
                    transition_exercised = true;
                    break;
                }
            }

            // if no transition was exercised, then exercise the default transition
            if (!transition_exercised)
            {
                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 351 "trison_parser.cpp"
 << " currently usable lookahead(s):")
                for (std::uint32_t i = 0; i < tested_lookahead_count; ++i)
                {
                    TRISON_CPP_DEBUG_CODE_(std::cerr << ' ' << Lookahead_(i))
                }
                TRISON_CPP_DEBUG_CODE_(std::cerr << std::endl)

                TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 362 "trison_parser.cpp"
 << " exercising default transition" << std::endl)
                // exercise the default transition.  a return value of true indicates
                // that the parser should return.
                if (ExerciseTransition_(*current_state.m_transition_table))
                {
                    // the token (data) on the top of the stack is the return token.
                    // set parser_return_code_ and assign the top stack token data to
                    // *return_token and then break out of the main parser loop.
                    assert(m_stack_[0].m_state_index == std::uint32_t(nonterminal_to_parse));
                    assert(m_stack_.size() == 2);
                    parser_return_code_ = PRC_SUCCESS;
                    *return_token = m_stack_.back().m_token.m_data;
                    // take the return token out of the stack, so it's not thrown away
                    // when we clear the stack later.
                    m_stack_.back().m_token.m_data = NULL;
                    break;
                }
            }
        }
    }

    // clear the stack, because we won't need it for the next parse.
    // we don't clear the lookahead queue here because we might want to
    // parse multiple times from the same input, and the lookahead queue
    // could have the next few tokens in it.
    ClearStack_();

    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_SUCCESS) std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 393 "trison_parser.cpp"
 << " Parse() is returning PRC_SUCCESS" << std::endl)
    TRISON_CPP_DEBUG_CODE_(if (parser_return_code_ == PRC_UNHANDLED_PARSE_ERROR) std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 398 "trison_parser.cpp"
 << " Parse() is returning PRC_UNHANDLED_PARSE_ERROR" << std::endl)

    return parser_return_code_;
}

void Parser::ThrowAwayToken_ (Token &token_) throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 409 "trison_parser.cpp"
 << " executing throw-away-token actions on token " << token_ << std::endl)

    ThrowAwayTokenData_(token_.m_data);
}

void Parser::ThrowAwayStackElement_ (StackElement_ &stack_element_) throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 420 "trison_parser.cpp"
 << " executing throw-away-token actions on token " << stack_element_.m_token << " corresponding to stack element with index " << stack_element_.m_state_index << std::endl)

    ThrowAwayTokenData_(stack_element_.m_token.m_data);
}

void Parser::ThrowAwayTokenData_ (Ast::Base * &token_data) throw()
{

#line 152 "trison_parser.trison"

    delete token_data;

#line 433 "trison_parser.cpp"
}

Parser::Token Parser::Scan_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 441 "trison_parser.cpp"
 << " executing scan actions" << std::endl)


#line 155 "trison_parser.trison"

    Ast::Base *lookahead_token_data = NULL;
    CommonLang::Scanner::Token::Type scanner_token_type = m_scanner.Scan(lookahead_token_data);
    assert(scanner_token_type >= 0);
    if (scanner_token_type < 0x100)
        return Token(Parser::Token::Id(scanner_token_type), lookahead_token_data);
    switch (scanner_token_type)
    {
        case CommonLang::Scanner::Token::BAD_END_OF_FILE:                     return Token(Terminal::END_, lookahead_token_data);
        case CommonLang::Scanner::Token::BAD_TOKEN:                           return Token(Terminal::BAD_TOKEN, lookahead_token_data);
        case CommonLang::Scanner::Token::CHAR_LITERAL:                        return Token(Terminal::CHAR_LITERAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL: return Token(Terminal::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_END:                       return Token(Terminal::DIRECTIVE_END, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_ERROR:                     return Token(Terminal::DIRECTIVE_ERROR, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_NONTERMINAL:               return Token(Terminal::DIRECTIVE_NONTERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_PREC:                      return Token(Terminal::DIRECTIVE_PREC, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TARGET:                    return Token(Terminal::DIRECTIVE_TARGET, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TARGETS:                   return Token(Terminal::DIRECTIVE_TARGETS, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TERMINAL:                  return Token(Terminal::DIRECTIVE_TERMINAL, lookahead_token_data);
        case CommonLang::Scanner::Token::DIRECTIVE_TYPE:                      return Token(Terminal::DIRECTIVE_TYPE, lookahead_token_data);
        case CommonLang::Scanner::Token::DUMB_CODE_BLOCK:                     return Token(Terminal::DUMB_CODE_BLOCK, lookahead_token_data);
        case CommonLang::Scanner::Token::END_OF_FILE:                         return Token(Terminal::END_, lookahead_token_data);
        case CommonLang::Scanner::Token::END_PREAMBLE:                        return Token(Terminal::END_PREAMBLE, lookahead_token_data);
        case CommonLang::Scanner::Token::ID:                                  return Token(Terminal::ID, lookahead_token_data);
        case CommonLang::Scanner::Token::NEWLINE:                             return Token(Terminal::NEWLINE, lookahead_token_data);
        case CommonLang::Scanner::Token::STRICT_CODE_BLOCK:                   return Token(Terminal::STRICT_CODE_BLOCK, lookahead_token_data);
        case CommonLang::Scanner::Token::STRING_LITERAL:                      return Token(Terminal::STRING_LITERAL, lookahead_token_data);

        case CommonLang::Scanner::Token::DIRECTIVE_ADD_CODESPEC:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_OPTIONAL_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_REQUIRED_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_CASE_INSENSITIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT:
        case CommonLang::Scanner::Token::DIRECTIVE_DUMB_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_ID:
        case CommonLang::Scanner::Token::DIRECTIVE_MACRO:
        case CommonLang::Scanner::Token::DIRECTIVE_START_IN_STATE_MACHINE:
        case CommonLang::Scanner::Token::DIRECTIVE_STRICT_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_STRING:
        case CommonLang::Scanner::Token::DIRECTIVE_UNGREEDY:
        case CommonLang::Scanner::Token::REGEX:
            assert(lookahead_token_data != NULL);
            EmitError("unrecognized token encountered in targetspec", lookahead_token_data->GetFiLoc());
            delete lookahead_token_data;
            return Token(Terminal::BAD_TOKEN);

        default:
            assert(false && "this should never happen");
            if (lookahead_token_data != NULL)
                delete lookahead_token_data;
            return Token(Terminal::BAD_TOKEN);
    }

#line 499 "trison_parser.cpp"
}

void Parser::ClearStack_ () throw()
{
    if (m_stack_.empty())
        return; // nothing to do

    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 510 "trison_parser.cpp"
 << " clearing the stack" << std::endl)

    Stack_::iterator it = m_stack_.begin();
    Stack_::iterator it_end = m_stack_.end();
    // skip the bottom of the stack, since it
    // contains the start state and no token data.
    ++it;
    for ( ; it != it_end; ++it)
        ThrowAwayStackElement_(*it);
    m_stack_.clear();
}

void Parser::ClearLookaheadQueue_ () throw()
{
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 528 "trison_parser.cpp"
 << " clearing the lookahead queue" << std::endl)

    for (LookaheadQueue_::iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
        ThrowAwayToken_(*it);
    m_lookahead_queue_.clear();
}

Parser::Token const &Parser::Lookahead_ (LookaheadQueue_::size_type index) throw()
{
    while (index >= m_lookahead_queue_.size())
    {
        m_lookahead_queue_.push_back(Scan_());

        TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 545 "trison_parser.cpp"
 << " pushed " << m_lookahead_queue_.back() << " onto back of lookahead queue" << std::endl)
    }
    return m_lookahead_queue_[index];
}

bool Parser::ExerciseTransition_ (Transition_ const &transition)
{
    switch (transition.m_type)
    {
        case Transition_::REDUCE:
        {
            // execute the indicated reduction rule, push the returned Token
            // onto the front of the lookahead queue, then pop the corresponding
            // number of stack elements.
            assert(transition.m_data < ms_rule_count_);
            Rule_ const &rule = ms_rule_table_[transition.m_data];
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 565 "trison_parser.cpp"
 << " REDUCE " << rule.m_description << std::endl)
            assert(m_stack_.size() > rule.m_token_count);
            m_lookahead_queue_.push_front(
                Token(
                    rule.m_reduction_nonterminal_token_id,
                    ExecuteReductionRule_(transition.m_data)));
            m_stack_.resize(m_stack_.size() - rule.m_token_count);
            assert(rule.m_reduction_nonterminal_token_id < ms_token_name_count_);
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 577 "trison_parser.cpp"
 << " pushed " << Token(rule.m_reduction_nonterminal_token_id) << " onto front of lookahead queue" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 582 "trison_parser.cpp"
 << std::endl)
            return false; // indicating the parser isn't returning
        }

        case Transition_::RETURN:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 591 "trison_parser.cpp"
 << " RETURN" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 596 "trison_parser.cpp"
 << std::endl)
            return true; // indicating the parser is returning

        case Transition_::SHIFT:
            // push the state (indicated by the shift transition) and token data
            // onto the stack, then pop the corresponding lookahead.
            assert(transition.m_data < ms_state_count_);
            assert(Lookahead_(0).m_id < ms_token_name_count_); // at this point, we're past a possible
                                                               // client error, so asserting here is ok.
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 609 "trison_parser.cpp"
 << " SHIFT " << Lookahead_(0) << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 614 "trison_parser.cpp"
 << std::endl)
            m_stack_.push_back(StackElement_(transition.m_data, Lookahead_(0)));
            m_lookahead_queue_.pop_front();
            return false; // indicating the parser isn't returning

        case Transition_::ERROR_PANIC:
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 624 "trison_parser.cpp"
 << " ERROR_PANIC" << std::endl)
            TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 629 "trison_parser.cpp"
 << std::endl)
            m_is_in_error_panic_ = true;
            return false; // indicating the parser isn't returning

        default:
            assert(false && "invalid transition type (bad state machine, or memory corruption)");
            return false; // indicating the parser isn't returning
    }
}

Parser::Token::Data Parser::ExecuteReductionRule_ (std::uint32_t const rule_index_) throw()
{
    assert(rule_index_ < ms_rule_count_);
    TRISON_CPP_DEBUG_CODE_(std::cerr << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 646 "trison_parser.cpp"
 << " executing reduction rule " << rule_index_ << std::endl)
    switch (rule_index_)
    {
        default:
            assert(false && "this should never happen");
            return NULL;

        case 0:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TerminalMap * terminal_map(Dsc<TerminalMap *>(m_stack_[m_stack_.size()-5].m_token.m_data));
            PrecedenceMap * precedence_map(Dsc<PrecedenceMap *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * default_parse_nonterminal_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            NonterminalMap * nonterminal_map(Dsc<NonterminalMap *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 255 "trison_parser.trison"

        assert(m_target_map != NULL);
        assert(m_terminal_list != NULL);
        assert(m_terminal_map != NULL);
        assert(terminal_map == m_terminal_map);
        assert(m_precedence_list != NULL);
        assert(precedence_map != NULL);
        assert(m_precedence_map == precedence_map);
        assert(m_nonterminal_list != NULL);

        // set the TargetMap's primary source path
        m_target_map->SetSourcePath(m_scanner.InputName());
        // make sure the %default_parse_nonterminal directive value specifies a real nonterminal
        if (default_parse_nonterminal_id != NULL &&
            nonterminal_map->Element(default_parse_nonterminal_id->GetText()) == NULL)
        {
            EmitError(
                "undeclared nonterminal \"" + default_parse_nonterminal_id->GetText() + "\"",
                default_parse_nonterminal_id->GetFiLoc());
        }

        PrimarySource *primary_source =
            new PrimarySource(
                m_terminal_list,
                terminal_map,
                precedence_map,
                m_precedence_list,
                default_parse_nonterminal_id->GetText(),
                throwaway->GetFiLoc(),
                m_nonterminal_list,
                nonterminal_map);
        delete throwaway;
        delete default_parse_nonterminal_id;
        return primary_source;
    
#line 699 "trison_parser.cpp"
            break;
        }

        case 1:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));

#line 299 "trison_parser.trison"

        delete throwaway;
        return NULL;
    
#line 713 "trison_parser.cpp"
            break;
        }

        case 2:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 305 "trison_parser.trison"

        return NULL;
    
#line 725 "trison_parser.cpp"
            break;
        }

        case 3:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));

#line 310 "trison_parser.trison"

        EmitError("parse error in directive %targets", throwaway->GetFiLoc());
        return NULL;
    
#line 739 "trison_parser.cpp"
            break;
        }

        case 4:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 319 "trison_parser.trison"

        assert(m_target_map != NULL);
        // if the given target doesn't exist in the target map, add it.
        if (m_target_map->Element(target_id->GetText()) == NULL)
        {
            CommonLang::Target *target = new CommonLang::Target(target_id->GetText());
            m_target_map->Add(target_id->GetText(), target);
        }
        // otherwise delete the target_id since we don't need it
        else
        {
            delete target_id;
        }
        return NULL;
    
#line 764 "trison_parser.cpp"
            break;
        }

        case 5:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 336 "trison_parser.trison"

        assert(m_target_map != NULL);
        return NULL;
    
#line 777 "trison_parser.cpp"
            break;
        }

        case 6:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            CommonLang::TargetDirective * target_directive(Dsc<CommonLang::TargetDirective *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 349 "trison_parser.trison"

        assert(m_target_map != NULL);
        m_target_map->SetTargetDirective(target_directive);
        return NULL;
    
#line 792 "trison_parser.cpp"
            break;
        }

        case 7:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 356 "trison_parser.trison"

        assert(m_target_map != NULL);
        return NULL;
    
#line 805 "trison_parser.cpp"
            break;
        }

        case 8:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-6].m_token.m_data));
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * target_directive(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::TextBase * param(Dsc<Ast::TextBase *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 365 "trison_parser.trison"

        delete throwaway;
        return new CommonLang::TargetDirective(target_id, target_directive, param);
    
#line 822 "trison_parser.cpp"
            break;
        }

        case 9:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-6].m_token.m_data));
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * target_directive(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 371 "trison_parser.trison"

        EmitError("parse error in parameter for directive %target." + target_id->GetText() + "." + target_directive->GetText(), throwaway->GetFiLoc());
        delete throwaway;
        delete target_id;
        delete target_directive;
        return NULL;
    
#line 841 "trison_parser.cpp"
            break;
        }

        case 10:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 380 "trison_parser.trison"

        EmitError("parse error in directive name for directive %target." + target_id->GetText(), throwaway->GetFiLoc());
        delete throwaway;
        delete target_id;
        return NULL;
    
#line 858 "trison_parser.cpp"
            break;
        }

        case 11:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 388 "trison_parser.trison"

        EmitError("parse error in target name for directive %target", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    
#line 873 "trison_parser.cpp"
            break;
        }

        case 12:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * value(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 397 "trison_parser.trison"
 return value; 
#line 884 "trison_parser.cpp"
            break;
        }

        case 13:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::String * value(Dsc<Ast::String *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 398 "trison_parser.trison"
 return value; 
#line 895 "trison_parser.cpp"
            break;
        }

        case 14:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::StrictCodeBlock * value(Dsc<Ast::StrictCodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 399 "trison_parser.trison"
 return value; 
#line 906 "trison_parser.cpp"
            break;
        }

        case 15:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::DumbCodeBlock * value(Dsc<Ast::DumbCodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 400 "trison_parser.trison"
 return value; 
#line 917 "trison_parser.cpp"
            break;
        }

        case 16:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 401 "trison_parser.trison"
 return NULL; 
#line 927 "trison_parser.cpp"
            break;
        }

        case 17:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TerminalMap * terminal_map(Dsc<TerminalMap *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 411 "trison_parser.trison"

        assert(terminal_map == m_terminal_map);
        return terminal_map;
    
#line 941 "trison_parser.cpp"
            break;
        }

        case 18:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 417 "trison_parser.trison"

        m_terminal_list = new TerminalList();
        m_terminal_map = new TerminalMap();

        Ast::Id *id;
        Trison::Terminal *terminal;

        // create and add the special END_ and ERROR_ terminals (with
        // token_index 0x100 and 0x101 respectively.
        assert(m_token_index == 0 && "must go from 0 to 0x100, all terminals, then all nonterminals");
        m_token_index = 0x100;

        id = new Ast::Id("END_", FiLoc::ms_invalid);
        terminal = new Trison::Terminal(id, m_token_index++);
        terminal->SetAssignedTypeMap(new TypeMap()); // default type
        m_terminal_list->Append(terminal);
        m_terminal_map->Add(terminal->GetText(), terminal);

        id = new Ast::Id("ERROR_", FiLoc::ms_invalid);
        terminal = new Trison::Terminal(id, m_token_index++);
        terminal->SetAssignedTypeMap(new TypeMap()); // default type
        m_terminal_list->Append(terminal);
        m_terminal_map->Add(terminal->GetText(), terminal);

        return m_terminal_map;
    
#line 976 "trison_parser.cpp"
            break;
        }

        case 19:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            TerminalList * terminal_list(Dsc<TerminalList *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            TypeMap * assigned_type_map(Dsc<TypeMap *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 448 "trison_parser.trison"

        assert(m_terminal_map != NULL);
        assert(terminal_list != NULL);
        assert(assigned_type_map != NULL);
        for (TerminalList::iterator it = terminal_list->begin(),
                                    it_end = terminal_list->end();
             it != it_end;
             ++it)
        {
            Trison::Terminal *terminal = *it;
            assert(terminal != NULL);
            terminal->SetAssignedTypeMap(assigned_type_map);
            m_terminal_list->Append(terminal);
            m_terminal_map->Add(terminal->GetText(), terminal);
        }
        terminal_list->clear();
        delete throwaway;
        delete terminal_list;
        return NULL;
    
#line 1008 "trison_parser.cpp"
            break;
        }

        case 20:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TerminalList * terminal_list(Dsc<TerminalList *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Trison::Terminal * terminal(Dsc<Trison::Terminal *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 473 "trison_parser.trison"

        if (terminal != NULL)
            terminal_list->Append(terminal);
        return terminal_list;
    
#line 1024 "trison_parser.cpp"
            break;
        }

        case 21:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Trison::Terminal * terminal(Dsc<Trison::Terminal *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 480 "trison_parser.trison"

        TerminalList *terminal_list = new TerminalList();
        if (terminal != NULL)
            terminal_list->Append(terminal);
        return terminal_list;
    
#line 1040 "trison_parser.cpp"
            break;
        }

        case 22:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            PrecedenceMap * precedence_map(Dsc<PrecedenceMap *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 495 "trison_parser.trison"

        assert(precedence_map != NULL);
        assert(m_precedence_map == precedence_map);
        assert(m_precedence_list != NULL);
        return precedence_map;
    
#line 1056 "trison_parser.cpp"
            break;
        }

        case 23:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 503 "trison_parser.trison"

        assert(m_precedence_list == NULL);
        assert(m_precedence_map == NULL);
        Precedence *precedence = new Precedence("DEFAULT_", A_LEFT, FiLoc::ms_invalid, 0);
        m_precedence_list = new PrecedenceList();
        m_precedence_list->Append(precedence);
        m_precedence_map = new PrecedenceMap();
        m_precedence_map->Add("DEFAULT_", precedence);
        return m_precedence_map;
    
#line 1075 "trison_parser.cpp"
            break;
        }

        case 24:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 518 "trison_parser.trison"

        assert(m_precedence_list != NULL);
        assert(m_precedence_map != NULL);
        Precedence *precedence =
            new Precedence(
                id->GetText(),
                A_NONASSOC,
                id->GetFiLoc(),
                m_precedence_map->size());
        m_precedence_list->Append(precedence);
        m_precedence_map->Add(precedence->m_precedence_id, precedence);
        delete throwaway;
        delete id;
        return m_precedence_map;
    
#line 1101 "trison_parser.cpp"
            break;
        }

        case 25:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-5].m_token.m_data));
            Ast::Id * associativity_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 535 "trison_parser.trison"

        assert(m_precedence_list != NULL);
        assert(m_precedence_map != NULL);
        assert(associativity_id != NULL);

        Associativity associativity = A_LEFT;
        if (associativity_id->GetText() == "left")
            associativity = A_LEFT;
        else if (associativity_id->GetText() == "nonassoc")
            associativity = A_NONASSOC;
        else if (associativity_id->GetText() == "right")
            associativity = A_RIGHT;
        else
            EmitError("invalid associativity specifier \"" + associativity_id->GetText() + "\"", throwaway->GetFiLoc());

        Precedence *precedence =
            new Precedence(
                id->GetText(),
                associativity,
                id->GetFiLoc(),
                m_precedence_map->size());
        m_precedence_list->Append(precedence);
        m_precedence_map->Add(precedence->m_precedence_id, precedence);
        delete throwaway;
        delete id;
        return m_precedence_map;
    
#line 1140 "trison_parser.cpp"
            break;
        }

        case 26:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 571 "trison_parser.trison"

        delete throwaway;
        return id;
    
#line 1155 "trison_parser.cpp"
            break;
        }

        case 27:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            NonterminalMap * nonterminal_map(Dsc<NonterminalMap *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Trison::Nonterminal * nonterminal(Dsc<Trison::Nonterminal *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 584 "trison_parser.trison"

        assert(m_terminal_map != NULL);
        assert(m_nonterminal_list != NULL);
        if (nonterminal != NULL)
        {
            nonterminal_map->Add(nonterminal->GetText(), nonterminal);
            m_nonterminal_list->Append(nonterminal);
        }
        return nonterminal_map;
    
#line 1176 "trison_parser.cpp"
            break;
        }

        case 28:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 596 "trison_parser.trison"

        assert(m_nonterminal_list == NULL);
        m_nonterminal_list = new NonterminalList();
        NonterminalMap *nonterminal_map = new NonterminalMap();

        // add the special "none_" nonterminal with token_index 0 and empty rule list
        Trison::Nonterminal *nonterminal = new Trison::Nonterminal("none_", 0, FiLoc::ms_invalid);
        nonterminal->SetRuleList(new RuleList());
        nonterminal_map->Add(nonterminal->GetText(), nonterminal);
        m_nonterminal_list->Append(nonterminal);

        return nonterminal_map;
    
#line 1198 "trison_parser.cpp"
            break;
        }

        case 29:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Trison::Nonterminal * nonterminal(Dsc<Trison::Nonterminal *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            RuleList * rule_list(Dsc<RuleList *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 614 "trison_parser.trison"

        if (nonterminal != NULL)
            nonterminal->SetRuleList(rule_list);
        else
            delete rule_list;
        return nonterminal;
    
#line 1216 "trison_parser.cpp"
            break;
        }

        case 30:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 623 "trison_parser.trison"

        EmitError("syntax error in nonterminal definition", GetFiLoc());
        return NULL;
    
#line 1229 "trison_parser.cpp"
            break;
        }

        case 31:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            TypeMap * assigned_type_map(Dsc<TypeMap *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 632 "trison_parser.trison"

        assert(m_terminal_map != NULL);
        assert(m_token_index >= 0x100);
        assert(id != NULL);
        assert(assigned_type_map != NULL);
        if (m_terminal_map->Element(id->GetText()) != NULL)
            EmitError("id collision with terminal " + id->GetText(), id->GetFiLoc());
        Trison::Nonterminal *nonterminal =
            new Trison::Nonterminal(
                id->GetText(),
                m_token_index++,
                id->GetFiLoc(),
                assigned_type_map);
        delete throwaway;
        delete id;
        return nonterminal;
    
#line 1258 "trison_parser.cpp"
            break;
        }

        case 32:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 651 "trison_parser.trison"

        assert(throwaway != NULL);
        EmitError("syntax error while parsing nonterminal specification", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    
#line 1274 "trison_parser.cpp"
            break;
        }

        case 33:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 659 "trison_parser.trison"

        assert(id != NULL);
        EmitError("syntax error in %nonterminal directive", id->GetFiLoc());
        delete throwaway;
        delete id;
        return NULL;
    
#line 1292 "trison_parser.cpp"
            break;
        }

        case 34:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RuleList * rule_list(Dsc<RuleList *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Rule * rule(Dsc<Rule *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 675 "trison_parser.trison"

        rule_list->Append(rule);
        return rule_list;
    
#line 1307 "trison_parser.cpp"
            break;
        }

        case 35:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Rule * rule(Dsc<Rule *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 681 "trison_parser.trison"

        RuleList *rule_list = new RuleList();
        rule_list->Append(rule);
        return rule_list;
    
#line 1322 "trison_parser.cpp"
            break;
        }

        case 36:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Rule * rule(Dsc<Rule *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            CommonLang::RuleHandlerMap * rule_handler_map(Dsc<CommonLang::RuleHandlerMap *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 691 "trison_parser.trison"

        rule->m_rule_handler_map = rule_handler_map;
        return rule;
    
#line 1337 "trison_parser.cpp"
            break;
        }

        case 37:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RuleTokenList * rule_token_list(Dsc<RuleTokenList *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::Id * rule_precedence_directive(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 700 "trison_parser.trison"

        Precedence *rule_precedence;
        if (rule_precedence_directive == NULL)
            rule_precedence = m_precedence_map->Element("DEFAULT_");
        else if ((rule_precedence = m_precedence_map->Element(rule_precedence_directive->GetText())) == NULL)
        {
            EmitError("undefined %prec value \"" + rule_precedence_directive->GetText() + "\"");
            rule_precedence = m_precedence_map->Element("DEFAULT_");
        }

        Rule *rule = new Rule(rule_token_list, rule_precedence, m_rule_count++);
        delete rule_precedence_directive;
        return rule;
    
#line 1362 "trison_parser.cpp"
            break;
        }

        case 38:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            CommonLang::RuleHandlerMap * rule_handler_map(Dsc<CommonLang::RuleHandlerMap *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            CommonLang::RuleHandler * rule_handler(Dsc<CommonLang::RuleHandler *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 719 "trison_parser.trison"

        if (rule_handler != NULL)
            rule_handler_map->Add(rule_handler->m_target_id->GetText(), rule_handler);
        return rule_handler_map;
    
#line 1378 "trison_parser.cpp"
            break;
        }

        case 39:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 726 "trison_parser.trison"

        return new CommonLang::RuleHandlerMap();
    
#line 1390 "trison_parser.cpp"
            break;
        }

        case 40:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::CodeBlock * code_block(Dsc<Ast::CodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 734 "trison_parser.trison"

        delete throwaway;
        assert(m_target_map != NULL);
        if (m_target_map->Element(target_id->GetText()) == NULL)
            EmitWarning(
                "undeclared target \"" + target_id->GetText() + "\"",
                target_id->GetFiLoc());
        return new CommonLang::RuleHandler(target_id, code_block);
    
#line 1411 "trison_parser.cpp"
            break;
        }

        case 41:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::CodeBlock * code_block(Dsc<Ast::CodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 745 "trison_parser.trison"

        assert(m_target_map != NULL);
        EmitError("parse error in target id after directive %target", throwaway->GetFiLoc());
        delete throwaway;
        delete code_block;
        return NULL;
    
#line 1429 "trison_parser.cpp"
            break;
        }

        case 42:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 754 "trison_parser.trison"

        assert(m_target_map != NULL);
        EmitError("parse error in directive %target", throwaway->GetFiLoc());
        delete throwaway;
        return NULL;
    
#line 1445 "trison_parser.cpp"
            break;
        }

        case 43:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::CodeBlock * code_block(Dsc<Ast::CodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 762 "trison_parser.trison"

        assert(m_target_map != NULL);
        EmitError("missing directive %target before rule handler code block", code_block->GetFiLoc());
        delete code_block;
        return NULL;
    
#line 1461 "trison_parser.cpp"
            break;
        }

        case 44:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RuleTokenList * rule_token_list(Dsc<RuleTokenList *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            RuleToken * rule_token(Dsc<RuleToken *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 773 "trison_parser.trison"

        rule_token_list->Append(rule_token);
        return rule_token_list;
    
#line 1476 "trison_parser.cpp"
            break;
        }

        case 45:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 779 "trison_parser.trison"

        return new RuleTokenList();
    
#line 1488 "trison_parser.cpp"
            break;
        }

        case 46:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TokenId * token_id(Dsc<TokenId *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * assigned_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 806 "trison_parser.trison"

        RuleToken *rule_token =
            token_id != NULL ?
            new RuleToken(token_id->GetText(), token_id->GetFiLoc(), assigned_id->GetText()) :
            NULL;
        delete token_id;
        delete assigned_id;
        return rule_token;
    
#line 1508 "trison_parser.cpp"
            break;
        }

        case 47:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TokenId * token_id(Dsc<TokenId *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 817 "trison_parser.trison"

        RuleToken *rule_token =
            token_id != NULL ?
            new RuleToken(token_id->GetText(), token_id->GetFiLoc()) :
            NULL;
        delete token_id;
        return rule_token;
    
#line 1526 "trison_parser.cpp"
            break;
        }

        case 48:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * assigned_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 838 "trison_parser.trison"

        RuleToken *rule_token = new RuleToken("END_", throwaway->GetFiLoc(), assigned_id->GetText());
        delete throwaway;
        delete assigned_id;
        return rule_token;
    
#line 1543 "trison_parser.cpp"
            break;
        }

        case 49:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 846 "trison_parser.trison"

        RuleToken *rule_token = new RuleToken("END_", throwaway->GetFiLoc());
        delete throwaway;
        return rule_token;
    
#line 1558 "trison_parser.cpp"
            break;
        }

        case 50:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::Id * assigned_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 906 "trison_parser.trison"

        EmitError("%error terminal must be followed by lookahead-specifier [a|b|...], where a, b, ... are the terminals which this error token won't accept, which must include %end", throwaway->GetFiLoc());
        // This is the minimal necessary token, although the EmitError call should prevent trison
        // from proceeding to parser generation.
        RuleTokenList *lookaheads = new RuleTokenList();
        lookaheads->Append(new RuleToken("END_", throwaway->GetFiLoc()));

        EmitError("%error terminal can't have an assigned id", throwaway->GetFiLoc());
        delete assigned_id;

        RuleTokenErrorUntilLookahead *rule_token_error_until_lookahead = new RuleTokenErrorUntilLookahead(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    
#line 1583 "trison_parser.cpp"
            break;
        }

        case 51:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 922 "trison_parser.trison"

        // This is the minimal necessary token, although the EmitError call should prevent trison
        // from proceeding to parser generation.
        RuleTokenList *lookaheads = new RuleTokenList();
        lookaheads->Append(new RuleToken("END_", throwaway->GetFiLoc()));

        EmitError("%error terminal must be followed by lookahead-specifier [a|b|...], where a, b, ... are the terminals which this error token won't accept, which must include %end", throwaway->GetFiLoc());

        RuleTokenErrorUntilLookahead *rule_token_error_until_lookahead = new RuleTokenErrorUntilLookahead(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    
#line 1605 "trison_parser.cpp"
            break;
        }

        case 52:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-5].m_token.m_data));
            RuleTokenList * lookaheads(Dsc<RuleTokenList *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            Ast::Id * assigned_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 937 "trison_parser.trison"

        EmitError("%error terminal can't have an assigned id", throwaway->GetFiLoc());
        delete assigned_id;
        RuleTokenErrorUntilLookahead *rule_token_error_until_lookahead = new RuleTokenErrorUntilLookahead(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    
#line 1624 "trison_parser.cpp"
            break;
        }

        case 53:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            RuleTokenList * lookaheads(Dsc<RuleTokenList *>(m_stack_[m_stack_.size()-2].m_token.m_data));

#line 946 "trison_parser.trison"

        RuleTokenErrorUntilLookahead *rule_token_error_until_lookahead = new RuleTokenErrorUntilLookahead(throwaway->GetFiLoc(), lookaheads);
        delete throwaway;
        return rule_token_error_until_lookahead;
    
#line 1640 "trison_parser.cpp"
            break;
        }

        case 54:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * assigned_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 969 "trison_parser.trison"

        return assigned_id;
    
#line 1653 "trison_parser.cpp"
            break;
        }

        case 55:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 974 "trison_parser.trison"

        return NULL;
    
#line 1665 "trison_parser.cpp"
            break;
        }

        case 56:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RuleTokenList * lookaheads(Dsc<RuleTokenList *>(m_stack_[m_stack_.size()-3].m_token.m_data));
            RuleToken * lookahead_terminal(Dsc<RuleToken *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 982 "trison_parser.trison"

        lookaheads->Append(lookahead_terminal);
        return lookaheads;
    
#line 1680 "trison_parser.cpp"
            break;
        }

        case 57:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            RuleToken * lookahead_terminal(Dsc<RuleToken *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 988 "trison_parser.trison"

        RuleTokenList *lookaheads = new RuleTokenList();
        lookaheads->Append(lookahead_terminal);
        return lookaheads;
    
#line 1695 "trison_parser.cpp"
            break;
        }

        case 58:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 998 "trison_parser.trison"

        RuleToken *rule_token = new RuleToken("END_", throwaway->GetFiLoc());
        delete throwaway;
        return rule_token;
    
#line 1710 "trison_parser.cpp"
            break;
        }

        case 59:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TokenId * token_id(Dsc<TokenId *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1005 "trison_parser.trison"

        assert(token_id != NULL && "If this fails, it's ok, I just wasn't sure that the condition was necessary");
        RuleToken *rule_token =
            token_id != NULL ?
            new RuleToken(token_id->GetText(), token_id->GetFiLoc()) :
            NULL;
        delete token_id;
        return rule_token;
    
#line 1729 "trison_parser.cpp"
            break;
        }

        case 60:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1019 "trison_parser.trison"

        delete throwaway;
        return id;
    
#line 1744 "trison_parser.cpp"
            break;
        }

        case 61:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1025 "trison_parser.trison"

        return NULL;
    
#line 1756 "trison_parser.cpp"
            break;
        }

        case 62:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1036 "trison_parser.trison"
 return NULL; 
#line 1766 "trison_parser.cpp"
            break;
        }

        case 63:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1038 "trison_parser.trison"
 return NULL; 
#line 1776 "trison_parser.cpp"
            break;
        }

        case 64:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1043 "trison_parser.trison"
 return NULL; 
#line 1786 "trison_parser.cpp"
            break;
        }

        case 65:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1045 "trison_parser.trison"
 return NULL; 
#line 1796 "trison_parser.cpp"
            break;
        }

        case 66:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1051 "trison_parser.trison"

        // here, the token_index doesn't matter, since this rule isn't used
        // in the terminal declarations.
        TokenId *token_id = new TokenId(id->GetText(), 0, id->GetFiLoc());
        delete id;
        return token_id;
    
#line 1813 "trison_parser.cpp"
            break;
        }

        case 67:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Char * ch(Dsc<Ast::Char *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1060 "trison_parser.trison"

        // here, the token_index doesn't matter, since this rule isn't used
        // in the terminal declarations.
        TokenId *token_id = new TokenId(CharLiteral(ch->GetChar()), 0, ch->GetFiLoc());
        delete ch;
        return token_id;
    
#line 1830 "trison_parser.cpp"
            break;
        }

        case 68:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Id * id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1071 "trison_parser.trison"
 return new Trison::Terminal(id, m_token_index++); 
#line 1841 "trison_parser.cpp"
            break;
        }

        case 69:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::Char * ch(Dsc<Ast::Char *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1073 "trison_parser.trison"
 return new Trison::Terminal(ch); 
#line 1852 "trison_parser.cpp"
            break;
        }

        case 70:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::DumbCodeBlock * dumb_code_block(Dsc<Ast::DumbCodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1078 "trison_parser.trison"
 return dumb_code_block; 
#line 1863 "trison_parser.cpp"
            break;
        }

        case 71:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            Ast::StrictCodeBlock * strict_code_block(Dsc<Ast::StrictCodeBlock *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1080 "trison_parser.trison"
 return strict_code_block; 
#line 1874 "trison_parser.cpp"
            break;
        }

        case 72:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());
            TypeMap * type_map(Dsc<TypeMap *>(m_stack_[m_stack_.size()-5].m_token.m_data));
            Ast::ThrowAway * throwaway(Dsc<Ast::ThrowAway *>(m_stack_[m_stack_.size()-4].m_token.m_data));
            Ast::Id * target_id(Dsc<Ast::Id *>(m_stack_[m_stack_.size()-2].m_token.m_data));
            Ast::String * assigned_type(Dsc<Ast::String *>(m_stack_[m_stack_.size()-1].m_token.m_data));

#line 1086 "trison_parser.trison"

        assert(type_map != NULL);
        assert(target_id != NULL);
        assert(assigned_type != NULL);
        type_map->Add(target_id->GetText(), assigned_type);
        delete throwaway;
        delete target_id;
        return type_map;
    
#line 1896 "trison_parser.cpp"
            break;
        }

        case 73:
        {
            assert(ms_rule_table_[rule_index_].m_token_count < m_stack_.size());

#line 1097 "trison_parser.trison"

        return new TypeMap();
    
#line 1908 "trison_parser.cpp"
            break;
        }

    }

    assert(false && "no value returned from reduction rule code block");
    return NULL;
}

void Parser::PrintParserStatus_ (std::ostream &stream) const
{
    assert(!m_stack_.empty());

    stream << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1925 "trison_parser.cpp"
 << " parser state stack: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        stream << it->m_state_index;
        Stack_::const_iterator next_it = it;
        if (++next_it != it_end)
            stream << ' ';
    }
    stream << std::endl;

    assert(m_stack_.size() >= 1);
    assert(m_stack_.front().m_token.m_id == std::uint32_t(Nonterminal_::none_));
    stream << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1941 "trison_parser.cpp"
 << " parser stack tokens . lookahead queue: ";
    for (Stack_::const_iterator it = m_stack_.begin(), it_end = m_stack_.end(); it != it_end; ++it)
    {
        // the first token is always Nonterminal_::none_, which doesn't correspond to a real token, so skip it.
        if (it == m_stack_.begin())
            continue;
        stream << it->m_token << ' ';
    }
    stream << '.';
    for (LookaheadQueue_::const_iterator it = m_lookahead_queue_.begin(), it_end = m_lookahead_queue_.end(); it != it_end; ++it)
    {
        Token const &lookahead_token = *it;
        assert(lookahead_token.m_id < ms_token_name_count_ && "Token id out of range");
        stream << ' ' << lookahead_token;
    }
    stream << std::endl;

    PrintIndented_(stream, ms_state_table_[m_stack_.back().m_state_index].m_description);
    stream << std::endl;
}

void Parser::PrintIndented_ (std::ostream &stream, char const *string) const
{
    assert(string != NULL);
    stream << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1969 "trison_parser.cpp"
 << "    ";
    while (*string != '\0')
    {
        if (*string == '\n')
            stream << '\n' << 
#line 214 "trison_parser.trison"
"Trison::Parser" << (GetFiLoc().IsValid() ? " ("+GetFiLoc().AsString()+")" : g_empty_string) << ":"
#line 1977 "trison_parser.cpp"
 << "    ";
        else
            stream << *string;
        ++string;
    }
}

std::ostream &operator << (std::ostream &stream, Parser::Token const &token)
{
    if (token.m_id < Parser::ms_token_name_count_)
        stream << Parser::ms_token_name_table_[token.m_id];
    else
        stream << "!INVALID TOKEN!";
    return stream;
}

Parser::Rule_ const Parser::ms_rule_table_[] =
{
    { Parser::Nonterminal_::root, 8, "root <- at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals" },
    { Parser::Nonterminal_::targets_directive, 3, "targets_directive <- DIRECTIVE_TARGETS target_ids at_least_one_newline" },
    { Parser::Nonterminal_::targets_directive, 0, "targets_directive <-" },
    { Parser::Nonterminal_::targets_directive, 3, "targets_directive <- DIRECTIVE_TARGETS ERROR_ at_least_one_newline" },
    { Parser::Nonterminal_::target_ids, 2, "target_ids <- target_ids ID" },
    { Parser::Nonterminal_::target_ids, 0, "target_ids <-" },
    { Parser::Nonterminal_::target_directives, 3, "target_directives <- target_directives target_directive at_least_one_newline" },
    { Parser::Nonterminal_::target_directives, 0, "target_directives <-" },
    { Parser::Nonterminal_::target_directive, 6, "target_directive <- DIRECTIVE_TARGET '.' ID '.' ID target_directive_param" },
    { Parser::Nonterminal_::target_directive, 6, "target_directive <- DIRECTIVE_TARGET '.' ID '.' ID ERROR_" },
    { Parser::Nonterminal_::target_directive, 4, "target_directive <- DIRECTIVE_TARGET '.' ID ERROR_" },
    { Parser::Nonterminal_::target_directive, 2, "target_directive <- DIRECTIVE_TARGET ERROR_" },
    { Parser::Nonterminal_::target_directive_param, 1, "target_directive_param <- ID" },
    { Parser::Nonterminal_::target_directive_param, 1, "target_directive_param <- STRING_LITERAL" },
    { Parser::Nonterminal_::target_directive_param, 1, "target_directive_param <- STRICT_CODE_BLOCK" },
    { Parser::Nonterminal_::target_directive_param, 1, "target_directive_param <- DUMB_CODE_BLOCK" },
    { Parser::Nonterminal_::target_directive_param, 0, "target_directive_param <-" },
    { Parser::Nonterminal_::terminal_directives, 2, "terminal_directives <- terminal_directives terminal_directive" },
    { Parser::Nonterminal_::terminal_directives, 0, "terminal_directives <-" },
    { Parser::Nonterminal_::terminal_directive, 4, "terminal_directive <- DIRECTIVE_TERMINAL terminals type_spec at_least_one_newline" },
    { Parser::Nonterminal_::terminals, 2, "terminals <- terminals terminal" },
    { Parser::Nonterminal_::terminals, 1, "terminals <- terminal" },
    { Parser::Nonterminal_::precedence_directives, 2, "precedence_directives <- precedence_directives precedence_directive" },
    { Parser::Nonterminal_::precedence_directives, 0, "precedence_directives <-" },
    { Parser::Nonterminal_::precedence_directive, 3, "precedence_directive <- DIRECTIVE_PREC ID at_least_one_newline" },
    { Parser::Nonterminal_::precedence_directive, 5, "precedence_directive <- DIRECTIVE_PREC '.' ID ID at_least_one_newline" },
    { Parser::Nonterminal_::start_directive, 3, "start_directive <- DIRECTIVE_DEFAULT_PARSE_NONTERMINAL ID at_least_one_newline" },
    { Parser::Nonterminal_::nonterminals, 2, "nonterminals <- nonterminals nonterminal" },
    { Parser::Nonterminal_::nonterminals, 0, "nonterminals <-" },
    { Parser::Nonterminal_::nonterminal, 4, "nonterminal <- nonterminal_specification ':' rules ';'" },
    { Parser::Nonterminal_::nonterminal, 2, "nonterminal <- ERROR_ ';'" },
    { Parser::Nonterminal_::nonterminal_specification, 3, "nonterminal_specification <- DIRECTIVE_NONTERMINAL ID type_spec" },
    { Parser::Nonterminal_::nonterminal_specification, 2, "nonterminal_specification <- DIRECTIVE_NONTERMINAL ERROR_" },
    { Parser::Nonterminal_::nonterminal_specification, 3, "nonterminal_specification <- DIRECTIVE_NONTERMINAL ID ERROR_" },
    { Parser::Nonterminal_::rules, 3, "rules <- rules '|' rule" },
    { Parser::Nonterminal_::rules, 1, "rules <- rule" },
    { Parser::Nonterminal_::rule, 2, "rule <- rule_specification rule_handlers" },
    { Parser::Nonterminal_::rule_specification, 2, "rule_specification <- rule_token_list rule_precedence_directive" },
    { Parser::Nonterminal_::rule_handlers, 2, "rule_handlers <- rule_handlers rule_handler" },
    { Parser::Nonterminal_::rule_handlers, 0, "rule_handlers <-" },
    { Parser::Nonterminal_::rule_handler, 4, "rule_handler <- DIRECTIVE_TARGET '.' ID any_type_of_code_block" },
    { Parser::Nonterminal_::rule_handler, 3, "rule_handler <- DIRECTIVE_TARGET ERROR_ any_type_of_code_block" },
    { Parser::Nonterminal_::rule_handler, 2, "rule_handler <- DIRECTIVE_TARGET ERROR_" },
    { Parser::Nonterminal_::rule_handler, 2, "rule_handler <- ERROR_ any_type_of_code_block" },
    { Parser::Nonterminal_::rule_token_list, 2, "rule_token_list <- rule_token_list rule_token" },
    { Parser::Nonterminal_::rule_token_list, 0, "rule_token_list <-" },
    { Parser::Nonterminal_::rule_token, 3, "rule_token <- token_id ':' ID" },
    { Parser::Nonterminal_::rule_token, 1, "rule_token <- token_id" },
    { Parser::Nonterminal_::rule_token, 3, "rule_token <- DIRECTIVE_END ':' ID" },
    { Parser::Nonterminal_::rule_token, 1, "rule_token <- DIRECTIVE_END" },
    { Parser::Nonterminal_::rule_token, 2, "rule_token <- DIRECTIVE_ERROR ID" },
    { Parser::Nonterminal_::rule_token, 1, "rule_token <- DIRECTIVE_ERROR" },
    { Parser::Nonterminal_::rule_token, 5, "rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list ']' ID" },
    { Parser::Nonterminal_::rule_token, 4, "rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list ']'" },
    { Parser::Nonterminal_::maybe_assigned_id, 2, "maybe_assigned_id <- ':' ID" },
    { Parser::Nonterminal_::maybe_assigned_id, 0, "maybe_assigned_id <-" },
    { Parser::Nonterminal_::lookahead_terminal_list, 3, "lookahead_terminal_list <- lookahead_terminal_list '|' lookahead_terminal" },
    { Parser::Nonterminal_::lookahead_terminal_list, 1, "lookahead_terminal_list <- lookahead_terminal" },
    { Parser::Nonterminal_::lookahead_terminal, 1, "lookahead_terminal <- DIRECTIVE_END" },
    { Parser::Nonterminal_::lookahead_terminal, 1, "lookahead_terminal <- token_id" },
    { Parser::Nonterminal_::rule_precedence_directive, 2, "rule_precedence_directive <- DIRECTIVE_PREC ID" },
    { Parser::Nonterminal_::rule_precedence_directive, 0, "rule_precedence_directive <-" },
    { Parser::Nonterminal_::at_least_zero_newlines, 2, "at_least_zero_newlines <- at_least_zero_newlines NEWLINE" },
    { Parser::Nonterminal_::at_least_zero_newlines, 0, "at_least_zero_newlines <-" },
    { Parser::Nonterminal_::at_least_one_newline, 2, "at_least_one_newline <- at_least_one_newline NEWLINE" },
    { Parser::Nonterminal_::at_least_one_newline, 1, "at_least_one_newline <- NEWLINE" },
    { Parser::Nonterminal_::token_id, 1, "token_id <- ID" },
    { Parser::Nonterminal_::token_id, 1, "token_id <- CHAR_LITERAL" },
    { Parser::Nonterminal_::terminal, 1, "terminal <- ID" },
    { Parser::Nonterminal_::terminal, 1, "terminal <- CHAR_LITERAL" },
    { Parser::Nonterminal_::any_type_of_code_block, 1, "any_type_of_code_block <- DUMB_CODE_BLOCK" },
    { Parser::Nonterminal_::any_type_of_code_block, 1, "any_type_of_code_block <- STRICT_CODE_BLOCK" },
    { Parser::Nonterminal_::type_spec, 5, "type_spec <- type_spec DIRECTIVE_TYPE '.' ID STRING_LITERAL" },
    { Parser::Nonterminal_::type_spec, 0, "type_spec <-" }
};
std::size_t const Parser::ms_rule_count_ = sizeof(Parser::ms_rule_table_) / sizeof(*Parser::ms_rule_table_);

Parser::State_ const Parser::ms_state_table_[] =
{
    { 3, ms_transition_table_+0, "START root                                                                                                                                                      \nrule 0: root <- . at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals\nrule 62: at_least_zero_newlines <- . at_least_zero_newlines NEWLINE                                                                                             \nrule 63: at_least_zero_newlines <- .                                                                                                                            " },
    { 1, ms_transition_table_+3, "RETURN root" },
    { 4, ms_transition_table_+4, "rule 0: root <- at_least_zero_newlines . targets_directive target_directives terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals\nrule 62: at_least_zero_newlines <- at_least_zero_newlines . NEWLINE                                                                                             \nrule 1: targets_directive <- . DIRECTIVE_TARGETS target_ids at_least_one_newline                                                                                \nrule 2: targets_directive <- .                                                                                                                                  \nrule 3: targets_directive <- . DIRECTIVE_TARGETS ERROR_ at_least_one_newline                                                                                    " },
    { 3, ms_transition_table_+8, "rule 1: targets_directive <- DIRECTIVE_TARGETS . target_ids at_least_one_newline\nrule 4: target_ids <- . target_ids ID                                           \nrule 5: target_ids <- .                                                         \nrule 3: targets_directive <- DIRECTIVE_TARGETS . ERROR_ at_least_one_newline    " },
    { 3, ms_transition_table_+11, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE             \nrule 65: at_least_one_newline <- . NEWLINE                                  \nrule 3: targets_directive <- DIRECTIVE_TARGETS ERROR_ . at_least_one_newline" },
    { 1, ms_transition_table_+14, "rule 65: at_least_one_newline <- NEWLINE ." },
    { 2, ms_transition_table_+15, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE             \nrule 3: targets_directive <- DIRECTIVE_TARGETS ERROR_ at_least_one_newline ." },
    { 1, ms_transition_table_+17, "rule 64: at_least_one_newline <- at_least_one_newline NEWLINE ." },
    { 4, ms_transition_table_+18, "rule 1: targets_directive <- DIRECTIVE_TARGETS target_ids . at_least_one_newline\nrule 4: target_ids <- target_ids . ID                                           \nrule 64: at_least_one_newline <- . at_least_one_newline NEWLINE                 \nrule 65: at_least_one_newline <- . NEWLINE                                      " },
    { 1, ms_transition_table_+22, "rule 4: target_ids <- target_ids ID ." },
    { 2, ms_transition_table_+23, "rule 1: targets_directive <- DIRECTIVE_TARGETS target_ids at_least_one_newline .\nrule 64: at_least_one_newline <- at_least_one_newline . NEWLINE                 " },
    { 1, ms_transition_table_+25, "rule 62: at_least_zero_newlines <- at_least_zero_newlines NEWLINE ." },
    { 2, ms_transition_table_+26, "rule 0: root <- at_least_zero_newlines targets_directive . target_directives terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals\nrule 6: target_directives <- . target_directives target_directive at_least_one_newline                                                                          \nrule 7: target_directives <- .                                                                                                                                  " },
    { 4, ms_transition_table_+28, "rule 0: root <- at_least_zero_newlines targets_directive target_directives . terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals\nrule 6: target_directives <- target_directives . target_directive at_least_one_newline                                                                          \nrule 8: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID target_directive_param                                                                             \nrule 9: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID ERROR_                                                                                             \nrule 10: target_directive <- . DIRECTIVE_TARGET '.' ID ERROR_                                                                                                   \nrule 11: target_directive <- . DIRECTIVE_TARGET ERROR_                                                                                                          \nrule 17: terminal_directives <- . terminal_directives terminal_directive                                                                                        \nrule 18: terminal_directives <- .                                                                                                                               " },
    { 3, ms_transition_table_+32, "rule 8: target_directive <- DIRECTIVE_TARGET . '.' ID '.' ID target_directive_param\nrule 9: target_directive <- DIRECTIVE_TARGET . '.' ID '.' ID ERROR_                \nrule 10: target_directive <- DIRECTIVE_TARGET . '.' ID ERROR_                      \nrule 11: target_directive <- DIRECTIVE_TARGET . ERROR_                             " },
    { 2, ms_transition_table_+35, "rule 8: target_directive <- DIRECTIVE_TARGET '.' . ID '.' ID target_directive_param\nrule 9: target_directive <- DIRECTIVE_TARGET '.' . ID '.' ID ERROR_                \nrule 10: target_directive <- DIRECTIVE_TARGET '.' . ID ERROR_                      " },
    { 3, ms_transition_table_+37, "rule 8: target_directive <- DIRECTIVE_TARGET '.' ID . '.' ID target_directive_param\nrule 9: target_directive <- DIRECTIVE_TARGET '.' ID . '.' ID ERROR_                \nrule 10: target_directive <- DIRECTIVE_TARGET '.' ID . ERROR_                      " },
    { 2, ms_transition_table_+40, "rule 8: target_directive <- DIRECTIVE_TARGET '.' ID '.' . ID target_directive_param\nrule 9: target_directive <- DIRECTIVE_TARGET '.' ID '.' . ID ERROR_                " },
    { 7, ms_transition_table_+42, "rule 8: target_directive <- DIRECTIVE_TARGET '.' ID '.' ID . target_directive_param\nrule 12: target_directive_param <- . ID                                            \nrule 13: target_directive_param <- . STRING_LITERAL                                \nrule 14: target_directive_param <- . STRICT_CODE_BLOCK                             \nrule 15: target_directive_param <- . DUMB_CODE_BLOCK                               \nrule 16: target_directive_param <- .                                               \nrule 9: target_directive <- DIRECTIVE_TARGET '.' ID '.' ID . ERROR_                " },
    { 1, ms_transition_table_+49, "rule 9: target_directive <- DIRECTIVE_TARGET '.' ID '.' ID ERROR_ ." },
    { 1, ms_transition_table_+50, "rule 15: target_directive_param <- DUMB_CODE_BLOCK ." },
    { 1, ms_transition_table_+51, "rule 12: target_directive_param <- ID ." },
    { 1, ms_transition_table_+52, "rule 14: target_directive_param <- STRICT_CODE_BLOCK ." },
    { 1, ms_transition_table_+53, "rule 13: target_directive_param <- STRING_LITERAL ." },
    { 1, ms_transition_table_+54, "rule 8: target_directive <- DIRECTIVE_TARGET '.' ID '.' ID target_directive_param ." },
    { 1, ms_transition_table_+55, "rule 10: target_directive <- DIRECTIVE_TARGET '.' ID ERROR_ ." },
    { 1, ms_transition_table_+56, "rule 11: target_directive <- DIRECTIVE_TARGET ERROR_ ." },
    { 3, ms_transition_table_+57, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE                       \nrule 65: at_least_one_newline <- . NEWLINE                                            \nrule 6: target_directives <- target_directives target_directive . at_least_one_newline" },
    { 2, ms_transition_table_+60, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE                       \nrule 6: target_directives <- target_directives target_directive at_least_one_newline ." },
    { 4, ms_transition_table_+62, "rule 0: root <- at_least_zero_newlines targets_directive target_directives terminal_directives . precedence_directives start_directive END_PREAMBLE nonterminals\nrule 17: terminal_directives <- terminal_directives . terminal_directive                                                                                        \nrule 19: terminal_directive <- . DIRECTIVE_TERMINAL terminals type_spec at_least_one_newline                                                                    \nrule 22: precedence_directives <- . precedence_directives precedence_directive                                                                                  \nrule 23: precedence_directives <- .                                                                                                                             " },
    { 5, ms_transition_table_+66, "rule 19: terminal_directive <- DIRECTIVE_TERMINAL . terminals type_spec at_least_one_newline\nrule 20: terminals <- . terminals terminal                                                  \nrule 68: terminal <- . ID                                                                   \nrule 69: terminal <- . CHAR_LITERAL                                                         \nrule 21: terminals <- . terminal                                                            " },
    { 1, ms_transition_table_+71, "rule 69: terminal <- CHAR_LITERAL ." },
    { 1, ms_transition_table_+72, "rule 68: terminal <- ID ." },
    { 5, ms_transition_table_+73, "rule 19: terminal_directive <- DIRECTIVE_TERMINAL terminals . type_spec at_least_one_newline\nrule 20: terminals <- terminals . terminal                                                  \nrule 68: terminal <- . ID                                                                   \nrule 69: terminal <- . CHAR_LITERAL                                                         \nrule 72: type_spec <- . type_spec DIRECTIVE_TYPE '.' ID STRING_LITERAL                      \nrule 73: type_spec <- .                                                                     " },
    { 1, ms_transition_table_+78, "rule 20: terminals <- terminals terminal ." },
    { 4, ms_transition_table_+79, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE                             \nrule 65: at_least_one_newline <- . NEWLINE                                                  \nrule 19: terminal_directive <- DIRECTIVE_TERMINAL terminals type_spec . at_least_one_newline\nrule 72: type_spec <- type_spec . DIRECTIVE_TYPE '.' ID STRING_LITERAL                      " },
    { 2, ms_transition_table_+83, "rule 72: type_spec <- type_spec DIRECTIVE_TYPE . '.' ID STRING_LITERAL" },
    { 2, ms_transition_table_+85, "rule 72: type_spec <- type_spec DIRECTIVE_TYPE '.' . ID STRING_LITERAL" },
    { 2, ms_transition_table_+87, "rule 72: type_spec <- type_spec DIRECTIVE_TYPE '.' ID . STRING_LITERAL" },
    { 1, ms_transition_table_+89, "rule 72: type_spec <- type_spec DIRECTIVE_TYPE '.' ID STRING_LITERAL ." },
    { 2, ms_transition_table_+90, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE                             \nrule 19: terminal_directive <- DIRECTIVE_TERMINAL terminals type_spec at_least_one_newline ." },
    { 1, ms_transition_table_+92, "rule 21: terminals <- terminal ." },
    { 1, ms_transition_table_+93, "rule 17: terminal_directives <- terminal_directives terminal_directive ." },
    { 5, ms_transition_table_+94, "rule 0: root <- at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives . start_directive END_PREAMBLE nonterminals\nrule 22: precedence_directives <- precedence_directives . precedence_directive                                                                                  \nrule 24: precedence_directive <- . DIRECTIVE_PREC ID at_least_one_newline                                                                                       \nrule 25: precedence_directive <- . DIRECTIVE_PREC '.' ID ID at_least_one_newline                                                                                \nrule 26: start_directive <- . DIRECTIVE_DEFAULT_PARSE_NONTERMINAL ID at_least_one_newline                                                                       " },
    { 2, ms_transition_table_+99, "rule 26: start_directive <- DIRECTIVE_DEFAULT_PARSE_NONTERMINAL . ID at_least_one_newline" },
    { 3, ms_transition_table_+101, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE                          \nrule 65: at_least_one_newline <- . NEWLINE                                               \nrule 26: start_directive <- DIRECTIVE_DEFAULT_PARSE_NONTERMINAL ID . at_least_one_newline" },
    { 2, ms_transition_table_+104, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE                          \nrule 26: start_directive <- DIRECTIVE_DEFAULT_PARSE_NONTERMINAL ID at_least_one_newline ." },
    { 3, ms_transition_table_+106, "rule 24: precedence_directive <- DIRECTIVE_PREC . ID at_least_one_newline       \nrule 25: precedence_directive <- DIRECTIVE_PREC . '.' ID ID at_least_one_newline" },
    { 2, ms_transition_table_+109, "rule 25: precedence_directive <- DIRECTIVE_PREC '.' . ID ID at_least_one_newline" },
    { 2, ms_transition_table_+111, "rule 25: precedence_directive <- DIRECTIVE_PREC '.' ID . ID at_least_one_newline" },
    { 3, ms_transition_table_+113, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE                 \nrule 65: at_least_one_newline <- . NEWLINE                                      \nrule 25: precedence_directive <- DIRECTIVE_PREC '.' ID ID . at_least_one_newline" },
    { 2, ms_transition_table_+116, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE                 \nrule 25: precedence_directive <- DIRECTIVE_PREC '.' ID ID at_least_one_newline ." },
    { 3, ms_transition_table_+118, "rule 64: at_least_one_newline <- . at_least_one_newline NEWLINE          \nrule 65: at_least_one_newline <- . NEWLINE                               \nrule 24: precedence_directive <- DIRECTIVE_PREC ID . at_least_one_newline" },
    { 2, ms_transition_table_+121, "rule 64: at_least_one_newline <- at_least_one_newline . NEWLINE          \nrule 24: precedence_directive <- DIRECTIVE_PREC ID at_least_one_newline ." },
    { 1, ms_transition_table_+123, "rule 22: precedence_directives <- precedence_directives precedence_directive ." },
    { 2, ms_transition_table_+124, "rule 0: root <- at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives start_directive . END_PREAMBLE nonterminals" },
    { 2, ms_transition_table_+126, "rule 0: root <- at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives start_directive END_PREAMBLE . nonterminals\nrule 27: nonterminals <- . nonterminals nonterminal                                                                                                             \nrule 28: nonterminals <- .                                                                                                                                      " },
    { 5, ms_transition_table_+128, "rule 0: root <- at_least_zero_newlines targets_directive target_directives terminal_directives precedence_directives start_directive END_PREAMBLE nonterminals .\nrule 27: nonterminals <- nonterminals . nonterminal                                                                                                             \nrule 29: nonterminal <- . nonterminal_specification ':' rules ';'                                                                                               \nrule 31: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID type_spec                                                                                      \nrule 32: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ERROR_                                                                                            \nrule 33: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID ERROR_                                                                                         \nrule 30: nonterminal <- . ERROR_ ';'                                                                                                                            " },
    { 2, ms_transition_table_+133, "rule 30: nonterminal <- ERROR_ . ';'" },
    { 1, ms_transition_table_+135, "rule 30: nonterminal <- ERROR_ ';' ." },
    { 3, ms_transition_table_+136, "rule 31: nonterminal_specification <- DIRECTIVE_NONTERMINAL . ID type_spec\nrule 32: nonterminal_specification <- DIRECTIVE_NONTERMINAL . ERROR_      \nrule 33: nonterminal_specification <- DIRECTIVE_NONTERMINAL . ID ERROR_   " },
    { 1, ms_transition_table_+139, "rule 32: nonterminal_specification <- DIRECTIVE_NONTERMINAL ERROR_ ." },
    { 3, ms_transition_table_+140, "rule 72: type_spec <- . type_spec DIRECTIVE_TYPE '.' ID STRING_LITERAL    \nrule 73: type_spec <- .                                                   \nrule 31: nonterminal_specification <- DIRECTIVE_NONTERMINAL ID . type_spec\nrule 33: nonterminal_specification <- DIRECTIVE_NONTERMINAL ID . ERROR_   " },
    { 1, ms_transition_table_+143, "rule 33: nonterminal_specification <- DIRECTIVE_NONTERMINAL ID ERROR_ ." },
    { 2, ms_transition_table_+144, "rule 72: type_spec <- type_spec . DIRECTIVE_TYPE '.' ID STRING_LITERAL    \nrule 31: nonterminal_specification <- DIRECTIVE_NONTERMINAL ID type_spec ." },
    { 1, ms_transition_table_+146, "rule 27: nonterminals <- nonterminals nonterminal ." },
    { 2, ms_transition_table_+147, "rule 29: nonterminal <- nonterminal_specification . ':' rules ';'" },
    { 5, ms_transition_table_+149, "rule 29: nonterminal <- nonterminal_specification ':' . rules ';'         \nrule 34: rules <- . rules '|' rule                                        \nrule 36: rule <- . rule_specification rule_handlers                       \nrule 37: rule_specification <- . rule_token_list rule_precedence_directive\nrule 44: rule_token_list <- . rule_token_list rule_token                  \nrule 45: rule_token_list <- .                                             \nrule 35: rules <- . rule                                                  " },
    { 3, ms_transition_table_+154, "rule 29: nonterminal <- nonterminal_specification ':' rules . ';'\nrule 34: rules <- rules . '|' rule                               " },
    { 1, ms_transition_table_+157, "rule 29: nonterminal <- nonterminal_specification ':' rules ';' ." },
    { 4, ms_transition_table_+158, "rule 34: rules <- rules '|' . rule                                        \nrule 36: rule <- . rule_specification rule_handlers                       \nrule 37: rule_specification <- . rule_token_list rule_precedence_directive\nrule 44: rule_token_list <- . rule_token_list rule_token                  \nrule 45: rule_token_list <- .                                             " },
    { 1, ms_transition_table_+162, "rule 34: rules <- rules '|' rule ." },
    { 2, ms_transition_table_+163, "rule 36: rule <- rule_specification . rule_handlers   \nrule 38: rule_handlers <- . rule_handlers rule_handler\nrule 39: rule_handlers <- .                           " },
    { 4, ms_transition_table_+165, "rule 36: rule <- rule_specification rule_handlers .                      \nrule 38: rule_handlers <- rule_handlers . rule_handler                   \nrule 40: rule_handler <- . DIRECTIVE_TARGET '.' ID any_type_of_code_block\nrule 41: rule_handler <- . DIRECTIVE_TARGET ERROR_ any_type_of_code_block\nrule 42: rule_handler <- . DIRECTIVE_TARGET ERROR_                       \nrule 43: rule_handler <- . ERROR_ any_type_of_code_block                 " },
    { 4, ms_transition_table_+169, "rule 70: any_type_of_code_block <- . DUMB_CODE_BLOCK    \nrule 71: any_type_of_code_block <- . STRICT_CODE_BLOCK  \nrule 43: rule_handler <- ERROR_ . any_type_of_code_block" },
    { 1, ms_transition_table_+173, "rule 70: any_type_of_code_block <- DUMB_CODE_BLOCK ." },
    { 1, ms_transition_table_+174, "rule 71: any_type_of_code_block <- STRICT_CODE_BLOCK ." },
    { 1, ms_transition_table_+175, "rule 43: rule_handler <- ERROR_ any_type_of_code_block ." },
    { 3, ms_transition_table_+176, "rule 40: rule_handler <- DIRECTIVE_TARGET . '.' ID any_type_of_code_block\nrule 41: rule_handler <- DIRECTIVE_TARGET . ERROR_ any_type_of_code_block\nrule 42: rule_handler <- DIRECTIVE_TARGET . ERROR_                       " },
    { 2, ms_transition_table_+179, "rule 40: rule_handler <- DIRECTIVE_TARGET '.' . ID any_type_of_code_block" },
    { 4, ms_transition_table_+181, "rule 40: rule_handler <- DIRECTIVE_TARGET '.' ID . any_type_of_code_block\nrule 70: any_type_of_code_block <- . DUMB_CODE_BLOCK                     \nrule 71: any_type_of_code_block <- . STRICT_CODE_BLOCK                   " },
    { 1, ms_transition_table_+185, "rule 40: rule_handler <- DIRECTIVE_TARGET '.' ID any_type_of_code_block ." },
    { 4, ms_transition_table_+186, "rule 70: any_type_of_code_block <- . DUMB_CODE_BLOCK                     \nrule 71: any_type_of_code_block <- . STRICT_CODE_BLOCK                   \nrule 41: rule_handler <- DIRECTIVE_TARGET ERROR_ . any_type_of_code_block\nrule 42: rule_handler <- DIRECTIVE_TARGET ERROR_ .                       " },
    { 1, ms_transition_table_+190, "rule 41: rule_handler <- DIRECTIVE_TARGET ERROR_ any_type_of_code_block ." },
    { 1, ms_transition_table_+191, "rule 38: rule_handlers <- rule_handlers rule_handler ." },
    { 9, ms_transition_table_+192, "rule 37: rule_specification <- rule_token_list . rule_precedence_directive \nrule 44: rule_token_list <- rule_token_list . rule_token                   \nrule 46: rule_token <- . token_id ':' ID                                   \nrule 66: token_id <- . ID                                                  \nrule 67: token_id <- . CHAR_LITERAL                                        \nrule 47: rule_token <- . token_id                                          \nrule 48: rule_token <- . DIRECTIVE_END ':' ID                              \nrule 49: rule_token <- . DIRECTIVE_END                                     \nrule 50: rule_token <- . DIRECTIVE_ERROR ID                                \nrule 51: rule_token <- . DIRECTIVE_ERROR                                   \nrule 52: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']' ID\nrule 53: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']'   \nrule 60: rule_precedence_directive <- . DIRECTIVE_PREC ID                  \nrule 61: rule_precedence_directive <- .                                    " },
    { 1, ms_transition_table_+201, "rule 67: token_id <- CHAR_LITERAL ." },
    { 2, ms_transition_table_+202, "rule 48: rule_token <- DIRECTIVE_END . ':' ID\nrule 49: rule_token <- DIRECTIVE_END .       " },
    { 2, ms_transition_table_+204, "rule 48: rule_token <- DIRECTIVE_END ':' . ID" },
    { 1, ms_transition_table_+206, "rule 48: rule_token <- DIRECTIVE_END ':' ID ." },
    { 2, ms_transition_table_+207, "rule 50: rule_token <- DIRECTIVE_ERROR . ID                                \nrule 51: rule_token <- DIRECTIVE_ERROR .                                   \nrule 52: rule_token <- DIRECTIVE_ERROR . '[' lookahead_terminal_list ']' ID\nrule 53: rule_token <- DIRECTIVE_ERROR . '[' lookahead_terminal_list ']'   " },
    { 7, ms_transition_table_+209, "rule 66: token_id <- . ID                                                           \nrule 67: token_id <- . CHAR_LITERAL                                                 \nrule 52: rule_token <- DIRECTIVE_ERROR '[' . lookahead_terminal_list ']' ID         \nrule 56: lookahead_terminal_list <- . lookahead_terminal_list '|' lookahead_terminal\nrule 58: lookahead_terminal <- . DIRECTIVE_END                                      \nrule 59: lookahead_terminal <- . token_id                                           \nrule 57: lookahead_terminal_list <- . lookahead_terminal                            \nrule 53: rule_token <- DIRECTIVE_ERROR '[' . lookahead_terminal_list ']'            " },
    { 1, ms_transition_table_+216, "rule 58: lookahead_terminal <- DIRECTIVE_END ." },
    { 1, ms_transition_table_+217, "rule 66: token_id <- ID ." },
    { 3, ms_transition_table_+218, "rule 52: rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list . ']' ID         \nrule 56: lookahead_terminal_list <- lookahead_terminal_list . '|' lookahead_terminal\nrule 53: rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list . ']'            " },
    { 1, ms_transition_table_+221, "rule 52: rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list ']' . ID\nrule 53: rule_token <- DIRECTIVE_ERROR '[' lookahead_terminal_list ']' .   " },
    { 7, ms_transition_table_+222, "rule 44: rule_token_list <- rule_token_list . rule_token                   \nrule 46: rule_token <- . token_id ':' ID                                   \nrule 66: token_id <- . ID                                                  \nrule 67: token_id <- . CHAR_LITERAL                                        \nrule 47: rule_token <- . token_id                                          \nrule 48: rule_token <- . DIRECTIVE_END ':' ID                              \nrule 49: rule_token <- . DIRECTIVE_END                                     \nrule 50: rule_token <- . DIRECTIVE_ERROR ID                                \nrule 51: rule_token <- . DIRECTIVE_ERROR                                   \nrule 52: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']' ID\nrule 53: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']'   " },
    { 1, ms_transition_table_+229, "rule 44: rule_token_list <- rule_token_list rule_token ." },
    { 2, ms_transition_table_+230, "rule 46: rule_token <- token_id . ':' ID\nrule 47: rule_token <- token_id .       " },
    { 2, ms_transition_table_+232, "rule 46: rule_token <- token_id ':' . ID" },
    { 1, ms_transition_table_+234, "rule 46: rule_token <- token_id ':' ID ." },
    { 6, ms_transition_table_+235, "rule 66: token_id <- . ID                                                           \nrule 67: token_id <- . CHAR_LITERAL                                                 \nrule 56: lookahead_terminal_list <- lookahead_terminal_list '|' . lookahead_terminal\nrule 58: lookahead_terminal <- . DIRECTIVE_END                                      \nrule 59: lookahead_terminal <- . token_id                                           " },
    { 1, ms_transition_table_+241, "rule 56: lookahead_terminal_list <- lookahead_terminal_list '|' lookahead_terminal ." },
    { 1, ms_transition_table_+242, "rule 59: lookahead_terminal <- token_id ." },
    { 1, ms_transition_table_+243, "rule 57: lookahead_terminal_list <- lookahead_terminal ." },
    { 2, ms_transition_table_+244, "rule 60: rule_precedence_directive <- DIRECTIVE_PREC . ID" },
    { 1, ms_transition_table_+246, "rule 60: rule_precedence_directive <- DIRECTIVE_PREC ID ." },
    { 1, ms_transition_table_+247, "rule 37: rule_specification <- rule_token_list rule_precedence_directive ." },
    { 1, ms_transition_table_+248, "rule 35: rules <- rule ." },
    { 3, ms_transition_table_+249, "START targets_directive                                                         \nrule 1: targets_directive <- . DIRECTIVE_TARGETS target_ids at_least_one_newline\nrule 2: targets_directive <- .                                                  \nrule 3: targets_directive <- . DIRECTIVE_TARGETS ERROR_ at_least_one_newline    " },
    { 1, ms_transition_table_+252, "RETURN targets_directive" },
    { 2, ms_transition_table_+253, "START target_ids                     \nrule 4: target_ids <- . target_ids ID\nrule 5: target_ids <- .              " },
    { 2, ms_transition_table_+255, "RETURN target_ids                    \nrule 4: target_ids <- target_ids . ID" },
    { 2, ms_transition_table_+257, "START target_directives                                                               \nrule 6: target_directives <- . target_directives target_directive at_least_one_newline\nrule 7: target_directives <- .                                                        " },
    { 3, ms_transition_table_+259, "RETURN target_directives                                                              \nrule 6: target_directives <- target_directives . target_directive at_least_one_newline\nrule 8: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID target_directive_param   \nrule 9: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID ERROR_                   \nrule 10: target_directive <- . DIRECTIVE_TARGET '.' ID ERROR_                         \nrule 11: target_directive <- . DIRECTIVE_TARGET ERROR_                                " },
    { 3, ms_transition_table_+262, "START target_directive                                                             \nrule 8: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID target_directive_param\nrule 9: target_directive <- . DIRECTIVE_TARGET '.' ID '.' ID ERROR_                \nrule 10: target_directive <- . DIRECTIVE_TARGET '.' ID ERROR_                      \nrule 11: target_directive <- . DIRECTIVE_TARGET ERROR_                             " },
    { 1, ms_transition_table_+265, "RETURN target_directive" },
    { 6, ms_transition_table_+266, "START target_directive_param                          \nrule 12: target_directive_param <- . ID               \nrule 13: target_directive_param <- . STRING_LITERAL   \nrule 14: target_directive_param <- . STRICT_CODE_BLOCK\nrule 15: target_directive_param <- . DUMB_CODE_BLOCK  \nrule 16: target_directive_param <- .                  " },
    { 1, ms_transition_table_+272, "RETURN target_directive_param" },
    { 2, ms_transition_table_+273, "START terminal_directives                                               \nrule 17: terminal_directives <- . terminal_directives terminal_directive\nrule 18: terminal_directives <- .                                       " },
    { 3, ms_transition_table_+275, "RETURN terminal_directives                                                                  \nrule 17: terminal_directives <- terminal_directives . terminal_directive                    \nrule 19: terminal_directive <- . DIRECTIVE_TERMINAL terminals type_spec at_least_one_newline" },
    { 3, ms_transition_table_+278, "START terminal_directive                                                                    \nrule 19: terminal_directive <- . DIRECTIVE_TERMINAL terminals type_spec at_least_one_newline" },
    { 1, ms_transition_table_+281, "RETURN terminal_directive" },
    { 5, ms_transition_table_+282, "START terminals                           \nrule 20: terminals <- . terminals terminal\nrule 68: terminal <- . ID                 \nrule 69: terminal <- . CHAR_LITERAL       \nrule 21: terminals <- . terminal          " },
    { 4, ms_transition_table_+287, "RETURN terminals                          \nrule 20: terminals <- terminals . terminal\nrule 68: terminal <- . ID                 \nrule 69: terminal <- . CHAR_LITERAL       " },
    { 2, ms_transition_table_+291, "START precedence_directives                                                   \nrule 22: precedence_directives <- . precedence_directives precedence_directive\nrule 23: precedence_directives <- .                                           " },
    { 3, ms_transition_table_+293, "RETURN precedence_directives                                                    \nrule 22: precedence_directives <- precedence_directives . precedence_directive  \nrule 24: precedence_directive <- . DIRECTIVE_PREC ID at_least_one_newline       \nrule 25: precedence_directive <- . DIRECTIVE_PREC '.' ID ID at_least_one_newline" },
    { 3, ms_transition_table_+296, "START precedence_directive                                                      \nrule 24: precedence_directive <- . DIRECTIVE_PREC ID at_least_one_newline       \nrule 25: precedence_directive <- . DIRECTIVE_PREC '.' ID ID at_least_one_newline" },
    { 1, ms_transition_table_+299, "RETURN precedence_directive" },
    { 3, ms_transition_table_+300, "START start_directive                                                                    \nrule 26: start_directive <- . DIRECTIVE_DEFAULT_PARSE_NONTERMINAL ID at_least_one_newline" },
    { 1, ms_transition_table_+303, "RETURN start_directive" },
    { 2, ms_transition_table_+304, "START nonterminals                                 \nrule 27: nonterminals <- . nonterminals nonterminal\nrule 28: nonterminals <- .                         " },
    { 5, ms_transition_table_+306, "RETURN nonterminals                                                       \nrule 27: nonterminals <- nonterminals . nonterminal                       \nrule 29: nonterminal <- . nonterminal_specification ':' rules ';'         \nrule 31: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID type_spec\nrule 32: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ERROR_      \nrule 33: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID ERROR_   \nrule 30: nonterminal <- . ERROR_ ';'                                      " },
    { 5, ms_transition_table_+311, "START nonterminal                                                         \nrule 29: nonterminal <- . nonterminal_specification ':' rules ';'         \nrule 31: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID type_spec\nrule 32: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ERROR_      \nrule 33: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID ERROR_   \nrule 30: nonterminal <- . ERROR_ ';'                                      " },
    { 1, ms_transition_table_+316, "RETURN nonterminal" },
    { 3, ms_transition_table_+317, "START nonterminal_specification                                           \nrule 31: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID type_spec\nrule 32: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ERROR_      \nrule 33: nonterminal_specification <- . DIRECTIVE_NONTERMINAL ID ERROR_   " },
    { 1, ms_transition_table_+320, "RETURN nonterminal_specification" },
    { 5, ms_transition_table_+321, "START rules                                                               \nrule 34: rules <- . rules '|' rule                                        \nrule 36: rule <- . rule_specification rule_handlers                       \nrule 37: rule_specification <- . rule_token_list rule_precedence_directive\nrule 44: rule_token_list <- . rule_token_list rule_token                  \nrule 45: rule_token_list <- .                                             \nrule 35: rules <- . rule                                                  " },
    { 2, ms_transition_table_+326, "RETURN rules                      \nrule 34: rules <- rules . '|' rule" },
    { 4, ms_transition_table_+328, "START rule                                                                \nrule 36: rule <- . rule_specification rule_handlers                       \nrule 37: rule_specification <- . rule_token_list rule_precedence_directive\nrule 44: rule_token_list <- . rule_token_list rule_token                  \nrule 45: rule_token_list <- .                                             " },
    { 1, ms_transition_table_+332, "RETURN rule" },
    { 3, ms_transition_table_+333, "START rule_specification                                                  \nrule 37: rule_specification <- . rule_token_list rule_precedence_directive\nrule 44: rule_token_list <- . rule_token_list rule_token                  \nrule 45: rule_token_list <- .                                             " },
    { 1, ms_transition_table_+336, "RETURN rule_specification" },
    { 2, ms_transition_table_+337, "START rule_handlers                                   \nrule 38: rule_handlers <- . rule_handlers rule_handler\nrule 39: rule_handlers <- .                           " },
    { 4, ms_transition_table_+339, "RETURN rule_handlers                                                     \nrule 38: rule_handlers <- rule_handlers . rule_handler                   \nrule 40: rule_handler <- . DIRECTIVE_TARGET '.' ID any_type_of_code_block\nrule 41: rule_handler <- . DIRECTIVE_TARGET ERROR_ any_type_of_code_block\nrule 42: rule_handler <- . DIRECTIVE_TARGET ERROR_                       \nrule 43: rule_handler <- . ERROR_ any_type_of_code_block                 " },
    { 4, ms_transition_table_+343, "START rule_handler                                                       \nrule 40: rule_handler <- . DIRECTIVE_TARGET '.' ID any_type_of_code_block\nrule 41: rule_handler <- . DIRECTIVE_TARGET ERROR_ any_type_of_code_block\nrule 42: rule_handler <- . DIRECTIVE_TARGET ERROR_                       \nrule 43: rule_handler <- . ERROR_ any_type_of_code_block                 " },
    { 1, ms_transition_table_+347, "RETURN rule_handler" },
    { 2, ms_transition_table_+348, "START rule_token_list                                   \nrule 44: rule_token_list <- . rule_token_list rule_token\nrule 45: rule_token_list <- .                           " },
    { 7, ms_transition_table_+350, "RETURN rule_token_list                                                     \nrule 44: rule_token_list <- rule_token_list . rule_token                   \nrule 46: rule_token <- . token_id ':' ID                                   \nrule 66: token_id <- . ID                                                  \nrule 67: token_id <- . CHAR_LITERAL                                        \nrule 47: rule_token <- . token_id                                          \nrule 48: rule_token <- . DIRECTIVE_END ':' ID                              \nrule 49: rule_token <- . DIRECTIVE_END                                     \nrule 50: rule_token <- . DIRECTIVE_ERROR ID                                \nrule 51: rule_token <- . DIRECTIVE_ERROR                                   \nrule 52: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']' ID\nrule 53: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']'   " },
    { 7, ms_transition_table_+357, "START rule_token                                                           \nrule 46: rule_token <- . token_id ':' ID                                   \nrule 66: token_id <- . ID                                                  \nrule 67: token_id <- . CHAR_LITERAL                                        \nrule 47: rule_token <- . token_id                                          \nrule 48: rule_token <- . DIRECTIVE_END ':' ID                              \nrule 49: rule_token <- . DIRECTIVE_END                                     \nrule 50: rule_token <- . DIRECTIVE_ERROR ID                                \nrule 51: rule_token <- . DIRECTIVE_ERROR                                   \nrule 52: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']' ID\nrule 53: rule_token <- . DIRECTIVE_ERROR '[' lookahead_terminal_list ']'   " },
    { 1, ms_transition_table_+364, "RETURN rule_token" },
    { 3, ms_transition_table_+365, "START maybe_assigned_id               \nrule 54: maybe_assigned_id <- . ':' ID\nrule 55: maybe_assigned_id <- .       " },
    { 2, ms_transition_table_+368, "rule 54: maybe_assigned_id <- ':' . ID" },
    { 1, ms_transition_table_+370, "rule 54: maybe_assigned_id <- ':' ID ." },
    { 1, ms_transition_table_+371, "RETURN maybe_assigned_id" },
    { 7, ms_transition_table_+372, "rule 66: token_id <- . ID                                                           \nrule 67: token_id <- . CHAR_LITERAL                                                 \nSTART lookahead_terminal_list                                                       \nrule 56: lookahead_terminal_list <- . lookahead_terminal_list '|' lookahead_terminal\nrule 58: lookahead_terminal <- . DIRECTIVE_END                                      \nrule 59: lookahead_terminal <- . token_id                                           \nrule 57: lookahead_terminal_list <- . lookahead_terminal                            " },
    { 2, ms_transition_table_+379, "RETURN lookahead_terminal_list                                                      \nrule 56: lookahead_terminal_list <- lookahead_terminal_list . '|' lookahead_terminal" },
    { 6, ms_transition_table_+381, "rule 66: token_id <- . ID                     \nrule 67: token_id <- . CHAR_LITERAL           \nSTART lookahead_terminal                      \nrule 58: lookahead_terminal <- . DIRECTIVE_END\nrule 59: lookahead_terminal <- . token_id     " },
    { 1, ms_transition_table_+387, "RETURN lookahead_terminal" },
    { 3, ms_transition_table_+388, "START rule_precedence_directive                          \nrule 60: rule_precedence_directive <- . DIRECTIVE_PREC ID\nrule 61: rule_precedence_directive <- .                  " },
    { 1, ms_transition_table_+391, "RETURN rule_precedence_directive" },
    { 2, ms_transition_table_+392, "START at_least_zero_newlines                                       \nrule 62: at_least_zero_newlines <- . at_least_zero_newlines NEWLINE\nrule 63: at_least_zero_newlines <- .                               " },
    { 2, ms_transition_table_+394, "RETURN at_least_zero_newlines                                      \nrule 62: at_least_zero_newlines <- at_least_zero_newlines . NEWLINE" },
    { 3, ms_transition_table_+396, "START at_least_one_newline                                     \nrule 64: at_least_one_newline <- . at_least_one_newline NEWLINE\nrule 65: at_least_one_newline <- . NEWLINE                     " },
    { 2, ms_transition_table_+399, "RETURN at_least_one_newline                                    \nrule 64: at_least_one_newline <- at_least_one_newline . NEWLINE" },
    { 4, ms_transition_table_+401, "START token_id                     \nrule 66: token_id <- . ID          \nrule 67: token_id <- . CHAR_LITERAL" },
    { 1, ms_transition_table_+405, "RETURN token_id" },
    { 4, ms_transition_table_+406, "START terminal                     \nrule 68: terminal <- . ID          \nrule 69: terminal <- . CHAR_LITERAL" },
    { 1, ms_transition_table_+410, "RETURN terminal" },
    { 4, ms_transition_table_+411, "START any_type_of_code_block                          \nrule 70: any_type_of_code_block <- . DUMB_CODE_BLOCK  \nrule 71: any_type_of_code_block <- . STRICT_CODE_BLOCK" },
    { 1, ms_transition_table_+415, "RETURN any_type_of_code_block" },
    { 2, ms_transition_table_+416, "START type_spec                                                       \nrule 72: type_spec <- . type_spec DIRECTIVE_TYPE '.' ID STRING_LITERAL\nrule 73: type_spec <- .                                               " },
    { 2, ms_transition_table_+418, "RETURN type_spec                                                      \nrule 72: type_spec <- type_spec . DIRECTIVE_TYPE '.' ID STRING_LITERAL" }
};
std::size_t const Parser::ms_state_count_ = sizeof(Parser::ms_state_table_) / sizeof(*Parser::ms_state_table_);

Parser::Transition_ const Parser::ms_transition_table_[] =
{
    { Parser::Transition_::REDUCE, 63, 0, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 1, 1, ms_lookahead_table_+0 },
    { Parser::Transition_::SHIFT, 2, 1, ms_lookahead_table_+1 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+2 },
    { Parser::Transition_::REDUCE, 2, 0, ms_lookahead_table_+2 },
    { Parser::Transition_::SHIFT, 3, 1, ms_lookahead_table_+2 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+3 },
    { Parser::Transition_::SHIFT, 12, 1, ms_lookahead_table_+4 },
    { Parser::Transition_::REDUCE, 5, 0, ms_lookahead_table_+5 },
    { Parser::Transition_::SHIFT, 4, 1, ms_lookahead_table_+5 },
    { Parser::Transition_::SHIFT, 8, 1, ms_lookahead_table_+6 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+7 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+7 },
    { Parser::Transition_::SHIFT, 6, 1, ms_lookahead_table_+8 },
    { Parser::Transition_::REDUCE, 65, 0, ms_lookahead_table_+9 },
    { Parser::Transition_::REDUCE, 3, 0, ms_lookahead_table_+9 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+9 },
    { Parser::Transition_::REDUCE, 64, 0, ms_lookahead_table_+10 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+10 },
    { Parser::Transition_::SHIFT, 9, 1, ms_lookahead_table_+10 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+11 },
    { Parser::Transition_::SHIFT, 10, 1, ms_lookahead_table_+12 },
    { Parser::Transition_::REDUCE, 4, 0, ms_lookahead_table_+13 },
    { Parser::Transition_::REDUCE, 1, 0, ms_lookahead_table_+13 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+13 },
    { Parser::Transition_::REDUCE, 62, 0, ms_lookahead_table_+14 },
    { Parser::Transition_::REDUCE, 7, 0, ms_lookahead_table_+14 },
    { Parser::Transition_::SHIFT, 13, 1, ms_lookahead_table_+14 },
    { Parser::Transition_::REDUCE, 18, 0, ms_lookahead_table_+15 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+15 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+16 },
    { Parser::Transition_::SHIFT, 29, 1, ms_lookahead_table_+17 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+18 },
    { Parser::Transition_::SHIFT, 15, 1, ms_lookahead_table_+18 },
    { Parser::Transition_::SHIFT, 26, 1, ms_lookahead_table_+19 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+20 },
    { Parser::Transition_::SHIFT, 16, 1, ms_lookahead_table_+20 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+21 },
    { Parser::Transition_::SHIFT, 17, 1, ms_lookahead_table_+21 },
    { Parser::Transition_::SHIFT, 25, 1, ms_lookahead_table_+22 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+23 },
    { Parser::Transition_::SHIFT, 18, 1, ms_lookahead_table_+23 },
    { Parser::Transition_::REDUCE, 16, 0, ms_lookahead_table_+24 },
    { Parser::Transition_::SHIFT, 19, 1, ms_lookahead_table_+24 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+25 },
    { Parser::Transition_::SHIFT, 21, 1, ms_lookahead_table_+26 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+27 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+28 },
    { Parser::Transition_::SHIFT, 24, 1, ms_lookahead_table_+29 },
    { Parser::Transition_::REDUCE, 9, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 15, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 12, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 14, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 13, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 8, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 10, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::REDUCE, 11, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+30 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+30 },
    { Parser::Transition_::SHIFT, 28, 1, ms_lookahead_table_+31 },
    { Parser::Transition_::REDUCE, 6, 0, ms_lookahead_table_+32 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+32 },
    { Parser::Transition_::REDUCE, 23, 0, ms_lookahead_table_+33 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+33 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+34 },
    { Parser::Transition_::SHIFT, 43, 1, ms_lookahead_table_+35 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+36 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+36 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+37 },
    { Parser::Transition_::SHIFT, 33, 1, ms_lookahead_table_+38 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+39 },
    { Parser::Transition_::REDUCE, 69, 0, ms_lookahead_table_+40 },
    { Parser::Transition_::REDUCE, 68, 0, ms_lookahead_table_+40 },
    { Parser::Transition_::REDUCE, 73, 0, ms_lookahead_table_+40 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+40 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+41 },
    { Parser::Transition_::SHIFT, 34, 1, ms_lookahead_table_+42 },
    { Parser::Transition_::SHIFT, 35, 1, ms_lookahead_table_+43 },
    { Parser::Transition_::REDUCE, 20, 0, ms_lookahead_table_+44 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+44 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+44 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+45 },
    { Parser::Transition_::SHIFT, 40, 1, ms_lookahead_table_+46 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+47 },
    { Parser::Transition_::SHIFT, 37, 1, ms_lookahead_table_+47 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+48 },
    { Parser::Transition_::SHIFT, 38, 1, ms_lookahead_table_+48 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+49 },
    { Parser::Transition_::SHIFT, 39, 1, ms_lookahead_table_+49 },
    { Parser::Transition_::REDUCE, 72, 0, ms_lookahead_table_+50 },
    { Parser::Transition_::REDUCE, 19, 0, ms_lookahead_table_+50 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+50 },
    { Parser::Transition_::REDUCE, 21, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::REDUCE, 17, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+51 },
    { Parser::Transition_::SHIFT, 44, 1, ms_lookahead_table_+51 },
    { Parser::Transition_::SHIFT, 47, 1, ms_lookahead_table_+52 },
    { Parser::Transition_::SHIFT, 54, 1, ms_lookahead_table_+53 },
    { Parser::Transition_::SHIFT, 55, 1, ms_lookahead_table_+54 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+55 },
    { Parser::Transition_::SHIFT, 45, 1, ms_lookahead_table_+55 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+56 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+56 },
    { Parser::Transition_::SHIFT, 46, 1, ms_lookahead_table_+57 },
    { Parser::Transition_::REDUCE, 26, 0, ms_lookahead_table_+58 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+58 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+59 },
    { Parser::Transition_::SHIFT, 48, 1, ms_lookahead_table_+59 },
    { Parser::Transition_::SHIFT, 52, 1, ms_lookahead_table_+60 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+61 },
    { Parser::Transition_::SHIFT, 49, 1, ms_lookahead_table_+61 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+62 },
    { Parser::Transition_::SHIFT, 50, 1, ms_lookahead_table_+62 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+63 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+63 },
    { Parser::Transition_::SHIFT, 51, 1, ms_lookahead_table_+64 },
    { Parser::Transition_::REDUCE, 25, 0, ms_lookahead_table_+65 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+65 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+66 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+66 },
    { Parser::Transition_::SHIFT, 53, 1, ms_lookahead_table_+67 },
    { Parser::Transition_::REDUCE, 24, 0, ms_lookahead_table_+68 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+68 },
    { Parser::Transition_::REDUCE, 22, 0, ms_lookahead_table_+69 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+69 },
    { Parser::Transition_::SHIFT, 56, 1, ms_lookahead_table_+69 },
    { Parser::Transition_::REDUCE, 28, 0, ms_lookahead_table_+70 },
    { Parser::Transition_::SHIFT, 57, 1, ms_lookahead_table_+70 },
    { Parser::Transition_::REDUCE, 0, 0, ms_lookahead_table_+71 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+71 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+72 },
    { Parser::Transition_::SHIFT, 65, 1, ms_lookahead_table_+73 },
    { Parser::Transition_::SHIFT, 66, 1, ms_lookahead_table_+74 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+75 },
    { Parser::Transition_::SHIFT, 59, 1, ms_lookahead_table_+75 },
    { Parser::Transition_::REDUCE, 30, 0, ms_lookahead_table_+76 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+76 },
    { Parser::Transition_::SHIFT, 61, 1, ms_lookahead_table_+76 },
    { Parser::Transition_::SHIFT, 62, 1, ms_lookahead_table_+77 },
    { Parser::Transition_::REDUCE, 32, 0, ms_lookahead_table_+78 },
    { Parser::Transition_::REDUCE, 73, 0, ms_lookahead_table_+78 },
    { Parser::Transition_::SHIFT, 63, 1, ms_lookahead_table_+78 },
    { Parser::Transition_::SHIFT, 64, 1, ms_lookahead_table_+79 },
    { Parser::Transition_::REDUCE, 33, 0, ms_lookahead_table_+80 },
    { Parser::Transition_::REDUCE, 31, 0, ms_lookahead_table_+80 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+80 },
    { Parser::Transition_::REDUCE, 27, 0, ms_lookahead_table_+81 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+81 },
    { Parser::Transition_::SHIFT, 67, 1, ms_lookahead_table_+81 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+82 },
    { Parser::Transition_::SHIFT, 68, 1, ms_lookahead_table_+82 },
    { Parser::Transition_::SHIFT, 108, 1, ms_lookahead_table_+83 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+84 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+85 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+86 },
    { Parser::Transition_::SHIFT, 69, 1, ms_lookahead_table_+86 },
    { Parser::Transition_::SHIFT, 70, 1, ms_lookahead_table_+87 },
    { Parser::Transition_::REDUCE, 29, 0, ms_lookahead_table_+88 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+88 },
    { Parser::Transition_::SHIFT, 71, 1, ms_lookahead_table_+88 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+89 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+90 },
    { Parser::Transition_::REDUCE, 34, 0, ms_lookahead_table_+91 },
    { Parser::Transition_::REDUCE, 39, 0, ms_lookahead_table_+91 },
    { Parser::Transition_::SHIFT, 73, 1, ms_lookahead_table_+91 },
    { Parser::Transition_::REDUCE, 36, 0, ms_lookahead_table_+92 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+92 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+93 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+94 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+95 },
    { Parser::Transition_::SHIFT, 75, 1, ms_lookahead_table_+95 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+96 },
    { Parser::Transition_::SHIFT, 77, 1, ms_lookahead_table_+97 },
    { Parser::Transition_::REDUCE, 70, 0, ms_lookahead_table_+98 },
    { Parser::Transition_::REDUCE, 71, 0, ms_lookahead_table_+98 },
    { Parser::Transition_::REDUCE, 43, 0, ms_lookahead_table_+98 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+98 },
    { Parser::Transition_::SHIFT, 79, 1, ms_lookahead_table_+98 },
    { Parser::Transition_::SHIFT, 82, 1, ms_lookahead_table_+99 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+100 },
    { Parser::Transition_::SHIFT, 80, 1, ms_lookahead_table_+100 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+101 },
    { Parser::Transition_::SHIFT, 75, 1, ms_lookahead_table_+101 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+102 },
    { Parser::Transition_::SHIFT, 81, 1, ms_lookahead_table_+103 },
    { Parser::Transition_::REDUCE, 40, 0, ms_lookahead_table_+104 },
    { Parser::Transition_::REDUCE, 42, 0, ms_lookahead_table_+104 },
    { Parser::Transition_::SHIFT, 75, 1, ms_lookahead_table_+104 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+105 },
    { Parser::Transition_::SHIFT, 83, 1, ms_lookahead_table_+106 },
    { Parser::Transition_::REDUCE, 41, 0, ms_lookahead_table_+107 },
    { Parser::Transition_::REDUCE, 38, 0, ms_lookahead_table_+107 },
    { Parser::Transition_::REDUCE, 61, 0, ms_lookahead_table_+107 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+107 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+108 },
    { Parser::Transition_::SHIFT, 90, 1, ms_lookahead_table_+109 },
    { Parser::Transition_::SHIFT, 105, 1, ms_lookahead_table_+110 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+111 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+112 },
    { Parser::Transition_::SHIFT, 107, 1, ms_lookahead_table_+113 },
    { Parser::Transition_::SHIFT, 98, 1, ms_lookahead_table_+114 },
    { Parser::Transition_::REDUCE, 67, 0, ms_lookahead_table_+115 },
    { Parser::Transition_::REDUCE, 49, 0, ms_lookahead_table_+115 },
    { Parser::Transition_::SHIFT, 88, 1, ms_lookahead_table_+115 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+116 },
    { Parser::Transition_::SHIFT, 89, 1, ms_lookahead_table_+116 },
    { Parser::Transition_::REDUCE, 48, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::REDUCE, 51, 0, ms_lookahead_table_+117 },
    { Parser::Transition_::SHIFT, 91, 1, ms_lookahead_table_+117 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+118 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+118 },
    { Parser::Transition_::SHIFT, 92, 1, ms_lookahead_table_+119 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+120 },
    { Parser::Transition_::SHIFT, 94, 1, ms_lookahead_table_+121 },
    { Parser::Transition_::SHIFT, 104, 1, ms_lookahead_table_+122 },
    { Parser::Transition_::SHIFT, 103, 1, ms_lookahead_table_+123 },
    { Parser::Transition_::REDUCE, 58, 0, ms_lookahead_table_+124 },
    { Parser::Transition_::REDUCE, 66, 0, ms_lookahead_table_+124 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+124 },
    { Parser::Transition_::SHIFT, 95, 1, ms_lookahead_table_+124 },
    { Parser::Transition_::SHIFT, 101, 1, ms_lookahead_table_+125 },
    { Parser::Transition_::REDUCE, 53, 0, ms_lookahead_table_+126 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+126 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+126 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+127 },
    { Parser::Transition_::SHIFT, 90, 1, ms_lookahead_table_+128 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+129 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+130 },
    { Parser::Transition_::SHIFT, 98, 1, ms_lookahead_table_+131 },
    { Parser::Transition_::REDUCE, 44, 0, ms_lookahead_table_+132 },
    { Parser::Transition_::REDUCE, 47, 0, ms_lookahead_table_+132 },
    { Parser::Transition_::SHIFT, 99, 1, ms_lookahead_table_+132 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+133 },
    { Parser::Transition_::SHIFT, 100, 1, ms_lookahead_table_+133 },
    { Parser::Transition_::REDUCE, 46, 0, ms_lookahead_table_+134 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+134 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+134 },
    { Parser::Transition_::SHIFT, 92, 1, ms_lookahead_table_+135 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+136 },
    { Parser::Transition_::SHIFT, 102, 1, ms_lookahead_table_+137 },
    { Parser::Transition_::SHIFT, 103, 1, ms_lookahead_table_+138 },
    { Parser::Transition_::REDUCE, 56, 0, ms_lookahead_table_+139 },
    { Parser::Transition_::REDUCE, 59, 0, ms_lookahead_table_+139 },
    { Parser::Transition_::REDUCE, 57, 0, ms_lookahead_table_+139 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+139 },
    { Parser::Transition_::SHIFT, 106, 1, ms_lookahead_table_+139 },
    { Parser::Transition_::REDUCE, 60, 0, ms_lookahead_table_+140 },
    { Parser::Transition_::REDUCE, 37, 0, ms_lookahead_table_+140 },
    { Parser::Transition_::REDUCE, 35, 0, ms_lookahead_table_+140 },
    { Parser::Transition_::REDUCE, 2, 0, ms_lookahead_table_+140 },
    { Parser::Transition_::SHIFT, 3, 1, ms_lookahead_table_+140 },
    { Parser::Transition_::SHIFT, 110, 1, ms_lookahead_table_+141 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+142 },
    { Parser::Transition_::REDUCE, 5, 0, ms_lookahead_table_+142 },
    { Parser::Transition_::SHIFT, 112, 1, ms_lookahead_table_+142 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+143 },
    { Parser::Transition_::SHIFT, 9, 1, ms_lookahead_table_+143 },
    { Parser::Transition_::REDUCE, 7, 0, ms_lookahead_table_+144 },
    { Parser::Transition_::SHIFT, 114, 1, ms_lookahead_table_+144 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+145 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+145 },
    { Parser::Transition_::SHIFT, 27, 1, ms_lookahead_table_+146 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+147 },
    { Parser::Transition_::SHIFT, 14, 1, ms_lookahead_table_+147 },
    { Parser::Transition_::SHIFT, 116, 1, ms_lookahead_table_+148 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+149 },
    { Parser::Transition_::REDUCE, 16, 0, ms_lookahead_table_+149 },
    { Parser::Transition_::SHIFT, 20, 1, ms_lookahead_table_+149 },
    { Parser::Transition_::SHIFT, 21, 1, ms_lookahead_table_+150 },
    { Parser::Transition_::SHIFT, 22, 1, ms_lookahead_table_+151 },
    { Parser::Transition_::SHIFT, 23, 1, ms_lookahead_table_+152 },
    { Parser::Transition_::SHIFT, 118, 1, ms_lookahead_table_+153 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+154 },
    { Parser::Transition_::REDUCE, 18, 0, ms_lookahead_table_+154 },
    { Parser::Transition_::SHIFT, 120, 1, ms_lookahead_table_+154 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+155 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+155 },
    { Parser::Transition_::SHIFT, 42, 1, ms_lookahead_table_+156 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+157 },
    { Parser::Transition_::SHIFT, 30, 1, ms_lookahead_table_+157 },
    { Parser::Transition_::SHIFT, 122, 1, ms_lookahead_table_+158 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+159 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+159 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+159 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+160 },
    { Parser::Transition_::SHIFT, 124, 1, ms_lookahead_table_+161 },
    { Parser::Transition_::SHIFT, 41, 1, ms_lookahead_table_+162 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+163 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+163 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+164 },
    { Parser::Transition_::SHIFT, 34, 1, ms_lookahead_table_+165 },
    { Parser::Transition_::REDUCE, 23, 0, ms_lookahead_table_+166 },
    { Parser::Transition_::SHIFT, 126, 1, ms_lookahead_table_+166 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+167 },
    { Parser::Transition_::SHIFT, 47, 1, ms_lookahead_table_+167 },
    { Parser::Transition_::SHIFT, 54, 1, ms_lookahead_table_+168 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+169 },
    { Parser::Transition_::SHIFT, 47, 1, ms_lookahead_table_+169 },
    { Parser::Transition_::SHIFT, 128, 1, ms_lookahead_table_+170 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+171 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+171 },
    { Parser::Transition_::SHIFT, 44, 1, ms_lookahead_table_+171 },
    { Parser::Transition_::SHIFT, 130, 1, ms_lookahead_table_+172 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+173 },
    { Parser::Transition_::REDUCE, 28, 0, ms_lookahead_table_+173 },
    { Parser::Transition_::SHIFT, 132, 1, ms_lookahead_table_+173 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+174 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+174 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+175 },
    { Parser::Transition_::SHIFT, 65, 1, ms_lookahead_table_+176 },
    { Parser::Transition_::SHIFT, 66, 1, ms_lookahead_table_+177 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+178 },
    { Parser::Transition_::SHIFT, 58, 1, ms_lookahead_table_+178 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+179 },
    { Parser::Transition_::SHIFT, 134, 1, ms_lookahead_table_+180 },
    { Parser::Transition_::SHIFT, 66, 1, ms_lookahead_table_+181 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+182 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+182 },
    { Parser::Transition_::SHIFT, 60, 1, ms_lookahead_table_+182 },
    { Parser::Transition_::SHIFT, 136, 1, ms_lookahead_table_+183 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+184 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+184 },
    { Parser::Transition_::SHIFT, 138, 1, ms_lookahead_table_+184 },
    { Parser::Transition_::SHIFT, 108, 1, ms_lookahead_table_+185 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+186 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+187 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+188 },
    { Parser::Transition_::SHIFT, 70, 1, ms_lookahead_table_+188 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+189 },
    { Parser::Transition_::SHIFT, 140, 1, ms_lookahead_table_+189 },
    { Parser::Transition_::SHIFT, 72, 1, ms_lookahead_table_+190 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+191 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+192 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+192 },
    { Parser::Transition_::SHIFT, 142, 1, ms_lookahead_table_+192 },
    { Parser::Transition_::SHIFT, 85, 1, ms_lookahead_table_+193 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+194 },
    { Parser::Transition_::REDUCE, 39, 0, ms_lookahead_table_+194 },
    { Parser::Transition_::SHIFT, 144, 1, ms_lookahead_table_+194 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+195 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+195 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+196 },
    { Parser::Transition_::SHIFT, 84, 1, ms_lookahead_table_+197 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+198 },
    { Parser::Transition_::SHIFT, 74, 1, ms_lookahead_table_+198 },
    { Parser::Transition_::SHIFT, 78, 1, ms_lookahead_table_+199 },
    { Parser::Transition_::SHIFT, 146, 1, ms_lookahead_table_+200 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+201 },
    { Parser::Transition_::REDUCE, 45, 0, ms_lookahead_table_+201 },
    { Parser::Transition_::SHIFT, 148, 1, ms_lookahead_table_+201 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+202 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+202 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+203 },
    { Parser::Transition_::SHIFT, 90, 1, ms_lookahead_table_+204 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+205 },
    { Parser::Transition_::SHIFT, 97, 1, ms_lookahead_table_+206 },
    { Parser::Transition_::SHIFT, 98, 1, ms_lookahead_table_+207 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+208 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+208 },
    { Parser::Transition_::SHIFT, 87, 1, ms_lookahead_table_+209 },
    { Parser::Transition_::SHIFT, 90, 1, ms_lookahead_table_+210 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+211 },
    { Parser::Transition_::SHIFT, 150, 1, ms_lookahead_table_+212 },
    { Parser::Transition_::SHIFT, 98, 1, ms_lookahead_table_+213 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+214 },
    { Parser::Transition_::REDUCE, 55, 0, ms_lookahead_table_+214 },
    { Parser::Transition_::SHIFT, 152, 1, ms_lookahead_table_+214 },
    { Parser::Transition_::SHIFT, 154, 1, ms_lookahead_table_+215 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+216 },
    { Parser::Transition_::SHIFT, 153, 1, ms_lookahead_table_+216 },
    { Parser::Transition_::REDUCE, 54, 0, ms_lookahead_table_+217 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+217 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+217 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+217 },
    { Parser::Transition_::SHIFT, 92, 1, ms_lookahead_table_+218 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+219 },
    { Parser::Transition_::SHIFT, 156, 1, ms_lookahead_table_+220 },
    { Parser::Transition_::SHIFT, 104, 1, ms_lookahead_table_+221 },
    { Parser::Transition_::SHIFT, 103, 1, ms_lookahead_table_+222 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+223 },
    { Parser::Transition_::SHIFT, 101, 1, ms_lookahead_table_+223 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+224 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+224 },
    { Parser::Transition_::SHIFT, 92, 1, ms_lookahead_table_+225 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+226 },
    { Parser::Transition_::SHIFT, 158, 1, ms_lookahead_table_+227 },
    { Parser::Transition_::SHIFT, 103, 1, ms_lookahead_table_+228 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+229 },
    { Parser::Transition_::REDUCE, 61, 0, ms_lookahead_table_+229 },
    { Parser::Transition_::SHIFT, 105, 1, ms_lookahead_table_+229 },
    { Parser::Transition_::SHIFT, 160, 1, ms_lookahead_table_+230 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+231 },
    { Parser::Transition_::REDUCE, 63, 0, ms_lookahead_table_+231 },
    { Parser::Transition_::SHIFT, 162, 1, ms_lookahead_table_+231 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+232 },
    { Parser::Transition_::SHIFT, 11, 1, ms_lookahead_table_+232 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+233 },
    { Parser::Transition_::SHIFT, 5, 1, ms_lookahead_table_+233 },
    { Parser::Transition_::SHIFT, 164, 1, ms_lookahead_table_+234 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+235 },
    { Parser::Transition_::SHIFT, 7, 1, ms_lookahead_table_+235 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+236 },
    { Parser::Transition_::SHIFT, 86, 1, ms_lookahead_table_+236 },
    { Parser::Transition_::SHIFT, 93, 1, ms_lookahead_table_+237 },
    { Parser::Transition_::SHIFT, 166, 1, ms_lookahead_table_+238 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+239 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+239 },
    { Parser::Transition_::SHIFT, 31, 1, ms_lookahead_table_+239 },
    { Parser::Transition_::SHIFT, 32, 1, ms_lookahead_table_+240 },
    { Parser::Transition_::SHIFT, 168, 1, ms_lookahead_table_+241 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+242 },
    { Parser::Transition_::ERROR_PANIC, 0, 0, ms_lookahead_table_+242 },
    { Parser::Transition_::SHIFT, 75, 1, ms_lookahead_table_+242 },
    { Parser::Transition_::SHIFT, 76, 1, ms_lookahead_table_+243 },
    { Parser::Transition_::SHIFT, 170, 1, ms_lookahead_table_+244 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+245 },
    { Parser::Transition_::REDUCE, 73, 0, ms_lookahead_table_+245 },
    { Parser::Transition_::SHIFT, 172, 1, ms_lookahead_table_+245 },
    { Parser::Transition_::RETURN, 0, 0, ms_lookahead_table_+246 },
    { Parser::Transition_::SHIFT, 36, 1, ms_lookahead_table_+246 }
};
std::size_t const Parser::ms_transition_count_ = sizeof(Parser::ms_transition_table_) / sizeof(*Parser::ms_transition_table_);

Parser::Token::Id const Parser::ms_lookahead_table_[] =
{
    Parser::Nonterminal_::root,
    Parser::Nonterminal_::at_least_zero_newlines,
    Parser::Terminal::DIRECTIVE_TARGETS,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::targets_directive,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::target_ids,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::ID,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::target_directives,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::target_directive,
    Parser::Nonterminal_::terminal_directives,
    '.',
    Parser::Terminal::ERROR_,
    Parser::Terminal::ID,
    '.',
    Parser::Terminal::ERROR_,
    Parser::Terminal::ID,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::ID,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Terminal::STRING_LITERAL,
    Parser::Nonterminal_::target_directive_param,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::DIRECTIVE_TERMINAL,
    Parser::Nonterminal_::terminal_directive,
    Parser::Nonterminal_::precedence_directives,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::terminals,
    Parser::Nonterminal_::terminal,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::terminal,
    Parser::Nonterminal_::type_spec,
    Parser::Terminal::DIRECTIVE_TYPE,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    '.',
    Parser::Terminal::ID,
    Parser::Terminal::STRING_LITERAL,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL,
    Parser::Terminal::DIRECTIVE_PREC,
    Parser::Nonterminal_::precedence_directive,
    Parser::Nonterminal_::start_directive,
    Parser::Terminal::ID,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    '.',
    Parser::Terminal::ID,
    Parser::Terminal::ID,
    Parser::Terminal::ID,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::END_PREAMBLE,
    Parser::Nonterminal_::nonterminals,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_NONTERMINAL,
    Parser::Nonterminal_::nonterminal,
    Parser::Nonterminal_::nonterminal_specification,
    ';',
    Parser::Terminal::ERROR_,
    Parser::Terminal::ID,
    Parser::Terminal::ERROR_,
    Parser::Nonterminal_::type_spec,
    Parser::Terminal::DIRECTIVE_TYPE,
    ':',
    Parser::Nonterminal_::rules,
    Parser::Nonterminal_::rule,
    Parser::Nonterminal_::rule_specification,
    Parser::Nonterminal_::rule_token_list,
    ';',
    '|',
    Parser::Nonterminal_::rule,
    Parser::Nonterminal_::rule_specification,
    Parser::Nonterminal_::rule_token_list,
    Parser::Nonterminal_::rule_handlers,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::rule_handler,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Nonterminal_::any_type_of_code_block,
    '.',
    Parser::Terminal::ERROR_,
    Parser::Terminal::ID,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Nonterminal_::any_type_of_code_block,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Nonterminal_::any_type_of_code_block,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::DIRECTIVE_ERROR,
    Parser::Terminal::DIRECTIVE_PREC,
    Parser::Terminal::ID,
    Parser::Nonterminal_::rule_token,
    Parser::Nonterminal_::rule_precedence_directive,
    Parser::Nonterminal_::token_id,
    ':',
    Parser::Terminal::ID,
    '[',
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::ID,
    Parser::Nonterminal_::lookahead_terminal_list,
    Parser::Nonterminal_::lookahead_terminal,
    Parser::Nonterminal_::token_id,
    ']',
    '|',
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::DIRECTIVE_ERROR,
    Parser::Terminal::ID,
    Parser::Nonterminal_::rule_token,
    Parser::Nonterminal_::token_id,
    ':',
    Parser::Terminal::ID,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::ID,
    Parser::Nonterminal_::lookahead_terminal,
    Parser::Nonterminal_::token_id,
    Parser::Terminal::ID,
    Parser::Terminal::DIRECTIVE_TARGETS,
    Parser::Nonterminal_::targets_directive,
    Parser::Nonterminal_::target_ids,
    Parser::Terminal::ID,
    Parser::Nonterminal_::target_directives,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::target_directive,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::target_directive,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::ID,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Terminal::STRING_LITERAL,
    Parser::Nonterminal_::target_directive_param,
    Parser::Nonterminal_::terminal_directives,
    Parser::Terminal::DIRECTIVE_TERMINAL,
    Parser::Nonterminal_::terminal_directive,
    Parser::Terminal::DIRECTIVE_TERMINAL,
    Parser::Nonterminal_::terminal_directive,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::terminals,
    Parser::Nonterminal_::terminal,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::terminal,
    Parser::Nonterminal_::precedence_directives,
    Parser::Terminal::DIRECTIVE_PREC,
    Parser::Nonterminal_::precedence_directive,
    Parser::Terminal::DIRECTIVE_PREC,
    Parser::Nonterminal_::precedence_directive,
    Parser::Terminal::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL,
    Parser::Nonterminal_::start_directive,
    Parser::Nonterminal_::nonterminals,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_NONTERMINAL,
    Parser::Nonterminal_::nonterminal,
    Parser::Nonterminal_::nonterminal_specification,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_NONTERMINAL,
    Parser::Nonterminal_::nonterminal,
    Parser::Nonterminal_::nonterminal_specification,
    Parser::Terminal::DIRECTIVE_NONTERMINAL,
    Parser::Nonterminal_::nonterminal_specification,
    Parser::Nonterminal_::rules,
    Parser::Nonterminal_::rule,
    Parser::Nonterminal_::rule_specification,
    Parser::Nonterminal_::rule_token_list,
    '|',
    Parser::Nonterminal_::rule,
    Parser::Nonterminal_::rule_specification,
    Parser::Nonterminal_::rule_token_list,
    Parser::Nonterminal_::rule_specification,
    Parser::Nonterminal_::rule_token_list,
    Parser::Nonterminal_::rule_handlers,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::rule_handler,
    Parser::Terminal::ERROR_,
    Parser::Terminal::DIRECTIVE_TARGET,
    Parser::Nonterminal_::rule_handler,
    Parser::Nonterminal_::rule_token_list,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::DIRECTIVE_ERROR,
    Parser::Terminal::ID,
    Parser::Nonterminal_::rule_token,
    Parser::Nonterminal_::token_id,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::DIRECTIVE_ERROR,
    Parser::Terminal::ID,
    Parser::Nonterminal_::rule_token,
    Parser::Nonterminal_::token_id,
    ':',
    Parser::Nonterminal_::maybe_assigned_id,
    Parser::Terminal::ID,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::ID,
    Parser::Nonterminal_::lookahead_terminal_list,
    Parser::Nonterminal_::lookahead_terminal,
    Parser::Nonterminal_::token_id,
    '|',
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::DIRECTIVE_END,
    Parser::Terminal::ID,
    Parser::Nonterminal_::lookahead_terminal,
    Parser::Nonterminal_::token_id,
    Parser::Terminal::DIRECTIVE_PREC,
    Parser::Nonterminal_::rule_precedence_directive,
    Parser::Nonterminal_::at_least_zero_newlines,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::NEWLINE,
    Parser::Nonterminal_::at_least_one_newline,
    Parser::Terminal::NEWLINE,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::token_id,
    Parser::Terminal::CHAR_LITERAL,
    Parser::Terminal::ID,
    Parser::Nonterminal_::terminal,
    Parser::Terminal::DUMB_CODE_BLOCK,
    Parser::Terminal::STRICT_CODE_BLOCK,
    Parser::Nonterminal_::any_type_of_code_block,
    Parser::Nonterminal_::type_spec,
    Parser::Terminal::DIRECTIVE_TYPE
};
std::size_t const Parser::ms_lookahead_count_ = sizeof(Parser::ms_lookahead_table_) / sizeof(*Parser::ms_lookahead_table_);

char const *const Parser::ms_token_name_table_[] =
{
    "'\\0'",
    "'\\x01'",
    "'\\x02'",
    "'\\x03'",
    "'\\x04'",
    "'\\x05'",
    "'\\x06'",
    "'\\a'",
    "'\\b'",
    "'\\t'",
    "'\\n'",
    "'\\v'",
    "'\\f'",
    "'\\r'",
    "'\\x0E'",
    "'\\x0F'",
    "'\\x10'",
    "'\\x11'",
    "'\\x12'",
    "'\\x13'",
    "'\\x14'",
    "'\\x15'",
    "'\\x16'",
    "'\\x17'",
    "'\\x18'",
    "'\\x19'",
    "'\\x1A'",
    "'\\x1B'",
    "'\\x1C'",
    "'\\x1D'",
    "'\\x1E'",
    "'\\x1F'",
    "' '",
    "'!'",
    "'\"'",
    "'#'",
    "'$'",
    "'%'",
    "'&'",
    "'\\''",
    "'('",
    "')'",
    "'*'",
    "'+'",
    "','",
    "'-'",
    "'.'",
    "'/'",
    "'0'",
    "'1'",
    "'2'",
    "'3'",
    "'4'",
    "'5'",
    "'6'",
    "'7'",
    "'8'",
    "'9'",
    "':'",
    "';'",
    "'<'",
    "'='",
    "'>'",
    "'?'",
    "'@'",
    "'A'",
    "'B'",
    "'C'",
    "'D'",
    "'E'",
    "'F'",
    "'G'",
    "'H'",
    "'I'",
    "'J'",
    "'K'",
    "'L'",
    "'M'",
    "'N'",
    "'O'",
    "'P'",
    "'Q'",
    "'R'",
    "'S'",
    "'T'",
    "'U'",
    "'V'",
    "'W'",
    "'X'",
    "'Y'",
    "'Z'",
    "'['",
    "'\\\\'",
    "']'",
    "'^'",
    "'_'",
    "'`'",
    "'a'",
    "'b'",
    "'c'",
    "'d'",
    "'e'",
    "'f'",
    "'g'",
    "'h'",
    "'i'",
    "'j'",
    "'k'",
    "'l'",
    "'m'",
    "'n'",
    "'o'",
    "'p'",
    "'q'",
    "'r'",
    "'s'",
    "'t'",
    "'u'",
    "'v'",
    "'w'",
    "'x'",
    "'y'",
    "'z'",
    "'{'",
    "'|'",
    "'}'",
    "'~'",
    "'\\x7F'",
    "'\\x80'",
    "'\\x81'",
    "'\\x82'",
    "'\\x83'",
    "'\\x84'",
    "'\\x85'",
    "'\\x86'",
    "'\\x87'",
    "'\\x88'",
    "'\\x89'",
    "'\\x8A'",
    "'\\x8B'",
    "'\\x8C'",
    "'\\x8D'",
    "'\\x8E'",
    "'\\x8F'",
    "'\\x90'",
    "'\\x91'",
    "'\\x92'",
    "'\\x93'",
    "'\\x94'",
    "'\\x95'",
    "'\\x96'",
    "'\\x97'",
    "'\\x98'",
    "'\\x99'",
    "'\\x9A'",
    "'\\x9B'",
    "'\\x9C'",
    "'\\x9D'",
    "'\\x9E'",
    "'\\x9F'",
    "'\\xA0'",
    "'\\xA1'",
    "'\\xA2'",
    "'\\xA3'",
    "'\\xA4'",
    "'\\xA5'",
    "'\\xA6'",
    "'\\xA7'",
    "'\\xA8'",
    "'\\xA9'",
    "'\\xAA'",
    "'\\xAB'",
    "'\\xAC'",
    "'\\xAD'",
    "'\\xAE'",
    "'\\xAF'",
    "'\\xB0'",
    "'\\xB1'",
    "'\\xB2'",
    "'\\xB3'",
    "'\\xB4'",
    "'\\xB5'",
    "'\\xB6'",
    "'\\xB7'",
    "'\\xB8'",
    "'\\xB9'",
    "'\\xBA'",
    "'\\xBB'",
    "'\\xBC'",
    "'\\xBD'",
    "'\\xBE'",
    "'\\xBF'",
    "'\\xC0'",
    "'\\xC1'",
    "'\\xC2'",
    "'\\xC3'",
    "'\\xC4'",
    "'\\xC5'",
    "'\\xC6'",
    "'\\xC7'",
    "'\\xC8'",
    "'\\xC9'",
    "'\\xCA'",
    "'\\xCB'",
    "'\\xCC'",
    "'\\xCD'",
    "'\\xCE'",
    "'\\xCF'",
    "'\\xD0'",
    "'\\xD1'",
    "'\\xD2'",
    "'\\xD3'",
    "'\\xD4'",
    "'\\xD5'",
    "'\\xD6'",
    "'\\xD7'",
    "'\\xD8'",
    "'\\xD9'",
    "'\\xDA'",
    "'\\xDB'",
    "'\\xDC'",
    "'\\xDD'",
    "'\\xDE'",
    "'\\xDF'",
    "'\\xE0'",
    "'\\xE1'",
    "'\\xE2'",
    "'\\xE3'",
    "'\\xE4'",
    "'\\xE5'",
    "'\\xE6'",
    "'\\xE7'",
    "'\\xE8'",
    "'\\xE9'",
    "'\\xEA'",
    "'\\xEB'",
    "'\\xEC'",
    "'\\xED'",
    "'\\xEE'",
    "'\\xEF'",
    "'\\xF0'",
    "'\\xF1'",
    "'\\xF2'",
    "'\\xF3'",
    "'\\xF4'",
    "'\\xF5'",
    "'\\xF6'",
    "'\\xF7'",
    "'\\xF8'",
    "'\\xF9'",
    "'\\xFA'",
    "'\\xFB'",
    "'\\xFC'",
    "'\\xFD'",
    "'\\xFE'",
    "'\\xFF'",
    "END_",
    "ERROR_",
    "BAD_TOKEN",
    "CHAR_LITERAL",
    "DIRECTIVE_DEFAULT_PARSE_NONTERMINAL",
    "DIRECTIVE_END",
    "DIRECTIVE_ERROR",
    "DIRECTIVE_NONTERMINAL",
    "DIRECTIVE_PREC",
    "DIRECTIVE_TARGET",
    "DIRECTIVE_TARGETS",
    "DIRECTIVE_TERMINAL",
    "DIRECTIVE_TYPE",
    "DUMB_CODE_BLOCK",
    "END_PREAMBLE",
    "ID",
    "NEWLINE",
    "STRICT_CODE_BLOCK",
    "STRING_LITERAL",
    "root",
    "targets_directive",
    "target_ids",
    "target_directives",
    "target_directive",
    "target_directive_param",
    "terminal_directives",
    "terminal_directive",
    "terminals",
    "precedence_directives",
    "precedence_directive",
    "start_directive",
    "nonterminals",
    "nonterminal",
    "nonterminal_specification",
    "rules",
    "rule",
    "rule_specification",
    "rule_handlers",
    "rule_handler",
    "rule_token_list",
    "rule_token",
    "maybe_assigned_id",
    "lookahead_terminal_list",
    "lookahead_terminal",
    "rule_precedence_directive",
    "at_least_zero_newlines",
    "at_least_one_newline",
    "token_id",
    "terminal",
    "any_type_of_code_block",
    "type_spec"
};
std::size_t const Parser::ms_token_name_count_ = sizeof(Parser::ms_token_name_table_) / sizeof(*Parser::ms_token_name_table_);

// ///////////////////////////////////////////////////////////////////////
// end of internal trison-generated parser guts
// ///////////////////////////////////////////////////////////////////////


#line 112 "trison_parser.trison"

CommonLang::TargetMap *Parser::StealTargetMap ()
{
    assert(m_target_map != NULL);
    CommonLang::TargetMap *retval = m_target_map;
    m_target_map = NULL;
    return retval;
}

bool Parser::OpenFile (string const &input_filename)
{
    ResetForNewInput();
    EmitExecutionMessage("opening file \"" + input_filename + "\" for input");
    bool scanner_open_file_succeeded = m_scanner.OpenFile(input_filename);
    if (scanner_open_file_succeeded)
        EmitExecutionMessage("opened file \"" + input_filename + "\" successfully");
    return scanner_open_file_succeeded;
}

void Parser::OpenString (string const &input_string, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    EmitExecutionMessage("using string " + input_name + " (" + StringLiteral(input_string) + ") for input");
    m_scanner.OpenString(input_string, input_name, use_line_numbers);
}

void Parser::OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers)
{
    ResetForNewInput();
    EmitExecutionMessage("using stream " + input_name + " for input");
    m_scanner.OpenUsingStream(input_stream, input_name, use_line_numbers);
}

} // end of namespace Trison

#line 3281 "trison_parser.cpp"
