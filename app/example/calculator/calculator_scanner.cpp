// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// calculator_scanner.cpp generated by reflex
// from calculator_scanner.reflex using reflex.cpp.targetspec and reflex.cpp.implementation.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#include "calculator_scanner.hpp"

#include <iostream>

#define REFLEX_CPP_DEBUG_SPEW_(spew_code) if (DebugSpew()) { spew_code; }


#line 47 "calculator_scanner.reflex"

// #define SPEW(x) cerr << x << endl
#define SPEW(x)

namespace Calculator {

#line 21 "calculator_scanner.cpp"

Scanner::Scanner (
#line 31 "calculator_scanner.reflex"
 string const &input_string 
#line 26 "calculator_scanner.cpp"
)
    :
    ReflexCpp_::AutomatonApparatus_(
        ms_state_table_,
        ms_state_count_,
        ms_transition_table_,
        ms_transition_count_,
        ms_accept_handler_count_,
        static_cast<ReflexCpp_::InputApparatus_::IsInputAtEndMethod_>(&Scanner::IsInputAtEnd_),
        static_cast<ReflexCpp_::InputApparatus_::ReadNextAtomMethod_>(&Scanner::ReadNextAtom_))
{
    // one-time initializations
    DebugSpew(false);
    // per-input initializations
    ResetForNewInput_();


#line 53 "calculator_scanner.reflex"

    m_input.str(input_string);

#line 48 "calculator_scanner.cpp"
}

Scanner::~Scanner ()
{
}

Scanner::Mode::Name Scanner::ScannerMode () const
{
    assert(InitialState_() != NULL);
    ReflexCpp_::Size_ initial_node_index = InitialState_() - ms_state_table_;
    assert(initial_node_index < ms_state_count_);
    switch (initial_node_index)
    {
        default: assert(false && "invalid initial node index -- this should never happen"); return Mode::START_;
        case 0: return Mode::MAIN;
    }
}

void Scanner::ScannerMode (Mode::Name mode)
{
    assert(
        mode == Mode::MAIN ||
        (false && "invalid Mode::Name"));
    InitialState_(ms_state_table_ + mode);
    REFLEX_CPP_DEBUG_SPEW_(std::cerr << "*** scanner: transitioning to mode ")
    if (false) { }
    else if (mode == Mode::MAIN) { REFLEX_CPP_DEBUG_SPEW_(std::cerr << "MAIN") }
    REFLEX_CPP_DEBUG_SPEW_(std::cerr << std::endl)
    assert(ScannerMode() == mode);
}

Parser::Token::Type Scanner::Scan (
#line 33 "calculator_scanner.reflex"
 cl_N &token 
#line 83 "calculator_scanner.cpp"
)
{

    std::string accepted_string;
    // this is the main scanner loop.  it only breaks when an accept handler
    // returns or after the unmatched character handler, if certain conditions
    // exist (see comments below).
    while (true)
    {
        bool was_at_end_of_input_ = IsAtEndOfInput();

        ReflexCpp_::Uint32_ accept_handler_index_ = RunDfa_(accepted_string);
        // if no valid accept_handler_index_ was returned, then accepted_string
        // was filled with the first unaccepted input atom (i.e. the rejected
        // atom).  we'll call the HandleUnmatchedCharacter_ method on it.
        if (accept_handler_index_ >= ms_accept_handler_count_)
        {
            // if we were already at the end of input and no
            // rule was matched, break out of the loop.
            if (was_at_end_of_input_)
                break;

            assert(accepted_string.length() == 1);
            ReflexCpp_::Uint8_ rejected_atom = accepted_string[0];
            REFLEX_CPP_DEBUG_SPEW_(
                std::cerr << "*** scanner: rejecting atom '";
                DebugPrintAtom_(rejected_atom);
                std::cerr << '\'' << std::endl)

            // execute the rejected-atom-handling actions.  the rejected atom
            // is in rejected_atom.  the loop is so a break statement inside
            // rejection_actions doesn't break out of the main scanner loop.
            do
            {

#line 74 "calculator_scanner.reflex"

    assert(false && "we should have handled this in the catch-all rule");

#line 123 "calculator_scanner.cpp"

            }
            while (false);
        }
        // otherwise, call the appropriate accept handler code.
        else
        {
            REFLEX_CPP_DEBUG_SPEW_(
                std::cerr << "*** scanner: accepting string ";
                DebugPrintString_(accepted_string);
                std::cerr << std::endl)
            // execute the appropriate accept handler.
            // the accepted string is in accepted_string.
            switch (accept_handler_index_)
            {
                case 0:
                {

#line 115 "calculator_scanner.reflex"

        token = cl_I(accepted_string.c_str());
        return Parser::Token::NUMBER;
    
#line 147 "calculator_scanner.cpp"

                }
                break;

                case 1:
                {

#line 121 "calculator_scanner.reflex"

        token = cl_F(accepted_string.c_str());
        return Parser::Token::NUMBER;
    
#line 160 "calculator_scanner.cpp"

                }
                break;

                case 2:
                {

#line 127 "calculator_scanner.reflex"

        token = pi(float_format(30)); // 100 digits of pi
        return Parser::Token::NUMBER;
    
#line 173 "calculator_scanner.cpp"

                }
                break;

                case 3:
                {

#line 133 "calculator_scanner.reflex"

        token = exp1(float_format(30)); // 100 digits of e
        return Parser::Token::NUMBER;
    
#line 186 "calculator_scanner.cpp"

                }
                break;

                case 4:
                {

#line 139 "calculator_scanner.reflex"

        token = sqrt(cl_N(-1)); // TODO -- find better way of returning I.
        return Parser::Token::NUMBER;
    
#line 199 "calculator_scanner.cpp"

                }
                break;

                case 5:
                {

#line 145 "calculator_scanner.reflex"

        return Parser::Token::RESULT;
    
#line 211 "calculator_scanner.cpp"

                }
                break;

                case 6:
                {

#line 150 "calculator_scanner.reflex"

        return Parser::Token::FLOAT;
    
#line 223 "calculator_scanner.cpp"

                }
                break;

                case 7:
                {

#line 155 "calculator_scanner.reflex"

        return Parser::Token::HELP;
    
#line 235 "calculator_scanner.cpp"

                }
                break;

                case 8:
                {

#line 160 "calculator_scanner.reflex"

        return Parser::Token::MOD;
    
#line 247 "calculator_scanner.cpp"

                }
                break;

                case 9:
                {

#line 165 "calculator_scanner.reflex"

        return Parser::Token::Type(accepted_string[0]);
    
#line 259 "calculator_scanner.cpp"

                }
                break;

                case 10:
                {

#line 170 "calculator_scanner.reflex"

        // ignore all non-newline whitespace
    
#line 271 "calculator_scanner.cpp"

                }
                break;

                case 11:
                {

#line 175 "calculator_scanner.reflex"

        return Parser::Token::NEWLINE;
    
#line 283 "calculator_scanner.cpp"

                }
                break;

                case 12:
                {

#line 180 "calculator_scanner.reflex"

        return Parser::Token::END_;
    
#line 295 "calculator_scanner.cpp"

                }
                break;

                case 13:
                {

#line 185 "calculator_scanner.reflex"

        return Parser::Token::BAD_TOKEN;
    
#line 307 "calculator_scanner.cpp"

                }
                break;

                default: assert(false && "this should never happen"); break;
            }
        }
    }


#line 56 "calculator_scanner.reflex"

    return Parser::Token::BAD_TOKEN;

#line 322 "calculator_scanner.cpp"
}

bool Scanner::IsInputAtEnd_ ()
{

#line 68 "calculator_scanner.reflex"

    return m_input.peek() == char_traits<char>::eof();

#line 332 "calculator_scanner.cpp"
}

ReflexCpp_::Uint8_ Scanner::ReadNextAtom_ ()
{

#line 71 "calculator_scanner.reflex"

    return m_input.get();

#line 342 "calculator_scanner.cpp"
}

void Scanner::ResetForNewInput_ ()
{
    ReflexCpp_::AutomatonApparatus_::ResetForNewInput_(ms_state_table_ + Mode::START_);


#line 77 "calculator_scanner.reflex"


#line 353 "calculator_scanner.cpp"
}

void Scanner::DebugPrintAtom_ (ReflexCpp_::Uint8_ atom)
{
    if (atom == '\\')                    std::cerr << "\\\\";
    else if (atom == '"')                std::cerr << "\\\"";
    else if (atom >= ' ' && atom <= '~') std::cerr << atom;
    else if (atom == '\n')               std::cerr << "\\n";
    else if (atom == '\t')               std::cerr << "\\t";
    else if (atom == '\0')               std::cerr << "\\0";
    else
    {
        std::cerr.width(2);
        std::cerr << "\\x" << std::hex << std::uppercase << ReflexCpp_::Uint16_(atom);
        std::cerr.width(1);
    }
}

void Scanner::DebugPrintString_ (std::string const &s)
{
    // save the existing std::cerr properties for later restoration
    std::ios_base::fmtflags saved_stream_flags = std::cerr.flags();
    char saved_stream_fill = std::cerr.fill();
    std::streamsize saved_stream_width = std::cerr.width();
    std::streamsize saved_stream_precision = std::cerr.precision();

    // clear all format flags to a neutral state
    std::cerr.unsetf(
        std::ios_base::boolalpha|std::ios_base::dec|std::ios_base::fixed|
        std::ios_base::hex|std::ios_base::internal|std::ios_base::left|
        std::ios_base::oct|std::ios_base::right|std::ios_base::scientific|
        std::ios_base::showbase|std::ios_base::showpoint|std::ios_base::showpos|
        std::ios_base::skipws|std::ios_base::unitbuf|std::ios_base::uppercase|
        std::ios_base::adjustfield|std::ios_base::basefield|std::ios_base::floatfield);
    // the '0' char is used hex escape chars, which always have width 2
    std::cerr.fill('0');

    std::cerr << '"';
    for (std::string::size_type i = 0; i < s.size(); ++i)
        DebugPrintAtom_(s[i]);
    std::cerr << '"';

    // restore the saved std::cerr properties
    std::cerr.setf(saved_stream_flags);
    std::cerr.fill(saved_stream_fill);
    std::cerr.width(saved_stream_width);
    std::cerr.precision(saved_stream_precision);
}

// the order of the states indicates priority (only for accept states).
// the lower the state's index in this array, the higher its priority.
ReflexCpp_::AutomatonApparatus_::DfaState_ const Scanner::ms_state_table_[] =
{
    { 14, 2, ms_transition_table_+0 },
    { 14, 30, ms_transition_table_+2 },
    { 13, 0, ms_transition_table_+32 },
    { 10, 0, ms_transition_table_+32 },
    { 11, 0, ms_transition_table_+32 },
    { 9, 0, ms_transition_table_+32 },
    { 0, 1, ms_transition_table_+32 },
    { 14, 1, ms_transition_table_+33 },
    { 1, 3, ms_transition_table_+34 },
    { 14, 4, ms_transition_table_+37 },
    { 14, 2, ms_transition_table_+41 },
    { 1, 0, ms_transition_table_+43 },
    { 1, 1, ms_transition_table_+43 },
    { 0, 2, ms_transition_table_+44 },
    { 0, 2, ms_transition_table_+46 },
    { 3, 0, ms_transition_table_+48 },
    { 13, 1, ms_transition_table_+48 },
    { 14, 1, ms_transition_table_+49 },
    { 14, 1, ms_transition_table_+50 },
    { 14, 1, ms_transition_table_+51 },
    { 6, 0, ms_transition_table_+52 },
    { 13, 1, ms_transition_table_+52 },
    { 14, 1, ms_transition_table_+53 },
    { 14, 1, ms_transition_table_+54 },
    { 7, 0, ms_transition_table_+55 },
    { 4, 0, ms_transition_table_+55 },
    { 13, 1, ms_transition_table_+55 },
    { 14, 1, ms_transition_table_+56 },
    { 8, 0, ms_transition_table_+57 },
    { 13, 1, ms_transition_table_+57 },
    { 2, 0, ms_transition_table_+58 },
    { 5, 0, ms_transition_table_+58 },
    { 12, 30, ms_transition_table_+58 }
};
ReflexCpp_::Size_ const Scanner::ms_state_count_ = sizeof(Scanner::ms_state_table_) / sizeof(ReflexCpp_::AutomatonApparatus_::DfaState_);

ReflexCpp_::AutomatonApparatus_::DfaTransition_ const Scanner::ms_transition_table_[] =
{
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_CONDITIONAL_, 2, 0, ms_state_table_+1 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_CONDITIONAL_, 2, 2, ms_state_table_+32 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 9, 9, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 10, 10, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 32, 32, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 44, 44, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 45, 45, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 46, 46, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 47, 47, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 48, 48, ms_state_table_+6 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 92, 92, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 93, 93, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 94, 94, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 101, 101, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 102, 102, ms_state_table_+16 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 103, 103, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 104, 104, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 105, 105, ms_state_table_+25 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 109, 109, ms_state_table_+26 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 112, 112, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 113, 113, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 114, 114, ms_state_table_+31 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 1, 8, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 11, 31, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 33, 39, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 40, 43, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 49, 57, ms_state_table_+13 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 58, 91, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 95, 100, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 106, 108, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 110, 111, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 115, 255, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 46, 46, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 48, 57, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 69, 69, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 101, 101, ms_state_table_+9 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 48, 57, ms_state_table_+8 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 43, 43, ms_state_table_+10 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 45, 45, ms_state_table_+10 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 48, 48, ms_state_table_+11 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 49, 57, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 48, 48, ms_state_table_+11 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 49, 57, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 48, 57, ms_state_table_+12 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 46, 46, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 48, 57, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 46, 46, ms_state_table_+7 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 48, 57, ms_state_table_+14 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 108, 108, ms_state_table_+17 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 111, 111, ms_state_table_+18 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 97, 97, ms_state_table_+19 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 116, 116, ms_state_table_+20 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 101, 101, ms_state_table_+22 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 108, 108, ms_state_table_+23 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 112, 112, ms_state_table_+24 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 111, 111, ms_state_table_+27 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 100, 100, ms_state_table_+28 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 105, 105, ms_state_table_+30 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 9, 9, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 10, 10, ms_state_table_+4 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 32, 32, ms_state_table_+3 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 44, 44, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 45, 45, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 46, 46, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 47, 47, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 48, 48, ms_state_table_+6 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 92, 92, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 93, 93, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 94, 94, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 101, 101, ms_state_table_+15 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 102, 102, ms_state_table_+16 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 103, 103, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 104, 104, ms_state_table_+21 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 105, 105, ms_state_table_+25 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 109, 109, ms_state_table_+26 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 112, 112, ms_state_table_+29 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 113, 113, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_, 114, 114, ms_state_table_+31 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 1, 8, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 11, 31, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 33, 39, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 40, 43, ms_state_table_+5 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 49, 57, ms_state_table_+13 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 58, 91, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 95, 100, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 106, 108, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 110, 111, ms_state_table_+2 },
    { ReflexCpp_::AutomatonApparatus_::DfaTransition_::TT_INPUT_ATOM_RANGE_, 115, 255, ms_state_table_+2 }
};
ReflexCpp_::Size_ const Scanner::ms_transition_count_ = sizeof(Scanner::ms_transition_table_) / sizeof(ReflexCpp_::AutomatonApparatus_::DfaTransition_);

ReflexCpp_::Uint32_ const Scanner::ms_accept_handler_count_ = 14;


#line 59 "calculator_scanner.reflex"

} // end of namespace Calculator

#line 543 "calculator_scanner.cpp"
