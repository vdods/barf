// ///////////////////////////////////////////////////////////////////////////
// calculator_parser.trison by Victor Dods, created 2007/11/10
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%targets cpp


%target.cpp.header_filename "calculator_parser.hpp"
%target.cpp.implementation_filename "calculator_parser.cpp"


%target.cpp.top_of_header_file %{
#if !defined(_CALCULATOR_PARSER_HPP_)
#define _CALCULATOR_PARSER_HPP_

#include "calculator.hpp"

namespace Calculator {

class Scanner;
%}
%target.cpp.class_name Parser
%target.cpp.bottom_of_class {
    bool ShouldPrintResult () const { return m_should_print_result; }

    void SetInputString (string const &input_string);

private:

    Scanner *m_scanner;
    cl_N m_last_result;
    cl_R m_modulus;
    bool m_should_print_result;
}

%target.cpp.bottom_of_header_file %{
} // end of namespace Calculator

#endif // !defined(_CALCULATOR_PARSER_HPP_)
%}


%target.cpp.top_of_implementation_file %{
#include "calculator_scanner.hpp"

#define MODULO(x) (zerop(m_modulus) ? x : cl_N(mod(realpart(x), m_modulus)))

namespace Calculator {
%}
%target.cpp.constructor_actions {
    m_scanner = NULL;
    m_last_result = cl_I(0);
    m_modulus = cl_I(0);
    m_should_print_result = true;
}
%target.cpp.destructor_actions {
    delete m_scanner;
    m_scanner = NULL;
}
%target.cpp.start_of_parse_method_actions %{
    m_should_print_result = true;
%}
%target.cpp.bottom_of_implementation_file %{
void Parser::SetInputString (string const &input_string)
{
    if (m_scanner != NULL)
        delete m_scanner;
    m_scanner = new Scanner(input_string);
    ResetForNewInput();
}

} // end of namespace Calculator
%}


%target.cpp.token_data_type "cl_N"
%target.cpp.token_data_default "0"
%target.cpp.scan_actions {
    assert(m_scanner != NULL);
    return m_scanner->Scan();
}


%target.cpp.generate_debug_spew_code
%target.cpp.dont_generate_timestamps


%terminal BAD_TOKEN
%terminal NEWLINE
%terminal NUMBER
%terminal RESULT
%terminal FLOAT HELP MOD
%terminal '+' '-' '*' '/' '^' '(' ')' '\\'

%prec.left ADDITION
%prec.left MULTIPLICATION
%prec.right UNARY
%prec.right EXPONENTIATION

%default_parse_nonterminal root

%%

%nonterminal root
:
    // empty reduction rule
    %target.cpp {
        m_should_print_result = false;
        return 0;
    }
|
    expression:result
    %target.cpp {
        result = MODULO(result);
        if (m_should_print_result)
            m_last_result = result;
        return result;
    }
|
    command
    %target.cpp {
        m_should_print_result = false;
        return 0;
    }
;

%nonterminal expression
:
    expression:lhs '+' expression:rhs %prec ADDITION %target.cpp { return MODULO(lhs + rhs); }
|
    expression:lhs '-' expression:rhs %prec ADDITION %target.cpp { return MODULO(lhs - rhs); }
|
    expression:lhs '*' expression:rhs %prec MULTIPLICATION %target.cpp { return MODULO(lhs * rhs); }
|
    expression:lhs '/' expression:rhs %prec MULTIPLICATION
    %target.cpp {
        if (zerop(rhs))
        {
            cerr << "error: divide by zero" << endl;
            m_should_print_result = false;
            return rhs; // arbitrary return value
        }
        else
            return lhs / rhs;
    }
|
    '+' expression:exp %prec UNARY %target.cpp { return MODULO(exp); }
|
    '-' expression:exp %prec UNARY %target.cpp { return MODULO(-exp); }
|
    expression:base '^' expression:power %prec EXPONENTIATION
    %target.cpp {
        if (zerop(base) && zerop(power))
        {
            cerr << "error: taking 0 to the 0 power" << endl;
            m_should_print_result = false;
            return base; // arbitrary return value
        }
        else
            return MODULO(expt(base, power));
    }
|
    '(' expression:exp ')' %target.cpp { return exp; }
|
    NUMBER:number %target.cpp { return MODULO(number); }
|
    RESULT %target.cpp { return m_last_result; }
;

%nonterminal command
:
    '\\' FLOAT
    %target.cpp {
        cout << "last result in floating-point: " << cl_float(realpart(m_last_result), float_format(FLOAT_DIGITS));
        if (!zerop(imagpart(m_last_result)))
            cout << " + " << cl_float(imagpart(m_last_result)) << "i";
        cout << endl;
        return 0;
    }
|
    '\\' HELP
    %target.cpp {
        cout << "Operators\n"
                "  + - * / ^ ( )\n"
                "Symbols\n"
                "  r          - The value of the previous result.\n"
                "  pi         - The ratio of a circle's circumference to its diameter.\n"
                "  e          - The base of the natural logarithm.\n"
                "  i          - The square root of -1.\n"
                "Commands\n"
                "  \\float     - Print last result in floating point format.\n"
                "  \\help      - This help screen.\n"
                "  \\mod [arg] - Sets the modulus (i.e. modulo arithmetic).  Giving no\n"
                "               argument will print the current modulus.  A modulus\n"
                "               of 0 indicates no result truncation." << endl;
        return 0;
    }
|
    '\\' MOD NUMBER:number
    %target.cpp {
        if (realpart(number) >= 0 && zerop(imagpart(number)))
        {
            m_modulus = realpart(number);
            cout << "current modulus set to: " << m_modulus << endl;
        }
        else
            cerr << "error: invalid modulus (must be non-negative, real)" << endl;
        return 0;
    }
|
    '\\' MOD
    %target.cpp {
        cout << "current modulus: " << m_modulus << endl;
        return 0;
    }
;

%nonterminal at_least_zero_newlines
:
    at_least_zero_newlines NEWLINE %target.cpp { return 0; }
|
    /* empty reduction rule */ %target.cpp { return 0; }
;
