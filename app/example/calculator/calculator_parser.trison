// ///////////////////////////////////////////////////////////////////////////
// calculator_parser.trison by Victor Dods, created 2007/11/10
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_class_name "Parser"

%parser_header_file_top%{
#if !defined(_CALCULATOR_PARSER_HPP_)
#define _CALCULATOR_PARSER_HPP_

#include "calculator.hpp"

namespace Calculator {

class Scanner;
%}

%parser_class_methods_and_members{
public:

    bool ShouldPrintResult () const { return m_should_print_result; }

    void SetInputString (string const &input_string);

private:

    Token::Type Scan ();

    Scanner *m_scanner;
    cl_N m_last_result;
    cl_R m_modulus;
    bool m_should_print_result;
}

%parser_header_file_bottom%{
} // end of namespace Calculator

#endif // !defined(_CALCULATOR_PARSER_HPP_)
%}

%parser_implementation_file_top%{
#include "calculator_scanner.hpp"

#define MODULO(x) (zerop(m_modulus) ? x : cl_N(mod(realpart(x), m_modulus)))

namespace Calculator {
%}

%parser_constructor_actions{
    m_scanner = NULL;
    m_last_result = cl_I(0);
    m_modulus = cl_I(0);
    m_should_print_result = true;
}

%parser_destructor_actions{
    delete m_scanner;
    m_scanner = NULL;
}

%parser_start_of_parse_method_actions{
    m_should_print_result = true;
}

%parser_throw_away_token_actions{
}

%parser_implementation_file_bottom%{
void Parser::SetInputString (string const &input_string)
{
    if (m_scanner != NULL)
        delete m_scanner;
    m_scanner = new Scanner(input_string);
}

Parser::Token::Type Parser::Scan ()
{
    assert(m_scanner != NULL);
    return m_scanner->Scan(m_lookahead_token);
}

} // end of namespace Calculator
%}

%parser_base_assigned_type "cl_N"
%parser_base_assigned_type_sentinel "0"

%token BAD_TOKEN
%token NEWLINE
%token NUMBER
%token RESULT
%token MOD FLOAT
%token '+' '-' '*' '/' '^' '(' ')' '\\'

%prec ADDITION
%prec MULTIPLICATION
%prec UNARY
%prec EXPONENTIATION

%start root

%%

root
:
    // empty reduction rule
    {
        m_should_print_result = false;
        return 0;
    }
|
    expression:result
    {
        result = MODULO(result);
        if (m_should_print_result)
            m_last_result = result;
        return result;
    }
|
    command
    {
        m_should_print_result = false;
        return 0;
    }
;

expression
:
    expression:lhs '+' expression:rhs %left %prec ADDITION { return MODULO(lhs + rhs); }
|
    expression:lhs '-' expression:rhs %left %prec ADDITION { return MODULO(lhs - rhs); }
|
    expression:lhs '*' expression:rhs %left %prec MULTIPLICATION { return MODULO(lhs * rhs); }
|
    expression:lhs '/' expression:rhs %left %prec MULTIPLICATION
    {
        if (zerop(rhs))
        {
            cerr << "error: divide by zero" << endl;
            m_should_print_result = false;
            return rhs; // arbitrary return value
        }
        else
            return lhs / rhs;
    }
|
    '+' expression:exp %right %prec UNARY { return MODULO(exp); }
|
    '-' expression:exp %right %prec UNARY { return MODULO(-exp); }
|
    expression:base '^' expression:power %right %prec EXPONENTIATION
    {
        if (zerop(base) && zerop(power))
        {
            cerr << "error: taking 0 to the 0 power" << endl;
            m_should_print_result = false;
            return base; // arbitrary return value
        }
        else
            return MODULO(expt(base, power));
    }
|
    '(' expression:exp ')' { return exp; }
// |
//     FLOAT '(' expression:exp ')' { return 
|
    NUMBER:number { return MODULO(number); }
|
    RESULT { return m_last_result; }
;

command
:
    '\\' MOD expression:exp
    {
        if (realpart(exp) >= 0 && zerop(imagpart(exp)))
            m_modulus = realpart(exp);
        else
            cerr << "error: invalid modulus (must be non-negative, real)" << endl;
        return 0;
    }
|
    '\\' MOD
    {
        cout << "current modulus: " << m_modulus << endl;
        return 0;
    }
;

at_least_zero_newlines
:
    at_least_zero_newlines NEWLINE { return 0; }
|
    /* empty reduction rule */ { return 0; }
;
