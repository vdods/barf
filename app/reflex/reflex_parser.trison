// ///////////////////////////////////////////////////////////////////////////
// reflex_parser.trison by Victor Dods, created 2006/10/18
// ///////////////////////////////////////////////////////////////////////////
// Unless a different license was explicitly granted in writing by the
// copyright holder (Victor Dods), this software is freely distributable under
// the terms of the GNU General Public License, version 2.  Any works deriving
// from this work must also be released under the GNU GPL.  See the included
// file LICENSE for details.
// ///////////////////////////////////////////////////////////////////////////

%parser_class_name "Parser"

%parser_header_file_top%{
#if !defined(_REFLEX_PARSER_HPP_)
#define _REFLEX_PARSER_HPP_

#include "reflex.hpp"

#include "barf_commonlang_scanner.hpp"
#include "barf_message.hpp"

namespace Barf {
namespace Ast {

class Base;

} // end of namespace Ast

namespace CommonLang {

class TargetMap;

} // end of namespace CommonLang

namespace Regex {

class RegularExpressionMap;

} // end of namespace Regex
} // end of namespace Barf

namespace Reflex {
%}

%parser_class_methods_and_members{
    FiLoc const &GetFiLoc () const { return m_scanner.GetFiLoc(); }

    bool ScannerDebugSpew () const { return m_scanner.DebugSpew(); }
    void ScannerDebugSpew (bool debug_spew) { m_scanner.DebugSpew(debug_spew); }

    bool OpenFile (string const &input_filename);

private:

    Token::Type Scan ();

    CommonLang::Scanner m_scanner;
    CommonLang::TargetMap *m_target_map;
    Regex::RegularExpressionMap *m_regex_macro_map;
}

%parser_header_file_bottom%{
} // end of namespace Reflex

#endif // !defined(_REFLEX_PARSER_HPP_)
%}

%parser_implementation_file_top%{
#include <sstream>

#include "barf_regex_ast.hpp"
#include "barf_regex_parser.hpp"
#include "reflex_ast.hpp"

namespace Reflex {
%}

%parser_constructor_actions{
    m_target_map = NULL;
    m_regex_macro_map = NULL;
}

%parser_destructor_actions{
}

%parser_throw_away_token_actions{
    delete token;
}

%parser_implementation_file_bottom%{
bool Parser::OpenFile (string const &input_filename)
{
    return m_scanner.OpenFile(input_filename);
}

Parser::Token::Type Parser::Scan ()
{
    CommonLang::Scanner::Token::Type scanner_token_type = m_scanner.Scan(&m_lookahead_token);
    assert(scanner_token_type >= 0);
    if (scanner_token_type < 0x100)
        return Parser::Token::Type(scanner_token_type);
    switch (scanner_token_type)
    {
        case CommonLang::Scanner::Token::BAD_END_OF_FILE:                 return Parser::Token::END_;
        case CommonLang::Scanner::Token::BAD_TOKEN:                       return Parser::Token::BAD_TOKEN;
        case CommonLang::Scanner::Token::DIRECTIVE_MACRO:                 return Parser::Token::DIRECTIVE_MACRO;
        case CommonLang::Scanner::Token::DIRECTIVE_START_IN_SCANNER_MODE: return Parser::Token::DIRECTIVE_START_IN_SCANNER_MODE;
        case CommonLang::Scanner::Token::DIRECTIVE_STATE:                 return Parser::Token::DIRECTIVE_STATE;
        case CommonLang::Scanner::Token::DIRECTIVE_TARGET:                return Parser::Token::DIRECTIVE_TARGET;
        case CommonLang::Scanner::Token::DIRECTIVE_TARGETS:               return Parser::Token::DIRECTIVE_TARGETS;
        case CommonLang::Scanner::Token::DUMB_CODE_BLOCK:                 return Parser::Token::DUMB_CODE_BLOCK;
        case CommonLang::Scanner::Token::END_OF_FILE:                     return Parser::Token::END_;
        case CommonLang::Scanner::Token::END_PREAMBLE:                    return Parser::Token::END_PREAMBLE;
        case CommonLang::Scanner::Token::ID:                              return Parser::Token::ID;
        case CommonLang::Scanner::Token::NEWLINE:                         return Parser::Token::NEWLINE;
        case CommonLang::Scanner::Token::REGEX:                           return Parser::Token::REGEX;
        case CommonLang::Scanner::Token::STRICT_CODE_BLOCK:               return Parser::Token::STRICT_CODE_BLOCK;
        case CommonLang::Scanner::Token::STRING_LITERAL:                  return Parser::Token::STRING_LITERAL;

        case CommonLang::Scanner::Token::CHAR_LITERAL:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_CODESPEC:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_OPTIONAL_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_ADD_REQUIRED_DIRECTIVE:
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT:
        case CommonLang::Scanner::Token::DIRECTIVE_DEFAULT_PARSE_NONTERMINAL:
        case CommonLang::Scanner::Token::DIRECTIVE_DUMB_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_ERROR:
        case CommonLang::Scanner::Token::DIRECTIVE_ID:
        case CommonLang::Scanner::Token::DIRECTIVE_LEFT:
        case CommonLang::Scanner::Token::DIRECTIVE_NONASSOC:
        case CommonLang::Scanner::Token::DIRECTIVE_NONTERMINAL:
        case CommonLang::Scanner::Token::DIRECTIVE_PREC:
        case CommonLang::Scanner::Token::DIRECTIVE_RIGHT:
        case CommonLang::Scanner::Token::DIRECTIVE_STRICT_CODE_BLOCK:
        case CommonLang::Scanner::Token::DIRECTIVE_STRING:
        case CommonLang::Scanner::Token::DIRECTIVE_TERMINAL:
        case CommonLang::Scanner::Token::DIRECTIVE_TYPE:
            assert(m_lookahead_token != NULL);
            EmitError(m_lookahead_token->GetFiLoc(), "unrecognized token encountered in targetspec");
            delete m_lookahead_token;
            m_lookahead_token = NULL;
            return Parser::Token::BAD_TOKEN;

        default:
            assert(false && "this should never happen");
            return Parser::Token::BAD_TOKEN;
    }
}

} // end of namespace Reflex
%}

%parser_base_assigned_type "Ast::Base *"
%parser_base_assigned_type_sentinel "NULL"
%parser_custom_cast "Dsc"

%token BAD_TOKEN
%token DIRECTIVE_MACRO %type "Ast::ThrowAway *"
%token DIRECTIVE_START_IN_SCANNER_MODE %type "Ast::ThrowAway *"
%token DIRECTIVE_STATE %type "Ast::ThrowAway *"
%token DIRECTIVE_TARGET %type "Ast::ThrowAway *"
%token DIRECTIVE_TARGETS %type "Ast::ThrowAway *"
%token DUMB_CODE_BLOCK %type "Ast::DumbCodeBlock *"
%token END_PREAMBLE %type "Ast::ThrowAway *"
%token ID %type "Ast::Id *"
%token NEWLINE
%token REGEX %type "Ast::String *"
%token STRICT_CODE_BLOCK %type "Ast::StrictCodeBlock *"
%token STRING_LITERAL %type "Ast::String *"
%token '.' ':' '|' ';'

%start root

%%

// ///////////////////////////////////////////////////////////////////////////
// root rule
// ///////////////////////////////////////////////////////////////////////////

root %type "PrimarySource *"
:
    at_least_zero_newlines
    targets_directive:target_map
    target_directives
    macro_directives:regular_expression_map
    start_in_scanner_mode_directive:start_in_scanner_mode_directive
    END_PREAMBLE:throwaway
    scanner_modes:scanner_mode_map
    {
        assert(m_target_map != NULL);
        assert(target_map == m_target_map);

        // set the TargetMap's primary source path
        target_map->SetSourcePath(m_scanner.GetInputName());
        // make sure the %start_in_scanner_mode directive value specifies a real scanner mode
        if (start_in_scanner_mode_directive != NULL &&
            scanner_mode_map->GetElement(start_in_scanner_mode_directive->m_scanner_mode_id->GetText()) == NULL)
        {
            EmitError(
                start_in_scanner_mode_directive->GetFiLoc(),
                "undeclared state \"" + start_in_scanner_mode_directive->m_scanner_mode_id->GetText() + "\"");
        }

        PrimarySource *primary_source =
            new PrimarySource(
                target_map,
                regular_expression_map,
                start_in_scanner_mode_directive,
                throwaway->GetFiLoc(),
                scanner_mode_map);
        delete throwaway;
        return primary_source;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// targets directive rules
// ///////////////////////////////////////////////////////////////////////////

targets_directive %type "CommonLang::TargetMap *"
:
    DIRECTIVE_TARGETS:throwaway target_ids:target_map at_least_one_newline
    {
        assert(m_target_map == NULL);
        m_target_map = target_map;
        delete throwaway;
        return target_map;
    }
|
    // empty reduction rule
    {
        assert(m_target_map == NULL);
        m_target_map = new CommonLang::TargetMap();
        return m_target_map;
    }
|
    DIRECTIVE_TARGETS:throwaway %error at_least_one_newline
    {
        assert(m_target_map == NULL);
        EmitError(throwaway->GetFiLoc(), "parse error in directive %targets");
        m_target_map = new CommonLang::TargetMap();
        return m_target_map;
    }
;

target_ids %type "CommonLang::TargetMap *"
:
    target_ids:target_map ID:target_id
    {
        CommonLang::Target *target = new CommonLang::Target(target_id->GetText());
        target->EnableCodeGeneration();
        target_map->Add(target_id->GetText(), target);
        return target_map;
    }
|
    // empty reduction rule
    {
        assert(m_target_map == NULL);
        return new CommonLang::TargetMap();
    }
;

// ///////////////////////////////////////////////////////////////////////////
// target directive rules
// ///////////////////////////////////////////////////////////////////////////

target_directives
:
    target_directives target_directive:target_directive
    {
        assert(m_target_map != NULL);
        if (target_directive != NULL)
            m_target_map->AddTargetDirective(target_directive);
        return NULL;
    }
|
    // empty reduction rule
    {
        if (m_target_map == NULL)
            m_target_map = new CommonLang::TargetMap();
        return NULL;
    }
;

target_directive %type "CommonLang::TargetDirective *"
:
    DIRECTIVE_TARGET:throwaway '.' ID:target_id '.' ID:target_directive target_directive_param:param at_least_one_newline
    {
        delete throwaway;
        return new CommonLang::TargetDirective(target_id, target_directive, param);
    }
|
    DIRECTIVE_TARGET:throwaway '.' ID:target_id '.' ID:target_directive %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in parameter for directive %target." + target_id->GetText() + "." + target_directive->GetText());
        delete throwaway;
        delete target_id;
        delete target_directive;
        return NULL;
    }
|
    DIRECTIVE_TARGET:throwaway '.' ID:target_id %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in directive name for directive %target." + target_id->GetText());
        delete throwaway;
        delete target_id;
        return NULL;
    }
|
    DIRECTIVE_TARGET:throwaway %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in target name for directive %target");
        delete throwaway;
        return NULL;
    }
;

target_directive_param %type "Ast::TextBase *"
:
    ID:value                    { return value; }
|   STRING_LITERAL:value        { return value; }
|   STRICT_CODE_BLOCK:value     { return value; }
|   DUMB_CODE_BLOCK:value       { return value; }
|   /* empty reduction rule */  { return NULL; }
;

// ///////////////////////////////////////////////////////////////////////////
// macro directive rules
// ///////////////////////////////////////////////////////////////////////////

macro_directives %type "Regex::RegularExpressionMap *"
:
    macro_directives:regular_expression_map DIRECTIVE_MACRO:throwaway ID:macro_id REGEX:macro_regex_string at_least_one_newline
    {
        Regex::Parser parser;
        istringstream in(macro_regex_string->GetText());
        parser.OpenUsingStream(&in, "%macro " + macro_regex_string->GetText(), false);
        try {
            if (parser.Parse(regular_expression_map) == Regex::Parser::PRC_SUCCESS)
                regular_expression_map->Add(
                    macro_id->GetText(),
                    Dsc<Regex::RegularExpression *>(parser.GetAcceptedToken()));
            else
                EmitError(throwaway->GetFiLoc(), "parse error in regular expression (" + macro_regex_string->GetText() + ")");
        } catch (string const &exception) {
            EmitError(throwaway->GetFiLoc(), exception + " in regular expression (" + macro_regex_string->GetText() + ")");
        }
        delete throwaway;
        delete macro_id;
        delete macro_regex_string;
        return regular_expression_map;
    }
|
    // empty reduction rule
    {
        // we save the regex macro map in a member var, so that the reduction
        // rule handler for the scanner mode rules can use it.
        m_regex_macro_map = new Regex::RegularExpressionMap();
        return m_regex_macro_map;
    }
|
    macro_directives:regular_expression_map DIRECTIVE_MACRO:throwaway ID:macro_id %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in directive %macro " + macro_id->GetText());
        delete throwaway;
        delete macro_id;
        return regular_expression_map;
    }
|
    macro_directives:regular_expression_map DIRECTIVE_MACRO:throwaway %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in directive %macro");
        delete throwaway;
        return regular_expression_map;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// start directive rule
// ///////////////////////////////////////////////////////////////////////////

start_in_scanner_mode_directive %type "StartInScannerModeDirective *"
:
    DIRECTIVE_START_IN_SCANNER_MODE:throwaway ID:scanner_mode_id at_least_one_newline
    {
        delete throwaway;
        return new StartInScannerModeDirective(scanner_mode_id);
    }
|
    DIRECTIVE_START_IN_SCANNER_MODE:throwaway %error at_least_one_newline
    {
        EmitError(throwaway->GetFiLoc(), "parse error in directive %start_in_scanner_mode");
        delete throwaway;
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// scanner mode rules
// ///////////////////////////////////////////////////////////////////////////

scanner_modes %type "ScannerModeMap *"
:
    scanner_modes:scanner_mode_map scanner_mode:scanner_mode
    {
        if (scanner_mode != NULL)
            scanner_mode_map->Add(scanner_mode->m_scanner_mode_id->GetText(), scanner_mode);
        return scanner_mode_map;
    }
|
    // empty reduction rule
    {
        return new ScannerModeMap();
    }
;

scanner_mode %type "ScannerMode *"
:
    DIRECTIVE_STATE:throwaway ID:scanner_mode_id ':' scanner_mode_rules:rule_list ';'
    {
        delete throwaway;
        return new ScannerMode(scanner_mode_id, rule_list);
    }
|
    DIRECTIVE_STATE:throwaway ID:scanner_mode_id ':' %error ';'
    {
        EmitError(throwaway->GetFiLoc(), "parse error in scanner mode rule list");
        delete throwaway;
        return new ScannerMode(scanner_mode_id, new RuleList());
    }
|
    DIRECTIVE_STATE:throwaway %error ':' scanner_mode_rules:rule_list ';'
    {
        EmitError(throwaway->GetFiLoc(), "parse error in scanner mode id");
        delete throwaway;
        delete rule_list;
        return NULL;
    }
;

scanner_mode_rules %type "RuleList *"
:
    rule_list:rule_list
    {
        return rule_list;
    }
|
    // empty reduction rule
    {
        return new RuleList();
    }
;

rule_list %type "RuleList *"
:
    rule_list:rule_list '|' rule:rule
    {
        rule_list->Append(rule);
        return rule_list;
    }
|
    rule:rule
    {
        RuleList *rule_list = new RuleList();
        rule_list->Append(rule);
        return rule_list;
    }
;

rule %type "Rule *"
:
    REGEX:regex_string rule_handlers:rule_handler_map
    {
        assert(m_regex_macro_map != NULL);

        // parse the rule regex
        Regex::RegularExpression *regex = NULL;
        {
            Regex::Parser parser;
            istringstream in(regex_string->GetText());
            parser.OpenUsingStream(&in, regex_string->GetText(), false);
            try {
                if (parser.Parse(m_regex_macro_map) == Regex::Parser::PRC_SUCCESS)
                    regex = Dsc<Regex::RegularExpression *>(parser.GetAcceptedToken());
                else
                {
                    EmitError(
                        regex_string->GetFiLoc(),
                        "parse error in regular expression (" + regex_string->GetText() + ")");
                    regex = new Regex::RegularExpression();
                }
            } catch (string const &exception) {
                EmitError(
                    regex_string->GetFiLoc(),
                    exception + " in regular expression (" + regex_string->GetText() + ")");
                regex = new Regex::RegularExpression();
            }
            assert(regex != NULL);
        }

        // enforcement of presence of rule handlers for all targets
        assert(m_target_map != NULL);
        for (CommonLang::TargetMap::const_iterator it = m_target_map->begin(),
                                                           it_end = m_target_map->end();
             it != it_end;
             ++it)
        {
            string const &target_id = it->first;
            if (rule_handler_map->GetElement(target_id) == NULL)
            {
                EmitWarning(
                    regex_string->GetFiLoc(),
                    "missing rule handler for target \"" + target_id + "\"");
                // add a blank code block for the rule handler's missing target
                rule_handler_map->Add(
                    target_id,
                    new CommonLang::RuleHandler(
                        new Ast::Id(target_id, FiLoc::ms_invalid),
                        new Ast::StrictCodeBlock(FiLoc::ms_invalid)));
                assert(rule_handler_map->GetElement(target_id) != NULL);
            }
        }

        Rule *rule = new Rule(regex_string->GetText(), regex, rule_handler_map);
        delete regex_string;
        return rule;
    }
;

rule_handlers %type "CommonLang::RuleHandlerMap *"
:
    rule_handlers:rule_handler_map rule_handler:rule_handler
    {
        if (rule_handler != NULL)
            rule_handler_map->Add(rule_handler->m_target_id->GetText(), rule_handler);
        return rule_handler_map;
    }
|
    // empty reduction rule
    {
        return new CommonLang::RuleHandlerMap();
    }
;

rule_handler %type "CommonLang::RuleHandler *"
:
    DIRECTIVE_TARGET:throwaway '.' ID:target_id any_type_of_code_block:code_block
    {
        delete throwaway;
        assert(m_target_map != NULL);
        if (m_target_map->GetElement(target_id->GetText()) == NULL)
            EmitWarning(
                target_id->GetFiLoc(),
                "undeclared target \"" + target_id->GetText() + "\"");
        return new CommonLang::RuleHandler(target_id, code_block);
    }
|
    DIRECTIVE_TARGET:throwaway %error any_type_of_code_block:code_block
    {
        assert(m_target_map != NULL);
        EmitError(throwaway->GetFiLoc(), "parse error in target id after directive %target");
        delete throwaway;
        delete code_block;
        return NULL;
    }
|
    DIRECTIVE_TARGET:throwaway %error
    {
        assert(m_target_map != NULL);
        EmitError(throwaway->GetFiLoc(), "parse error in directive %target");
        delete throwaway;
        return NULL;
    }
|
    %error any_type_of_code_block:code_block
    {
        assert(m_target_map != NULL);
        EmitError(code_block->GetFiLoc(), "missing directive %target before rule handler code block");
        delete code_block;
        return NULL;
    }
;

// ///////////////////////////////////////////////////////////////////////////
// misc rules
// ///////////////////////////////////////////////////////////////////////////

any_type_of_code_block %type "Ast::CodeBlock *"
:
    DUMB_CODE_BLOCK:dumb_code_block { return dumb_code_block; }
|
    STRICT_CODE_BLOCK:strict_code_block { return strict_code_block; }
;

at_least_zero_newlines
:
    at_least_zero_newlines NEWLINE  { return NULL; }
|
    /* empty reduction rule */  { return NULL; }
;

at_least_one_newline
:
    at_least_one_newline NEWLINE { return NULL; }
|
    NEWLINE { return NULL; }
;
