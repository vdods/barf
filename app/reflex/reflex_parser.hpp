// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY
// reflex_parser.hpp generated by trison
// from reflex_parser.trison using trison.cpp.targetspec and trison.cpp.header.codespec
// DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY ! DO NOT MODIFY

#pragma once


#include <cassert>
#include <cstdint>
#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <set>
#include <utility>
#include <vector>


#line 19 "reflex_parser.trison"

#if !defined(REFLEX_PARSER_HPP_)
#define REFLEX_PARSER_HPP_

#include "reflex.hpp"

#include "barf_commonlang_scanner.hpp"
#include "barf_message.hpp"
#include "reflex_ast.hpp"

namespace Barf {
namespace Ast {

class Base;

} // end of namespace Ast

namespace CommonLang {

struct TargetMap;

} // end of namespace CommonLang

namespace Regex {

struct RegularExpressionMap;

} // end of namespace Regex
} // end of namespace Barf

namespace Reflex {

#line 54 "reflex_parser.hpp"

/// @brief A parser class.
///
/// A parser class generated by trison
/// from reflex_parser.trison using trison.cpp.targetspec and trison.cpp.header.codespec.
///
/// The term "primary source" will be used to refer to the .trison source file from which
/// this file was generated.  Specifically, the primary source is reflex_parser.trison.
///
/// The term "client" will be used to refer to the programmer who is writing the trison
/// primary source file to generate a parser (e.g. "the client shouldn't return X from Y"
/// or "the client must provide a way to X and Y").
class Parser
{
public:

    /// Return values for Parse().
    enum ParserReturnCode : std::uint32_t
    {
        /// Indicates the Parse() method returned successfully.
        PRC_SUCCESS = 0,
        /// Indicates an unhandled parse error occurred (i.e. no %error-accepting
        /// rules were encountered).
        PRC_UNHANDLED_PARSE_ERROR,
        /// Indicates that the parse was halted because the number of realized
        /// lookaheads exceeded the max allowable lookahead count (NPDA target only).
        PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT,
        /// Indicates that the parse didn't complete because of some internal error.
        PRC_INTERNAL_ERROR
    }; // end of enum Parser::ParserReturnCode

    /// "Namespace" for Parser::Terminal::Name, which enumerates all valid
    /// token ids which this parser will accept as lookaheads.
    struct Terminal
    {
        /// @brief Acceptable values returnable to the parser in %target.cpp.scan_actions.
        /// There are two special terminals: END_ and ERROR_.
        ///
        /// Parser::Terminal::END_ should be returned in %target.cpp.scan_actions
        /// by the client when the input source has reached the end of input.  The parser
        /// will not request any more input after Parser::Terminal::END_ is received.
        ///
        /// Parser::Terminal::ERROR_ should not ever be used by the client, as
        /// it is used internally by the parser.
        ///
        /// The rest are the terminals as declared in the primary source, and should
        /// be used by the client when returning from %target.cpp.scan_actions.
        enum Name
        {
            END_ = 256,
            ERROR_ = 257,
            BAD_TOKEN = 258,
            DIRECTIVE_CASE_INSENSITIVE = 259,
            DIRECTIVE_MACRO = 260,
            DIRECTIVE_START_IN_STATE_MACHINE = 261,
            DIRECTIVE_STATE_MACHINE = 262,
            DIRECTIVE_TARGET = 263,
            DIRECTIVE_TARGETS = 264,
            DIRECTIVE_UNGREEDY = 265,
            DUMB_CODE_BLOCK = 266,
            END_PREAMBLE = 267,
            ID = 268,
            NEWLINE = 269,
            REGEX = 270,
            STRICT_CODE_BLOCK = 271,
            STRING_LITERAL = 272
        }; // end of enum Parser::Terminal::Name
    }; // end of struct Parser::Terminal

    /// "Namespace" for Parser::Nonterminal::Name, which enumerates all nonterminals.
    /// This is used internally by the parser, but is also used by the client to specify which
    /// nonterminal should be parsed by the parser.
    struct Nonterminal
    {
        /// There is one special nonterminal: none_.  This should not be used by the client,
        /// as it is only used internally by the parser.
        enum Name
        {
            none_ = 0,
            root = 273,
            preamble_directives = 274,
            preamble_directive = 275,
            targets_directive = 276,
            target_ids = 277,
            target_directive = 278,
            target_directive_param = 279,
            macro_directive = 280,
            start_with_state_machine_directive = 281,
            state_machines = 282,
            nonempty_state_machines = 283,
            state_machine = 284,
            state_machine_mode_flags_then_colon = 285,
            state_machine_mode_flags = 286,
            state_machine_mode_flag = 287,
            state_machine_rules_then_semicolon = 288,
            rule_list = 289,
            rule = 290,
            rule_handlers = 291,
            rule_handler = 292,
            any_type_of_code_block = 293,
            at_least_one_newline = 294
        }; // end of enum Parser::Nonterminal::Name
    }; // end of struct Parser::Nonterminal

    /// @brief Return type for %target.cpp.scan_actions.
    ///
    /// The client should package-up and return a Parser::Token from
    /// the code specified by %target.cpp.scan_actions, which delivers the
    /// token type and token data to the parser for input.  The constructor
    /// takes one or two parameters; the second can be omitted, indicating
    /// that the %target.cpp.token_data_default value will be used.
    struct Token
    {
        typedef std::uint32_t Id; // TODO -- smallest int
        typedef Ast::Base * Data;

        Id m_id;
        Data m_data;

        /// @brief Constructor for Token struct.
        ///
        /// @param id Gives the token id, e.g. Terminal::END_ or whatever
        ///        other terminals were declared in the primary source.
        /// @param data Gives the data associated with this token, e.g. if
        ///        you were constructing an AST, data would point to an AST
        ///        node constructed during scanning.
        Token (Id id, Data const &data = NULL) : m_id(id), m_data(data) { }
    }; // end of struct Parser::Token

public:

    /// Constructor.  The client can specify parameters in the primary source
    /// via the %target.cpp.constructor_parameters directive.
    Parser ();
    /// Destructor.  The client can force the destructor to be declared virtual
    /// by specifying the %target.cpp.force_virtual_destructor directive in the
    /// primary source.
    ~Parser ();

    /// @brief Returns true if and only if the next unshifted lookahead
    ///        token is Terminal::END_.
    ///
    /// It is not sufficient to just check the EOF condition on the input
    /// source (e.g. the scanner, cin, etc), because the parser may have read,
    /// but not consumed, additional lookaheads up to EOF.  Thus checking
    /// the input source for EOF condition may give false positives.  This
    /// method should be the preferred means to check EOF condition.
    ///
    /// It should be noted that this may cause the parser to read (but never
    /// consume) up to one additional lookahead token, owing to the necessity
    /// of checking what the next lookahead token is.
    bool IsAtEndOfInput ();
    /// Returns true iff the most recent parse encountered an error (even if it
    /// recovered using error handling rules in the grammar).
    bool HasEncounteredErrorState () const;
    /// Returns the highest value that MaxRealizedLookaheadCount may be before the
    /// PRC_EXCEEDED_MAX_ALLOWABLE_LOOKAHEAD_COUNT error is generated.  The default
    /// is set by the default_max_allowable_lookahead_count directive, which is
    /// documented in trison.cpp.targetspec.  A negative value means that there is
    /// no limit.
    std::int64_t MaxAllowableLookaheadCount () const;
    /// Returns the maximum number of lookaheads used in any parser decision so far
    /// (this is not the theoretical maximum for the grammar/npda, it's the maximum
    /// only for the states the parser has actually encountered).
    std::size_t MaxRealizedLookaheadCount () const;

    /// Sets the maximum allowable lookahead count.  The initial value is given by
    /// the default_max_allowable_lookahead_count directive defined in trison.cpp.targetspec.
    void SetMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count);

    /// Returns true if and only if "debug spew" is enabled (which prints, to the
    /// debug spew stream, exactly what the parser is doing at each step).  This
    /// method, along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    bool DebugSpewIsEnabled () const { return m_debug_spew_stream_ != NULL; }
    /// Returns the debug spew stream (see DebugSpewIsEnabled()).  This method,
    /// along with all other debug spew code can be removed by removing the
    /// %target.cpp.generate_debug_spew_code directive from the primary source.
    std::ostream *DebugSpewStream () { return m_debug_spew_stream_; }
    /// Sets the debug spew stream (see DebugSpewIsEnabled()).  If NULL is passed
    /// in, then debug spew printing will be disabled.  The default value is NULL.
    /// This method, along with all other debug spew code can be removed by removing
    /// the %target.cpp.generate_debug_spew_code directive from the primary source.
    void SetDebugSpewStream (std::ostream *debug_spew_stream) { m_debug_spew_stream_ = debug_spew_stream; }
    /// Returns the debug spew prefix string, which may depend on values like the
    /// current filename, line number, etc.
    std::string DebugSpewPrefix () const;

    /// @brief This method must be called if the input source changes.
    ///
    /// This parser is capable of attempting multiple contiguous parses from the
    /// same input source.  The lookahead queue is preserved between calls to
    /// Parse().  Therefore, if the input source changes, the lookahead queue
    /// must be cleared so that the new input source can be read.  The client
    /// must call this method if the input source changes.
    void ResetForNewInput ();

    /// @brief This is the main method of the parser; it will attempt to parse
    ///        the nonterminal specified.
    ///
    /// The %target.cpp.parse_method_access directive can be used to specify the
    /// access level of this method.
    ///
    /// The %target.cpp.top_of_parse_method_actions and
    /// %target.cpp.bottom_of_parse_method_actions directives can be used to specify
    /// code to execute at the beginning and end, respectively, of the Parse() method.
    /// This includes the ability to enclose the body of the Parse() method within a
    /// try {} block, for exception handling (if exceptions are thrown in scan_actions
    /// or any reduction rule code, then the %target.cpp.enable_scan_actions_exceptions
    /// or %target.cpp.enable_reduction_rule_exceptions directives must be specified
    /// respectively; this will cause the parser to catch and rethrow any exceptions
    /// thrown by scan_actions or reduction rule code, allowing it to clean up
    /// dynamically allocated memory, etc.
    ///
    /// @param return_token A pointer to the value which will be assigned to upon
    ///        successfully parsing the requested nonterminal. If the parse fails,
    ///        the value of the %target.cpp.token_data_default directive will
    ///        be assigned.
    /// @param nonterminal_to_parse The Parse() method can attempt to parse any
    ///        nonterminal declared in the primary source.  If unspecified, the
    ///        Parse() method will attempt to parse the nonterminal specified by the
    ///        %default_parse_nonterminal directive.
    /// @return Parser::PRC_SUCCESS if the parse was successful (which includes
    ///         occurrences of parse errors which were handled by client-specified
    ///         %error-accepting rules), or Parser::PRC_UNHANDLED_PARSE_ERROR
    ///         if a parse error was not handled by any %error-accepting rules.
    ParserReturnCode Parse (Ast::Base * *return_token, Nonterminal::Name nonterminal_to_parse = Nonterminal::root);


#line 52 "reflex_parser.trison"

    FiLoc const &GetFiLoc () const { return m_scanner.GetFiLoc(); }
    CommonLang::TargetMap &GetTargetMap () { assert(m_target_map != NULL); return *m_target_map; }
    CommonLang::TargetMap *StealTargetMap ();

    bool ScannerDebugSpewIsEnabled () const { return m_scanner.DebugSpewIsEnabled(); }
    std::ostream *ScannerDebugSpewStream () { return m_scanner.DebugSpewStream(); }
    void SetScannerDebugSpewStream (std::ostream *debug_spew_stream) { m_scanner.SetDebugSpewStream(debug_spew_stream); }

    bool OpenFile (string const &input_filename);
    void OpenString (string const &input_string, string const &input_name, bool use_line_numbers = false);
    void OpenUsingStream (istream *input_stream, string const &input_name, bool use_line_numbers);

private:

    CommonLang::Scanner m_scanner;
    CommonLang::TargetMap *m_target_map;
    // The regex macro map in a member var, so that the reduction rule handler for
    // the state machine rules can use it.
    Regex::RegularExpressionMap *m_regex_macro_map;
    // This is a member var because THERE CAN BE ONLY ONE.
    StartWithStateMachineDirective *m_start_with_state_machine_directive;

#line 308 "reflex_parser.hpp"


private:

    // ///////////////////////////////////////////////////////////////////////
    // begin internal trison-generated parser guts -- don't use
    // ///////////////////////////////////////////////////////////////////////

    std::int64_t m_max_allowable_lookahead_count;

    // debug spew methods
    void PrintIndented_ (std::ostream &stream, char const *string) const;

    std::ostream *m_debug_spew_stream_;

    static char const *const ms_parser_return_code_string_table_[];
    static std::size_t const ms_parser_return_code_string_count_;

    static char const *const ms_token_name_table_[];
    static std::size_t const ms_token_name_count_;

    static std::uint32_t NonterminalStartStateIndex_ (Nonterminal::Name nonterminal);
    ParserReturnCode Parse_ (Ast::Base * *return_token, Nonterminal::Name nonterminal_to_parse);
    void ThrowAwayToken_ (Token const &token) throw();
    void ThrowAwayTokenData_ (Ast::Base * const &token_data) throw();
    void ResetForNewInput_ () throw();
    Token Scan_ () throw();
    void RunNonassocErrorActions_ (Token const &lookahead);
    // debug spew methods
    void PrintParserStatus_ (std::ostream &out) const;

private:

    struct Grammar_
    {
        // TODO: Rename to Precedence
        struct Precedence_
        {
            std::int32_t    m_level;                // default precedence is 0, higher values have higher precedence.
            std::uint32_t   m_associativity_index;  // 0 for %left, 1 for %nonassoc, and 2 for %right.
            char const *    m_name;
        }; // end of struct Parser::Grammar_::Precedence_

        // TODO: Rename to Rule
        struct Rule_
        {
            Token::Id       m_reduction_nonterminal_token_id;
            std::uint32_t   m_token_count;
            std::uint32_t   m_precedence_index;
            char const *    m_description;
        }; // end of struct Parser::Grammar_::Rule_

        // TODO: Get rid of trailing _ chars

        // Returns true iff lhs_rule_index denotes a rule with a higher precedence than that denoted by rhs_rule_index.
        static bool CompareRuleByPrecedence_ (std::uint32_t lhs_rule_index, std::uint32_t rhs_rule_index);

        // TODO: rename to PRECEDENCE_TABLE and RULE_TABLE ?
        static Precedence_ const    ms_precedence_table_[];
        static std::size_t const    ms_precedence_count_;
        static Rule_ const          ms_rule_table_[];
        static std::size_t const    ms_rule_count_;
    }; // end of struct Parser::Grammar_

    struct Npda_
    {
        struct Transition_;

        // TODO: Get rid of trailing _ chars
        struct State_
        {
            std::size_t         m_transition_count; // TODO: smallest int
            Transition_ const * m_transition_table;
            std::uint32_t       m_associated_rule_index;
            char const *        m_description;
        }; // end of struct Parser::Grammar_::State_

        struct Transition_
        {
            // TODO: Make this into a strong enum (C++11)
            enum Type { RETURN = 1, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, EPSILON };
            std::uint8_t    m_type;
            // TODO: Rename this to m_token_id
            std::uint32_t   m_token_index;  // TODO: smallest int
            std::uint32_t   m_data_index;   // TODO: smallest int

            // TODO: Make a typedef for sorted type index?

            // Lexicographic ordering on the tuple (m_type, m_token_index, m_data_index).
            struct Order
            {
                // TODO: Rename SortedTypeIndex to ActionClassIndex?
                static std::uint32_t SortedTypeIndex (Type type)
                {
                    switch (type)
                    {
                        case REDUCE:
                        case SHIFT:
                            return 0;

                        case DISCARD_LOOKAHEAD:
                        case POP_STACK:
                            return 1;

                        case RETURN:
                            return 2;

                        case INSERT_LOOKAHEAD_ERROR:
                        case EPSILON:
                            return 3;

                        default:
                            assert(false && "this should never happen");
                            return 3; // Arbitrary
                    }
                }

                bool operator () (Transition_ const &lhs, Transition_ const &rhs) const
                {
                    std::uint32_t sorted_type_index_lhs = SortedTypeIndex(Type(lhs.m_type));
                    std::uint32_t sorted_type_index_rhs = SortedTypeIndex(Type(rhs.m_type));
                    if (sorted_type_index_lhs != sorted_type_index_rhs)
                        return sorted_type_index_lhs < sorted_type_index_rhs;
                    else if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;
                    else if (lhs.m_token_index != rhs.m_token_index)
                        return lhs.m_token_index < rhs.m_token_index;
                    else
                        return lhs.m_data_index < rhs.m_data_index;
                }
            }; // end of struct Parser::Grammar_::Transition_::Order
        }; // end of struct Parser::Grammar_::Transition_

        typedef std::set<Transition_,Transition_::Order>    TransitionSet_;
        typedef std::vector<Transition_>                    TransitionVector_;

        typedef std::uint32_t                               StateIndex_;
        typedef std::set<StateIndex_>                       StateIndexSet_;
        typedef std::vector<StateIndex_>                    StateIndexVector_;

    private:

        // These functions are used in the implementation of NonEpsilonTransitionsOfState_.

        // Returns the epsilon closure of the given NPDA state.  Return value is memoized.
        static StateIndexVector_ const &EpsilonClosureOfState_ (StateIndex_ state_index);
        // Computes the epsilon closure of the given NPDA state, placing the computed value in epsilon_closure.
        static void ComputeEpsilonClosureOfState_ (StateIndex_ state_index, StateIndexSet_ &epsilon_closure);

    public:

        // Returns the transitions, matching given sorted_type_index, for the epsilon closure of the given NPDA state.  Return value is memoized.
        static TransitionVector_ const &NonEpsilonTransitionsOfState_ (StateIndex_ state_index, std::uint32_t sorted_type_index);

        // TODO: rename to STATE_TABLE and TRANSITION_TABLE ?
        static State_ const         ms_state_table_[];
        static std::size_t const    ms_state_count_;
        static Transition_ const    ms_transition_table_[];
        static std::size_t const    ms_transition_count_;
    }; // end of struct Parser::Npda_

    // NOTE: Because this uses std::shared_ptr, if you create a cycle in the list (which is valid and
    // the algorithms will work), then you must explicitly break it later in order for that memory to
    // be cleaned up (otherwise the ref count of the elements in the cycle will never go back to zero).
    template <typename DataType>
    struct TreeNode_ : public std::enable_shared_from_this<TreeNode_<DataType>>
    {
        // Ideally this would be private and std::make_shared<TreeNode_> would be a friend
        // in order to force use of std::make_shared to construct std::shared_ptr<TreeNode_>
        // instances instead of bare TreeNode_ instances, but I couldn't figure out how to
        // do this correctly.
        template <typename... Types>
        TreeNode_ (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
            :   m_parent(parent)
            ,   m_data(std::forward<Types>(args)...)
        { }

        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateWithParent (std::shared_ptr<TreeNode_> const &parent, Types&&... args)
        {
            return std::make_shared<TreeNode_>(parent, std::forward<Types>(args)...);
        }
        template <typename... Types>
        static std::shared_ptr<TreeNode_> CreateOrphan (Types&&... args)
        {
            return std::make_shared<TreeNode_>(nullptr, std::forward<Types>(args)...);
        }

        static bool Equals (std::shared_ptr<TreeNode_ const> const &lhs, std::shared_ptr<TreeNode_ const> const &rhs)
        {
            if (lhs.get() == rhs.get())
                return true;

            assert(bool(lhs) || bool(rhs)); // They can't both be null at this point.
            if (!bool(lhs) || !bool(rhs))
                return false; // If either one is null, then they're not equal.

            return lhs->Data() == rhs->Data() && Equals(lhs->Parent(), rhs->Parent());
        }

        bool HasParent () const { return bool(m_parent); }
        std::shared_ptr<TreeNode_ const> Parent () const { return m_parent; }
        std::shared_ptr<TreeNode_> const &Parent () { return m_parent; }
        DataType const &Data () const { return m_data; }
        DataType &Data () { return m_data; }
        std::size_t BranchLength () const
        {
            if (HasParent())
                return 1 + Parent()->BranchLength_Impl(*this);
            else
                return 1;
        }

        // The print_delimiter_at_branch_length parameter should be the realized stack depth.  It will
        // print a semicolon after the realized portion of the stack, so that the hypothetical portion
        // of the stack can be visually distinguished.
        template <typename T>
        void PrintRootToLeaf (std::ostream &out, T (*DataTransform)(DataType const &), std::shared_ptr<TreeNode_> const &delimiting_ancestor = std::shared_ptr<TreeNode_>(), std::string const &delimiter = std::string()) const
        {
            if (this->HasParent())
            {
                Parent()->PrintRootToLeaf(out, DataTransform, delimiting_ancestor);
                out << ' ';
            }
            // If there is no delimiting ancestor, then the delimiting ancestor is the root.
            else if (!bool(delimiting_ancestor) && !delimiter.empty())
                out << delimiter << ' ';

            out << DataTransform(Data());

            // Print the delimiter, if called for.
            if (Equals(this->shared_from_this(), delimiting_ancestor) && !delimiter.empty())
                out << ' ' << delimiter;
        }

    private:

        // The initial_element parameter is used to prevent infinite loop in the case of a branch containing a cycle.
        std::size_t BranchLength_Impl (TreeNode_ const &initial_element) const
        {
            if (this == &initial_element)
                return 0;
            else if (HasParent())
                return 1 + Parent()->BranchLength_Impl(initial_element);
            else
                return 1;
        }

        std::shared_ptr<TreeNode_> m_parent;
        DataType m_data;
    };

    typedef std::uint32_t                               ActionData_;

    typedef std::deque<Token>                           TokenQueue_;
    typedef std::vector<Token>                          TokenStack_;
    typedef std::deque<Token::Id>                       TokenIdQueue_;

    // This forms one element, containing the NPDA state index, of a NPDA state stack (aka branch).
    typedef TreeNode_<Npda_::StateIndex_>               BranchState_;
    typedef std::shared_ptr<BranchState_>               BranchStatePtr_;

    // These are tracked in parallel with BranchState_, etc for the purposes of debug spew only.
    typedef TreeNode_<Token::Id>                        BranchTokenId_;
    typedef std::shared_ptr<BranchTokenId_>             BranchTokenIdPtr_;

    // These are used in printing the branch state stacks and token id stacks.
    template <typename T>
    static T const &IdentityTransform_ (T const &x) { return x; }
    static char const *TokenName_ (Token::Id const &token_id) { return ms_token_name_table_[token_id]; }

    struct Branch_
    {
        Branch_ () { } // Default initialization is nullptr.
        Branch_ (BranchStatePtr_ const &state_ptr, BranchTokenIdPtr_ const &token_id_ptr)
            :   m_state_ptr(state_ptr)
            ,   m_token_id_ptr(token_id_ptr)
        {
            assert(bool(m_state_ptr) == bool(m_token_id_ptr) && "pointers must both be set or both be unset");
        }

        bool HasParent () const {
            assert(m_state_ptr->HasParent() == m_token_id_ptr->HasParent());
            return m_state_ptr->HasParent();
        }
        Branch_ Parent () const {
            return Branch_(m_state_ptr->Parent(), m_token_id_ptr->Parent());
        }
        bool HasAsAncestor (Branch_ const &other) const
        {
            Branch_ b(*this);
            while (true)
            {
                if (b == other)
                    return true;

                if (b.HasParent())
                    b = b.Parent();
                else
                    return false;
            }
        }

        bool operator == (Branch_ const &other) const { return BranchState_::Equals(m_state_ptr, other.m_state_ptr); }

        BranchStatePtr_ const &StatePtr () const { return m_state_ptr; }
        BranchTokenIdPtr_ const &TokenIdPtr () const { return m_token_id_ptr; }

    private:

        // This is the head of the NPDA state branch that this HPS tracks.
        BranchStatePtr_ m_state_ptr;
        // This is the head of the Token::Id branch that this HPS tracks (which is exactly
        // parallel to the NPDA state branch tracked by m_state_ptr).
        BranchTokenIdPtr_ m_token_id_ptr;
    };

    typedef std::vector<Branch_>            BranchVector_;
    typedef std::vector<BranchVector_>      BranchVectorStack_;

    struct  ParseTreeNode_;

    typedef std::deque<ParseTreeNode_ *>    HPSQueue_;

    struct RealizedState_
    {
        RealizedState_      (Npda_::StateIndex_ initial_state);

        BranchVectorStack_ const &BranchVectorStack             () const { return m_branch_vector_stack; }
        TokenStack_ const & TokenStack                          () const { return m_token_stack; }
        TokenQueue_ const & LookaheadQueue                      () const { return m_lookahead_queue; }

        std::size_t         MaxRealizedLookaheadCount           () const { return m_max_realized_lookahead_count; }
        bool                HasExceededMaxAllowableLookaheadCount (std::int64_t max_allowable_lookahead_count) const { return max_allowable_lookahead_count >= 0 && m_max_realized_lookahead_count > std::size_t(max_allowable_lookahead_count); }
        bool                HasEncounteredErrorState            () const { return m_has_encountered_error_state; }

        // This is used during the hypothetical branch processing for when more lookaheads are needed in the queue.
        void                PushBackLookahead                   (Token const &lookahead, HPSQueue_ const &hps_queue);

        Token               PopStack                            ();
        Token               PopFrontLookahead                   (HPSQueue_ &hps_queue);

        void                StealTokenStackTop                  (Ast::Base * *&return_token);

        // void                ExecuteAction                       (Npda_::Transition_::Type action, ActionData_ action_data);

        // TODO: Need to figure out how to handle popping the token stack (since in a way it should be the
        // responsibility of ExecuteAction).  Maybe ExecuteAction should accept Token* which it will populate
        // with the popped token in the case of POP_STACK, so that the parser can call the throw-away-token actions.

        void                ExecuteActionReduce                 (Grammar_::Rule_ const &rule, Token::Data const &reduced_nonterminal_token_data, HPSQueue_ &hps_queue);
        void                ExecuteActionShift                  (BranchVector_ const &shifted_branch_vector, HPSQueue_ &hps_queue);
        void                ExecuteActionInsertLookaheadError   (HPSQueue_ &hps_queue);
        void                ExecuteActionDiscardLookahead       (HPSQueue_ &hps_queue);
        // This one is tricky to implement within RealizedState_ alone.
        //void                ExecuteActionPopStack               (std::uint32_t pop_count);

        void                ClearStack                          ();
        void                Reinitialize                        (Npda_::StateIndex_ initial_state);

    private:

        void                Initialize                          (Npda_::StateIndex_ initial_state);

        void                PushFrontLookahead                  (Token const &lookahead, HPSQueue_ &hps_queue);
        void                UpdateMaxRealizedLookaheadCount     ();
        void                SetHasEncounteredErrorState         () { m_has_encountered_error_state = true; }

        static bool         IsScannerGeneratedTokenId           (Token::Id token_id)
        {
            // If this is a Terminal (anything between 0 and Terminal::STRING_LITERAL)
            // that isn't ERROR_, then it's scanner-generated (i.e. not parser-generated).
            return token_id != Terminal::ERROR_ && token_id <= Terminal::STRING_LITERAL;
        }

        // The set of the realized branches (i.e. the set of the tops of the NPDA state stacks)
        BranchVectorStack_  m_branch_vector_stack;
        TokenStack_         m_token_stack;
        TokenQueue_         m_lookahead_queue;
        // This is related to k in the LALR(k) quantity of the grammar, though it's only what's been realized
        // during the parse, not the theoretical bound (if it even exists).
        std::size_t         m_max_realized_lookahead_count;
        // TODO: Maybe make this into the number of times error recovery has been entered.
        bool                m_has_encountered_error_state;
    }; // end of struct Parser::RealizedState_

    struct HypotheticalState_
    {
        HypotheticalState_      (std::uint32_t initial_state);
        ~HypotheticalState_     ();

        // The min and max realized lookahead cursors being equal across all HPSes indicates that
        // all HPSes have consumed the same number of lookaheads, so they're in a well-defined
        // state with respect to resolving SHIFT/REDUCE conflicts.
        bool                    MinAndMaxRealizedLookaheadCursorsAreEqual () const;

        // Deletes the branch that the given node (which may not be the root node) is a part of.
        // A branch of a node N is defined as the set of nodes that are descendants of N, and all
        // ancestors of N having exactly one child, excluding the root node.  Thus if the whole parse
        // tree is a single line of nodes extending from the root, then calling DeleteBranch on any
        // non-root node will delete all non-root nodes.
        void                    DeleteBranch (ParseTreeNode_ *branch_node);

        // Destroys the parse tree and recreates a root node with no children.
        void                    DestroyParseTree ();

    //private: // TEMP commented out until HypotheticalState_ is properly encapsulated.

        // Note that if m_hps_queue is empty, then *min = std::numeric_limits<std::uint32_t>::max()
        // and *max = std::numeric_limits<std::uint32_t>::min().  If min or max is nullptr, doesn't
        // assign to that one.
        void                    ComputeMinAndMaxRealizedLookaheadCursors (std::uint32_t *min, std::uint32_t *max) const;

        ParseTreeNode_ *        m_root;
        HPSQueue_               m_hps_queue;
        // This is stored so new memory isn't necessarily allocated for each parse iteration.
        HPSQueue_               m_new_hps_queue;
    }; // end of struct Parser::HypotheticalState_

    void ExecuteAndRemoveTrunkActions_ (bool &should_return, ParserReturnCode &parser_return_code, Ast::Base * *&return_token);
    void ContinueNPDAParse_ (bool &should_return);
    Token::Data ExecuteReductionRule_ (std::uint32_t const rule_index_, TokenStack_ const &token_stack) throw();

    // TODO: This should probably be inside HypotheticalState_
    struct ParseTreeNode_
    {
        // The values of RETURN through POP_STACK coincide with the same in Npda_::Transition_::Type.
        // Note: HPS stands for "Hypothetical Parser State", which represents one of possibly many
        // ways the non-deterministic parser can parse the input.
        // TODO: probably order this so that the Spec::Order gives an obvious way to do error handling action last
        enum Type { ROOT = 0, RETURN, REDUCE, SHIFT, INSERT_LOOKAHEAD_ERROR, DISCARD_LOOKAHEAD, POP_STACK, HPS, COUNT_ };
        static std::uint32_t const UNUSED_DATA = std::uint32_t(-1);

        struct Spec
        {
            Type m_type;
            // Only used by REDUCE, SHIFT, POP_STACK.
            std::uint32_t m_single_data;

            Spec (Type type, std::uint32_t single_data = UNUSED_DATA)
                : m_type(type)
                , m_single_data(single_data)
            {
                if (m_type != REDUCE && m_type != SHIFT && m_type != POP_STACK)
                {
                    assert(m_single_data == UNUSED_DATA);
                }
            }

            // The granularity of the ordering depends on m_type.  In particular,
            // - POP_STACK is lexicographic ordering on the tuple (m_type, m_single_data).
            // - REDUCE only cares about m_type; the rule number itself doesn't matter.
            // - SHIFT only cares about m_type; the shifted token ID is only used in printing anyway
            // - other types only care about m_type.
            struct Order
            {
                bool operator () (Spec const &lhs, Spec const &rhs) const
                {
                    if (lhs.m_type != rhs.m_type)
                        return lhs.m_type < rhs.m_type;

                    switch (lhs.m_type) // Note that lhs.m_type == rhs.m_type at this point.
                    {
                        case POP_STACK:
                            return lhs.m_single_data < rhs.m_single_data;

                        case REDUCE:
                            return false;

                        case SHIFT:
                            return false;

                        default:
                            assert(lhs.m_single_data == UNUSED_DATA);
                            assert(rhs.m_single_data == UNUSED_DATA);
                            return false;
                    }
                }
            }; // end of struct Parser::ParseTreeNode_::Spec::Order
        }; // end of struct Parser::ParseTreeNode_::Spec

        static char const *AsString (Type type);

        struct ParseTreeNodeOrder
        {
            bool operator () (ParseTreeNode_ const *lhs, ParseTreeNode_ const *rhs) const;
        };

        typedef std::set<ParseTreeNode_ *,ParseTreeNodeOrder>           ParseTreeNodeSet;
        typedef std::map<Spec,ParseTreeNodeSet,Spec::Order>             ChildMap;
        typedef std::pair<std::int32_t,std::int32_t>                    PrecedenceLevelRange;

        Spec                    m_spec;
        Branch_                 m_hypothetical_head;
        BranchVector_           m_child_branch_vector;
        // m_hypothetical_lookahead_token_id_queue comes before the realized lookahead queue, and m_realized_lookahead_cursor
        // is the index into the realized lookahead queue for where the end of m_hypothetical_lookahead_token_id_queue
        // lands.  In other words, this node's "total" lookahead
        TokenIdQueue_           m_hypothetical_lookahead_token_id_queue;
        std::uint32_t           m_realized_lookahead_cursor; // this is an index into the realized lookahead queue.
        ParseTreeNode_ *        m_parent_node;
        ChildMap                m_child_nodes;

        ParseTreeNode_ (Spec const &spec)
            :   m_spec(spec)
            ,   m_realized_lookahead_cursor(0)
            ,   m_parent_node(NULL)
        { }
        ~ParseTreeNode_ ();

        bool IsRoot () const { return m_parent_node == NULL; }
        bool HasParent () const { return m_parent_node != NULL; }
        bool HasTrunkChild () const;
        ParseTreeNode_ *PopTrunkChild ();
        bool HasChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.find(spec) != m_child_nodes.end(); }
        ParseTreeNodeSet const &ChildrenHavingSpec (Spec const &spec) const { return m_child_nodes.at(spec); }
        ParseTreeNodeSet &ChildrenHavingSpec (Spec const &spec) { return m_child_nodes.at(spec); }
        bool HasExactlyOneChild () const;
        // This returns the most root-ward ancestor such that the entire ancestor line only has one child each.
        // This may return the root of the tree itself, or it may return this node (if this node's parent has
        // multiple children).
        ParseTreeNode_ *BranchRoot ();
        Token::Id LookaheadTokenId (Parser &parser) const;
        // Some actions are considered to block the HPS from continuing (because it must be realized before
        // continuing).  RETURN is considered to block, since nothing can happen after.
        bool IsBlockedHPS () const;
        PrecedenceLevelRange ComputePrecedenceLevelRange (std::uint32_t current_child_depth) const;
        // Returns true if and only if there is exactly one SHIFT child and one REDUCE child.
        bool HasShiftReduceConflict (ParseTreeNode_ *&shift, ParseTreeNode_ *&reduce);

        void AddChild (ParseTreeNode_ *child);
        void RemoveChild (ParseTreeNode_ *child);
        void RemoveFromParent ();
        // Traverses this node's descendants, and for each HPS node descendant, if that HPS node is present
        // in the given HPSQueue_, that HPSQueue_ entry is replaced with NULL.  This is so that a costly
        // deletion is not done, and is handled in a single "clean-up" phase by copying non-null entries
        // into m_new_hps_queue_.
        void NullifyHPSNodeDescendantsInHPSQueue (HPSQueue_ &hps_queue) const;

        ParseTreeNode_ *CloneLeafNode () const;
        // orphan_target must not have a parent (because its m_spec may change and affect its relationship with its parent).
        void CloneLeafNodeInto (ParseTreeNode_ &orphan_target) const;

        void Print (std::ostream &out, Parser const *parser, std::string const &prefix, std::uint32_t indent_level = 0, bool suppress_initial_prefix = false) const;
    }; // end of struct Parser::ParseTreeNode_

    Token const &Lookahead_ (TokenQueue_::size_type index) throw();

    ParseTreeNode_ *        TakeHypotheticalActionOnHPS_ (ParseTreeNode_ const &hps, ParseTreeNode_::Type action_type, std::uint32_t action_data);
    // Recreates the parse tree (i.e. the contents of m_hypothetical_state_) from the top of the
    // branch set stack of m_realized_state_, specifically, creates an HPS corresponding to each
    // branch, adding each created HPS as a child to the root node.
    void                    CreateParseTreeFromRealizedState_ ();

    static bool             CompareTokenId_             (Token::Id lhs, Token::Id rhs) { return lhs < rhs; }

    // This doesn't reset the error state.
    void                    ClearStack_                 ();
    // This resets the error state.
    void                    CleanUpAllInternals_        ();

    RealizedState_     *    m_realized_state_;
    HypotheticalState_ *    m_hypothetical_state_;

    // ///////////////////////////////////////////////////////////////////////
    // end of internal trison-generated parser guts
    // ///////////////////////////////////////////////////////////////////////

    friend std::ostream &operator << (std::ostream &stream, Parser::ParserReturnCode parser_return_code);
    friend std::ostream &operator << (std::ostream &stream, Parser::Token const &token);
}; // end of class Parser

std::ostream &operator << (std::ostream &stream, Parser::ParserReturnCode parser_return_code);

std::ostream &operator << (std::ostream &stream, Parser::Token const &token);

#line 75 "reflex_parser.trison"

} // end of namespace Reflex

#endif // !defined(REFLEX_PARSER_HPP_)

#line 891 "reflex_parser.hpp"
