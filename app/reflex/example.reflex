%targets cpp

%target.cpp.class_name Scanner

%target.cpp.top_of_header_file %{
#include <iostream>
#include <string>

using namespace std;

#if !defined(_AWESOMESCANNER_HPP_)
#define _AWESOMESCANNER_HPP_

enum TokenType
{
    TT_STRING_LITERAL = 0,
    TT_END_OF_FILE,
    TT_BAD_TOKEN,

    TT_COUNT
}; // end of enum TokenType

ostream &operator << (ostream &stream, TokenType token_type);
%}

%target.cpp.top_of_class_methods_and_members {
private:

    string m_accumulator;
}

%target.cpp.bottom_of_header_file %{
#endif // !defined(_AWESOMESCANNER_HPP_)
%}

%target.cpp.end_of_scan_method_actions {
    assert(false && "you didn't handle EOF properly");
    return TT_END_OF_FILE;
}

%target.cpp.top_of_implementation_file %{
ostream &operator << (ostream &stream, TokenType token_type)
{
    static string const s_token_type_string[TT_COUNT] =
    {
        "TT_STRING_LITERAL",
        "TT_END_OF_FILE",
        "TT_BAD_TOKEN"
    };
    assert(token_type >= 0 && token_type < TT_COUNT);
    return stream << s_token_type_string[token_type];
}
%}

%target.cpp.bottom_of_implementation_file %{
int main (int argc, char **argv)
{
    cin.unsetf(ios_base::skipws);
    Scanner::PerformStateMachineConsistencyCheck();
    Scanner scanner;
//     scanner.SetDebugSpewFlags(Scanner::DEBUG_ALL);
    TokenType token_type;
    do
    {
        token_type = scanner.Scan();
        cerr << token_type << endl;
    }
    while (token_type != TT_END_OF_FILE);
    return 0;
}
%}

%target.cpp.return_type "TokenType"
%target.cpp.return_true_iff_input_is_at_end { return cin.eof(); }
%target.cpp.return_next_input_char { return cin.get(); }
%target.cpp.reset_for_new_input_actions { m_accumulator.clear(); }

// everything that doesn't need to be escaped in a string literal
%macro STRING_NORMAL_CHAR   ([^[:cntrl:]"\\]|\t|\n)
// single-char escape codes for a string literal (e.g. "yo!\n")
%macro STRING_ESC_CHAR      (\\[[:print:]])

%start MAIN

%%

%scanner_mode MAIN
:
    (")
    %target.cpp {
        cerr << "starting to scan string literal" << endl;
        assert(m_accumulator.empty());
        ScannerMode(Mode::SCANNING_STRING_LITERAL);
    }
|
    (//.*$)
    %target.cpp {
        cerr << "scanned a line comment" << endl;
    }
|
    (/\*)
    %target.cpp {
        cerr << "starting to scan block comment" << endl;
        ScannerMode(Mode::SCANNING_BLOCK_COMMENT);
    }
|
    ([ \t\n]+) %target.cpp { }
|
    (\z)
    %target.cpp {
        cerr << "end of file" << endl;
        return TT_END_OF_FILE;
    }
|
    (.)
    %target.cpp {
        cerr << "unrecognized char " << int(accepted_text[0]) << endl;
        return TT_BAD_TOKEN;
    }
;

%scanner_mode SCANNING_STRING_LITERAL
:
    (")
    %target.cpp {
        cerr << "ending string literal -- \"" << m_accumulator << "\"" << endl;
        m_accumulator.clear();
        ScannerMode(Mode::MAIN);
        return TT_STRING_LITERAL;
    }
|
    ({STRING_NORMAL_CHAR}) %target.cpp { m_accumulator += accepted_text; }
|
    ({STRING_ESC_CHAR}) %target.cpp { m_accumulator += accepted_text; }
|
    (\z)
    %target.cpp {
        cerr << "unterminated string literal" << endl;
        return TT_END_OF_FILE;
    }
|
    (.)
    %target.cpp {
        cerr << "unrecognized char " << int(accepted_text[0]) << endl;
        return TT_BAD_TOKEN;
    }
;

%scanner_mode SCANNING_BLOCK_COMMENT
:
    (\*/)
    %target.cpp {
        cerr << "ending block comment" << endl;
        ScannerMode(Mode::MAIN);
    }
|
    (\z)
    %target.cpp {
        cerr << "unterminated block comment" << endl;
        return TT_END_OF_FILE;
    }
|
    (.) %target.cpp { }
;
